/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../chunks/_rollupPluginBabelHelpers","../request","../core/maybe","../core/queryUtils","../geometry/support/normalizeUtils","./networkService","./utils","./support/RouteSolveResult"],(function(e,t,r,s,i,o,a,l,n){"use strict";const u=i.createQueryParamsHelper({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,directionsTimeAttribute:{name:"directionsTimeAttributeName"},impedanceAttribute:{name:"impedanceAttributeName"},outSpatialReference:{name:"outSR",getter:e=>e.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},stops:!0,travelMode:!0});function c(e){return"esri.rest.support.FeatureSet"===(null==e?void 0:e.declaredClass)}function p(e,t,r){return f.apply(this,arguments)}function f(){return(f=t._asyncToGenerator((function*(e,t,s){const i=[],n=[],p={},f={},d=l.parseUrl(e),{path:y}=d;c(t.stops)&&a.collectGeometries(t.stops.features,n,"stops.features",p),c(t.pointBarriers)&&a.collectGeometries(t.pointBarriers.features,n,"pointBarriers.features",p),c(t.polylineBarriers)&&a.collectGeometries(t.polylineBarriers.features,n,"polylineBarriers.features",p),c(t.polygonBarriers)&&a.collectGeometries(t.polygonBarriers.features,n,"polygonBarriers.features",p);const g=yield o.normalizeCentralMeridian(n);for(const r in p){const e=p[r];i.push(r),f[r]=g.slice(e[0],e[1])}if(a.isInputGeometryZAware(f,i)){let e=null;try{e=yield a.fetchServiceDescription(y,t.apiKey,s)}catch{}e&&!e.hasZ&&a.dropZValuesOffInputGeometry(f,i)}for(const r in f)f[r].forEach(((e,s)=>{t.get(r)[s].geometry=e}));const v={...s,query:{...d.query,...u.toQueryParams(t),f:"json"}},R=y.endsWith("/solve")?y:`${y}/solve`,{data:h}=yield r(R,v);return m(h)}))).apply(this,arguments)}function m(e){var t,r,i,o,a;const l=new Map,{directionLines:u,directionPoints:c,directions:p,routes:f,stops:m,barriers:d,polygonBarriers:y,polylineBarriers:g,messages:v}=e,R=null!=(t=null!=(r=null!=(i=null!=(o=null==f?void 0:f.spatialReference)?o:null==m?void 0:m.spatialReference)?i:null==d?void 0:d.spatialReference)?r:null==y?void 0:y.spatialReference)?t:null==g?void 0:g.spatialReference;null==f||f.features.forEach((e=>{const t=e.attributes.Name,r=e.attributes.ObjectID;l.has(t)?(l.get(t).route=e,l.get(t).routeId=r):l.set(t,{route:e,routeId:r,routeName:t}),s.isSome(e.geometry)&&(e.geometry.spatialReference=R)})),null==p||p.forEach((e=>{const t=e.routeName;l.has(t)?l.get(t).directions=e:l.set(t,{routeName:t,directions:e})})),null==m||m.features.forEach((e=>{var t;const r=null!=(t=e.attributes.RouteName)?t:null;l.has(r)?l.get(r).stops?l.get(r).stops.push(e):l.get(r).stops=[e]:l.set(r,{stops:[e],routeName:r}),s.isSome(e.geometry)&&(e.geometry.spatialReference=R)}));const h=null==(a=null==m?void 0:m.features.every((e=>null==e.attributes.RouteName)))||a;if((null==m?void 0:m.features.length)>0&&h){const e=Array.from(l.keys())[0];l.get(e).stops=l.get(null).stops,l.delete(null)}null==u||u.features.forEach((e=>{var t;const r=e.attributes.RouteID,s=null==(t=Array.from(l.values()).find((e=>e.routeId===r)))?void 0:t.routeName;if(s)if(l.has(s))if(l.get(s).directionLines)l.get(s).directionLines.features.push(e);else{const{fieldAliases:t,geometryType:r,spatialReference:i}=u;l.get(s).directionLines={features:[e],fieldAliases:t,geometryType:r,spatialReference:i}}else{const{fieldAliases:t,geometryType:r,spatialReference:i}=u;l.set(s,{routeName:s,directionLines:{features:[e],fieldAliases:t,geometryType:r,spatialReference:i}})}})),null==c||c.features.forEach((e=>{var t;const r=e.attributes.RouteID,s=null==(t=Array.from(l.values()).find((e=>e.routeId===r)))?void 0:t.routeName;if(s)if(l.has(s))if(l.get(s).directionPoints)l.get(s).directionPoints.features.push(e);else{const{fieldAliases:t,geometryType:r,spatialReference:i}=c;l.get(s).directionPoints={features:[e],fieldAliases:t,geometryType:r,spatialReference:i}}else{const{fieldAliases:t,geometryType:r,spatialReference:i}=c;l.set(s,{routeName:s,directionPoints:{features:[e],fieldAliases:t,geometryType:r,spatialReference:i}})}}));const b=Array.from(l.values());return n.fromJSON({routeResults:b,barriers:d,polygonBarriers:y,polylineBarriers:g,messages:v})}e.solve=p,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
