/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../chunks/_rollupPluginBabelHelpers","../request","../core/maybe","../geometry/support/normalizeUtils","./networkService","./utils","./route/utils","./support/FeatureSet","./support/RouteSolveResult"],(function(e,r,t,s,o,a,n,i,u,c){"use strict";function l(e){return e instanceof u}function p(e,r,t){return f.apply(this,arguments)}function f(){return(f=r._asyncToGenerator((function*(e,r,s){const u=[],c=[],p={},f={},d=n.parseUrl(e),{path:m}=d;l(r.stops)&&a.collectGeometries(r.stops.features,c,"stops.features",p),l(r.pointBarriers)&&a.collectGeometries(r.pointBarriers.features,c,"pointBarriers.features",p),l(r.polylineBarriers)&&a.collectGeometries(r.polylineBarriers.features,c,"polylineBarriers.features",p),l(r.polygonBarriers)&&a.collectGeometries(r.polygonBarriers.features,c,"polygonBarriers.features",p);const g=yield o.normalizeCentralMeridian(c);for(const t in p){const e=p[t];u.push(t),f[t]=g.slice(e[0],e[1])}if(a.isInputGeometryZAware(f,u)){let e=null;try{e=yield a.fetchServiceDescription(m,r.apiKey,s)}catch{}e&&!e.hasZ&&a.dropZValuesOffInputGeometry(f,u)}for(const t in f)f[t].forEach(((e,s)=>{r.get(t)[s].geometry=e}));const h={...s,query:{...d.query,...i.routeParametersToQueryParameters(r),f:"json"}},R=m.endsWith("/solve")?m:`${m}/solve`,{data:v}=yield t(R,h);return y(v)}))).apply(this,arguments)}function y(e){const{barriers:r,directionLines:t,directionPoints:o,directions:a,messages:n,polygonBarriers:i,polylineBarriers:u,routes:l,stops:p,traversedEdges:f,traversedJunctions:y,traversedTurns:d}=e,m=e=>{const r=h.find((r=>r.routeName===e));if(s.isSome(r))return r;const t={routeId:h.length+1,routeName:e};return h.push(t),t},g=e=>{const r=h.find((r=>r.routeId===e));if(s.isSome(r))return r;const t={routeId:e,routeName:null};return h.push(t),t},h=[];l?.features.forEach(((e,r)=>{e.geometry.spatialReference=l.spatialReference;const t=e.attributes.Name,s=r+1;h.push({routeId:s,routeName:t,route:e})})),a?.forEach((e=>{const{routeName:r}=e;m(r).directions=e}));const R=(p?.features.every((e=>s.isNone(e.attributes.RouteName)))??!1)&&h.length>0?h[0].routeName:null;return p?.features.forEach((e=>{var r;e.geometry&&((r=e.geometry).spatialReference??(r.spatialReference=p.spatialReference));const t=R??e.attributes.RouteName,s=m(t);s.stops??(s.stops=[]),s.stops.push(e)})),t?.features.forEach((e=>{const r=e.attributes.RouteID,s=g(r),{geometryType:o,spatialReference:a}=t;s.directionLines??(s.directionLines={features:[],geometryType:o,spatialReference:a}),s.directionLines.features.push(e)})),o?.features.forEach((e=>{const r=e.attributes.RouteID,t=g(r),{geometryType:s,spatialReference:a}=o;t.directionPoints??(t.directionPoints={features:[],geometryType:s,spatialReference:a}),t.directionPoints.features.push(e)})),f?.features.forEach((e=>{const r=e.attributes.RouteID,t=g(r),{geometryType:s,spatialReference:o}=f;t.traversedEdges??(t.traversedEdges={features:[],geometryType:s,spatialReference:o}),t.traversedEdges.features.push(e)})),y?.features.forEach((e=>{const r=e.attributes.RouteID,t=g(r),{geometryType:s,spatialReference:o}=y;t.traversedJunctions??(t.traversedJunctions={features:[],geometryType:s,spatialReference:o}),t.traversedJunctions.features.push(e)})),d?.features.forEach((e=>{const r=e.attributes.RouteID,t=g(r);t.traversedTurns??(t.traversedTurns={features:[]}),t.traversedTurns.features.push(e)})),c.fromJSON({routeResults:h,barriers:r,polygonBarriers:i,polylineBarriers:u,messages:n})}e.solve=p,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
