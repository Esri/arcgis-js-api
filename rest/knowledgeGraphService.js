/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import"../geometry.js";import{id as e}from"../kernel.js";import r from"../request.js";import t from"../core/Error.js";import a from"../core/Logger.js";import n from"./knowledgeGraph/GraphQueryResult.js";import o from"./knowledgeGraph/GraphQueryStreamingResult.js";import s from"./knowledgeGraph/KnowledgeGraph.js";import{getWasmInterface as i}from"./knowledgeGraph/wasmInterface/knowledgeWasmAccess.js";import{bindParamArrayToWasm as d,geometryToWasm as c,bindParamObjectToWasm as l}from"./knowledgeGraph/wasmInterface/queryToWasmEncodedFactories.js";import{wasmToDataModel as u}from"./knowledgeGraph/wasmInterface/wasmToDataModelFactories.js";import{decodedWasmObjToQueryResponseObj as p}from"./knowledgeGraph/wasmInterface/wasmToQueryResponseObjFactories.js";import f from"../geometry/Geometry.js";const g=a.getLogger("esri.rest.knowledgeGraph.knowledgeGraphService");async function y(e,a,o){const s=`${e.url}/graph/query`,d=await r(s,{responseType:"array-buffer",query:{f:"pbf",openCypherQuery:a.openCypherQuery,...o?.query},signal:o?.signal,timeout:o?.timeout}),c=d.getHeader("content-type"),l=d.data;if(c?.includes("application/x-protobuf")){const e=new((await i()).GraphQueryDecoder);return e.deleteLater(),new n({resultRows:G(e,l)})}throw new t("knowledge-graph:unexpected-server-response","server returned an unexpected response",{responseType:c,data:d.data})}async function h(e,r,t){const a=`${e.url}/graph/query`;await k(e);const n=await T(a,t);n.data.body=await q(r);const s=await fetch(n.data.url,n.data);return new o({resultRowsStream:await C(s)})}async function w(e,a,o){const s=`${e.url}/graph/search`,d=await r(s,{responseType:"array-buffer",query:{f:"pbf",searchQuery:`"${a.searchQuery}"`,typeCategoryFilter:a.typeCategoryFilter,...o?.query},signal:o?.signal,timeout:o?.timeout}),c=d.getHeader("content-type"),l=d.data;if(c?.includes("application/x-protobuf")){const e=new((await i()).GraphQueryDecoder);return e.deleteLater(),new n({resultRows:G(e,l)})}throw new t("knowledge-graph:unexpected-server-response","server returned an unexpected response",{responseType:c,data:d.data})}async function m(e,r,t){const a=`${e.url}/graph/search`;await k(e);const n=await T(a,t);n.data.body=await x(r);const s=await fetch(n.data.url,n.data);return new o({resultRowsStream:await C(s)})}async function _(e){const r=new s({url:e});return await b(r),r}async function b(e){e.dataModel=await j(e)}async function k(r){const t=e?.findCredential(r.url);t||(r.dataModel?await j(r):await b(r))}function v(e,r,t,a){if(null==r)t.set_param_key_value(e,"");else if("object"!=typeof r)t.set_param_key_value(e,r);else if(r instanceof Date)t.set_param_key_value(e,r);else if(r instanceof f){const n=c(r,a);t.set_param_key_value(e,n),n.delete()}else if(r instanceof Array){const n=d(r,a);t.set_param_key_value(e,n),n.delete()}else{const n=l(r,a);t.set_param_key_value(e,n),n.delete()}}async function q(e){const r=await i(),a=new r.GraphQueryRequestEncoder;if(a.deleteLater(),a.open_cypher_query=e.openCypherQuery,e.bindParameters){a.input_quantization_parameters=r.InputQuantizationUtil.WGS84_lossless(),a.output_spatial_reference=r.SpatialReferenceUtil.WGS84();for(const[t,n]of Object.entries(e.bindParameters))v(t,n,a,r)}try{a.encode()}catch(o){throw new t("knowledge-graph:query-encoding-failed","Attempting to encode the query failed",{error:o})}const n=a.get_encoding_result();if(0!==n.error.error_code)throw new t("knowledge-graph:query-encoding-failed","Attempting to encode the query failed",{errorCode:n.error.error_code,errorMessage:n.error.error_message});return n.get_byte_buffer()}async function x(e){const r=await i(),a=new r.GraphSearchRequestEncoder;if(a.deleteLater(),a.search_query=e.searchQuery,a.type_category_filter=r.esriNamedTypeCategory[e.typeCategoryFilter.toString()],!0===e.returnSearchContext&&(a.return_search_context=e.returnSearchContext),void 0!==e.start&&e.start>0&&(a.start_index=e.start),void 0!==e.num&&(a.max_num_results=e.num),void 0!==e.globalIdsFilter&&Array.isArray(e.globalIdsFilter)&&e.globalIdsFilter.length>0)try{a.set_globalids_filter(d(e.globalIdsFilter,r))}catch(o){throw new t("knowledge-graph:globalIds-format-error","Attempting to set globalids filter failed.  This is usually caused by an incorrectly formatted UUID string",{error:o})}e.namedTypesFilter?.forEach((e=>{a.add_named_type_filter(e)}));try{a.encode()}catch(o){throw new t("knowledge-graph:search-encoding-failed","Attempting to encode the search failed",{error:o})}const n=a.get_encoding_result();if(0!==n.error.error_code)throw new t("knowledge-graph:search-encoding-failed","Attempting to encode the search failed",{errorCode:n.error.error_code,errorMessage:n.error.error_message});return n.get_byte_buffer()}async function T(e,t){return r(e,{responseType:"native-request-init",method:"post",query:{f:"pbf",...t?.query},body:"x",headers:{"Content-Type":"application/octet-stream"},signal:t?.signal,timeout:t?.timeout})}function G(e,r){e.push_buffer(new Uint8Array(r));const t=[];let a=0;for(;e.next_row();){a||(a=e.get_header_keys().size());const r=new Array(a);for(let t=0;t<a;t++){const a=e.get_value(t);r[t]=p(a)}t.push(r)}return t}async function C(e){const r=e.headers.get("content-type");if(e.headers.get("content-length")&&g.warnOnce("Found `Content-Length` header when expecting a streaming HTTP response! Please investigate whether all intermediate HTTP proxies and/or load balancers are configured such that they don't forcefully buffer the entire response before returning it to the client. A valid HTTP streaming response should use Chunked Transfer Encoding and not have a Content Length defined."),r?.includes("application/x-protobuf")){const r=e.body.getReader(),a=new((await i()).GraphQueryDecoder);return new ReadableStream({async start(e){try{return n()}catch(o){throw a.delete(),e.close(),r.releaseLock(),new t("knowledge-graph::stream-decoding-error","The server returned a valid response, but there was an error decoding the response stream",{error:o})}function n(){return r.read().then((({done:o,value:s})=>{if(o){let n;if(a.has_error&&(n=new t("knowledge-graph::stream-decoding-error","One or more result rows was not successfully decoded",{errorCode:a.error.error_code,errorMessage:a.error.error_message})),a.delete(),e.close(),r.releaseLock(),n)throw n;return}const i=G(a,s);return i.length>0&&e.enqueue(i),n()}))}}})}throw new t("knowledge-graph:unexpected-server-response","server returned an unexpected response",{responseType:r,data:e.text()})}async function j(e){const a=`${e.url}/dataModel/queryDataModel`,n=await r(a,{responseType:"array-buffer",query:{f:"pbf"}}),o=n.getHeader("content-type"),s=n.data;if(o?.includes("application/x-protobuf")){const e=(await i()).decode_data_model_from_protocol_buffer(new Uint8Array(s));return u(e)}throw new t("knowledge-graph:unexpected-server-response","server returned an unexpected response",{responseType:o,data:n.data})}export{y as executeQuery,h as executeQueryStreaming,w as executeSearch,m as executeSearchStreaming,_ as fetchKnowledgeGraph,b as refreshDataModel};
