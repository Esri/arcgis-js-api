/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import t from"./Analysis.js";import o from"./LineOfSightAnalysisObserver.js";import r from"./LineOfSightAnalysisTarget.js";import s from"../core/Collection.js";import{castForReferenceSetter as i,referenceSetter as n}from"../core/collectionUtils.js";import{isNone as p,isSome as l,applySome as a,unwrap as c}from"../core/maybe.js";import{watch as u,syncAndInitial as m}from"../core/reactiveUtils.js";import{property as g}from"../core/accessorSupport/decorators/property.js";import"../core/arrayUtils.js";import"../core/has.js";import"../core/accessorSupport/ensureType.js";import{subclass as y}from"../core/accessorSupport/decorators/subclass.js";import{projectOrLoad as h}from"../geometry/projection.js";import{fromValues as f,expandWithVec3 as d,toExtent as v}from"../geometry/support/aaBoundingBox.js";import{getGeometryEffectiveElevationMode as b}from"../support/elevationInfoUtils.js";const j=s.ofType(r);let x=class extends t{constructor(e){super(e),this.type="line-of-sight",this.observer=null,this.extent=null,this.nonEditableMessage="Assign an observer location to the analysis to allow editing."}initialize(){this.own(u((()=>this._computeExtent()),(e=>{(p(e)||p(e.pending))&&this._set("extent",l(e)?e.extent:null)}),m))}get targets(){return this._get("targets")||new j}set targets(e){this._set("targets",n(e,this.targets,j))}get spatialReference(){return l(this.observer)&&l(this.observer.position)?this.observer.position.spatialReference:null}get requiredPropertiesForEditing(){return[a(this.observer,(e=>e.position))]}async waitComputeExtent(){const e=this._computeExtent();return l(e)?c(e.pending):null}_computeExtent(){const e=this.spatialReference;if(p(this.observer)||p(this.observer.position)||p(e))return null;const t=e=>"absolute-height"===b(e.position,e.elevationInfo),o=this.observer.position,r=f(o.x,o.y,o.z,o.x,o.y,o.z);for(const i of this.targets)if(l(i.position)){const t=h(i.position,e);if(l(t.pending))return{pending:t.pending,extent:null};if(l(t.geometry)){const{x:e,y:o,z:s}=t.geometry;d(r,[e,o,s])}}const s=v(r,e);return t(this.observer)&&this.targets.every(t)||(s.zmin=null,s.zmax=null),{pending:null,extent:s}}clear(){this.observer=null,this.targets.removeAll()}};e([g({type:["line-of-sight"]})],x.prototype,"type",void 0),e([g({type:o,json:{read:!0,write:!0}})],x.prototype,"observer",void 0),e([g({cast:i,type:j,nonNullable:!0,json:{read:!0,write:!0}})],x.prototype,"targets",null),e([g({value:null,readOnly:!0})],x.prototype,"extent",void 0),e([g({readOnly:!0})],x.prototype,"spatialReference",null),e([g({readOnly:!0})],x.prototype,"requiredPropertiesForEditing",null),e([g({readOnly:!0})],x.prototype,"nonEditableMessage",void 0),x=e([y("esri.analysis.LineOfSightAnalysis")],x);const E=x;export{E as default};
