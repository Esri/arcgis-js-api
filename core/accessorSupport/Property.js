/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{OriginId as s}from"./PropertyOrigin.js";import{trackAccess as t,runTracked as e,trackExplicitDependencies as i,runUntracked as r}from"./tracking.js";import{Flags as n}from"./tracking/Flags.js";import{ObservationHandle as o}from"./tracking/ObservationHandle.js";class l{constructor(s,t,e){this.properties=s,this.propertyName=t,this.metadata=e,this._observers=null,this._accessed=null,this._handles=null,this.flags=n.Dirty|(e.nonNullable?n.NonNullable:0)|(e.hasOwnProperty("value")?n.HasDefaultValue:0)|(void 0===e.get?n.DepTrackingInitialized:0)|(void 0===e.dependsOn?n.AutoTracked:0)}destroy(){if(this.flags&n.Dirty&&this._observers){const s=this._observers.slice();for(const t of s)t.onCommitted()}this._accessed=null,this._observers=null,this._clearObservationHandles()}getComputed(){t(this);const o=this.properties.store,l=this.propertyName,a=this.flags,h=o.get(l);if(a&n.Computing)return h;if(~a&n.Dirty&&o.has(l))return h;this.flags|=n.Computing;const d=this.properties.host;let c;a&n.AutoTracked?c=e(this,this.metadata.get,d):(i(d,this),c=this.metadata.get.call(d)),o.set(l,c,s.COMPUTED);const u=o.get(l);return u===h?this.flags&=~n.Dirty:r(this.commit,this),this.flags&=~n.Computing,u}onObservableAccessed(s){s!==this&&(null===this._accessed&&(this._accessed=[]),this._accessed.includes(s)||this._accessed.push(s))}onTrackingEnd(){this._clearObservationHandles(),this.flags|=n.DepTrackingInitialized;const s=this._accessed;if(null===s)return;let t=this._handles;null===t&&(t=this._handles=[]);for(let e=0;e<s.length;++e)t.push(s[e].observe(this));s.length=0}observe(s){return null===this._observers&&(this._observers=[]),this._observers.includes(s)||this._observers.push(s),new o(this._observers,s)}notifyChange(){this.onInvalidated(),this.onCommitted()}invalidate(){this.onInvalidated()}onInvalidated(){~this.flags&n.Overriden&&(this.flags|=n.Dirty);const s=this._observers;if(null!==s)for(let t=0;t<s.length;++t)s[t].onInvalidated()}commit(){this.flags&=~n.Dirty,this.onCommitted()}onCommitted(){if(null===this._observers)return;const s=this._observers.slice();for(let t=0;t<s.length;++t)s[t].onCommitted()}_clearObservationHandles(){const s=this._handles;if(null!==s){for(let t=0;t<s.length;++t)s[t].remove();s.length=0}}}export{l as Property};
