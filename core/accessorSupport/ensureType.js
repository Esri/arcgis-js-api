/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../has","../Logger"],(function(e,n,r){"use strict";const t=r.getLogger("esri.core.Accessor");function u(e){return null==e?e:new Date(e)}function o(e){return null==e?e:!!e}function s(e){return null==e?e:e.toString()}function a(e){return null==e?e:(e=parseFloat(e),isNaN(e)?0:e)}function i(e){return null==e?e:Math.round(parseFloat(e))}function l(e){return e&&e.constructor&&void 0!==e.constructor.__accessorMetadata__}function c(e,n){return null!=n&&e&&!(n instanceof e)}function f(e){return e&&"isCollection"in e}function y(e){return e&&e.Type?"function"==typeof e.Type?e.Type:e.Type.base:null}function p(e,n){return!!l(n)&&(t.error("Accessor#set","Assigning an instance of '"+(n.declaredClass||"unknown")+"' which is not a subclass of '"+v(e)+"'"),!0)}function g(e,n){return null==n?n:f(e)?function(e,n){if(!n||!n.constructor||!f(n.constructor))return p(e,n)?n:new e(n);const r=y(e.prototype.itemType),t=y(n.constructor.prototype.itemType);return r?t?r===t?n:r.prototype.isPrototypeOf(t.prototype)?new e(n):(p(e,n),n):new e(n):n}(e,n):c(e,n)?p(e,n)?n:new e(n):n}function v(e){return e&&e.prototype&&e.prototype.declaredClass||"unknown"}function d(e){switch(e){case Number:return a;case w:return i;case Boolean:return o;case String:return s;case Date:return u;default:return g.bind(null,e)}}function h(e,n){const r=d(e);return 1===arguments.length?r:r(n)}function b(e,n,r){return 1===arguments.length?b.bind(null,e):n?Array.isArray(n)?n.map((n=>e(n,r))):[e(n,r)]:n}function m(e,n,r){return 0!==n&&Array.isArray(r)?r.map((r=>m(e,n-1,r))):e(r)}function A(e,n,r){if(2===arguments.length)return A.bind(null,e,n);if(!r)return r;let t=n,u=r=m(e,n,r);for(;t>0&&Array.isArray(u);)t--,u=u[0];if(void 0!==u)for(let e=0;e<t;e++)r=[r];return r}let w=function(){};const $={native:e=>({type:"native",value:e}),array:e=>({type:"array",value:e}),oneOf:e=>({type:"one-of",values:e})};function T(e){switch(e.type){case"native":switch(e.value){case Number:return"number";case String:return"string";case Boolean:return"boolean";case w:return"integer";case Date:return"date";default:return v(e.value)}case"array":return`array of ${T(e.value)}`;case"one-of":{const n=e.values.map((e=>T(e)));return`one of ${n.slice(0,n.length-1)} or ${n[n.length-1]}`}}return"unknown"}function N(e,n){if(null==e)return!0;switch(n.type){case"native":switch(n.value){case Number:case w:return"number"==typeof e;case Boolean:return"boolean"==typeof e;case String:return"string"==typeof e}return e instanceof n.value;case"array":return!!Array.isArray(e)&&!e.some((e=>!N(e,n.value)));case"one-of":return n.values.some((n=>N(e,n)))}}e.Integer=w,e.default=h,e.ensureArray=function(e,n){return 1===arguments.length?b(h.bind(null,e)):b(h.bind(null,e),n)},e.ensureArrayTyped=b,e.ensureBoolean=o,e.ensureClass=g,e.ensureDate=u,e.ensureInteger=i,e.ensureLongFormType=function e(n){switch(n.type){case"native":return h(n.value);case"array":return b(e(n.value));case"one-of":return function(e){let n=null;return(r,u)=>N(r,e)?r:(null==n&&(n=T(e)),t.error("Accessor#set",`Invalid property value, value needs to be of type ${n}`),u&&(u.valid=!1),null)}(n);default:return null}},e.ensureNArray=function(e,n,r){return 2===arguments.length?A(h.bind(null,e),n):A(h.bind(null,e),n,r)},e.ensureNArrayTyped=A,e.ensureNumber=a,e.ensureOneOf=function e(n,r){if(2===arguments.length)return e(n).call(null,r);const u=new Set,o=n.filter((e=>"function"!=typeof e)),s=n.filter((e=>"function"==typeof e));for(const e of n)"string"!=typeof e&&"number"!=typeof e||u.add(e);let a=null,i=null;return(e,n)=>{if(null==e)return e;const r=typeof e,l="string"===r||"number"===r;return l&&(u.has(e)||s.some((e=>"string"===r&&e===String||"number"===r&&e===Number)))||"object"===r&&s.some((n=>!c(e,n)))?e:(l&&o.length?(a||(a=o.map((e=>"string"==typeof e?`'${e}'`:`${e}`)).join(", ")),t.error("Accessor#set",`'${e}' is not a valid value for this property, only the following values are valid: ${a}`)):"object"==typeof e&&s.length?(i||(i=s.map((e=>v(e))).join(", ")),t.error("Accessor#set",`'${e}' is not a valid value for this property, value must be one of ${i}`)):t.error("Accessor#set",`'${e}' is not a valid value for this property`),n&&(n.valid=!1),null)}},e.ensureOneOfType=function e(n,r){if(2===arguments.length)return e(n).call(null,r);const u={},o=[],s=[];for(const e in n.typeMap){const r=n.typeMap[e];u[e]=h(r),o.push(v(r)),s.push(e)}const a=()=>`'${o.join("', '")}'`,i=()=>`'${s.join("', '")}'`,f="string"==typeof n.key?e=>e[n.key]:n.key;return e=>{if(n.base&&!c(n.base,e))return e;if(null==e)return e;const r=f(e)||n.defaultKeyValue,o=u[r];if(!o)return t.error("Accessor#set",`Invalid property value, value needs to be one of ${a()}, or a plain object that can autocast (having .type = ${i()})`),null;if(!c(n.typeMap[r],e))return e;if("string"==typeof n.key&&!l(e)){const r={};for(const t in e)t!==n.key&&(r[t]=e[t]);return o(r)}return o(e)}},e.ensureString=s,e.ensureType=h,e.isClassedType=l,e.isLongFormType=function(e){if(!e||!("type"in e))return!1;switch(e.type){case"native":case"array":case"one-of":return!0}return!1},e.isOneOf=function(e){return!!Array.isArray(e)&&!e.some((n=>{const r=typeof n;return!("string"===r||"number"===r||"function"===r&&e.length>1)}))},e.requiresType=c,e.types=$,Object.defineProperty(e,"__esModule",{value:!0})}));
