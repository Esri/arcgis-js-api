/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{version as e}from"../../kernel.js";import s from"../Error.js";import{on as t}from"../events.js";import{removeMaybe as o,isSome as r}from"../maybe.js";import{isAborted as i,createAbortError as n,onAbort as a,isPromiseLike as c,isAbortError as l}from"../promiseUtils.js";import{newJobId as p,MessageType as h,receiveMessage as u,toInvokeError as _,postMessage as d}from"./utils.js";import{commitHash as g,buildDate as m}from"../../support/revision.js";const k={statsWorker:()=>import("../../smartMapping/statistics/support/statsWorker.js"),geometryEngineWorker:()=>import("../../geometry/geometryEngineWorker.js"),CSVSourceWorker:()=>import("../../layers/graphics/sources/support/CSVSourceWorker.js"),EdgeProcessingWorker:()=>import("../../views/3d/webgl-engine/lib/edgeRendering/EdgeProcessingWorker.js"),ElevationSamplerWorker:()=>import("../../geometry/support/meshUtils/ElevationSamplerWorker.js"),FeatureServiceSnappingSourceWorker:()=>import("../../views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js"),GeoJSONSourceWorker:()=>import("../../layers/graphics/sources/geojson/GeoJSONSourceWorker.js"),LercWorker:()=>import("../../layers/support/LercWorker.js"),MemorySourceWorker:()=>import("../../layers/graphics/sources/support/MemorySourceWorker.js"),PBFDecoderWorker:()=>import("../../views/3d/support/PBFDecoderWorker.js"),Pipeline:()=>import("../../views/2d/layers/features/Pipeline.js"),PointCloudWorker:()=>import("../../views/3d/layers/PointCloudWorker.js"),RasterWorker:()=>import("../../layers/support/RasterWorker.js"),SceneLayerSnappingSourceWorker:()=>import("../../views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker.js"),SceneLayerWorker:()=>import("../../views/3d/layers/SceneLayerWorker.js"),WFSSourceWorker:()=>import("../../layers/graphics/sources/WFSSourceWorker.js"),WorkerTileHandler:()=>import("../../views/2d/engine/vectorTiles/WorkerTileHandler.js")},{CLOSE:b,ABORT:v,INVOKE:y,RESPONSE:j,OPEN_PORT:S,ON:f}=h,W=2;class M{constructor(e){this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._invoke=e,this._timer=null,this._process=this._process.bind(this)}push(e){e.type===h.ABORT?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)))}clear(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null}_process(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0}}class w{constructor(e,s,t){this._port=e,this._getNextJob=t,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new M((e=>this._onInvokeMessage(e))),this._client=s.client,this._onMessage=this._onMessage.bind(this),this._channel=s.channel,this._schedule=s.schedule,this._port.addEventListener("message",this._onMessage),this._port.start()}static connect(e){const s=new MessageChannel;let t;t="function"==typeof e?new e:"default"in e&&"function"==typeof e.default?new e.default:e;const o=new w(s.port1,{channel:s,client:t},(()=>null));return"object"==typeof t&&"remoteClient"in t&&(t.remoteClient=o),w.clients.set(o,t),s.port2}static loadWorker(e){const s=k[e];return s?s():Promise.resolve(null)}close(){this._post({type:b}),this._close()}isBusy(){return this._outJobs.size>0}invoke(e,t,r){const c=r&&r.signal,l=r&&r.transferList;if(!this._port)return Promise.reject(new s("worker:port-closed",`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:t}));const h=p();return new Promise(((s,r)=>{if(i(c))return this._processWork(),void r(n());const p=a(c,(()=>{const e=this._outJobs.get(h);e&&(this._outJobs.delete(h),this._processWork(),o(e.abortHandle),this._post({type:v,jobId:h}),r(n()))})),u={resolve:s,reject:r,abortHandle:p,debugInfo:e};this._outJobs.set(h,u),this._post({type:y,jobId:h,methodName:e,abortable:null!=c},t,l)}))}on(e,s){const t=new MessageChannel;function o(e){s(e.data)}return this._port.postMessage({type:h.ON,eventType:e,port:t.port2},[t.port2]),t.port1.addEventListener("message",o),t.port1.start(),{remove(){t.port1.postMessage({type:h.CLOSE}),t.port1.close(),t.port1.removeEventListener("message",o)}}}jobAdded(){this._processWork()}openPort(){const e=new MessageChannel;return this._post({type:S,port:e.port2}),e.port1}_processWork(){if(this._outJobs.size>=W)return;const e=this._getNextJob();if(!e)return;const{methodName:s,data:t,invokeOptions:o,deferred:r}=e;this.invoke(s,t,o).then((e=>r.resolve(e))).catch((e=>r.reject(e)))}_close(){this._channel&&(this._channel=null),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach((e=>{o(e.abortHandle),e.reject(n(`Worker closing, aborting job calling '${e.debugInfo}'`))})),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=this._client=this._schedule=null}_onMessage(e){r(this._schedule)?this._schedule((()=>this._processMessage(e))):this._processMessage(e)}_processMessage(e){const s=u(e);if(s)switch(s.type){case j:this._onResponseMessage(s);break;case y:this._invokeQueue.push(s);break;case v:this._onAbortMessage(s);break;case b:this._onCloseMessage();break;case S:this._onOpenPortMessage(s);break;case f:this._onOnMessage(s)}}_onAbortMessage(e){const s=this._inJobs,t=e.jobId,o=s.get(t);this._invokeQueue.push(e),o&&(o.controller&&o.controller.abort(),s.delete(t))}_onCloseMessage(){const e=this._client;this._close(),e&&"destroy"in e&&w.clients.get(this)===e&&e.destroy(),w.clients.delete(this),e&&e.remoteClient&&(e.remoteClient=null)}_onInvokeMessage(e){const{methodName:s,jobId:t,data:o,abortable:r}=e,i=r?new AbortController:null,n=this._inJobs;let a,p=this._client,h=p[s];try{if(!h&&s&&s.includes(".")){const e=s.split(".");for(let s=0;s<e.length-1;s++)p=p[e[s]],h=p[e[s+1]]}if("function"!=typeof h)throw new TypeError(`${s} is not a function`);a=h.call(p,o,{client:this,signal:i?i.signal:null})}catch(u){return void this._post({type:j,jobId:t,error:_(u)})}c(a)?(n.set(t,{controller:i,promise:a}),a.then((e=>{n.has(t)&&(n.delete(t),this._post({type:j,jobId:t},e))}),(e=>{n.has(t)&&(n.delete(t),l(e)||this._post({type:j,jobId:t,error:_(e||{message:`Error encountered at method ${s}`})}))}))):this._post({type:j,jobId:t},a)}_onOpenPortMessage(e){new w(e.port,{client:this._client},(()=>null))}_onOnMessage(e){const{port:s}=e,o=this._client.on(e.eventType,(e=>{s.postMessage(e)})),r=t(e.port,"message",(e=>{u(e).type===h.CLOSE&&(r.remove(),o.remove(),s.close())}))}_onResponseMessage(e){const{jobId:t,error:r,data:i}=e,n=this._outJobs;if(!n.has(t))return;const a=n.get(t);this._processWork(),n.delete(t),o(a.abortHandle),r?a.reject(s.fromJSON(JSON.parse(r))):a.resolve(i)}_post(e,s,t){return d(this._port,e,s,t)}}w.kernelInfo={revision:g,version:e,buildDate:m},w.clients=new Map;export{w as default};
