/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["require","../../kernel","../Error","../events","../maybe","../promiseUtils","./utils","../../support/revision"],(function(e,s,t,o,r,n,i,a){"use strict";const c=e=>Object.freeze(Object.defineProperty({__proto__:null,default:e},Symbol.toStringTag,{value:"Module"})),l={statsWorker:()=>new Promise(((s,t)=>e(["../../smartMapping/statistics/support/statsWorker"],s,t))),geometryEngineWorker:()=>new Promise(((s,t)=>e(["../../geometry/geometryEngineWorker"],s,t))),CSVSourceWorker:()=>new Promise(((s,t)=>e(["../../layers/graphics/sources/support/CSVSourceWorker"],s,t))),EdgeProcessingWorker:()=>new Promise(((s,t)=>e(["../../views/3d/webgl-engine/lib/edgeRendering/EdgeProcessingWorker"],s,t))),ElevationSamplerWorker:()=>new Promise(((s,t)=>e(["../../geometry/support/meshUtils/ElevationSamplerWorker"],(e=>s(c(e))),t))),FeatureServiceSnappingSourceWorker:()=>new Promise(((s,t)=>e(["../../views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker"],s,t))),GeoJSONSourceWorker:()=>new Promise(((s,t)=>e(["../../layers/graphics/sources/geojson/GeoJSONSourceWorker"],(e=>s(c(e))),t))),LercWorker:()=>new Promise(((s,t)=>e(["../../layers/support/LercWorker"],(e=>s(c(e))),t))),MemorySourceWorker:()=>new Promise(((s,t)=>e(["../../layers/graphics/sources/support/MemorySourceWorker"],(e=>s(c(e))),t))),PBFDecoderWorker:()=>new Promise(((s,t)=>e(["../../views/3d/support/PBFDecoderWorker"],(e=>s(c(e))),t))),Pipeline:()=>new Promise(((s,t)=>e(["../../views/2d/layers/features/Pipeline"],s,t))),PointCloudWorker:()=>new Promise(((s,t)=>e(["../../views/3d/layers/PointCloudWorker"],(e=>s(c(e))),t))),RasterWorker:()=>new Promise(((s,t)=>e(["../../layers/support/RasterWorker"],(e=>s(c(e))),t))),SceneLayerWorker:()=>new Promise(((s,t)=>e(["../../views/3d/layers/SceneLayerWorker"],s,t))),WFSSourceWorker:()=>new Promise(((s,t)=>e(["../../layers/graphics/sources/WFSSourceWorker"],(e=>s(c(e))),t))),WorkerTileHandler:()=>new Promise(((s,t)=>e(["../../views/2d/engine/vectorTiles/WorkerTileHandler"],(e=>s(c(e))),t)))},{CLOSE:u,ABORT:h,INVOKE:p,RESPONSE:_,OPEN_PORT:d,ON:g}=i.MessageType;let m=function(){function e(e){this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._invoke=e,this._timer=null,this._process=this._process.bind(this)}var s=e.prototype;return s.push=function(e){e.type===i.MessageType.ABORT?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)))},s.clear=function(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null},s._process=function(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0},e}(),b=function(){function e(e,s){this._port=e,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new m((e=>this._onInvokeMessage(e))),this._client=s.client,this._onMessage=this._onMessage.bind(this),this._channel=s.channel,this._schedule=s.schedule,this._port.addEventListener("message",this._onMessage),this._port.start()}e.connect=function(s){const t=new MessageChannel;let o;o="function"==typeof s?new s:"default"in s&&"function"==typeof s.default?new s.default:s;const r=new e(t.port1,{channel:t,client:o});return"object"==typeof o&&"remoteClient"in o&&(o.remoteClient=r),e.clients.set(r,o),t.port2},e.loadWorker=function(e){const s=l[e];return s?s():Promise.resolve(null)};var s=e.prototype;return s.close=function(){this._post({type:u}),this._close()},s.isBusy=function(){return this._outJobs.size>0},s.invoke=function(e,s,o){const r=o&&o.signal,a=o&&o.transferList;if(!this._port)return Promise.reject(new t("worker:port-closed",`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:s}));const c=i.newJobId();return new Promise(((t,o)=>{const i=n.onAbortOrThrow(r,(()=>{var e;const s=this._outJobs.get(c);s&&(this._outJobs.delete(c),null==(e=s.abortHandle)||e.remove(),this._post({type:h,jobId:c}),o(n.createAbortError()))})),l={resolve:t,reject:o,abortHandle:i,debugInfo:e};this._outJobs.set(c,l),this._post({type:p,jobId:c,methodName:e,abortable:null!=r},s,a)}))},s.on=function(e,s){const t=new MessageChannel;function o(e){s(e.data)}return this._port.postMessage({type:i.MessageType.ON,eventType:e,port:t.port2},[t.port2]),t.port1.addEventListener("message",o),t.port1.start(),{remove(){t.port1.postMessage({type:i.MessageType.CLOSE}),t.port1.close(),t.port1.removeEventListener("message",o)}}},s.openPort=function(){const e=new MessageChannel;return this._post({type:d,port:e.port2}),e.port1},s._close=function(){this._channel&&(this._channel=null),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach((e=>{var s;null==(s=e.abortHandle)||s.remove(),e.reject(n.createAbortError(`Worker closing, aborting job calling '${e.debugInfo}'`))})),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=this._client=this._schedule=null},s._onMessage=function(e){r.isSome(this._schedule)?this._schedule((()=>this._processMessage(e))):this._processMessage(e)},s._processMessage=function(e){const s=i.receiveMessage(e);if(s)switch(s.type){case _:this._onResponseMessage(s);break;case p:this._invokeQueue.push(s);break;case h:this._onAbortMessage(s);break;case u:this._onCloseMessage();break;case d:this._onOpenPortMessage(s);break;case g:this._onOnMessage(s)}},s._onAbortMessage=function(e){const s=this._inJobs,t=e.jobId,o=s.get(t);this._invokeQueue.push(e),o&&(o.controller&&o.controller.abort(),s.delete(t))},s._onCloseMessage=function(){const s=this._client;this._close(),s&&"destroy"in s&&e.clients.get(this)===s&&s.destroy(),e.clients.delete(this),s&&s.remoteClient&&(s.remoteClient=null)},s._onInvokeMessage=function(e){const{methodName:s,jobId:t,data:o,abortable:r}=e,a=r?new AbortController:null,c=this._inJobs;let l,u=this._client,h=u[s];try{if(!h&&s&&-1!==s.indexOf(".")){const e=s.split(".");for(let s=0;s<e.length-1;s++)u=u[e[s]],h=u[e[s+1]]}if("function"!=typeof h)throw new TypeError(`${s} is not a function`);l=h.call(u,o,{client:this,signal:a?a.signal:null})}catch(p){return void this._post({type:_,jobId:t,error:i.toInvokeError(p)})}n.isPromiseLike(l)?(c.set(t,{controller:a,promise:l}),l.then((e=>{c.has(t)&&(c.delete(t),this._post({type:_,jobId:t},e))}),(e=>{c.has(t)&&(c.delete(t),n.isAbortError(e)||this._post({type:_,jobId:t,error:i.toInvokeError(e||{message:`Error encountered at method ${s}`})}))}))):this._post({type:_,jobId:t},l)},s._onOpenPortMessage=function(s){new e(s.port,{client:this._client})},s._onOnMessage=function(e){const{port:s}=e,t=this._client.on(e.eventType,(e=>{s.postMessage(e)})),r=o.on(e.port,"message",(e=>{i.receiveMessage(e).type===i.MessageType.CLOSE&&(r.remove(),t.remove(),s.close())}))},s._onResponseMessage=function(e){var s;const{jobId:o,error:r,data:n}=e,i=this._outJobs;if(!i.has(o))return;const a=i.get(o);i.delete(o),null==(s=a.abortHandle)||s.remove(),r?a.reject(t.fromJSON(JSON.parse(r))):a.resolve(n)},s._post=function(e,s,t){return i.postMessage(this._port,e,s,t)},e}();return b.kernelInfo={revision:a.commitHash,version:s.version,buildDate:a.buildDate},b.clients=new Map,b}));
