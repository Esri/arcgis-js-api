/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["require","../../kernel","../Error","../events","../maybe","../promiseUtils","./utils","../../support/revision"],(function(e,s,t,o,r,n,i,c){"use strict";const a=e=>Object.freeze(Object.defineProperty({__proto__:null,default:e},Symbol.toStringTag,{value:"Module"})),l={statsWorker:()=>new Promise(((s,t)=>e(["../../smartMapping/statistics/support/statsWorker"],s,t))),geometryEngineWorker:()=>new Promise(((s,t)=>e(["../../geometry/geometryEngineWorker"],s,t))),CSVSourceWorker:()=>new Promise(((s,t)=>e(["../../layers/graphics/sources/support/CSVSourceWorker"],(e=>s(a(e))),t))),EdgeProcessingWorker:()=>new Promise(((s,t)=>e(["../../views/3d/webgl-engine/lib/edgeRendering/EdgeProcessingWorker"],(e=>s(a(e))),t))),ElevationSamplerWorker:()=>new Promise(((s,t)=>e(["../../geometry/support/meshUtils/ElevationSamplerWorker"],(e=>s(a(e))),t))),FeatureServiceSnappingSourceWorker:()=>new Promise(((s,t)=>e(["../../views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker"],(e=>s(a(e))),t))),GeoJSONSourceWorker:()=>new Promise(((s,t)=>e(["../../layers/graphics/sources/geojson/GeoJSONSourceWorker"],(e=>s(a(e))),t))),LercWorker:()=>new Promise(((s,t)=>e(["../../layers/support/LercWorker"],(e=>s(a(e))),t))),MemorySourceWorker:()=>new Promise(((s,t)=>e(["../../layers/graphics/sources/support/MemorySourceWorker"],(e=>s(a(e))),t))),PBFDecoderWorker:()=>new Promise(((s,t)=>e(["../../views/3d/support/PBFDecoderWorker"],(e=>s(a(e))),t))),Pipeline:()=>new Promise(((s,t)=>e(["../../views/2d/layers/features/Pipeline"],(e=>s(a(e))),t))),PointCloudWorker:()=>new Promise(((s,t)=>e(["../../views/3d/layers/PointCloudWorker"],(e=>s(a(e))),t))),RasterWorker:()=>new Promise(((s,t)=>e(["../../layers/support/RasterWorker"],(e=>s(a(e))),t))),SceneLayerSnappingSourceWorker:()=>new Promise(((s,t)=>e(["../../views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker"],(e=>s(a(e))),t))),SceneLayerWorker:()=>new Promise(((s,t)=>e(["../../views/3d/layers/SceneLayerWorker"],s,t))),WFSSourceWorker:()=>new Promise(((s,t)=>e(["../../layers/graphics/sources/WFSSourceWorker"],(e=>s(a(e))),t))),WorkerTileHandler:()=>new Promise(((s,t)=>e(["../../views/2d/engine/vectorTiles/WorkerTileHandler"],(e=>s(a(e))),t)))},{CLOSE:u,ABORT:p,INVOKE:h,RESPONSE:_,OPEN_PORT:d,ON:g}=i.MessageType,b=2;let m=function(){function e(e){this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._invoke=e,this._timer=null,this._process=this._process.bind(this)}var s=e.prototype;return s.push=function(e){e.type===i.MessageType.ABORT?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)))},s.clear=function(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null},s._process=function(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0},e}(),k=function(){function e(e,s,t){this._port=e,this._getNextJob=t,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new m((e=>this._onInvokeMessage(e))),this._client=s.client,this._onMessage=this._onMessage.bind(this),this._channel=s.channel,this._schedule=s.schedule,this._port.addEventListener("message",this._onMessage),this._port.start()}e.connect=function(s){const t=new MessageChannel;let o;o="function"==typeof s?new s:"default"in s&&"function"==typeof s.default?new s.default:s;const r=new e(t.port1,{channel:t,client:o},(()=>null));return"object"==typeof o&&"remoteClient"in o&&(o.remoteClient=r),e.clients.set(r,o),t.port2},e.loadWorker=function(e){const s=l[e];return s?s():Promise.resolve(null)};var s=e.prototype;return s.close=function(){this._post({type:u}),this._close()},s.isBusy=function(){return this._outJobs.size>0},s.invoke=function(e,s,o){const c=o&&o.signal,a=o&&o.transferList;if(!this._port)return Promise.reject(new t("worker:port-closed",`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:s}));const l=i.newJobId();return new Promise(((t,o)=>{if(n.isAborted(c))return this._processWork(),void o(n.createAbortError());const i=n.onAbort(c,(()=>{const e=this._outJobs.get(l);e&&(this._outJobs.delete(l),this._processWork(),r.removeMaybe(e.abortHandle),this._post({type:p,jobId:l}),o(n.createAbortError()))})),u={resolve:t,reject:o,abortHandle:i,debugInfo:e};this._outJobs.set(l,u),this._post({type:h,jobId:l,methodName:e,abortable:null!=c},s,a)}))},s.on=function(e,s){const t=new MessageChannel;function o(e){s(e.data)}return this._port.postMessage({type:i.MessageType.ON,eventType:e,port:t.port2},[t.port2]),t.port1.addEventListener("message",o),t.port1.start(),{remove(){t.port1.postMessage({type:i.MessageType.CLOSE}),t.port1.close(),t.port1.removeEventListener("message",o)}}},s.jobAdded=function(){this._processWork()},s.openPort=function(){const e=new MessageChannel;return this._post({type:d,port:e.port2}),e.port1},s._processWork=function(){if(this._outJobs.size>=b)return;const e=this._getNextJob();if(!e)return;const{methodName:s,data:t,invokeOptions:o,deferred:r}=e;this.invoke(s,t,o).then((e=>r.resolve(e))).catch((e=>r.reject(e)))},s._close=function(){this._channel&&(this._channel=void 0),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach((e=>{r.removeMaybe(e.abortHandle),e.reject(n.createAbortError(`Worker closing, aborting job calling '${e.debugInfo}'`))})),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=this._client=this._schedule=null},s._onMessage=function(e){r.isSome(this._schedule)?this._schedule((()=>this._processMessage(e))):this._processMessage(e)},s._processMessage=function(e){const s=i.receiveMessage(e);if(s)switch(s.type){case _:this._onResponseMessage(s);break;case h:this._invokeQueue.push(s);break;case p:this._onAbortMessage(s);break;case u:this._onCloseMessage();break;case d:this._onOpenPortMessage(s);break;case g:this._onOnMessage(s)}},s._onAbortMessage=function(e){const s=this._inJobs,t=e.jobId,o=s.get(t);this._invokeQueue.push(e),o&&(o.controller&&o.controller.abort(),s.delete(t))},s._onCloseMessage=function(){const s=this._client;this._close(),s&&"destroy"in s&&e.clients.get(this)===s&&s.destroy(),e.clients.delete(this),s&&s.remoteClient&&(s.remoteClient=null)},s._onInvokeMessage=function(e){const{methodName:s,jobId:t,data:o,abortable:r}=e,c=r?new AbortController:null,a=this._inJobs;let l,u=this._client,p=u[s];try{if(!p&&s&&s.includes(".")){const e=s.split(".");for(let s=0;s<e.length-1;s++)u=u[e[s]],p=u[e[s+1]]}if("function"!=typeof p)throw new TypeError(`${s} is not a function`);l=p.call(u,o,{client:this,signal:c?c.signal:null})}catch(h){return void this._post({type:_,jobId:t,error:i.toInvokeError(h)})}n.isPromiseLike(l)?(a.set(t,{controller:c,promise:l}),l.then((e=>{a.has(t)&&(a.delete(t),this._post({type:_,jobId:t},e))}),(e=>{a.has(t)&&(a.delete(t),n.isAbortError(e)||this._post({type:_,jobId:t,error:i.toInvokeError(e||{message:`Error encountered at method ${s}`})}))}))):this._post({type:_,jobId:t},l)},s._onOpenPortMessage=function(s){new e(s.port,{client:this._client},(()=>null))},s._onOnMessage=function(e){const{port:s}=e,t=this._client.on(e.eventType,(e=>{s.postMessage(e)})),r=o.on(e.port,"message",(e=>{i.receiveMessage(e)?.type===i.MessageType.CLOSE&&(r.remove(),t.remove(),s.close())}))},s._onResponseMessage=function(e){const{jobId:s,error:o,data:n}=e,i=this._outJobs;if(!i.has(s))return;const c=i.get(s);i.delete(s),this._processWork(),r.removeMaybe(c.abortHandle),o?c.reject(t.fromJSON(JSON.parse(o))):c.resolve(n)},s._post=function(e,s,t){return i.postMessage(this._port,e,s,t)},e}();return k.kernelInfo={revision:c.commitHash,version:s.version,buildDate:c.buildDate},k.clients=new Map,k}));
