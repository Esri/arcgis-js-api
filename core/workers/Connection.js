/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{handlesGroup as e}from"../handleUtils.js";import t from"../Logger.js";import{isPromiseLike as s,createAbortError as n,createDeferred as i,throwIfAborted as o}from"../promiseUtils.js";import r from"../Queue.js";import l from"./RemoteClient.js";const h=t.getLogger("esri.core.workers.Connection");class c{constructor(){this._inUseClients=new Array,this._clients=new Array,this._clientPromises=new Array,this._ongoingJobsQueue=new r}destroy(){this.close()}get closed(){return!this._clients||!this._clients.length}open(e,t){return new Promise(((n,i)=>{let r=!0;const h=e=>{o(t.signal),r&&(r=!1,e())};this._clients.length=e.length,this._clientPromises.length=e.length,this._inUseClients.length=e.length;for(let o=0;o<e.length;++o){const r=e[o];s(r)?this._clientPromises[o]=r.then((e=>(this._clients[o]=new l(e,t,(()=>this._ongoingJobsQueue.pop())),h(n),this._clients[o])),(()=>(h(i),null))):(this._clients[o]=new l(r,t,(()=>this._ongoingJobsQueue.pop())),this._clientPromises[o]=Promise.resolve(this._clients[o]),h(n))}}))}broadcast(e,t,s){const n=new Array(this._clientPromises.length);for(let i=0;i<this._clientPromises.length;++i){const o=this._clientPromises[i];n[i]=o.then((n=>n.invoke(e,t,s)))}return n}close(){let e;for(;e=this._ongoingJobsQueue.pop();)e.deferred.reject(n(`Worker closing, aborting job calling '${e.methodName}'`));for(const t of this._clientPromises)t.then((e=>e.close()));this._clients.length=0,this._clientPromises.length=0}invoke(e,t,s){let n=null;Array.isArray(s)?(h.warn("invoke()","The transferList parameter is deprecated, use the options object instead"),n={transferList:s}):n=s;const o=i();this._ongoingJobsQueue.push({methodName:e,data:t,invokeOptions:n,deferred:o});for(let i=0;i<this._clientPromises.length;i++){const e=this._clients[i];e?e.jobAdded():this._clientPromises[i].then((e=>e.jobAdded()))}return o.promise}on(t,s){return Promise.all(this._clientPromises).then((()=>e(this._clients.map((e=>e.on(t,s))))))}openPorts(){return new Promise((e=>{const t=new Array(this._clientPromises.length);let s=t.length;for(let n=0;n<this._clientPromises.length;++n){this._clientPromises[n].then((i=>{t[n]=i.openPort(),0==--s&&e(t)}))}}))}get test(){return{numClients:this._clients.length}}}export{c as default};
