/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{clock as t}from"./clock.js";import{deprecatedFunction as e}from"./deprecate.js";import r from"./Error.js";import{once as n}from"./events.js";import o from"./Logger.js";import{isSome as i,isNone as s,assumeNonNull as c,removeMaybe as u}from"./maybe.js";async function l(t,e){const r=t.slice(),n=await Promise.all(t.map(((t,r)=>e(t,r))));return r.filter(((t,e)=>n[e]))}function a(t){return e(o.getLogger("esri.core.promiseUtils"),"create",{moduleName:"esri.core.promiseUtils",replacement:"new Promise()",version:"4.24"}),new Promise(((e,r)=>{try{t(e,r)}catch(n){Promise.resolve().then((()=>r(n)))}}))}function m(t="Aborted"){return new r("AbortError",t)}function f(t,e="Aborted"){if(p(t))throw m(e)}function h(t){return i(t)?"aborted"in t?t:t.signal:t}function p(t){const e=h(t);return i(e)&&e.aborted}function w(t){if(g(t))throw t}function b(t){if(!g(t))throw t}function v(t,e){const r=h(t);if(!s(r)){if(!r.aborted)return n(r,"abort",(()=>e()));e()}}function d(t,e){const r=h(t);if(!s(r))return f(r),n(r,"abort",(()=>e(m())))}function y(t,e){const r=h(e);return s(r)?t:new Promise(((r,n)=>{let o=v(e,(()=>n(m())));const i=()=>o=u(o);t.then(i,i),t.then(r,n)}))}function P(t,e,n){return Promise.race([t,L(e).then((()=>{throw new r("timeout",`Did not resolve within ${e} milliseconds (${n??"timeout"})`)}))])}function g(t){return t&&"AbortError"===t.name}async function j(t){try{return await t}catch(e){if(!g(e))throw e}}async function A(t,e=o.getLogger("esri")){try{return await t}catch(r){g(r)||e.error(r)}}function T(){let t=null;const e=new Promise(((e,r)=>{t={promise:void 0,resolve:e,reject:r}}));return t.promise=e,t}async function E(t){if(!t)return;if("function"!=typeof t.forEach){const e=Object.keys(t),r=e.map((e=>t[e])),n=await E(r),o={};return e.map(((t,e)=>o[t]=n[e])),o}const e=t;return new Promise((t=>{const r=[];let n=e.length;0===n&&t(r),e.forEach((e=>{const o={promise:e||Promise.resolve(e)};r.push(o),o.promise.then((t=>{o.value=t})).catch((t=>{o.error=t})).then((()=>{--n,0===n&&t(r)}))}))}))}async function C(t){return(await E(t)).filter((t=>!!t.value)).map((t=>t.value))}function L(t,e,r){const n=new AbortController;return v(r,(()=>n.abort())),new Promise(((r,o)=>{let i=setTimeout((()=>{i=0,r(e)}),t);v(n,(()=>{i&&(clearTimeout(i),o(m()))}))}))}function U(t,e,n,o){const i=n&&"abort"in n?n:null;null!=o||i||(o=n);let s=setTimeout((()=>{s=0,i&&i.abort()}),e);const c=()=>o||new r("promiseUtils:timeout","The wrapped promise did not resolve within "+e+" ms");return t.then((t=>{if(0===s)throw c();return clearTimeout(s),t}),(t=>{throw clearTimeout(s),0===s?c():t}))}function k(t){return t&&"function"==typeof t.then}function $(t){return k(t)?t:Promise.resolve(t)}function x(t,e=-1){let r,n,o,i,s=null;const u=(...l)=>{if(r){n=l,i&&i.reject(m()),i=T();const t=c(i.promise);if(s){const t=s;s=null,t.abort()}return t}if(o=i||T(),i=null,e>0){const n=new AbortController;r=$(t(...l,n.signal));const o=r;L(e).then((()=>{r===o&&(i?n.abort():s=n)}))}else r=1,r=$(t(...l));const a=()=>{const t=n;n=o=r=s=null,null!=t&&u(...t)},f=r,h=o;return f.then(a,a),f.then(h.resolve,h.reject),c(h.promise)};return u}function D(){let e,r;const n=new Promise(((t,n)=>{e=t,r=n})),o=t=>{e(t)};return o.resolve=t=>e(t),o.reject=t=>r(t),o.timeout=(e,r)=>t.setTimeout((()=>o.reject(r)),e),o.promise=n,o}function N(t,e){return t.then(e,e)}function O(t,e){let r,n=new AbortController;const o=t(n.signal);let s={promise:o,finished:!1,abort:()=>{n&&(n.abort(),n=null)}};const c=()=>{s&&(s.finished=!0,s=null),i(r)&&(r.remove(),r=null),n=null};return o.then(c,c),r=v(e,(()=>{i(s)&&s.abort()})),s}async function q(t){await Promise.resolve(),f(t)}export{L as after,N as always,a as create,m as createAbortError,T as createDeferred,D as createResolver,O as createTask,x as debounce,E as eachAlways,C as eachAlwaysValues,l as filter,j as ignoreAbortErrors,g as isAbortError,p as isAborted,k as isPromiseLike,A as logOnError,v as onAbort,d as onAbortOrThrow,w as throwIfAbortError,f as throwIfAborted,b as throwIfNotAbortError,U as timeout,q as waitTick,$ as when,y as whenOrAbort,P as whenOrTimeout};
