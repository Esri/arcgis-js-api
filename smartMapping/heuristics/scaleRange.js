/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../core/Error","../../core/maybe","../../geometry/support/scaleUtils","../statistics/spatialStatistics","../support/binningUtils","../support/adapters/support/layerUtils"],(function(e,n,a,t,i,r,l){"use strict";const s=500,o=1e8,c=1280,u=12,p=30,y=15;function f(e){return g.apply(this,arguments)}function g(){return(g=e._asyncToGenerator((function*(e){const{view:t,sampleSize:i}=e;if(!(e&&t&&e.layer))throw new n("scale-range:missing-parameters","'view' and 'layer' parameters are required");e.forBinning&&r.verifyBinningParams(e,"scale-range");const{layer:o,...c}=e,u=e.forBinning?l.binningCapableLayerTypes:l.featureCapableLayerTypes,p=l.createLayerAdapter(o,u,e.forBinning),y={layerAdapter:p,...c};if(y.sampleSize=i||s,!p)throw new n("scale-range:invalid-parameters","'layer' must be one of these types: "+l.getLayerTypeLabels(u).join(", "));yield t.when();const f=a.isSome(y.signal)?{signal:y.signal}:null;return yield p.load(f),y}))).apply(this,arguments)}function m(e,n){const a=u,t=c/4,i=p,r=c/4,l=y,s=c/2;let o=null,f=null,g=null,m=null;switch(e){case"point":case"multipoint":{const e=n;o=e.avgMinDistance,f=a,g=e.minDistance,m=t;break}case"polyline":{const e=n;o=e.avgLength,f=i,g=e.minLength,m=r;break}case"polygon":{const e=n;o=e.avgSize,f=l,g=e.minSize,m=s;break}}return{resolutionForMinScale:o>0?o/f:null,resolutionForMaxScale:g>0?g/m:null}}function S(e,n,a){const i=m(e.geometryType,n);return{minScale:t.getScaleForResolution(i.resolutionForMinScale,a.spatialReference),maxScale:t.getScaleForResolution(i.resolutionForMaxScale,a.spatialReference)}}function h(e,n,a=!0){if(e.constraints&&"effectiveLODs"in e.constraints){const t=e.constraints.effectiveLODs,i=a?t:t.slice(0).reverse();let r=null;for(const e of i)if(!(a?e.scale>n:e.scale<n)){r=e;break}return r}}function d(e,a,t,i){const{view:r,snapToLOD:l,layerAdapter:s}=e;if(l){const e=h(r,a),n=h(r,t,!1);a=e?e.scale:a,t=n?n.scale:t}if(a<t)throw new n("scale-range:invalid","calculated minScale is less than maxScale.");return t>a/2&&(t=Math.floor(t/2)),a>o&&(a=0),"polygon"!==s.geometryType&&(t=0),{minScale:Math.ceil(a),maxScale:Math.floor(t),spatialStatistics:i}}function v(e){return w.apply(this,arguments)}function w(){return(w=e._asyncToGenerator((function*(e){const a=yield f(e),{view:t,sampleSize:r,layerAdapter:l,signal:s}=a,o=yield l.getSampleFeatures({view:t,sampleSize:r,returnGeometry:!0,signal:s});if(!o?.length)throw new n("scale-range:insufficient-info","No features are available to calculate statistics");const c=yield i({features:o,geometryType:l.geometryType}),{minScale:u,maxScale:p}=S(l,c,t);return d(a,u,p,c)}))).apply(this,arguments)}return v}));
