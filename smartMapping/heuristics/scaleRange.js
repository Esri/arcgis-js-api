/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{isSome as a}from"../../core/maybe.js";import{getScaleForResolution as t}from"../../geometry/support/scaleUtils.js";import n from"../statistics/spatialStatistics.js";import{createLayerAdapter as s,featureCapableLayerTypes as r,getLayerTypeLabels as i}from"../support/adapters/support/layerUtils.js";const l=500,o=1e8,c=1280,m=12,p=30,u=15;async function f(t){const{view:n,sampleSize:o}=t;if(!(t&&n&&t.layer))throw new e("scale-range:missing-parameters","'view' and 'layer' parameters are required");const{layer:c,...m}=t,p=s(c,r),u={layerAdapter:p,...m};if(u.sampleSize=o||l,!p)throw new e("scale-range:invalid-parameters","'layer' must be one of these types: "+i(r).join(", "));await n.when();const f=a(u.signal)?{signal:u.signal}:null;return await p.load(f),u}function y(e,a){const t=m,n=c/4,s=p,r=c/4,i=u,l=c/2;let o=null,f=null,y=null,g=null;switch(e){case"point":case"multipoint":{const e=a;o=e.avgMinDistance,f=t,y=e.minDistance,g=n;break}case"polyline":{const e=a;o=e.avgLength,f=s,y=e.minLength,g=r;break}case"polygon":{const e=a;o=e.avgSize,f=i,y=e.minSize,g=l;break}}return{resolutionForMinScale:o>0?o/f:null,resolutionForMaxScale:y>0?y/g:null}}function g(e,a,n){const s=y(e.geometryType,a);return{minScale:t(s.resolutionForMinScale,n.spatialReference),maxScale:t(s.resolutionForMaxScale,n.spatialReference)}}function S(e,a,t=!0){if(e.constraints&&"effectiveLODs"in e.constraints){const n=e.constraints.effectiveLODs,s=t?n:n.slice(0).reverse();let r=null;for(const e of s)if(!(t?e.scale>a:e.scale<a)){r=e;break}return r}}function w(a,t,n,s){const{view:r,snapToLOD:i,layerAdapter:l}=a;if(i){const e=S(r,t),a=S(r,n,!1);t=e?e.scale:t,n=a?a.scale:n}if(t<n)throw new e("scale-range:invalid","calculated minScale is less than maxScale.");return n>t/2&&(n=Math.floor(n/2)),t>o&&(t=0),"polygon"!==l.geometryType&&(n=0),{minScale:Math.ceil(t),maxScale:Math.floor(n),spatialStatistics:s}}async function v(e){const a=await f(e),{view:t,sampleSize:s,layerAdapter:r,signal:i}=a,l=await r.getSampleFeatures({view:t,sampleSize:s,returnGeometry:!0,signal:i}),o=await n({features:l,geometryType:r.geometryType}),{minScale:c,maxScale:m}=g(r,o,t);return w(a,c,m,o)}export{v as default};
