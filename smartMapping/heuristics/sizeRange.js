/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["../../core/has","../../core/maybe","../../core/Error","../../core/screenUtils","../../renderers/visualVariables/SizeVariable","../../geometry/support/scaleUtils","../support/adapters/support/layerUtils","./scaleRange"],(function(e,l,s,a,n,i,t,o){"use strict";const r=1e8,c=1128.497176,u=591657527.591555,p=[10,8,4,2],v=[100,100,60,30],m=[2,1,.75,.5],f=[32,18,12,6],w=[{level:0,resolution:156543.03392800014,scale:591657527.591555},{level:1,resolution:78271.51696399994,scale:295828763.795777},{level:2,resolution:39135.75848200009,scale:147914381.897889},{level:3,resolution:19567.87924099992,scale:73957190.948944},{level:4,resolution:9783.93962049996,scale:36978595.474472},{level:5,resolution:4891.96981024998,scale:18489297.737236},{level:6,resolution:2445.98490512499,scale:9244648.868618},{level:7,resolution:1222.992452562495,scale:4622324.434309},{level:8,resolution:611.4962262813797,scale:2311162.217155},{level:9,resolution:305.74811314055756,scale:1155581.108577},{level:10,resolution:152.87405657041106,scale:577790.554289},{level:11,resolution:76.43702828507324,scale:288895.277144},{level:12,resolution:38.21851414253662,scale:144447.638572},{level:13,resolution:19.10925707126831,scale:72223.819286},{level:14,resolution:9.554628535634155,scale:36111.909643},{level:15,resolution:4.77731426794937,scale:18055.954822},{level:16,resolution:2.388657133974685,scale:9027.977411},{level:17,resolution:1.1943285668550503,scale:4513.988705},{level:18,resolution:.5971642835598172,scale:2256.994353},{level:19,resolution:.29858214164761665,scale:1128.497176}];async function g(e){const{view:a}=e;if(!(e&&a&&e.layer))throw new s("size-range:missing-parameters","'view' and 'layer' parameters are required");const n=[0,2,3,1],{layer:i,...o}=e,r=t.createLayerAdapter(i,n),c={layerAdapter:r,...o};if(!r)throw new s("size-range:invalid-parameters","'layer' must be one of these types: "+t.getLayerTypeLabels(n).join(", "));await a.when();const u=l.isSome(c.signal)?{signal:c.signal}:null;await r.load(u);const p=r.geometryType;if("point"!==p&&"multipoint"!==p&&"polyline"!==p&&"polygon"!==p)throw new s("size-range:not-supported",`sizeRange is not supported for geometryType: ${p}`);return c}function S(e,l){const s=Math.ceil(e/l);let a=Math.ceil(s/4);a<4?a=4:a>16&&(a=16);const n=5*a;return{min:a,max:n<50?50:n}}function x(e,l){const{view:s}=e,a=l.minScale||r,n=s.constraints&&"effectiveLODs"in s.constraints&&s.constraints.effectiveLODs||w,i=[];for(const t in n){if(n[t].scale>a)continue;const e=Number(t),l=[e-3,e,e+3,e+6];for(const s of l)s>-1&&s<n.length&&i.push(n[s].scale);break}return i.sort(((e,l)=>e-l))}function y(e,l){const{view:s,layerAdapter:a}=e,n=a.fullExtent,t=a.minScale||c,o=a.maxScale||u,r=l.minScale||0,p=l.maxScale||0;let v=n?i.getScale(s,n):0;v=v<t&&v>o?v:0;return{scales:[t,o,r,p,v].map(Math.round).sort(((e,l)=>e-l)).filter(((e,l,s)=>!!e&&s.indexOf(e)===l)).filter(((e,l,s)=>!l||Math.abs(e-s[l-1])>5)),fullExtentScale:v}}function h(e,l){const{minScale:i,maxScale:t}=l,o=x(e,{minScale:i,maxScale:t});if(!o.length)throw new s("scale-range:insufficient-info","not enough scale values");return{minSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:a.px2pt(p[l])})))}),maxSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:a.px2pt(v[l])})))})}}function z(e,l){const{minScale:i,maxScale:t}=l,o=x(e,{minScale:i,maxScale:t});if(!o.length)throw new s("scale-range:insufficient-info","not enough scale values");return{minSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:a.px2pt(m[l])})))}),maxSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:a.px2pt(f[l])})))})}}function d(e,l){const{spatialStatistics:i,minScale:t,maxScale:o}=l;if(!("avgSize"in i)||!i.avgSize)throw new s("size-range:insufficient-info","average polygon size is invalid");const r=i.avgSize,{resolution:c,scale:u}=e.view,p=c/u,{scales:v,fullExtentScale:m}=y(e,{minScale:t,maxScale:o}),f=[],w=[];v.forEach(((e,l)=>{const{min:s,max:n}=S(r,p*e),i=v.indexOf(m),t=i>-1&&l>i?2:1;f.push({value:e,size:a.px2pt(s/t)}),w.push({value:e,size:a.px2pt(n/t)})}));return{minSize:new n({valueExpression:"$view.scale",stops:f}),maxSize:new n({valueExpression:"$view.scale",stops:w})}}async function E(e){const l=await g(e),{view:s,layerAdapter:a,signal:n}=l,i=await o({layer:a,view:s,signal:n});switch(a.geometryType){case"point":case"multipoint":return h(l,i);case"polyline":return z(l,i);case"polygon":return d(l,i);case"mesh":case"multipatch":return null}return null}return E}));
