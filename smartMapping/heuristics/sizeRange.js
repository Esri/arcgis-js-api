/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../core/has","../../core/Error","../../core/maybe","../../core/screenUtils","../../geometry/support/scaleUtils","../../renderers/visualVariables/SizeVariable","./scaleRange","../support/adapters/support/layerUtils"],(function(e,l,n,s,a,t,i,o,r){"use strict";const c=1e8,u=1128.497176,p=591657527.591555,v=[10,8,4,2],f=[100,100,60,30],m=[2,1,.75,.5],y=[32,18,12,6],g=[{level:0,resolution:156543.03392800014,scale:591657527.591555},{level:1,resolution:78271.51696399994,scale:295828763.795777},{level:2,resolution:39135.75848200009,scale:147914381.897889},{level:3,resolution:19567.87924099992,scale:73957190.948944},{level:4,resolution:9783.93962049996,scale:36978595.474472},{level:5,resolution:4891.96981024998,scale:18489297.737236},{level:6,resolution:2445.98490512499,scale:9244648.868618},{level:7,resolution:1222.992452562495,scale:4622324.434309},{level:8,resolution:611.4962262813797,scale:2311162.217155},{level:9,resolution:305.74811314055756,scale:1155581.108577},{level:10,resolution:152.87405657041106,scale:577790.554289},{level:11,resolution:76.43702828507324,scale:288895.277144},{level:12,resolution:38.21851414253662,scale:144447.638572},{level:13,resolution:19.10925707126831,scale:72223.819286},{level:14,resolution:9.554628535634155,scale:36111.909643},{level:15,resolution:4.77731426794937,scale:18055.954822},{level:16,resolution:2.388657133974685,scale:9027.977411},{level:17,resolution:1.1943285668550503,scale:4513.988705},{level:18,resolution:.5971642835598172,scale:2256.994353},{level:19,resolution:.29858214164761665,scale:1128.497176}];function w(e){return S.apply(this,arguments)}function S(){return(S=e._asyncToGenerator((function*(e){const{view:l}=e;if(!(e&&l&&e.layer))throw new n("size-range:missing-parameters","'view' and 'layer' parameters are required");const{layer:a,...t}=e,i=r.createLayerAdapter(a,r.featureCapableLayerTypes),o={layerAdapter:i,...t};if(!i)throw new n("size-range:invalid-parameters","'layer' must be one of these types: "+r.getLayerTypeLabels(r.featureCapableLayerTypes).join(", "));yield l.when();const c=s.isSome(o.signal)?{signal:o.signal}:null;yield i.load(c);const u=i.geometryType;if("point"!==u&&"multipoint"!==u&&"polyline"!==u&&"polygon"!==u)throw new n("size-range:not-supported",`sizeRange is not supported for geometryType: ${u}`);return o}))).apply(this,arguments)}function h(e,l){const n=Math.ceil(e/l);let s=Math.ceil(n/4);s<4?s=4:s>16&&(s=16);const a=5*s;return{min:s,max:a<50?50:a}}function x(e,l){const{view:n}=e,s=l.minScale||c,a=n.constraints&&"effectiveLODs"in n.constraints&&n.constraints.effectiveLODs||g,t=[];for(const i in a){if(a[i].scale>s)continue;const e=Number(i),l=[e-3,e,e+3,e+6];for(const n of l)n>-1&&n<a.length&&t.push(a[n].scale);break}return t.sort(((e,l)=>e-l))}function z(e,l){const{view:n,layerAdapter:a}=e,i=a.fullExtent,o=a.minScale||u,r=a.maxScale||p,c=l.minScale||0,v=l.maxScale||0;let f=s.isSome(i)?t.getScale(n,i):0;f=f<o&&f>r?f:0;return{scales:[o,r,c,v,f].map(Math.round).sort(((e,l)=>e-l)).filter(((e,l,n)=>!!e&&n.indexOf(e)===l)).filter(((e,l,n)=>!l||Math.abs(e-n[l-1])>5)),fullExtentScale:f}}function d(e,l){const{minScale:s,maxScale:t}=l,o=x(e,{minScale:s,maxScale:t});if(!o.length)throw new n("scale-range:insufficient-info","not enough scale values");return{minSize:new i({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:a.px2pt(v[l])})))}),maxSize:new i({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:a.px2pt(f[l])})))})}}function b(e,l){const{minScale:s,maxScale:t}=l,o=x(e,{minScale:s,maxScale:t});if(!o.length)throw new n("scale-range:insufficient-info","not enough scale values");return{minSize:new i({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:a.px2pt(m[l])})))}),maxSize:new i({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:a.px2pt(y[l])})))})}}function E(e,l){const{spatialStatistics:s,minScale:t,maxScale:o}=l;if(!("avgSize"in s)||!s.avgSize)throw new n("size-range:insufficient-info","average polygon size is invalid");const r=s.avgSize,{resolution:c,scale:u}=e.view,p=c/u,{scales:v,fullExtentScale:f}=z(e,{minScale:t,maxScale:o}),m=[],y=[];v.forEach(((e,l)=>{const{min:n,max:s}=h(r,p*e),t=v.indexOf(f),i=t>-1&&l>t?2:1;m.push({value:e,size:a.px2pt(n/i)}),y.push({value:e,size:a.px2pt(s/i)})}));return{minSize:new i({valueExpression:"$view.scale",stops:m}),maxSize:new i({valueExpression:"$view.scale",stops:y})}}function T(e){return L.apply(this,arguments)}function L(){return(L=e._asyncToGenerator((function*(e){const l=yield w(e),{view:n,layerAdapter:s,signal:a}=l,t=yield o({layer:s,view:n,signal:a});switch(s.geometryType){case"point":case"multipoint":return d(l,t);case"polyline":return b(l,t);case"polygon":return E(l,t);case"mesh":case"multipatch":return null}return null}))).apply(this,arguments)}return T}));
