/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../core/lang","../../core/maybe","../../core/Error","../../intl/messages","../../renderers/PointCloudRenderer","../../renderers/support/LegendOptions","../../renderers/PointCloudClassBreaksRenderer","../../renderers/PointCloudRGBRenderer","../../renderers/PointCloudStretchRenderer","../../renderers/PointCloudUniqueValueRenderer","../../renderers/Renderer","../../renderers/ClassBreaksRenderer","../../renderers/UniqueValueRenderer","../../renderers/DictionaryRenderer","../../renderers/DotDensityRenderer","../../renderers/HeatmapRenderer","../../renderers/SimpleRenderer","../../renderers/support/jsonUtils","../support/utils","../../renderers/support/utils","../support/adapters/support/layerUtils","../heuristics/outline","../heuristics/sizeRange","./support/utils","../statistics/uniqueValues","../../chunks/type"],(function(e,l,r,a,s,n,t,i,o,u,d,p,c,m,y,b,f,h,v,g,w,T,S,E,V,x,z){"use strict";const I="date";async function M(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new a("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new a("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");const s={...e};s.symbolType=s.symbolType||"2d",s.numTypes=null==s.numTypes?10:s.numTypes,s.defaultSymbolEnabled=null==s.defaultSymbolEnabled||s.defaultSymbolEnabled,s.sortBy=null==s.sortBy?"count":s.sortBy,s.sortEnabled=null==s.sortEnabled||s.sortEnabled,s.statistics=l.clone(s.statistics);const n=[0,2,1,3],t=T.createLayerAdapter(s.layer,n);if(s.layer=t,!t)throw new a("type-renderer:invalid-parameters","'layer' must be one of these types: "+T.getLayerTypeLabels(n).join(", "));const i=r.isSome(s.signal)?{signal:s.signal}:null;await t.load(i);const o=t.geometryType;if(s.outlineOptimizationEnabled="polygon"===o&&s.outlineOptimizationEnabled,s.sizeOptimizationEnabled=("point"===o||"multipoint"===o||"polyline"===o)&&s.sizeOptimizationEnabled,"mesh"===o)s.symbolType="3d-volumetric",s.colorMixMode=s.colorMixMode||"replace",s.edgesType=s.edgesType||"none";else{if("3d-volumetric-uniform"===s.symbolType&&"point"!==o)throw new a("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(s.symbolType.indexOf("3d-volumetric")>-1&&(!s.view||"3d"!==s.view.type))throw new a("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const u=await g.getFieldsList({field:s.field,valueExpression:s.valueExpression}),d=V.verifyBasicFieldValidity(t,u,"type-renderer:invalid-parameters");if(d)throw d;return s}async function q(e){if(!(e&&e.layer&&e.field))throw new a("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const s={...e};s.statistics=l.clone(s.statistics);const n=[4],t=T.createLayerAdapter(s.layer,n);if(s.layer=t,s.density=s.density||25,s.size=s.size||"100%",!V.isValidPointSize(s.size))throw new a("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");if(!t)throw new a("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+T.getLayerTypeLabels(n).join(", "));const i=r.isSome(s.signal)?{signal:s.signal}:null;await t.load(i);const o=await g.getFieldsList({field:s.field}),u=V.verifyBasicFieldValidity(t,o,"type-point-cloud-class-renderer:invalid-parameters");if(u)throw u;return s}async function C(e){let l=e.typeScheme,a=null,s=null;const n=await V.getBasemapInfo(e.basemap,e.view);if(a=r.isSome(n.basemapId)?n.basemapId:null,s=r.isSome(n.basemapTheme)?n.basemapTheme:null,l)return{scheme:z.cloneScheme(l),basemapId:a,basemapTheme:s};const t=z.getSchemes({basemap:a,basemapTheme:s,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return t&&(l=t.primaryScheme,a=t.basemapId,s=t.basemapTheme),{scheme:l,basemapId:a,basemapTheme:s}}function R(e,l){let r;return r=e.label<l.label?-1:e.label>l.label?1:0,r}function O(e,l){let r;return r=e.value<l.value?-1:e.value>l.value?1:0,r}function L(e,l){let r=l.count-e.count;return 0===r&&(r=R(e,l)),r}function B(e,l){let r=l.count-e.count;return 0===r&&(r=O(e,l)),r}function P(e,l,r){let a;"count"===l?(a=B,r&&r.codedValues&&(a=L)):"value"===l&&(a=O,r&&r.codedValues&&(a=R)),a&&e.sort(a)}async function F(e,l,r,a){const n=await s.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),i=e.uniqueValueInfos,o=l.layer,u=l.field,d=u?o.getField(u):null,p=d?o.getFieldDomain(d.name):null,c=-1===l.numTypes?i.length:l.numTypes,y=o.geometryType,b=await C({basemap:l.basemap,geometryType:y,typeScheme:l.typeScheme,worldScale:l.symbolType.indexOf("3d-volumetric")>-1,view:l.view}),f=b.scheme,h=new m({field:u});let v,g=-1;const T={value:null,domain:p,fieldInfo:d};if(i.forEach(((e,l)=>{T.value=e.value,e.label=w.createUniqueValueLabel(T),null===e.value&&(g=l)})),g>-1&&(v=i.splice(g,1)[0]),!1!==l.sortEnabled&&P(i,l.sortBy,p),d&&d.type===I){const e=i.filter(((e,l)=>l<c)).map((e=>e.value));T.dateFormatInterval=w.calculateDateFormatInterval(e)}const S=r&&r.opacity;let E=V.createColors(f.colors,i.length);const x=V.getSymbolSizeFromScheme(f,y),M=V.getSymbolOutlineFromScheme(f,y,S);i.forEach(((e,r)=>{T.value=e.value,e.label=w.createUniqueValueLabel(T),e.symbol=V.createSymbol(y,{type:l.symbolType,color:E[r],size:x,outline:M,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})})),l.valueExpression&&(h.valueExpression=l.valueExpression,h.valueExpressionTitle=l.valueExpressionTitle),l.legendOptions&&(h.legendOptions=new t.LegendOptions(l.legendOptions)),E=V.createColors(f.colors,c);for(let s=0;s<c;s++){const e=i[s];e&&h.addUniqueValueInfo({value:e.value,label:e.label,symbol:V.createSymbol(y,{type:l.symbolType,color:E[s],size:x,outline:M,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})})}l.defaultSymbolEnabled&&(h.defaultSymbol=V.createSymbol(y,{type:l.symbolType,color:f.noDataColor,size:x,outline:M,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}}),h.defaultLabel=n.other),v&&(v.symbol=V.createSymbol(y,{type:l.symbolType,color:f.noDataColor,size:x,outline:M,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}}),i.push(v));const q=[],R=h.uniqueValueInfos.length===i.length?-1:h.uniqueValueInfos.length;if(R>-1)for(let s=R;s<i.length;s++)q.push({...i[s]});return r&&r.visualVariables&&r.visualVariables.length&&(h.visualVariables=r.visualVariables.map((e=>e.clone()))),a&&a.minSize&&(h.visualVariables?h.visualVariables.push(a.minSize):h.visualVariables=[a.minSize]),{renderer:h,uniqueValueInfos:i,excludedUniqueValueInfos:q,typeScheme:z.cloneScheme(f),basemapId:b.basemapId,basemapTheme:b.basemapTheme}}async function U(e,l){const r=e.uniqueValueInfos,a=await C({basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:l}),s=a&&a.scheme,n="point-cloud-class"===s.theme,t=n?s.colors:V.createColors(s.colors,r.length);return P(r,"value"),r.map(((e,l)=>{const r=e.value;let a=null;return n?(a=t[r],a||(a=t[t.length-1])):a=t[l],{values:[r],color:a,label:e.label}}))}async function D(e){const l=await M(e),{layer:r,view:a,signal:s}=l,n={layer:r,field:l.field,valueExpression:l.valueExpression,returnAllCodedValues:l.returnAllCodedValues,view:a,signal:s},[t,i,o]=await Promise.all([null!=l.statistics?l.statistics:x(n),l.outlineOptimizationEnabled?S({layer:r,view:a,signal:s}):null,l.sizeOptimizationEnabled?E({layer:r,view:a,signal:s}):null]);return F(t,l,i,o)}async function A(e){const l=await q(e),r=null!=l.statistics?l.statistics:await x({layer:l.layer,field:l.field,signal:l.signal});return{renderer:new d({field:l.field,pointsPerInch:l.density,pointSizeAlgorithm:V.getPointSizeAlgorithm(l.size),colorUniqueValueInfos:await U(r,l.typeScheme)})}}e.createPCClassRenderer=A,e.createRenderer=D,Object.defineProperty(e,"__esModule",{value:!0})}));
