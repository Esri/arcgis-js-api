/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../core/maybe","../../core/Error","../../intl/substitute","../../intl/messages","../../renderers/PointCloudRenderer","../../renderers/PointCloudClassBreaksRenderer","../../renderers/PointCloudRGBRenderer","../../renderers/PointCloudStretchRenderer","../../renderers/PointCloudUniqueValueRenderer","../../renderers/support/AuthoringInfoVisualVariable","../../renderers/support/AuthoringInfo","../../renderers/Renderer","../../renderers/visualVariables/ColorVariable","../../renderers/ClassBreaksRenderer","../../renderers/UniqueValueRenderer","../../renderers/DictionaryRenderer","../../renderers/DotDensityRenderer","../../renderers/HeatmapRenderer","../../renderers/SimpleRenderer","../../renderers/support/jsonUtils","../support/utils","../../renderers/support/utils","../support/adapters/support/layerUtils","../statistics/support/ageUtils","../heuristics/ageUnit","../heuristics/outline","../heuristics/sizeRange","./support/utils","../../chunks/color"],(function(e,r,a,i,o,l,n,s,t,m,d,u,c,p,y,f,b,h,g,v,w,T,S,x,E,V,z,M,I,C){"use strict";const O="date",F="high-to-low",L=2**53-1,q=5;async function P(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new a("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new a("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");const i={...e};if("90-10"===i.theme)throw new a("color-visual-variable:not-supported","Only 'high-to-low', 'above-and-below', 'centered-on', 'extremes', 'above', 'below' themes are supported.");const o=[0,2,1,3],l=x.createLayerAdapter(i.layer,o);if(i.layer=l,!l)throw new a("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+x.getLayerTypeLabels(o).join(", "));const n=r.isSome(i.signal)?{signal:i.signal}:null;await l.load(n);if("mesh"!==l.geometryType&&i.worldScale&&(!i.view||"3d"!==i.view.type))return Promise.reject(I.createError("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true"));const s=await T.getFieldsList({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),t=I.verifyBasicFieldValidity(l,s,"color-visual-variable:invalid-parameters");if(t)throw t;return i}async function R(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new a("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new a("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled=null==i.defaultSymbolEnabled||i.defaultSymbolEnabled;const o=[0,2,1,3],l=x.createLayerAdapter(i.layer,o);if(i.layer=l,!l)throw new a("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+x.getLayerTypeLabels(o).join(", "));const n=r.isSome(i.signal)?{signal:i.signal}:null;await l.load(n);const s=l.geometryType;if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&i.sizeOptimizationEnabled,"mesh"===s)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==s)throw new a("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.indexOf("3d-volumetric")>-1&&(!i.view||"3d"!==i.view.type))throw new a("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await T.getFieldsList({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),m=I.verifyBasicFieldValidity(l,t,"color-continuous-renderer:invalid-parameters");if(m)throw m;return i}async function B(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new a("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new a("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled=null==i.defaultSymbolEnabled||i.defaultSymbolEnabled,i.classificationMethod=i.classificationMethod||"equal-interval",i.normalizationType=T.getNormalizationType(i);const o=[0,2,1,3],l=x.createLayerAdapter(i.layer,o);if(i.layer=l,!l)throw new a("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+x.getLayerTypeLabels(o).join(", "));if(!(null!=i.minValue&&null!=i.maxValue)&&(null!=i.minValue||null!=i.maxValue))throw new a("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=r.isSome(i.signal)?{signal:i.signal}:null;await l.load(n);const s=l.geometryType;if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,"mesh"===s)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==s)throw new a("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.indexOf("3d-volumetric")>-1&&(!i.view||"3d"!==i.view.type))throw new a("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await T.getFieldsList({field:i.field,normalizationField:i.normalizationField}),m=I.verifyBasicFieldValidity(l,t,"color-class-breaks-renderer:invalid-parameters");if(m)throw m;return i}function k(e){const r={...e};delete r.basemap,delete r.colorScheme,delete r.legendOptions,delete r.symbolType,delete r.defaultSymbolEnabled,delete r.colorMixMode,delete r.edgesType;const a=r;return a.analyzeData=!(null!=r.minValue&&null!=r.maxValue),a}function U(e){if(!e||!e.layer)return Promise.reject(I.createError("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required"));const a={...e},i=[4],o=x.createLayerAdapter(a.layer,i);if(a.layer=o,a.density=a.density||25,a.size=a.size||"100%",!I.isValidPointSize(a.size))return Promise.reject(I.createError("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'"));if(!o)return Promise.reject(I.createError("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+x.getLayerTypeLabels(i).join(", ")));const l=r.isSome(a.signal)?{signal:a.signal}:null;return o.load(l).then((()=>a))}function A(e){if(!(e&&e.layer&&e.field))return Promise.reject(I.createError("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required"));const a=e.field.toLowerCase();if("intensity"!==a&&"elevation"!==a)return Promise.reject(I.createError("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'"));const i={...e},o=[4],l=x.createLayerAdapter(i.layer,o);if(i.layer=l,i.density=i.density||25,i.size=i.size||"100%",!I.isValidPointSize(i.size))return Promise.reject(I.createError("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'"));if(!l)return Promise.reject(I.createError("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+x.getLayerTypeLabels(o).join(", ")));const n=r.isSome(i.signal)?{signal:i.signal}:null;return l.load(n).then((()=>i))}function D(e){const r={...e},a=r.symbolType.indexOf("3d-volumetric")>-1;delete r.symbolType,delete r.defaultSymbolEnabled,delete r.colorMixMode,delete r.edgesType;const i=r;return i.worldScale=a,i}async function j(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new a("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled=null==i.defaultSymbolEnabled||i.defaultSymbolEnabled;const o=[0,2,1,3],l=x.createLayerAdapter(i.layer,o);if(i.layer=l,!l)throw new a("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+x.getLayerTypeLabels(o).join(", "));const n=r.isSome(i.signal)?{signal:i.signal}:null;await l.load(n);const s=l.geometryType;if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&i.sizeOptimizationEnabled,"mesh"===s)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else if("3d-volumetric-uniform"===i.symbolType&&"point"!==s)throw new a("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.indexOf("3d-volumetric")>-1&&(!i.view||"3d"!==i.view.type))throw new a("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const t=E.verifyDates(l,i.startTime,i.endTime,"color-age-renderer:invalid-parameters");if(t)throw t;if(i.unit&&-1===E.supportedAgeUnits.indexOf(i.unit))throw new a("color-age-renderer:invalid-unit",`Supported units are: ${E.supportedAgeUnits.join(", ")}`);return i}async function _(e,a){let i=e.colorScheme,o=null,l=null;const n=await I.getBasemapInfo(e.basemap,e.view);if(o=r.isSome(n.basemapId)?n.basemapId:null,l=r.isSome(n.basemapTheme)?n.basemapTheme:null,i)return{scheme:C.cloneScheme(i),basemapId:o,basemapTheme:l};const s=a||e.theme||F,t=C.getSchemes({theme:s,basemap:o,basemapTheme:l,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});if(t)if(o=t.basemapId,l=t.basemapTheme,e.schemeId){const r=s+"/"+o+"/"+e.schemeId;i=C.getSchemeById({id:r,geometryType:e.geometryType})}else i=t.primaryScheme;return{scheme:i,basemapId:o,basemapTheme:l}}async function G(e,r){const a=r.layer,i=await _({basemap:r.basemap,colorScheme:r.colorScheme,geometryType:a.geometryType,schemeId:"elevation"===r.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),o=i.scheme;if(!o)throw I.createError("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const l=I.createColors(o.colors,q);if(l.length<q)throw I.createError("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const n=I.getDefaultDataRange(e,!1,!0),s=n?I.createDefaultStopValues(n[0],n[1],5):I.createStopValues(e);return{stops:S.createColorStops({values:s,isDate:!1,dateFormatOptions:null,colors:l,labelIndexes:[0,2,4]}),basemapId:i.basemapId,basemapTheme:i.basemapTheme,statistics:e,defaultValuesUsed:!!n,colorScheme:C.cloneScheme(o)}}async function W(e,r,a){const i=e.layer,{field:o,theme:l}=e,n=o&&!("function"==typeof o)?i.getField(o):null,s=n&&n.type===O,t=await _({basemap:e.basemap,theme:e.theme,geometryType:i.geometryType,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),m=t.scheme;if(!m)throw I.createError("color-visual-variable:insufficient-info","Unable to find color scheme");const c=I.createColors(m.colors,q);if(c.length<q)throw I.createError("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const y=m.id.indexOf("seq-")>-1,f=I.getDataRange(r,a,l,s,"90-10"!==l),b=I.createDataValues(f,r,l,y),h=I.createColors(c,q),g=new p({field:o,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:b.map(((e,r)=>({value:e,color:h[r]}))),legendOptions:e.legendOptions}),v=new d({type:"color",minSliderValue:null!=e.minValue?e.minValue:r.min,maxSliderValue:null!=e.maxValue?e.maxValue:r.max,theme:m.theme}),w=new u({visualVariables:[v]});return{basemapId:t.basemapId,basemapTheme:t.basemapTheme,visualVariable:g,statistics:r,defaultValuesUsed:f.defaultValuesUsed,colorScheme:C.cloneScheme(m),authoringInfo:w}}async function $(e,r,a,i,l,n){const s=await o.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),t=n.layer,m=n.field,d=t.geometryType,u=n.defaultSymbolEnabled,c=C.cloneScheme(e.colorScheme),p=r&&r.opacity,f=[e.visualVariable.clone()];r&&r.visualVariables&&r.visualVariables.length&&f.push(...r.visualVariables.map((e=>e.clone()))),a&&a.minSize&&f.push(a.minSize);return{renderer:new y({classBreakInfos:[{minValue:-L,maxValue:L,symbol:I.createSymbol(d,{type:n.symbolType,color:c.noDataColor,size:I.getSymbolSizeFromScheme(c,d),outline:I.getSymbolOutlineFromScheme(c,d,p),meshInfo:{colorMixMode:n.colorMixMode,edgesType:n.edgesType}})}],defaultLabel:u?s.other:null,defaultSymbol:u?I.createSymbol(d,{type:n.symbolType,color:c.noDataColor,size:I.getSymbolSizeFromScheme(c,d),outline:I.getSymbolOutlineFromScheme(c,d,p),meshInfo:{colorMixMode:n.colorMixMode,edgesType:n.edgesType}}):null,field:m,normalizationType:i,normalizationField:l,valueExpression:n.valueExpression,valueExpressionTitle:n.valueExpressionTitle,visualVariables:f,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:C.cloneScheme(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function H(e){const r=await P(e),{view:a,field:i,valueExpression:o,minValue:l,maxValue:n,layer:s,normalizationField:t,signal:m,statistics:d}=r,u=t?"field":void 0,[c,p]=await Promise.all([d||I.getSummaryStatistics({layer:s,field:i,valueExpression:o,sqlExpression:r.sqlExpression,sqlWhere:r.sqlWhere,normalizationType:u,normalizationField:t,minValue:l,maxValue:n,view:a,signal:m}),"90-10"===r.theme?I.getClassBreaks({layer:s,field:i,normalizationField:t,valueExpression:o,classificationMethod:"quantile",minValue:l,maxValue:n,view:a,numClasses:10,signal:m}):null]);return W(r,c,null==p?void 0:p.result)}function N(e,r){const a=e.colorsForClassBreaks;let i;if(a&&a.length>0&&(a.some((e=>(e.numClasses===r&&(i=e.colors),!!i))),!i)){const e=a[a.length-1],o=r-e.numClasses;if(o>0){const r=e.colors[e.numClasses-1];i=e.colors.splice(0);for(let e=1;e<=o;e++)i.push(r)}}return i&&(i=I.createColors(i,i.length)),i}async function J(e,r){const i=await o.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),l=e.layer,n=e.defaultSymbolEnabled,s=l.geometryType,t=await _({basemap:e.basemap,geometryType:s,colorScheme:e.colorScheme,worldScale:e.symbolType.indexOf("3d-volumetric")>-1,view:e.view}),m=t.scheme,{result:d,outlineResult:c}=r,p=d.classBreakInfos,f=e.classificationMethod,b="standard-deviation"===f,h=e.normalizationType;if(!m)throw new a("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const g=N(m,p.length);if(!g||g.length!==p.length)throw new a("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const v=c&&c.opacity,w=new y({classBreakInfos:p.map(((r,a)=>({minValue:r.minValue,maxValue:r.maxValue,symbol:I.createSymbol(s,{type:e.symbolType,color:g[a],size:I.getSymbolSizeFromScheme(m,s),outline:I.getSymbolOutlineFromScheme(m,s,v),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:r.label}))),defaultLabel:n?i.other:null,defaultSymbol:n?I.createSymbol(s,{type:e.symbolType,color:m.noDataColor,size:I.getSymbolSizeFromScheme(m,s),outline:I.getSymbolOutlineFromScheme(m,s,v),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:h,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===h?d.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new u({type:"class-breaks-color",classificationMethod:f,standardDeviationInterval:e.standardDeviationInterval})});return b||S.setLabelsForClassBreaks({classBreakInfos:w.classBreakInfos,classificationMethod:f,normalizationType:h,round:!0}),c&&c.visualVariables&&c.visualVariables.length&&(w.visualVariables=c.visualVariables.map((e=>e.clone()))),{renderer:w,colorScheme:C.cloneScheme(m),classBreaksResult:d,defaultValuesUsed:r.defaultValuesUsed,basemapId:t.basemapId,basemapTheme:t.basemapTheme}}async function K(e){const r=await R(e),{layer:a,view:i,signal:o}=r,[l,n,s]=await Promise.all([H(D(r)),r.outlineOptimizationEnabled?z({layer:a,view:i,signal:o}):null,r.sizeOptimizationEnabled?M({layer:a,view:i,signal:o}):null]),t=r.normalizationField;return $(l,n,s,t?"field":void 0,t,r)}async function Q(e){const r=await B(e);return J(r,await I.getClassBreaks(k(r),r.outlineOptimizationEnabled))}function X(e){return U(e).then((e=>({renderer:new s({field:"RGB",pointsPerInch:e.density,pointSizeAlgorithm:I.getPointSizeAlgorithm(e.size)})})))}async function Y(e){const r=await A(e),a=r.statistics?r.statistics:await I.getSummaryStatistics({layer:r.layer,field:r.field,signal:r.signal}),i=await G(a,r);return{renderer:new t({field:r.field,pointsPerInch:r.density,pointSizeAlgorithm:I.getPointSizeAlgorithm(r.size),stops:i.stops}),basemapId:i.basemapId,basemapTheme:i.basemapTheme,statistics:i.statistics,defaultValuesUsed:i.defaultValuesUsed,colorScheme:i.colorScheme}}async function Z(e){const r=await o.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),a=await j(e),{defaultSymbolEnabled:l,view:n,startTime:s,endTime:t,symbolType:m,colorMixMode:d,edgesType:u,minValue:c,maxValue:p,signal:y}=a,f=a.layer,[b,h,g]=await Promise.all([a.unit?{unit:a.unit,statistics:null}:V({view:n,layer:f,startTime:s,endTime:t,minValue:c,maxValue:p,signal:y}),a.outlineOptimizationEnabled?z({layer:f,view:n,signal:y}):null,a.sizeOptimizationEnabled?M({layer:f,view:n,signal:y}):null]),{unit:v,statistics:w}=b,T=E.getAgeExpressions({layer:f,startTime:s,endTime:t,unit:v}).valueExpression,S=i.substitute(r[`ageInfo_${v}`],{unit:v,startTime:I.formatDate(s,v,f),endTime:I.formatDate(t,v,f)}),x=await H(D({layer:f,basemap:a.basemap,valueExpression:T,symbolType:m,statistics:w,legendOptions:{title:S},colorScheme:a.colorScheme,theme:a.theme,view:n,minValue:a.minValue,maxValue:a.maxValue,signal:y})),C={layer:f,valueExpression:T,defaultSymbolEnabled:l,symbolType:m,colorMixMode:d,edgesType:u},O=await $(x,h,g,null,null,C);return O.renderer.authoringInfo.visualVariables.forEach((e=>I.updateAgeRendererAuthoringInfoVV(e,s,t,v))),{...O,unit:v}}e.createAgeRenderer=Z,e.createClassBreaksRenderer=Q,e.createContinuousRenderer=K,e.createPCContinuousRenderer=Y,e.createPCTrueColorRenderer=X,e.createVisualVariable=H,Object.defineProperty(e,"__esModule",{value:!0})}));
