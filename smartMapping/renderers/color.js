/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../core/maybe","../../core/Error","../../core/promiseUtils","../../intl/substitute","../../intl/messages","../../renderers/PointCloudRenderer","../../renderers/PointCloudClassBreaksRenderer","../../renderers/PointCloudRGBRenderer","../../renderers/PointCloudStretchRenderer","../../renderers/PointCloudUniqueValueRenderer","../../renderers/support/AuthoringInfoVisualVariable","../../renderers/support/AuthoringInfo","../../renderers/Renderer","../../renderers/visualVariables/ColorVariable","../../renderers/ClassBreaksRenderer","../../renderers/UniqueValueRenderer","../../renderers/DictionaryRenderer","../../renderers/DotDensityRenderer","../../renderers/HeatmapRenderer","../../renderers/SimpleRenderer","../../renderers/support/jsonUtils","../support/utils","../../renderers/support/utils","../support/adapters/support/layerUtils","../statistics/support/ageUtils","../heuristics/ageUnit","../heuristics/outline","../heuristics/sizeRange","./support/utils","../../chunks/color"],(function(e,r,a,i,o,l,n,s,t,d,m,u,c,p,y,f,b,h,g,v,w,T,S,x,E,V,z,M,I,C,O){"use strict";const F=Math.pow(2,53)-1;function L(e){const r={...e},a=r.symbolType.indexOf("3d-volumetric")>-1;delete r.symbolType,delete r.defaultSymbolEnabled,delete r.colorMixMode,delete r.edgesType;const i=r;return i.worldScale=a,i}async function q(e,a){let i=e.colorScheme,o=null,l=null;const n=await C.getBasemapInfo(e.basemap,e.view);if(o=r.isSome(n.basemapId)?n.basemapId:null,l=r.isSome(n.basemapTheme)?n.basemapTheme:null,i)return{scheme:O.cloneScheme(i),basemapId:o,basemapTheme:l};const s=a||e.theme||"high-to-low",t=O.getSchemes({theme:s,basemap:o,basemapTheme:l,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});if(t)if(o=t.basemapId,l=t.basemapTheme,e.schemeId){const r=s+"/"+o+"/"+e.schemeId;i=O.getSchemeById({id:r,geometryType:e.geometryType})}else i=t.primaryScheme;return{scheme:i,basemapId:o,basemapTheme:l}}async function R(e,r,a,i,o,n){const s=await l.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),t=n.layer,d=n.field,m=t.geometryType,u=n.defaultSymbolEnabled,c=O.cloneScheme(e.colorScheme),p=r&&r.opacity,y=[e.visualVariable.clone()];r&&r.visualVariables&&r.visualVariables.length&&y.push(...r.visualVariables.map((e=>e.clone()))),a&&a.minSize&&y.push(a.minSize);return{renderer:new f({classBreakInfos:[{minValue:-F,maxValue:F,symbol:C.createSymbol(m,{type:n.symbolType,color:c.noDataColor,size:C.getSymbolSizeFromScheme(c,m),outline:C.getSymbolOutlineFromScheme(c,m,p),meshInfo:{colorMixMode:n.colorMixMode,edgesType:n.edgesType}})}],defaultLabel:u?s.other:null,defaultSymbol:u?C.createSymbol(m,{type:n.symbolType,color:c.noDataColor,size:C.getSymbolSizeFromScheme(c,m),outline:C.getSymbolOutlineFromScheme(c,m,p),meshInfo:{colorMixMode:n.colorMixMode,edgesType:n.edgesType}}):null,field:d,normalizationType:i,normalizationField:o,valueExpression:n.valueExpression,valueExpressionTitle:n.valueExpressionTitle,visualVariables:y,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:O.cloneScheme(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function B(e){const o=await async function(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new a("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new a("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");const o={...e};if("90-10"===o.theme)throw new a("color-visual-variable:not-supported","Only 'high-to-low', 'above-and-below', 'centered-on', 'extremes', 'above', 'below' themes are supported.");const l=[0,2,1,3],n=E.createLayerAdapter(o.layer,l);if(o.layer=n,!n)throw new a("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+E.getLayerTypeLabels(l).join(", "));const s=r.isSome(o.signal)?{signal:o.signal}:null;if(await n.load(s),"mesh"!==n.geometryType&&o.worldScale&&(!o.view||"3d"!==o.view.type))return i.reject(C.createError("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true"));const t=await S.getFieldsList({field:o.field,normalizationField:o.normalizationField,valueExpression:o.valueExpression}),d=C.verifyBasicFieldValidity(n,t,"color-visual-variable:invalid-parameters");if(d)throw d;return o}(e),{view:l,field:n,valueExpression:s,minValue:t,maxValue:d,layer:m,normalizationField:p,signal:f,statistics:b}=o,h=p?"field":void 0,[g,v]=await i.all([b||C.getSummaryStatistics({layer:m,field:n,valueExpression:s,sqlExpression:o.sqlExpression,sqlWhere:o.sqlWhere,normalizationType:h,normalizationField:p,minValue:t,maxValue:d,view:l,signal:f}),"90-10"===o.theme?C.getClassBreaks({layer:m,field:n,normalizationField:p,valueExpression:s,classificationMethod:"quantile",minValue:t,maxValue:d,view:l,numClasses:10,signal:f}):null]);return async function(e,r,a){const i=e.layer,{field:o,theme:l}=e,n=o&&"function"!=typeof o?i.getField(o):null,s=n&&"date"===n.type,t=await q({basemap:e.basemap,theme:e.theme,geometryType:i.geometryType,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),d=t.scheme;if(!d)throw C.createError("color-visual-variable:insufficient-info","Unable to find color scheme");const m=C.createColors(d.colors,5);if(m.length<5)throw C.createError("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const p=d.id.indexOf("seq-")>-1,f=C.getDataRange(r,a,l,s,"90-10"!==l),b=C.createDataValues(f,r,l,p),h=C.createColors(m,5),g=new y({field:o,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:b.map(((e,r)=>({value:e,color:h[r]}))),legendOptions:e.legendOptions}),v=new u({type:"color",minSliderValue:null!=e.minValue?e.minValue:r.min,maxSliderValue:null!=e.maxValue?e.maxValue:r.max,theme:d.theme}),w=new c({visualVariables:[v]});return{basemapId:t.basemapId,basemapTheme:t.basemapTheme,visualVariable:g,statistics:r,defaultValuesUsed:f.defaultValuesUsed,colorScheme:O.cloneScheme(d),authoringInfo:w}}(o,g,null==v?void 0:v.result)}async function k(e,r){const i=await l.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),o=e.layer,n=e.defaultSymbolEnabled,s=o.geometryType,t=await q({basemap:e.basemap,geometryType:s,colorScheme:e.colorScheme,worldScale:e.symbolType.indexOf("3d-volumetric")>-1,view:e.view}),d=t.scheme,{result:m,outlineResult:u}=r,p=m.classBreakInfos,y=e.classificationMethod,b="standard-deviation"===y,h=e.normalizationType;if(!d)throw new a("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const g=function(e,r){const a=e.colorsForClassBreaks;let i;if(a&&a.length>0&&(a.some((e=>(e.numClasses===r&&(i=e.colors),!!i))),!i)){const e=a[a.length-1],o=r-e.numClasses;if(o>0){const r=e.colors[e.numClasses-1];i=e.colors.splice(0);for(let e=1;e<=o;e++)i.push(r)}}return i&&(i=C.createColors(i,i.length)),i}(d,p.length);if(!g||g.length!==p.length)throw new a("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const v=u&&u.opacity,w=new f({classBreakInfos:p.map(((r,a)=>({minValue:r.minValue,maxValue:r.maxValue,symbol:C.createSymbol(s,{type:e.symbolType,color:g[a],size:C.getSymbolSizeFromScheme(d,s),outline:C.getSymbolOutlineFromScheme(d,s,v),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:r.label}))),defaultLabel:n?i.other:null,defaultSymbol:n?C.createSymbol(s,{type:e.symbolType,color:d.noDataColor,size:C.getSymbolSizeFromScheme(d,s),outline:C.getSymbolOutlineFromScheme(d,s,v),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:h,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===h?m.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new c({type:"class-breaks-color",classificationMethod:y,standardDeviationInterval:e.standardDeviationInterval})});return b||x.setLabelsForClassBreaks({classBreakInfos:w.classBreakInfos,classificationMethod:y,normalizationType:h,round:!0}),u&&u.visualVariables&&u.visualVariables.length&&(w.visualVariables=u.visualVariables.map((e=>e.clone()))),{renderer:w,colorScheme:O.cloneScheme(d),classBreaksResult:m,defaultValuesUsed:r.defaultValuesUsed,basemapId:t.basemapId,basemapTheme:t.basemapTheme}}e.createAgeRenderer=async function(e){const n=await l.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),s=await async function(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new a("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled=null==i.defaultSymbolEnabled||i.defaultSymbolEnabled;const o=[0,2,1,3],l=E.createLayerAdapter(i.layer,o);if(i.layer=l,!l)throw new a("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+E.getLayerTypeLabels(o).join(", "));const n=r.isSome(i.signal)?{signal:i.signal}:null;await l.load(n);const s=l.geometryType;if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&i.sizeOptimizationEnabled,"mesh"===s)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else if("3d-volumetric-uniform"===i.symbolType&&"point"!==s)throw new a("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.indexOf("3d-volumetric")>-1&&(!i.view||"3d"!==i.view.type))throw new a("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const t=V.verifyDates(l,i.startTime,i.endTime,"color-age-renderer:invalid-parameters");if(t)throw t;if(i.unit&&-1===V.supportedAgeUnits.indexOf(i.unit))throw new a("color-age-renderer:invalid-unit",`Supported units are: ${V.supportedAgeUnits.join(", ")}`);return i}(e),{defaultSymbolEnabled:t,view:d,startTime:m,endTime:u,symbolType:c,colorMixMode:p,edgesType:y,minValue:f,maxValue:b,signal:h}=s,g=s.layer,[v,w,T]=await i.all([s.unit?{unit:s.unit,statistics:null}:z({view:d,layer:g,startTime:m,endTime:u,minValue:f,maxValue:b,signal:h}),s.outlineOptimizationEnabled?M({layer:g,view:d,signal:h}):null,s.sizeOptimizationEnabled?I({layer:g,view:d,signal:h}):null]),{unit:S,statistics:x}=v,O=V.getAgeExpressions({layer:g,startTime:m,endTime:u,unit:S}).valueExpression,F=o.substitute(n[`ageInfo_${S}`],{unit:S,startTime:C.formatDate(m,S,g),endTime:C.formatDate(u,S,g)}),q=await B(L({layer:g,basemap:s.basemap,valueExpression:O,symbolType:c,statistics:x,legendOptions:{title:F},colorScheme:s.colorScheme,theme:s.theme,view:d,minValue:s.minValue,maxValue:s.maxValue,signal:h})),k={layer:g,valueExpression:O,defaultSymbolEnabled:t,symbolType:c,colorMixMode:p,edgesType:y},U=await R(q,w,T,null,null,k);return U.renderer.authoringInfo.visualVariables.forEach((e=>C.updateAgeRendererAuthoringInfoVV(e,m,u,S))),{...U,unit:S}},e.createClassBreaksRenderer=async function(e){const i=await async function(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new a("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new a("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled=null==i.defaultSymbolEnabled||i.defaultSymbolEnabled,i.classificationMethod=i.classificationMethod||"equal-interval",i.normalizationType=S.getNormalizationType(i);const o=[0,2,1,3],l=E.createLayerAdapter(i.layer,o);if(i.layer=l,!l)throw new a("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+E.getLayerTypeLabels(o).join(", "));if(!(null!=i.minValue&&null!=i.maxValue||null==i.minValue&&null==i.maxValue))throw new a("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=r.isSome(i.signal)?{signal:i.signal}:null;await l.load(n);const s=l.geometryType;if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,"mesh"===s)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==s)throw new a("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.indexOf("3d-volumetric")>-1&&(!i.view||"3d"!==i.view.type))throw new a("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await S.getFieldsList({field:i.field,normalizationField:i.normalizationField}),d=C.verifyBasicFieldValidity(l,t,"color-class-breaks-renderer:invalid-parameters");if(d)throw d;return i}(e);return k(i,await C.getClassBreaks(function(e){const r={...e};delete r.basemap,delete r.colorScheme,delete r.legendOptions,delete r.symbolType,delete r.defaultSymbolEnabled,delete r.colorMixMode,delete r.edgesType;const a=r;return a.analyzeData=!(null!=r.minValue&&null!=r.maxValue),a}(i),i.outlineOptimizationEnabled))},e.createContinuousRenderer=async function(e){const o=await async function(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new a("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new a("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled=null==i.defaultSymbolEnabled||i.defaultSymbolEnabled;const o=[0,2,1,3],l=E.createLayerAdapter(i.layer,o);if(i.layer=l,!l)throw new a("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+E.getLayerTypeLabels(o).join(", "));const n=r.isSome(i.signal)?{signal:i.signal}:null;await l.load(n);const s=l.geometryType;if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&i.sizeOptimizationEnabled,"mesh"===s)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==s)throw new a("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.indexOf("3d-volumetric")>-1&&(!i.view||"3d"!==i.view.type))throw new a("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await S.getFieldsList({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),d=C.verifyBasicFieldValidity(l,t,"color-continuous-renderer:invalid-parameters");if(d)throw d;return i}(e),{layer:l,view:n,signal:s}=o,[t,d,m]=await i.all([B(L(o)),o.outlineOptimizationEnabled?M({layer:l,view:n,signal:s}):null,o.sizeOptimizationEnabled?I({layer:l,view:n,signal:s}):null]),u=o.normalizationField;return R(t,d,m,u?"field":void 0,u,o)},e.createPCContinuousRenderer=async function(e){const a=await function(e){if(!(e&&e.layer&&e.field))return i.reject(C.createError("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required"));const a=e.field.toLowerCase();if("intensity"!==a&&"elevation"!==a)return i.reject(C.createError("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'"));const o={...e},l=[4],n=E.createLayerAdapter(o.layer,l);if(o.layer=n,o.density=o.density||25,o.size=o.size||"100%",!C.isValidPointSize(o.size))return i.reject(C.createError("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'"));if(!n)return i.reject(C.createError("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+E.getLayerTypeLabels(l).join(", ")));const s=r.isSome(o.signal)?{signal:o.signal}:null;return n.load(s).then((()=>o))}(e),o=a.statistics?a.statistics:await C.getSummaryStatistics({layer:a.layer,field:a.field,signal:a.signal}),l=await async function(e,r){const a=r.layer,i=await q({basemap:r.basemap,colorScheme:r.colorScheme,geometryType:a.geometryType,schemeId:"elevation"===r.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),o=i.scheme;if(!o)throw C.createError("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const l=C.createColors(o.colors,5);if(l.length<5)throw C.createError("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const n=C.getDefaultDataRange(e,!1,!0),s=n?C.createDefaultStopValues(n[0],n[1],5):C.createStopValues(e);return{stops:x.createColorStops({values:s,isDate:!1,dateFormatOptions:null,colors:l,labelIndexes:[0,2,4]}),basemapId:i.basemapId,basemapTheme:i.basemapTheme,statistics:e,defaultValuesUsed:!!n,colorScheme:O.cloneScheme(o)}}(o,a);return{renderer:new d({field:a.field,pointsPerInch:a.density,pointSizeAlgorithm:C.getPointSizeAlgorithm(a.size),stops:l.stops}),basemapId:l.basemapId,basemapTheme:l.basemapTheme,statistics:l.statistics,defaultValuesUsed:l.defaultValuesUsed,colorScheme:l.colorScheme}},e.createPCTrueColorRenderer=function(e){return function(e){if(!e||!e.layer)return i.reject(C.createError("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required"));const a={...e},o=[4],l=E.createLayerAdapter(a.layer,o);if(a.layer=l,a.density=a.density||25,a.size=a.size||"100%",!C.isValidPointSize(a.size))return i.reject(C.createError("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'"));if(!l)return i.reject(C.createError("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+E.getLayerTypeLabels(o).join(", ")));const n=r.isSome(a.signal)?{signal:a.signal}:null;return l.load(n).then((()=>a))}(e).then((e=>({renderer:new t({field:"RGB",pointsPerInch:e.density,pointSizeAlgorithm:C.getPointSizeAlgorithm(e.size)})})))},e.createVisualVariable=B,Object.defineProperty(e,"__esModule",{value:!0})}));
