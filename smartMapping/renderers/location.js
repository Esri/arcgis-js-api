/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import e from"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import r from"../../core/Error.js";import{isSome as i}from"../../core/maybe.js";import o from"../heuristics/outline.js";import a from"../heuristics/sizeRange.js";import{createSymbol as s,getSymbolSizeFromScheme as n,getSymbolOutlineFromScheme as t,getBasemapInfo as l}from"./support/utils.js";import{createLayerAdapter as m,featureCapableLayerTypes as p,getLayerTypeLabels as d}from"../support/adapters/support/layerUtils.js";import{cloneScheme as c,getSchemes as u}from"../symbology/location.js";async function y(e){if(!e||!e.layer)throw new r("location-renderer:missing-parameters","'layer' parameter is required");const o={...e};o.symbolType=o.symbolType||"2d";const a=m(o.layer,p);if(o.layer=a,!a)throw new r("location-renderer:invalid-parameters","'layer' must be one of these types: "+d(p).join(", "));const s=i(o.signal)?{signal:o.signal}:null;await a.load(s);const n=a.geometryType;if(o.outlineOptimizationEnabled="polygon"===n&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===n||"multipoint"===n||"polyline"===n)&&o.sizeOptimizationEnabled,"mesh"===n)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==n)throw new r("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}return o}async function b(e,r){let o=e.locationScheme,a=null,s=null;const n=await l(e.basemap,e.view);if(a=i(n.basemapId)?n.basemapId:null,s=i(n.basemapTheme)?n.basemapTheme:null,o)return{scheme:c(o),basemapId:a,basemapTheme:s};const t=u({basemap:a,basemapTheme:s,geometryType:r,worldScale:e.symbolType.includes("3d-volumetric"),view:e.view});return t&&(o=t.primaryScheme,a=t.basemapId,s=t.basemapTheme),{scheme:o,basemapId:a,basemapTheme:s}}async function h(i){const l=await y(i),m=l.layer.geometryType,p=await b(l,m),d=p.scheme;if(!d)throw new r("location-renderer:insufficient-info","Unable to find location scheme");const{view:u,layer:h,signal:f}=l,[w,v]=await Promise.all([l.outlineOptimizationEnabled?o({view:u,layer:h,signal:f}):null,l.sizeOptimizationEnabled?a({view:u,layer:h,signal:f}):null]),T=w&&w.opacity,g=new e({symbol:s(m,{type:l.symbolType,color:d.color,size:n(d,m),outline:t(d,m,T),meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})});return w&&w.visualVariables&&w.visualVariables.length&&(g.visualVariables=w.visualVariables.map((e=>e.clone()))),v&&v.minSize&&(g.visualVariables?g.visualVariables.push(v.minSize):g.visualVariables=[v.minSize]),{renderer:g,locationScheme:c(d),basemapId:p.basemapId,basemapTheme:p.basemapTheme}}export{h as createRenderer};
