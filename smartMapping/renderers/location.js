/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../core/maybe","../../core/Error","../../renderers/Renderer","../../renderers/ClassBreaksRenderer","../../renderers/UniqueValueRenderer","../../renderers/DictionaryRenderer","../../renderers/DotDensityRenderer","../../renderers/HeatmapRenderer","../../renderers/SimpleRenderer","../../renderers/support/jsonUtils","../../chunks/location","../support/adapters/support/layerUtils","../heuristics/outline","../heuristics/sizeRange","./support/utils"],(function(e,r,a,i,n,o,s,l,t,m,p,c,d,y,u,b){"use strict";async function h(e){if(!e||!e.layer)throw new a("location-renderer:missing-parameters","'layer' parameter is required");const i={...e};i.symbolType=i.symbolType||"2d";const n=[0,2,1,3],o=d.createLayerAdapter(i.layer,n);if(i.layer=o,!o)throw new a("location-renderer:invalid-parameters","'layer' must be one of these types: "+d.getLayerTypeLabels(n).join(", "));const s=r.isSome(i.signal)?{signal:i.signal}:null;await o.load(s);const l=o.geometryType;if(i.outlineOptimizationEnabled="polygon"===l&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===l||"multipoint"===l||"polyline"===l)&&i.sizeOptimizationEnabled,"mesh"===l)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==l)throw new a("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.indexOf("3d-volumetric")>-1&&(!i.view||"3d"!==i.view.type))throw new a("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}return i}async function w(e,a){let i=e.locationScheme,n=null,o=null;const s=await b.getBasemapInfo(e.basemap,e.view);if(n=r.isSome(s.basemapId)?s.basemapId:null,o=r.isSome(s.basemapTheme)?s.basemapTheme:null,i)return{scheme:c.cloneScheme(i),basemapId:n,basemapTheme:o};const l=c.getSchemes({basemap:n,basemapTheme:o,geometryType:a,worldScale:e.symbolType.indexOf("3d-volumetric")>-1,view:e.view});return l&&(i=l.primaryScheme,n=l.basemapId,o=l.basemapTheme),{scheme:i,basemapId:n,basemapTheme:o}}async function f(e){const r=await h(e),i=r.layer.geometryType,n=await w(r,i),o=n.scheme;if(!o)throw new a("location-renderer:insufficient-info","Unable to find location scheme");const{view:s,layer:l,signal:t}=r,[p,d]=await Promise.all([r.outlineOptimizationEnabled?y({view:s,layer:l,signal:t}):null,r.sizeOptimizationEnabled?u({view:s,layer:l,signal:t}):null]),f=p&&p.opacity,v=new m({symbol:b.createSymbol(i,{type:r.symbolType,color:o.color,size:b.getSymbolSizeFromScheme(o,i),outline:b.getSymbolOutlineFromScheme(o,i,f),meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}})});return p&&p.visualVariables&&p.visualVariables.length&&(v.visualVariables=p.visualVariables.map((e=>e.clone()))),d&&d.minSize&&(v.visualVariables?v.visualVariables.push(d.minSize):v.visualVariables=[d.minSize]),{renderer:v,locationScheme:c.cloneScheme(o),basemapId:n.basemapId,basemapTheme:n.basemapTheme}}e.createRenderer=f,Object.defineProperty(e,"__esModule",{value:!0})}));
