/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../chunks/_rollupPluginBabelHelpers","../../renderers/ClassBreaksRenderer","../../renderers/DictionaryRenderer","../../renderers/DotDensityRenderer","../../renderers/HeatmapRenderer","../../renderers/PieChartRenderer","../../renderers/Renderer","../../renderers/SimpleRenderer","../../renderers/UniqueValueRenderer","../../renderers/support/jsonUtils","../../core/Error","../../core/maybe","../heuristics/outline","../heuristics/sizeRange","./support/utils","../support/binningUtils","../support/adapters/support/layerUtils","../symbology/location"],(function(e,r,n,i,a,o,l,s,t,m,p,u,c,y,d,b,h,f,g){"use strict";function T(e){return v.apply(this,arguments)}function v(){return(v=r._asyncToGenerator((function*(e){if(!e||!e.layer)throw new u("location-renderer:missing-parameters","'layer' parameter is required");e.forBinning&&h.verifyBinningParams(e,"location-renderer");const r={...e};r.symbolType=r.symbolType||"2d";const n=e.forBinning?f.binningCapableLayerTypes:f.featureCapableLayerTypes,i=f.createLayerAdapter(r.layer,n,e.forBinning);if(r.layer=i,!i)throw new u("location-renderer:invalid-parameters","'layer' must be one of these types: "+f.getLayerTypeLabels(n).join(", "));const a=c.isSome(r.signal)?{signal:r.signal}:null;yield i.load(a);const o=i.geometryType;if(r.outlineOptimizationEnabled="polygon"===o&&r.outlineOptimizationEnabled,r.sizeOptimizationEnabled=("point"===o||"multipoint"===o||"polyline"===o)&&r.sizeOptimizationEnabled,"mesh"===o)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else{if("3d-volumetric-uniform"===r.symbolType&&"point"!==o)throw new u("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new u("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}return r}))).apply(this,arguments)}function w(e,r){return S.apply(this,arguments)}function S(){return(S=r._asyncToGenerator((function*(e,r){let n=e.locationScheme,i=null,a=null;const o=yield b.getBasemapInfo(e.basemap,e.view);if(i=c.isSome(o.basemapId)?o.basemapId:null,a=c.isSome(o.basemapTheme)?o.basemapTheme:null,n)return{scheme:g.cloneScheme(n),basemapId:i,basemapTheme:a};const l=g.getSchemes({basemap:i,basemapTheme:a,geometryType:r,worldScale:e.symbolType.includes("3d-volumetric"),view:e.view});return l&&(n=l.primaryScheme,i=l.basemapId,a=l.basemapTheme),{scheme:n,basemapId:i,basemapTheme:a}}))).apply(this,arguments)}function z(e){return M.apply(this,arguments)}function M(){return(M=r._asyncToGenerator((function*(e){const r=yield T(e),n=r.layer.geometryType,i=yield w(r,n),a=i.scheme;if(!a)throw new u("location-renderer:insufficient-info","Unable to find location scheme");const{view:o,layer:l,signal:s}=r,[m,p]=yield Promise.all([r.outlineOptimizationEnabled?y({view:o,layer:l,signal:s}):null,r.sizeOptimizationEnabled?d({view:o,layer:l,signal:s}):null]),c=m&&m.opacity,h=new t({symbol:b.createSymbol(n,{type:r.symbolType,color:a.color,size:b.getSymbolSizeFromScheme(a,n),outline:b.getSymbolOutlineFromScheme(a,n,c),meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}})});return m&&m.visualVariables&&m.visualVariables.length&&(h.visualVariables=m.visualVariables.map((e=>e.clone()))),p&&p.minSize&&(h.visualVariables?h.visualVariables.push(p.minSize):h.visualVariables=[p.minSize]),{renderer:h,locationScheme:g.cloneScheme(a),basemapId:i.basemapId,basemapTheme:i.basemapTheme}}))).apply(this,arguments)}e.createRenderer=z,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
