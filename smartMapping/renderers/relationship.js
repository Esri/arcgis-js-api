/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../core/lang","../../core/maybe","../../core/Error","../../core/promiseUtils","../../intl/messages","../../renderers/support/AuthoringInfoClassBreakInfo","../../renderers/support/AuthoringInfoFieldInfo","../../renderers/support/AuthoringInfo","../../symbols/support/utils","../support/adapters/support/layerUtils","./support/utils","./type","../../chunks/relationship"],(function(e,a,n,l,i,r,s,o,t,d,u,m,f,p){"use strict";const c=["equal-interval","natural-breaks","quantile"],h=["HH","HL","LH","LL"],y={2:[["HL","HH"],["LL","LH"]],3:[["HL","HM","HH"],["ML","MM","MH"],["LL","LM","LH"]],4:[["HL","HM1","HM2","HH"],["M2L","M2M1","M2M2","M2H"],["M1L","M1M1","M1M2","M1H"],["LL","LM1","LM2","LH"]]},b={2:["L","H"],3:["L","M","H"],4:["L","M1","M2","H"]},w=e=>({minValue:e.minValue,maxValue:e.maxValue});function v(e,n){const l=a.clone(y[e]);return p.flatten2DArray(l,n)}function g(e,a,n,l){const{field:i,normalizationField:r}=e,{field:s,normalizationField:o}=a,t=n.map((e=>[e.minValue,e.maxValue])),d=l.map((e=>[e.minValue,e.maxValue])),u=t.length,m=b[u];return`\n  var field1 = $feature['${i}'];\n  var field2 = $feature['${s}'];\n  var hasNormField1 = ${r?"true":"false"};\n  var hasNormField2 = ${o?"true":"false"};\n  var normField1 = ${r?`$feature['${r}']`:"null"};\n  var normField2 = ${o?`$feature['${o}']`:"null"};\n\n  if (\n    IsEmpty(field1) ||\n    IsEmpty(field2) ||\n    (hasNormField1 && (IsEmpty(normField1) || normField1 == 0)) ||\n    (hasNormField2 && (IsEmpty(normField2) || normField2 == 0))\n  ) {\n    return null;\n  }\n\n  var value1 = IIf(hasNormField1, (field1 / normField1), field1);\n  var value2 = IIf(hasNormField2, (field2 / normField2), field2);\n\n  var breaks1 = ${JSON.stringify(t)};\n  var breaks2 = ${JSON.stringify(d)};\n  var classCodes = ${JSON.stringify(m)};\n\n  function getClassCode(value, breaks) {\n    var code = null;\n\n    for (var i in breaks) {\n      var info = breaks[i];\n      if (value >= info[0] && value <= info[1]) {\n        code = classCodes[i];\n        break;\n      }\n    }\n\n    return code;\n  }\n\n  var code1 = getClassCode(value1, breaks1);\n  var code2 = getClassCode(value2, breaks2);\n\n  var classValue = IIf(IsEmpty(code1) || IsEmpty(code2), null, code1 + code2);\n  return classValue;\n  `}async function I(e,a,i){const s=await r.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),{basemap:o,classificationMethod:d,field1:u,field2:c,focus:h,numClasses:y,signal:b}=e,I=e.layer,M=a.classBreakInfos,z=i.classBreakInfos;if(y!==M.length||M.length!==z.length)throw new l("relationship-renderer:error","incompatible class breaks");const F=function(e,a){return v(e,a).map((e=>({value:e,count:0})))}(y,h),T=g(e.field1,e.field2,M,z),L=(await async function(e){let a=e.relationshipScheme,l=null,i=null;const r=await m.getBasemapInfo(e.basemap,e.view);if(l=n.isSome(r.basemapId)?r.basemapId:null,i=n.isSome(r.basemapTheme)?r.basemapTheme:null,a)return{scheme:p.cloneScheme(a),basemapId:l,basemapTheme:i};const s=p.getSchemes({basemap:l,basemapTheme:i,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return s&&(a=s.primaryScheme,l=s.basemapId,i=s.basemapTheme),{scheme:a,basemapId:l,basemapTheme:i}}({basemap:o,geometryType:I.geometryType,theme:"default",relationshipScheme:e.relationshipScheme,worldScale:e.symbolType.indexOf("3d-volumetric")>-1,view:e.view})).scheme,V=await f.createRenderer({layer:I,basemap:o,valueExpression:T,valueExpressionTitle:s.relationship.legendTitle,numTypes:-1,sortEnabled:!1,defaultSymbolEnabled:e.defaultSymbolEnabled,typeScheme:{colors:p.getColors(L,y,h),...L},statistics:{uniqueValueInfos:F},legendOptions:e.legendOptions,outlineOptimizationEnabled:e.outlineOptimizationEnabled,sizeOptimizationEnabled:e.sizeOptimizationEnabled,symbolType:e.symbolType,colorMixMode:e.colorMixMode,edgesType:e.edgesType,view:e.view,signal:b}),k=V.renderer,C=k.uniqueValueInfos,H=s.relationship;for(const e of C)e.label=H[e.value];const x=new t({type:"relationship",classificationMethod:d,numClasses:y,focus:h,field1:{field:u.field,normalizationField:u.normalizationField,label:u.label,classBreakInfos:M.map(w)},field2:{field:c.field,normalizationField:c.normalizationField,label:c.label,classBreakInfos:z.map(w)}});return k.authoringInfo=x,{renderer:k,classBreaks:{field1:a,field2:i},uniqueValueInfos:V.uniqueValueInfos,relationshipScheme:L,basemapId:V.basemapId,basemapTheme:V.basemapTheme}}e.createRenderer=async function(e){const a=await async function(e){if(!(e&&e.layer&&e.view&&e.field1&&e.field2))throw new l("relationship-renderer:missing-parameters","'layer', 'view', 'field1' and 'field2' parameters are required");const a={...e};if(a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled=null==a.defaultSymbolEnabled||a.defaultSymbolEnabled,a.classificationMethod=a.classificationMethod||"quantile",a.numClasses=a.numClasses||3,a.focus=a.focus||null,-1===c.indexOf(a.classificationMethod))throw new l("relationship-renderer:invalid-parameters",`classification method ${a.classificationMethod} is not supported`);if(a.numClasses<2||a.numClasses>4)throw new l("relationship-renderer:invalid-parameters","'numClasses' must be 2, 3 or 4");if(e.focus&&-1===h.indexOf(e.focus))throw new l("relationship-renderer:invalid-parameters","'focus' must be 'HH', 'HL', 'LH', 'LL' or null");const i=[0,2,1,3],r=u.createLayerAdapter(a.layer,i);if(a.layer=r,!r)throw new l("relationship-renderer:invalid-parameters","'layer' must be one of these types: "+u.getLayerTypeLabels(i).join(", "));const s=n.isSome(a.signal)?{signal:a.signal}:null;await r.load(s);const o=r.geometryType,t=a.symbolType.indexOf("3d")>-1;if(a.outlineOptimizationEnabled="polygon"===o&&a.outlineOptimizationEnabled,a.sizeOptimizationEnabled=("point"===o||"multipoint"===o||"polyline"===o)&&a.sizeOptimizationEnabled,"mesh"===o)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==o)throw new l("relationship-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(t&&"polygon"===o)throw new l("relationship-renderer:not-supported","3d symbols are not supported for polygon layers");if(a.symbolType.indexOf("3d-volumetric")>-1&&(!a.view||"3d"!==a.view.type))throw new l("relationship-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const{field1:d,field2:f}=a,p=[d.field,f.field];d.normalizationField&&p.push(d.normalizationField),f.normalizationField&&p.push(f.normalizationField);const y=m.verifyBasicFieldValidity(r,p,"relationship-renderer:invalid-parameters");if(y)throw y;return a}(e),{layer:r,classificationMethod:s,field1:o,field2:t,numClasses:d,view:f,signal:p}=a,y={layer:r,classificationMethod:s,field:o.field,normalizationField:o.normalizationField,normalizationType:o.normalizationField?"field":null,minValue:o.minValue,maxValue:o.maxValue,analyzeData:!(null!=o.minValue&&null!=o.maxValue),numClasses:d,view:f,signal:p},b={layer:r,classificationMethod:s,field:t.field,normalizationField:t.normalizationField,normalizationType:t.normalizationField?"field":null,minValue:t.minValue,maxValue:t.maxValue,analyzeData:!(null!=t.minValue&&null!=t.maxValue),numClasses:d,view:f,signal:p},[w,v]=await i.all([m.getClassBreaks(y),m.getClassBreaks(b)]);if(!w||!v)throw new l("relationship-renderer:error","error when calculating class breaks");return I(a,w.result,v.result)},e.updateRenderer=async function(e){const a=await async function(e){if(!(e&&e.renderer&&e.numClasses))throw new l("update-relationship-renderer:missing-parameters","'renderer' and 'numClasses' parameters are required");const{field1:a,field2:n,renderer:i,numClasses:r,colors:s}=e,o=Math.pow(r,2);if((a||n)&&!(a&&n&&a.field&&n.field))throw new l("update-relationship-renderer:missing-parameters","'field1' and 'field2' parameters are required");if(a&&!a.classBreakInfos||n&&!n.classBreakInfos)throw new l("update-relationship-renderer:missing-parameters","'field1.classBreakInfos' and 'field2.classBreakInfos' are required");if(!i.authoringInfo)throw new l("update-relationship-renderer:missing-parameters","'renderer.authoringInfo' is required");if(i.uniqueValueInfos.length!==o)throw new l("update-relationship-renderer:invalid-parameters",`Renderer must have ${o} unique value infos to support ${r} classes`);if(s&&s.length!==o)throw new l("update-relationship-renderer:invalid-parameters",`The scheme must have ${o} colors`);return e}(e),{field1:n,field2:i,renderer:r,numClasses:t,focus:u,colors:f}=a,p=r.clone();if(p.valueExpression=g(n,i,n.classBreakInfos,i.classBreakInfos),function(e,a,n){const l=v(a,n);e.sort(((e,a)=>{const n=l.indexOf(e.value),i=l.indexOf(a.value);let r=0;return n<i?r=-1:n>i&&(r=1),r}))}(p.uniqueValueInfos,t,u),f){const e=m.createColors(f,f.length);p.uniqueValueInfos.forEach(((a,n)=>d.applyColorToSymbol(a.symbol,e[n])))}return function(e,a){const{authoringInfo:n}=e;n.numClasses=a.numClasses,n.focus=a.focus||null,n.focus||delete n.focus;const{field1:l,field2:i}=a;n.field1=new o.default({field:l.field,normalizationField:l.normalizationField,label:l.label,classBreakInfos:l.classBreakInfos.map((e=>new s.default(w(e))))}),n.field2=new o.default({field:i.field,normalizationField:i.normalizationField,label:i.label,classBreakInfos:i.classBreakInfos.map((e=>new s.default(w(e))))}),e.authoringInfo=n}(p,a),p},Object.defineProperty(e,"__esModule",{value:!0})}));
