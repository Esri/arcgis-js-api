/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../geometry","../../../core/Error","../../../core/maybe","../../../core/screenUtils","../../../geometry/SpatialReference","../../../geometry/support/quantizationUtils","../../../geometry/support/spatialReferenceUtils","../../../layers/support/fieldUtils","../../../renderers/support/heatmapUtils","../../../statistics/utils","../../../support/arcadeOnDemand","../../../geometry/Point"],(function(e,t,n,r,i,l,s,o,a,u,c,f,d,p){"use strict";let m=null;function y(e,t,n){return e.x<0?e.x+=t:e.x>n&&(e.x-=t),e}function h(e,t,n,r){const l=a.isWrappable(n)?a.getInfo(n):null,s=l?Math.round((l.valid[1]-l.valid[0])/t.scale[0]):null;return e.map((e=>{const n=new p(i.unwrap(e.geometry));return o.quantizePoint(t,n,n,n.hasZ,n.hasM),e.geometry=l?y(n,s,r[0]):n,e}))}function g(e,t=18,n,r,i,s){const o=new Float64Array(i*s);t=Math.round(l.pt2px(t));let a=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,f=0,d=0,p=0,m=0;const y=c.createValueFunction(r,n);for(const{geometry:l,attributes:g}of e){const{x:e,y:n}=l,r=Math.max(0,e-t),h=Math.max(0,n-t),$=Math.min(s,n+t),F=Math.min(i,e+t),I=+y(g);for(let l=h;l<$;l++)for(let s=r;s<F;s++){const r=l*i+s,y=c.evaluateDensityKernel(s-e,l-n,t),h=o[r];f=o[r]+=y*I;const g=f-h;d+=g,p+=g*g,f<a&&(a=f),f>u&&(u=f),m++}}if(!m)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const h=(u-a)/2;return{mean:d/m,stdDev:Math.sqrt((p-d*d/m)/m),min:a,max:u,mid:h,count:m}}function $(e,t){return F.apply(this,arguments)}function F(){return(F=t._asyncToGenerator((function*(e,t){if(!t)return[];const{field:n,field2:r,field3:i,fieldDelimiter:l}=e,o=e.valueExpression,a=e.normalizationType,u=e.normalizationField,c=e.normalizationTotal,p=[],y=e.viewInfoParams;let h=null,g=null;if(o){if(!m){const{arcadeUtils:e}=yield d.loadArcade();m=e}h=m.createFunction(o),g=y&&m.getViewInfo({viewingMode:y.viewingMode,scale:y.scale,spatialReference:new s(y.spatialReference)})}const $=e.fieldInfos,F=!(t[0]&&"declaredClass"in t[0]&&"esri.Graphic"===t[0].declaredClass)&&$?{fields:$}:null;return t.forEach((e=>{const t=e.attributes;let s;if(o){const t=F?{...e,layer:F}:e,n=m.createExecContext(t,g);s=m.executeFunction(h,n)}else t&&(s=t[n],r&&(s=`${f.processNullValue(s)}${l}${f.processNullValue(t[r])}`,i&&(s=`${s}${l}${f.processNullValue(t[i])}`)));if(a&&"number"==typeof s&&isFinite(s)){const e=t&&parseFloat(t[u]);s=f.getNormalizedValue(s,a,e,c)}p.push(s)})),p}))).apply(this,arguments)}function I(e){const t=e.field,n=e.normalizationType,r=e.normalizationField;let i;return"field"===n?i="(NOT "+r+" = 0)":"log"!==n&&"natural-log"!==n&&"square-root"!==n||(i=`(${t} > 0)`),i}function x(e,t){return new r(e,t)}function v(e,t,n){const r=null!=t?e+" >= "+t:"",i=null!=n?e+" <= "+n:"";let l="";return l=r&&i?E(r,i):r||i,l?"("+l+")":""}function b(e,t,n,r){let i=null;return t?t.name!==e.objectIdField&&r.includes(t.type)||(i=x(n,"'field' should be one of these types: "+r.join(","))):i=x(n,"'field' is not defined in the layer schema"),i}function N(e,t,n){let r;return t?t.name!==e.objectIdField&&u.isNumericField(t)||(r=x(n,"'field' should be one of these numeric types: "+u.numericTypes.join(","))):r=x(n,"'field' is not defined in the layer schema"),r}function E(e,t){let n=i.isSome(e)?e:"";return i.isSome(t)&&t&&(n=n?"("+n+") AND ("+t+")":t),n}function V(e,t){if(e&&"intersects"!==e.spatialRelationship)return x(t,"Only 'intersects' spatialRelationship is supported for featureFilter")}function j(e,t,n){const r=T({layer:e,fields:t});if(r.length)return x(n,"Unknown fields: "+r.join(", ")+". You can only use fields defined in the layer schema");const i=M({layer:e,fields:t});return i.length?x(n,"Unsupported fields: "+i.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function T(e){const t=e.layer;return e.fields.filter((e=>!t.getField(e)))}function M(e){const t=e.layer;return e.fields.filter((e=>{const n=t.getFieldUsageInfo(e);return!n||!n.supportsStatistics}))}function S(e,t,n){const r=[],i=[],l=[],s=[],o=[];e.forEach(((e,t)=>{const a=e.field?"field":"expression",u=e.field||e.valueExpression;e.field?(o.push(u),i.push(`var ${a}${t} = Number($feature["${u}"]);`)):(r.push(`function getValueForExpr${t}() {\n  ${u} \n}`),i.push(`var ${a}${t} = Number(getValueForExpr${t}());`)),n||l.push(`${a}${t} = IIf(${a}${t} < 0, 0, ${a}${t});`),s.push(`${a}${t}`)}));let a="return sum;";const u=r.length?null:o.reduce(((e,t)=>`${e} + ${t}`));let c=null;t||n?t?n||(a="return IIf(sum >= 0, sum, null);",u&&(c=`(( ${u} ) >= 0)`)):(a="return IIf(sum != 0, sum, null);",u&&(c=`(( ${u} ) <> 0)`)):(a="return IIf(sum > 0, sum, null);",u&&(c=`(( ${u} ) > 0)`));return{valueExpression:[r.length?r.join("\n"):"",i.join("\n"),l.join("\n"),`var sum = ${s.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:u,sqlWhere:c}}e.calculateHeatmapStats=g,e.createError=x,e.getDataValues=$,e.getRangeExpr=v,e.getSQLFilterForNormalization=I,e.getSumOfAttributesExpr=S,e.mergeWhereClauses=E,e.quantizeFeatures=h,e.verifyBasicFieldValidity=j,e.verifyFieldType=b,e.verifyFilterValidty=V,e.verifyNumericField=N,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
