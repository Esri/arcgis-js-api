/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../geometry","../../../core/Error","../../../core/maybe","../../../core/screenUtils","../../../geometry/SpatialReference","../../../geometry/support/quantizationUtils","../../../geometry/support/spatialReferenceUtils","../../../layers/support/fieldUtils","../../../renderers/support/heatmapUtils","../../../statistics/utils","../../../support/arcadeOnDemand","../../../geometry/Point"],(function(e,t,n,i,r,l,s,o,a,u,c,f,d,p){"use strict";let m=null;function h(e,t,n){return e.x<0?e.x+=t:e.x>n&&(e.x-=t),e}function y(e,t,n,i){const l=a.isWrappable(n)?a.getInfo(n):null,s=l?Math.round((l.valid[1]-l.valid[0])/t.scale[0]):null;return e.map((e=>{const n=new p(r.unwrap(e.geometry));return o.quantizePoint(t,n,n,n.hasZ,n.hasM),e.geometry=l?h(n,s,i[0]):n,e}))}function g(e,t=18,n,i,r,s){const o=new Float64Array(r*s);t=Math.round(l.pt2px(t));let a=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,f=0,d=0,p=0,m=0;const h=c.createValueFunction(i,n);for(const{geometry:l,attributes:g}of e){const{x:e,y:n}=l,i=Math.max(0,e-t),y=Math.max(0,n-t),$=Math.min(s,n+t),F=Math.min(r,e+t),I=+h(g);for(let l=y;l<$;l++)for(let s=i;s<F;s++){const i=l*r+s,h=c.evaluateDensityKernel(s-e,l-n,t),y=o[i];f=o[i]+=h*I;const g=f-y;d+=g,p+=g*g,f<a&&(a=f),f>u&&(u=f),m++}}if(!m)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const y=(u-a)/2;return{mean:d/m,stdDev:Math.sqrt((p-d*d/m)/m),min:a,max:u,mid:y,count:m}}function $(e,t){return F.apply(this,arguments)}function F(){return(F=t._asyncToGenerator((function*(e,t){if(!t)return[];const{field:n,field2:i,field3:r,fieldDelimiter:l}=e,o=e.valueExpression,a=e.normalizationType,u=e.normalizationField,c=e.normalizationTotal,p=[],h=e.viewInfoParams;let y=null,g=null;if(o){if(!m){const{arcadeUtils:e}=yield d.loadArcade();m=e}y=m.createFunction(o),g=h&&m.getViewInfo({viewingMode:h.viewingMode,scale:h.scale,spatialReference:new s(h.spatialReference)})}const $=e.fieldInfos,F=!(t[0]&&"declaredClass"in t[0]&&"esri.Graphic"===t[0].declaredClass)&&$?{fields:$}:null;return t.forEach((e=>{const t=e.attributes;let s;if(o){const t=F?{...e,layer:F}:e,n=m.createExecContext(t,g);s=m.executeFunction(y,n)}else t&&(s=t[n],i&&(s=`${f.processNullValue(s)}${l}${f.processNullValue(t[i])}`,r&&(s=`${s}${l}${f.processNullValue(t[r])}`)));if(a&&"number"==typeof s&&isFinite(s)){const e=t&&parseFloat(t[u]);s=f.getNormalizedValue(s,a,e,c)}p.push(s)})),p}))).apply(this,arguments)}function I(e){const t=e.field,n=e.normalizationType,i=e.normalizationField;let r;return"field"===n?r="(NOT "+i+" = 0)":"log"!==n&&"natural-log"!==n&&"square-root"!==n||(r=`(${t} > 0)`),r}function x(e,t){return new i(e,t)}function v(e,t,n){const i=null!=t?e+" >= "+t:"",r=null!=n?e+" <= "+n:"";let l="";return l=i&&r?E(i,r):i||r,l?"("+l+")":""}function b(e,t,n,i){let r=null;return t?t.name!==e.objectIdField&&i.includes(t.type)||(r=x(n,"'field' should be one of these types: "+i.join(","))):r=x(n,"'field' is not defined in the layer schema"),r}function N(e,t,n){let i;return t?t.name!==e.objectIdField&&u.isNumericField(t)||(i=x(n,"'field' should be one of these numeric types: "+u.numericTypes.join(","))):i=x(n,"'field' is not defined in the layer schema"),i}function E(e,t){let n=r.isSome(e)?e:"";return r.isSome(t)&&t&&(n=n?"("+n+") AND ("+t+")":t),n}function V(e,t){if(e&&"intersects"!==e.spatialRelationship)return x(t,"Only 'intersects' spatialRelationship is supported for featureFilter")}function j(e,t,n){const i=M({layer:e,fields:t});if(i.length)return x(n,"Unknown fields: "+i.join(", ")+". You can only use fields defined in the layer schema");const r=T({layer:e,fields:t});return r.length?x(n,"Unsupported fields: "+r.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function M(e){const t=e.layer;return e.fields.filter((e=>!t.getField(e)))}function T(e){const t=e.layer;return e.fields.filter((e=>{const n=t.getFieldUsageInfo(e);return!n||!n.supportsStatistics}))}function S(e,t,n){const i=[],r=[],l=[],s=[],o=[];e.forEach(((e,t)=>{const a=e.field?"field":"expression",u=e.field||e.valueExpression;e.field?(o.push(u),r.push(`var ${a}${t} = Number($feature["${u}"]);`)):(i.push(`function getValueForExpr${t}() {\n  ${u} \n}`),r.push(`var ${a}${t} = Number(getValueForExpr${t}());`)),n||l.push(`${a}${t} = IIf(${a}${t} < 0, 0, ${a}${t});`),s.push(`${a}${t}`)}));let a="return sum;";const u=i.length?null:o.reduce(((e,t)=>`${e} + ${t}`));let c=null;t||n?t?n||(a="return IIf(sum >= 0, sum, null);",u&&(c=`(( ${u} ) >= 0)`)):(a="return IIf(sum != 0, sum, null);",u&&(c=`(( ${u} ) <> 0)`)):(a="return IIf(sum > 0, sum, null);",u&&(c=`(( ${u} ) > 0)`));return{valueExpression:[i.length?i.join("\n"):"",r.join("\n"),l.join("\n"),`var sum = ${s.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:u,sqlWhere:c}}e.calculateHeatmapStats=g,e.createError=x,e.getDataValues=$,e.getRangeExpr=v,e.getSQLFilterForNormalization=I,e.getSumOfAttributesExpr=S,e.mergeWhereClauses=E,e.quantizeFeatures=y,e.verifyBasicFieldValidity=j,e.verifyFieldType=b,e.verifyFilterValidty=V,e.verifyNumericField=N,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
