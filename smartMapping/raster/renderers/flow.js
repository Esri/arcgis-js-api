/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import{isSome as a}from"../../../core/maybe.js";import i from"../../../renderers/support/AuthoringInfo.js";import r from"../../../renderers/support/AuthoringInfoVisualVariable.js";import{createFlowRenderer as t,estimateMagnitudeRange as n}from"../../../renderers/support/rasterRendererHelper.js";import l from"../../../renderers/visualVariables/ColorVariable.js";import o from"../../../renderers/visualVariables/OpacityVariable.js";import s from"../../../renderers/visualVariables/SizeVariable.js";import{processRasterRendererParameters as m}from"../support/utils.js";import{createError as p,getDataRange as u,createDataValues as c,createColors as f,getBasemapInfo as d}from"../../renderers/support/utils.js";import{cloneScheme as h,getSchemes as w}from"../../symbology/flow.js";const b=5;async function y(e){const a={...e};return a.theme||(a.theme="flow-line"),m(a)}async function V(e){let i=e.flowScheme,r=null,t=null;const n=await d(null,e.view);if(r=a(n.basemapId)?n.basemapId:null,t=a(n.basemapTheme)?n.basemapTheme:null,i)return{scheme:h(i),basemapId:r,basemapTheme:t};const l=w({basemap:r,basemapTheme:t,theme:e.theme,hasSizeVariable:e.hasSizeVariable});return l&&(i=l.primaryScheme,r=l.basemapId,t=l.basemapTheme),{scheme:i,basemapId:r,basemapTheme:t}}async function g(e,t){t.flowRepresentation&&(e.flowRepresentation=t.flowRepresentation);const m=await V({theme:t.theme,flowScheme:t.flowScheme,view:t.view,hasSizeVariable:t.includeSizeVariable}),d=m.scheme;if(!d)throw p("flow-renderer:insufficient-info","Unable to find flow scheme");e.flowSpeed=d.flowSpeed,e.density=d.density,e.trailLength=d.trailLength,e.trailWidth=d.trailWidth,e.trailCap=d.trailCap,e.color=d.color;const w=[],y=[],g="Magnitude",S=t.layer.rasterInfo,v=!a(S.statistics)||"vector-magdir"!==S.dataType&&"vector-uv"!==S.dataType?{minMagnitude:0,maxMagnitude:10}:n(S.dataType,S.statistics);if(!v||null==v.minMagnitude||null==v.maxMagnitude)throw p("flow-renderer:insufficient-info","stats not available");const x={min:v.minMagnitude,max:v.maxMagnitude},I={min:x.min,max:null!=x.max?x.max/2:null},T=u(I,null,null,null),j=c(T,I,null);if(t.includeColorVariable){const e=f(d.colors,b);if(e.length<b)throw p("flow-renderer:insufficient-info","Flow scheme does not have enough colors");const a=new l({field:g,stops:j.map(((a,i)=>({value:a,color:e[i]})))});w.push(a);const i=new r({type:"color",minSliderValue:x.min,maxSliderValue:x.max,theme:"high-to-low"});y.push(i)}if(t.includeOpacityVariable){const e=new o({field:g,stops:[{value:j[0],opacity:d.minOpacity},{value:j[4],opacity:d.maxOpacity}]});w.push(e);const a=new r({type:"opacity",minSliderValue:x.min,maxSliderValue:x.max});y.push(a)}if(t.includeSizeVariable){const e=new s({field:g,stops:[{value:x.min,size:d.minSize},{value:x.max,size:d.maxSize}]});w.push(e);const a=new r({type:"size",minSliderValue:x.min,maxSliderValue:x.max,theme:"high-to-low"});y.push(a)}const z=new i({type:"flow",visualVariables:y.length?y:null,flowTheme:d.theme});return e.visualVariables=w,e.authoringInfo=z,e.legendOptions=t.legendOptions,{renderer:e,visualVariables:w.map((e=>e.clone())),flowScheme:h(d),basemapId:m.basemapId,basemapTheme:m.basemapTheme,layerEffect:d.layerEffect,statistics:x}}async function S(i){i=await y(i);const r=t(i.layer.rasterInfo);if(!a(r))throw new e("flow-renderer:not-supported","Only vector data is supported");return g(r,i)}export{S as createRenderer};
