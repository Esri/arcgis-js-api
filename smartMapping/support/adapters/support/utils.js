/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../core/promiseUtils","../../../../support/arcadeOnDemand","../../../../tasks/support/ClassBreaksDefinition","../../../../tasks/support/generateRendererUtils","../../utils","../../../../renderers/support/heatmapUtils"],(function(t,e,n,a,o,i,l){"use strict";const r=/_value$/i,s=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,u=Math.LOG10E,c=["min","max","avg","stddev","count","sum","variance"];let m=null;function f(t,e,n){return e=null==e?-1/0:e,n=null==n?1/0:n,t.filter((t=>null!=t&&I(t)&&t>=e&&t<=n))}async function d(t,e){const a=t.field,o="function"==typeof a,i=t.valueExpression,l=t.normalizationType,r=t.normalizationField,s=t.normalizationTotal,u=[],c=t.view;let f=null,d=null;if(i){if(!m){const{arcadeUtils:t}=await n.loadArcade();m=t}f=m.createFunction(i),d=c&&m.getViewInfo({viewingMode:"2d"===c.type?"map":c.viewingMode,scale:c.scale,spatialReference:c.spatialReference})}return e?(e.forEach((t=>{const e=t.attributes;let n;if(i){const e=m.createExecContext(t,d);n=m.executeFunction(f,e)}else o?n=a.call(null,t):e&&(n=e[a]);if(l&&null!=n&&I(n)){const t=e&&parseFloat(e[r]);"log"===l&&0!==n?n=Math.log(n)*Math.LOG10E:"percent-of-total"===l&&I(s)&&0!==s?n=n/s*100:"field"===l&&I(t)&&0!==t&&(n/=t)}u.push(n)})),u):u}function p(t){const e=t.field,n=t.classificationMethod||"equal-interval",o=t.normalizationType,i=t.normalizationField,l=new a;return l.classificationField=e,l.breakCount=t.breakCount,l.classificationMethod=n,l.standardDeviationInterval="standard-deviation"===n?t.standardDeviationInterval||1:void 0,l.normalizationType=o,l.normalizationField="field"===o?i:void 0,l}function v(t,e){let n=e.classBreaks;const a=n.length,o=n[0].minValue,i=n[a-1].maxValue,l="standard-deviation"===t.classificationMethod,r=s;return n=n.map((t=>{const e=t.label,n={minValue:t.minValue,maxValue:t.maxValue,label:e};if(l&&e){const t=e.match(r).map((t=>+t.trim()));2===t.length?(n.minStdDev=t[0],n.maxStdDev=t[1],t[0]<0&&t[1]>0&&(n.hasAvg=!0)):1===t.length&&(e.indexOf("<")>-1?(n.minStdDev=null,n.maxStdDev=t[0]):e.indexOf(">")>-1&&(n.minStdDev=t[0],n.maxStdDev=null))}return n})),{minValue:o,maxValue:i,classBreakInfos:n,normalizationTotal:e.normalizationTotal}}function h(t,e,n){const a=(e-t)/n,o=[];let i,l=t;for(let t=1;t<=n;t++)i=l+a,i=Number(i.toFixed(16)),o.push([l,i]),l=i;return o}function x(t){const{field:e,normalizationType:n,normalizationField:a,normalizationTotal:o,layer:l}=t,r=i.isIntegerField(l,e);let s=e;return"percent-of-total"===n?s=`((${r?i.castIntegerFieldToFloat(e):e} / ${o}) * 100)`:"log"===n?s=`(log(${e}) * ${u})`:"field"===n&&(s=`(${r?i.castIntegerFieldToFloat(e):e} / ${a})`),s}function F(t,e){let n=-1;for(let a=t.length-1;a>=0;a--){if(e>=t[a][0]){n=a;break}}return n}function g(t,e){let n;if(e=e.toLowerCase(),t)for(const a in t)if(a.toLowerCase()!==e){n=t[a];break}return n}function y(t,e){let n;if(e=e.toLowerCase(),t)for(const a in t)if(a.toLowerCase()===e){n=t[a];break}return n}function V(t,e){if(e)for(const n in t)t[n].label=e[n];return{count:t}}function T(t,e,n){const a=t.count,o=[];if(n&&e&&"coded-value"===e.type){e.codedValues.forEach((t=>{const e=t.code;a.hasOwnProperty(e)||(a[e]={data:e,count:0})}))}for(const t in a){const e=a[t];o.push({value:e.data,count:e.count,label:e.label})}return{uniqueValueInfos:o}}function I(t){return"number"==typeof t&&!isNaN(t)&&t!==1/0&&t!==-1/0}t.calculateClassBreaksFromMemory=async function(t,e){const n=t.normalizationTotal,a=p({field:t.field,normalizationType:t.normalizationType,normalizationField:t.normalizationField,classificationMethod:t.classificationMethod,standardDeviationInterval:t.standardDeviationInterval,breakCount:t.numClasses||5});let i=await d(t,e);return i=f(i,t.minValue,t.maxValue),v(t,o.createGenerateRendererClassBreaks({definition:a,values:i,normalizationTotal:n}))},t.calculateHeatmapStats=function(t,e=10,n,a,o,i){const r=new Float64Array(o*i),s=l.createKernel(e),u=Math.round(3*e);let c=Number.POSITIVE_INFINITY,m=Number.NEGATIVE_INFINITY,f=0,d=0,p=0,v=0;const h=l.createValueFunction(a,n);for(const{geometry:e,attributes:n}of t){const t=e.x-u,a=e.y-u,l=Math.max(0,t),x=Math.max(0,a),F=Math.min(i,e.y+u),g=Math.min(o,e.x+u),y=+h(n);for(let e=x;e<F;e++){const n=s[e-a];for(let a=l;a<g;a++){const i=s[a-t],l=e*o+a,u=r[l];f=r[l]+=n*i*y;const h=f-u;d+=h,p+=h*h,f<c&&(c=f),f>m&&(m=f),v++}}}if(!v)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const x=(m-c)/2;return{mean:d/v,stdDev:Math.sqrt((p-d*d/v)/v),min:c,max:m,mid:x,count:v}},t.calculateHistogramFromMemory=async function(t,e,n){const{min:a,max:o,normTotal:i}=e,l=t.numBins||10,r=e.intervals||h(a,o,l),s=r.map(((t,e)=>({minValue:r[e][0],maxValue:r[e][1],count:0}))),u=await d(t,n);for(const t of u)if(null!=t&&t>=a&&t<=o){const e=F(r,t);e>-1&&s[e].count++}return{bins:s,minValue:a,maxValue:o,normalizationTotal:i}},t.calculateStatsFromMemory=async function(t,e,n){let a=await d(t,e);a=f(a,t.minValue,t.maxValue);const o=function(t,e){let n=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY,o=null,i=null,l=null,r=null;for(const e of t)o+=e,n=Math.min(n,e),a=Math.max(a,e);const s=t.length;if(s){i=o/s;let n=0;for(const e of t)n+=Math.pow(e-i,2);r=e?s>1?n/(s-1):0:s>0?n/s:0,l=Math.sqrt(r)}else n=null,a=null;return{avg:i,count:s,max:a,min:n,stddev:l,sum:o,variance:r}}(a,!t.normalizationType);return n&&["avg","stddev","variance"].forEach((t=>{null!=o[t]&&(o[t]=Math.ceil(o[t]))})),o},t.calculateUniqueValuesFromMemory=async function(t,e,n){const a=await d(t,e),o={};for(let t of a)(null==t||"string"==typeof t&&""===t.trim())&&(t=null),null==o[t]?o[t]={count:1,data:t}:o[t].count++;return T({count:o},n,t.returnAllCodedValues)},t.createCBDefn=p,t.createUVResult=T,t.generateBinParams=function(t){const e=[],n=t.classBreaks,a=n[0].minValue,o=n[n.length-1].maxValue;n.forEach((t=>{e.push([t.minValue,t.maxValue])}));const i={field:t.field,normalizationType:t.normalizationType,normalizationField:t.normalizationField,normalizationTotal:t.normalizationTotal,layer:t.layer};return{min:a,max:o,intervals:e,sqlExpr:x(i),excludeZerosExpr:t.where,normTotal:t.normalizationTotal}},t.getDataValues=d,t.getEqualIntervalBins=h,t.getFieldExpr=x,t.getHistogramFromFeatureSet=function(t,e,n,a,o){const i={},l="countOFExpr";t&&t.features&&t.features.forEach((t=>{const e=t.attributes,n=g(e,l),a=y(e,l);0!==n&&(i[n]=a)}));const r=[];return h(e,n,a).forEach(((t,e)=>{const n=(e+1).toString();r.push({minValue:t[0],maxValue:t[1],count:i.hasOwnProperty(n)?i[n]:0})})),{bins:r,minValue:e,maxValue:n,normalizationTotal:o}},t.getMissingFields=async function(t,e,n){const a=[];if(e)for(const o of e){const e=t.getField(o);"availableFields"in n&&-1===n.availableFields.indexOf(e.name)&&a.push(e.name)}return a},t.getSummaryStatisticsFromFeatureSet=function(t,e){const n=t&&t.features,a=n&&n[0]&&n[0].attributes,o={};for(const t in a)o[t.replace(r,"").toLowerCase()]=a[t];return o.min===o.max&&null!=o.min&&null==o.stddev&&(o.stddev=o.variance=0),e&&(["min","max","avg","stddev","sum","variance"].forEach((t=>{null!=o[t]&&(o[t]=Math.ceil(o[t]))})),o.min===o.max&&null!=o.min&&(o.avg=o.min,o.stddev=o.variance=0)),o},t.getUniqueValuesFromFeatureSet=function(t,n,a,o,i){const l=t&&t.features,r="countOF"+(a||"Expr"),s={};let u=!1;if(l.forEach((t=>{const e=t.attributes,n=y(e,r);let o=a?y(e,a):g(e,r);null===o&&0===n&&(u=!0),(null==o||"string"==typeof o&&""===o.trim())&&(o=null),null==s[o]?s[o]={count:n,data:o}:s[o].count=s[o].count+n})),a&&u){const t=a+" is NULL";return n.queryFeatureCount(t,i).then((t=>(t=t||0,s.null.count=s.null.count+t,V(s,o)))).catch((()=>(e.throwIfAborted(i),V(s,o))))}return e.resolve(V(s,o))},t.isValidNumber=I,t.msSinceUnixEpochSQL=function(t,e){return i.getDateDiffSQL(t,new Date(0),e,"milliseconds").sqlExpression},t.processSummaryStatisticsResult=function(t){let e;for(e in t)c.indexOf(e)>-1&&(I(t[e])||(t[e]=null));return t},t.resolveCBResult=v,t.statisticTypes=c,Object.defineProperty(t,"__esModule",{value:!0})}));
