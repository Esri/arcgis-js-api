/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["require","exports","../../core/maybe","../../core/Error","../../request","./arcgisLayerUrl","./lazyLayerLoader"],(function(e,r,a,t,n,l,s){"use strict";function o(e){return Object.freeze({__proto__:null,default:e})}function u(e,r){return e?e.find((e=>e.id===r)):null}function i(e){return!e.type||"Feature Layer"===e.type}async function c(e){return(await n(e,{responseType:"json",query:{f:"json"}})).data}r.fromUrl=async function(r){const n=await async function(e){const r=l.parse(e);if(a.isNone(r))throw new t("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:e});const{serverType:n,sublayer:o}=r;let u;const y={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(n){case"MapServer":u=null!=o?"FeatureLayer":async function(e){return(await c(e)).tileInfo}(e).then((e=>e?"TileLayer":"MapImageLayer"));break;case"ImageServer":u=c(e).then((e=>{const r=e.tileInfo&&e.tileInfo.format;return e.tileInfo?!r||"LERC"!==r.toUpperCase()||e.cacheType&&"elevation"!==e.cacheType.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer"}));break;case"SceneServer":u=c(r.url.path).then((e=>{const r={Point:"SceneLayer","3DObject":"SceneLayer",IntegratedMesh:"IntegratedMeshLayer",PointCloud:"PointCloudLayer",Building:"BuildingSceneLayer"};if(e&&Array.isArray(e.layers)&&e.layers.length>0){const a=e.layers[0].layerType;if(null!=r[a])return r[a]}return"SceneLayer"}));break;default:u=y[n]}const d={FeatureLayer:!0,SceneLayer:!0},f="FeatureServer"===n,I={parsedUrl:r,Constructor:null,layerOrTableId:f?o:null,sublayerIds:null,tableIds:null},b=await u;if(d[b]&&null==o){const r=await async function(e,r){var a,t;let n,l=!1;if("FeatureServer"===r){const r=await async function(e){var r,a;let t=await c(e);t=t||{},t.layers=(null==(r=t.layers)?void 0:r.filter(i))||[];const n={serviceJSON:t};if(t.currentVersion<10.5)return n;const l=await c(e+"/layers");return n.layersJSON={layers:(null==l||null==(a=l.layers)?void 0:a.filter(i))||[],tables:(null==l?void 0:l.tables)||[]},n}(e);l=!!r.layersJSON,n=r.layersJSON||r.serviceJSON}else n=await c(e);const s=null==(a=n)?void 0:a.layers,o=null==(t=n)?void 0:t.tables;return{layerIds:(null==s?void 0:s.map((e=>e.id)).reverse())||[],tableIds:(null==o?void 0:o.map((e=>e.id)).reverse())||[],layerInfos:l?s:[],tableInfos:l?o:[]}}(e,n);f&&(I.sublayerInfos=r.layerInfos,I.tableInfos=r.tableInfos);if(1!==r.layerIds.length+r.tableIds.length)I.sublayerIds=r.layerIds,I.tableIds=r.tableIds;else if(f){var v,p;I.layerOrTableId=null!=(v=r.layerIds[0])?v:r.tableIds[0],I.sourceJSON=null!=(p=r.layerInfos[0])?p:r.tableInfos[0]}}return I.Constructor=await async function(e){return(0,s.layerLookupMap[e])()}(b),I}(r.url),y={...r.properties,url:r.url};if(!n.sublayerIds)return null!=n.layerOrTableId&&(y.layerId=n.layerOrTableId,y.sourceJSON=n.sourceJSON),new n.Constructor(y);const d=new(0,(await new Promise((function(r,a){e(["../GroupLayer"],(function(e){r(o(e))}),a)}))).default)({title:n.parsedUrl.title});return function(e,r,t){function n(e,n){const l={...t,layerId:e,sublayerTitleMode:"service-name"};return a.isSome(n)&&(l.sourceJSON=n),new r.Constructor(l)}r.sublayerIds.forEach((a=>{const t=n(a,u(r.sublayerInfos,a));e.add(t)})),r.tableIds.forEach((a=>{const t=n(a,u(r.tableInfos,a));e.tables.add(t)}))}(d,n,y),d},Object.defineProperty(r,"__esModule",{value:!0})}));
