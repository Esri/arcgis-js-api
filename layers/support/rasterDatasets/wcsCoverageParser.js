/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../geometry/Extent.js";import t from"../../../geometry/Polygon.js";import{isAxesOrderReversedForWkid as n}from"../../ogc/crsUtils.js";import i from"../RasterInfo.js";import{getElements as s,isSameTagIgnoreNS as a,getElementValue as o,getElementValues as l,getNodeNameIgnoreNS as r,getElement as u,getSpaceDelimitedNumericValues as m}from"./xmlUtilities.js";function p(e){return{requestResponseCRSs:l(e,"requestResponseCRSs").map((e=>e.split(":")[1])),nativeCRSs:l(e,"nativeCRSs").map((e=>e.split(":")[1]))}}function d(e,t){const n=l(e,"1.0.0"===t?"interpolationMethod":"InterpolationMethod"),i="1.0.0"===t?e.getAttribute("default"):o(e,"InterpolationMethods/Default");return null!=i?[i].concat(n.filter((e=>e.toLowerCase()!==i.toLowerCase()))):n}function c(e){return null==e?["nearest"]:e.map((e=>{const t=e.toLowerCase();return t.includes("nearest")?"nearest":t.includes("linear")?"bilinear":t.includes("cubic")?"cubic":null})).filter((e=>!!e))}function f(t){const n=s(t,"pos"),i=m(n[0]),a=m(n[1]);return new e({xmin:i[0],ymin:i[1],xmax:a[0],ymax:a[1],spatialReference:{wkid:4326}})}function g(e,t){const n=l(e,t);return n?.length&&""!==n[0]&&!isNaN(Number(n[0]))?n.map((e=>Number(e))):null}function h(e){return e.every((t=>t===e[0]))?e[0]:e}function b(e){const t=[],n=s(e,"RangeSet");let i=[];for(let a=0;a<n.length;a++){const e=o(n[a],"name"),r=o(n[a],"label"),u=[],m=g(n[a],"nullValues/singleValue"),p=s(n[a],"AxisDescription");for(let t=0;t<p.length;t++){const e=o(p[t],"name"),n=o(p[t],"label"),s=l(p[t],"singleValue");if(0===s.length){const e=o(p[t],"min"),n=o(p[t],"max"),i=Number(o(p[t],"res"))||1;if(null!==e&&null!==n)for(let t=parseInt(e,10);t<=parseInt(n,10);t+=i)s.push(t.toString())}"band"===e.toLowerCase()&&(i=s),u.push({name:e,label:n,values:s})}t.push({name:e,label:r,nullValues:m,axis:u})}return{rangeSet:t,bandNames:i}}function x(e=null){if(!e)return{resolution:null,units:null};let t=e.toUpperCase();const n=["Y","M","D"],i=["H","M","S"],s=["Years","Months","Days","Hours","Minutes","Seconds"];let a,o,l;return t.includes("PT")?(t=t.slice(2),l=i.findIndex((e=>t.includes(e))),a=s[3+l],o=parseFloat(t.substring(0,t.length-1))):(t=t.slice(1),l=n.findIndex((e=>t.includes(e))),l>-1&&(a=s[l]),o=parseFloat(t.substring(0,t.length-1))),{resolution:o,units:a}}function v(e){const t=s(e,"timeposition");if(t.length>0){const e=[];for(let n=0;n<t.length;n++)e.push(new Date(o(t[n])));return{begin:e[0],end:e[e.length-1],values:e}}const n=u(e,"timePeriod")||u(e,"TimePeriod");if(n){return{begin:new Date(o(n,"beginPosition")||o(n,"BeginPosition")),end:new Date(o(n,"endPosition")||o(n,"EndPosition")),...x(o(n,"timeResolution")||o(n,"TimeResolution"))}}return null}function D(t){const n=u(t,"spatialDomain"),i=u(n,"Envelope")||u(n,"EnvelopeWithTimePeriod"),a=i.getAttribute("srsName").split(":"),l=a[a.length-1],r=s(i,"pos"),p=m(r[0]),d=m(r[1]),c=parseInt(l,10),f=isNaN(c)?null:{wkid:c},g=new e({xmin:p[0],ymin:p[1],xmax:d[0],ymax:d[1],spatialReference:f}),h=u(n,"RectifiedGrid"),b=o(h,"low").split(" "),x=o(h,"high").split(" "),D=parseInt(x[0],10)-parseInt(b[0],10)+1,w=parseInt(x[1],10)-parseInt(b[1],10)+1,y=m(n,"origin/pos"),S=s(n,"offsetVector"),L={envelope:g,columns:D,rows:w,offset:{x:parseFloat(o(S[0]).split(" ")[0]),y:parseFloat(o(S[1]).split(" ")[1])},origin:{x:y[0],y:y[1]}},I=u(t,"temporalDomain")||u(t,"TemporalDomain");return{spatialDomain:L,temporalDomain:I?v(I):null}}function w(e){const t={version:"1.0"};let n,s=[];for(let i=0;i<e.childNodes.length;i++){const r=e.childNodes[i];if(1===r.nodeType)if(a(r,"description"))t.description=o(r);else if(a(r,"name"))t.name=o(r);else if(a(r,"label"))t.label=o(r);else if(a(r,"supportedFormats"))t.supportedFormats=l(r,"formats");else if(a(r,"supportedCRSs"))t.supportedCRSs=p(r);else if(a(r,"supportedInterpolations"))t.supportedInterpolations=d(r,"1.0.0");else if(a(r,"lonLatEnvelope"))t.lonLatEnvelope=f(r);else if(a(r,"rangeSet")){const e=b(r);t.rangeSet=e.rangeSet,s=e.bandNames;const i=e.rangeSet[0].nullValues;i?.length&&(n=h(i))}else a(r,"domainSet")&&(t.domainSet=D(r))}const r=c(t.supportedInterpolations),{name:u,description:m,label:g,lonLatEnvelope:x,supportedFormats:v}=t,{spatialDomain:w}=t.domainSet,S={x:Math.abs(w.offset.x),y:Math.abs(w.offset.y)},L=y(t.domainSet),I=new i({width:w.columns,height:w.rows,pixelSize:S,extent:w.envelope,spatialReference:w.envelope.spatialReference,bandCount:s.length||1,noDataValue:n,multidimensionalInfo:L});return{id:u,title:t.name,description:m||g,lonLatEnvelope:x,rasterInfo:I,bandNames:s,supportedFormats:v,supportedInterpolations:r,coverageDescription:t,version:"1.0.0",useEPSGAxis:!1}}function y(e){if(!e.temporalDomain)return null;const{begin:t,end:n,values:i,units:s,resolution:a}=e.temporalDomain;return{variables:[{name:"default",description:"",dimensions:[{name:"StdTime",description:"",unit:"ISO8601",values:i?.map((e=>e.getTime())),hasRegularIntervals:!i,interval:a,intervalUnit:s,extent:[t.getTime(),n.getTime()]}]}]}}function S(e,t){const n=[],i=s(e,"Field");let a,r=[];for(let u=0;u<i.length;u++){const e=o(i[u],"Identifier"),m=o(i[u],"Description"),p=o(i[u],"Definition"),c=o(i[u],"Abstract"),f=o(i[u],"Title"),h=g(i[u],"NullValue"),b=d(i[u],"1.1.0"),x=[],v=s(i[u],"Axis");for(let n=0;n<v.length;n++){const e=v[n].getAttribute("identifier"),i=o(v[n],"UOM"),s=o(v[n],"DataType"),u=l(v[n],"Key");t&&!e.toLowerCase().includes("band")||(r=u,a=h),x.push({identifier:e,uom:i,dataType:s,values:u,bandNoDataValues:a})}n.push({identifier:e,description:m,definition:p,abstract:c,title:f,supportedInterpolations:b,axis:x,nullValues:h})}return{rangeSet:n,bandNames:r,bandNoDataValues:a}}function L(e,t){if(!t.temporalDomain)return null;const n=e.filter((e=>!e.identifier.toLowerCase().includes("field_1")&&!e.axis.some((e=>e.identifier.includes("band"))))),i=[];if(n.length&&n.forEach((e=>{const t=e.axis.map((e=>{const t=e.values.map((t=>{if("ISO8601"===e.uom){return(t=t.trim()).toLowerCase().includes("z")?new Date(t).getTime():new Date(t+"Z").getTime()}return parseFloat(t.trim())})),n=[Math.min.apply(null,t),Math.max.apply(null,t)];return{name:e.identifier.trim(),description:"",field:e.identifier.trim(),unit:e.uom?e.uom.trim():"",hasRegularIntervals:!1,values:t,extent:n}}));i.push({name:e.identifier.trim(),description:e.description?.trim()??"",unit:"",dimensions:t})})),t.temporalDomain){const{begin:e,end:n,values:s,units:a,resolution:o}=t.temporalDomain;i.some((e=>e.dimensions.some((e=>"stdtime"===e.name.toLowerCase()))))||i.forEach((t=>{t.dimensions.push({name:"StdTime",description:"",unit:"ISO8601",values:s?.map((e=>e.getTime())),hasRegularIntervals:!s,interval:o,intervalUnit:a,extent:[e.getTime(),n.getTime()]})}))}return i.length?{variables:i}:null}function I(t){const i=u(t,"SpatialDomain"),a=u(i,"GridCRS"),l=o(a,"GridBaseCRS"),r=o(a,"GridOrigin")?.split(" ").map((e=>parseFloat(e)))??[0,0],p=m(a,"GridOffsets"),d=s(i,"BoundingBox");let c,f,g,h;for(let n=0;n<d.length;n++){const t=d[n].getAttribute("crs")?.toLowerCase();if(null!=t)if(t.includes("imagecrs")){const e=m(d[n],"LowerCorner"),t=m(d[n],"UpperCorner");c=t[0]-e[0]+1,f=t[1]-e[1]+1}else if(t.indexOf("epsg")>0){const i=t.split(":");g=parseInt(i[i.length-1],10);const s=m(d[n],"LowerCorner"),a=m(d[n],"UpperCorner");h=new e({xmin:s[0],ymin:s[1],xmax:a[0],ymax:a[1],spatialReference:{wkid:g}})}}const b=c>f,x=h.xmax-h.xmin>h.ymax-h.ymin;let D=!1;n(g)&&(b===x?D=!1:(D=!0,h=new e({xmin:h.ymin,ymin:h.xmin,xmax:h.ymax,ymax:h.xmax,spatialReference:{wkid:g}})));const w={columns:c,rows:f,origin:{x:r[0],y:r[1]},offset:{x:p[0],y:p[p.length-1]},gridBaseCRS:l,envelope:h,useEPSGAxis:D},y=u(t,"temporalDomain")||u(t,"TemporalDomain");return{spatialDomain:w,temporalDomain:y?v(y):null}}function C(e,t){const n=[],s=[],a={supportedFormats:n,supportedCRSs:s,version:"1.1"};let l,u;for(let i=0;i<e.childNodes.length;i++){const t=e.childNodes[i];if(1!==t.nodeType)continue;const m=r(t).toLowerCase();switch(m){case"title":case"abstract":case"identifier":a[m]=o(t);break;case"supportedformat":{const e=o(t);n.includes(e)||n.push(e)}break;case"supportedcrs":{const e=o(t);s.includes(e)||s.push(e)}break;case"range":{const e=S(t,!!a.domain?.temporalDomain);a.range=e.rangeSet,l=e.bandNames;const{bandNoDataValues:n}=e;n?.length&&(u=h(n))}break;case"domain":a.domain=I(t)}}const m=c(a.range[0].supportedInterpolations),{identifier:p,abstract:d,title:f,domain:g,range:b}=a,x={x:Math.abs(g.spatialDomain.offset.x),y:Math.abs(g.spatialDomain.offset.y)},v=L(b,g);v&&(u=b[0].nullValues,1===u?.length&&(u=u[0]));const D=new i({width:g.spatialDomain.columns,height:g.spatialDomain.rows,pixelSize:x,extent:g.spatialDomain.envelope,spatialReference:g.spatialDomain.envelope.spatialReference,bandCount:l.length||1,noDataValue:u,multidimensionalInfo:v});return{id:p,title:a.title,description:d||f,lonLatEnvelope:null,bandNames:l,rasterInfo:D,supportedFormats:n,supportedInterpolations:m,coverageDescription:a,version:t,useEPSGAxis:g.spatialDomain.useEPSGAxis}}function R(t){const n=u(t,"Envelope")||u(t,"EnvelopeWithTimePeriod"),i=n.getAttribute("srsName"),s=i.slice(i.lastIndexOf("/")+1),l=n.getAttribute("axisLabels").split(" ").map((e=>e.trim())).filter((e=>""!==e.trim())),r=m(n,"lowerCorner"),p=m(n,"upperCorner"),d=!["y","lat","latitude","north","nor","n","b"].includes(l[0].toLowerCase());let c;const f=parseInt(s,10),g=isNaN(f)?null:{wkid:f};c=new e(d?{xmin:r[0],ymin:r[1],xmax:p[0],ymax:p[1],spatialReference:g}:{xmin:r[1],ymin:r[0],xmax:p[1],ymax:p[0],spatialReference:g});const h={mins:r,maxs:p},b=n.getAttribute("uomLabels").trim().split(" ");let x,v;if(a(n,"EnvelopeWithTimePeriod")){x=new Date(o(t,"beginPosition")||o(t,"BeginPosition")),v=new Date(o(t,"endPosition")||o(t,"EndPosition"));const e=b?.findIndex((e=>"oledatetime"===e?.toLowerCase()));e>-1&&(b[e]="ISO8601")}return{envelope:c,axisLabels:l,uomLabels:b.length?b:null,envelopeAllDims:h,beginPosition:x,endPosition:v,isEastFirst:d}}function T(e,t){const n=[],i=s(e,"DataRecord"),a=[];let l,r=[];for(let p=0;p<i.length;p++){const e=s(i[p],"field"),d=[];for(let n=0;n<e.length;n++){const i=e[n].getAttribute("name"),s=o(e[n],"description")||"",p=u(e[n],"uom")?.getAttribute("code")||"",c=m(e[n],"interval"),f=g(e[n],"nilValue")?.[0];t&&!i.toLowerCase().includes("band")||(a.push(i),c?.length&&(l=l||[],l.push({min:c[0],max:c[1],avg:-1,stddev:-1})),r.push(f)),d.push({name:i,description:s,uom:p,allowedValues:c,nilValue:f})}n.push(d)}return r.some((e=>null!=e))||(r=null),{rangeType:n,bandNames:a,bandStats:l,bandNoDataValues:r}}function N(e){let t=1,n="";const i=.01;return Math.abs(e-1/24)<1/24*i?n="Hours":Math.abs(e-1)<1*i?n="Days":e<1?(t=Math.round(24*e),n="Hours"):e>28-i&&e<31+i||Math.round(e/30)<12?n="Months":e>365-i&&e<366+i&&(n="Years"),{interval:t,intervalUnit:n}}function M(e,t,n){if(n.axisLabels.length<=2)return null;const i=[];for(let a=0;a<e.length;a++){const t=e[a];for(let e=0;e<t.length;e++)t[e].name.toLowerCase().includes("band")||i.push(t[e])}const s=[];if(i.length){const e=[];for(let i=2;i<n.axisLabels.length;i++){const s=(t.uomLabels&&t.uomLabels.length)>i?t.uomLabels[i]:"",a=n.axisLabels[i].toLowerCase().includes("time")||"iso8601"===s.toLowerCase()||"oledatetime"===s.toLowerCase();let o,l;if(a){const e=N(n.offset[i]);o=e.interval,l=e.intervalUnit}else o=n.offset[i],l=s;const r=[];a?(r.push((new Date).setTime(24*(t.envelopeAllDims.mins[i]-25569)*3600*1e3)),r.push((new Date).setTime(24*(t.envelopeAllDims.maxs[i]-25569)*3600*1e3))):(r.push(t.envelopeAllDims.mins[i]),r.push(t.envelopeAllDims.maxs[i])),e.push({name:n.axisLabels[i].trim(),description:n.axisLabels[i].trim(),unit:t.uomLabels&&t.uomLabels.length>i?t.uomLabels[i].trim():"",hasRegularIntervals:!0,extent:r,interval:o,intervalUnit:l})}if(i.forEach((t=>{const{allowedValues:n}=t,i=2===n?.length?[{min:n[0],max:n[1],avg:-1,stddev:-1}]:null;s.push({name:t.name.trim(),description:t.description?.trim()??"",unit:t.uom.trim(),statistics:i,dimensions:e})})),s.length)return{variables:s}}return null}function P(e,t){const n=u(e,"RectifiedGrid"),i=m(n,"low"),a=m(n,"high"),l=[];for(let s=0;s<i.length;s++)l.push(a[s]-i[s]+1);const r=o(n,"axisLabels").split(" "),p=m(n,"origin/pos"),d=s(n,"offsetVector"),c=[];for(let s=0;s<d.length;s++){const e=m(d[s]),t=e.findIndex((e=>0!==e));c[t]=e[t]}const f=["y","lat","latitude","north","nor","n","b"];let g=!1;if(t?.length&&r?.length){g=[...t].sort(((e,t)=>e<t?-1:1)).join(",")===[...r].sort(((e,t)=>e<t?-1:1)).join(",")}const h=g?r:t;let b,x,v;return f.includes(h[0].toLowerCase())?(b=l[1],x=l[0],v={y:Math.abs(c[0]),x:Math.abs(c[1])}):(b=l[0],x=l[1],v={x:Math.abs(c[0]),y:Math.abs(c[1])}),{columns:b,rows:x,origin:p,offset:c,resolution:v,gridSamples:l,axisLabels:r,hasSameAxisLabelsAsBoundedBy:g}}function E(e){const n=u(e,"EarthObservation");if(!n)return null;const i=u(n,"phenomenonTime"),s=i?v(i):null,a=u(n,"phenomenonTime"),l=a?v(a):null,r=o(n,"featureOfInterest/Footprint/multiExtentOf/MultiSurface/surfaceMembers/Polygon/exterior/LinearRing/posList");let m=null;if(r){const e=r.split(" ").map((e=>e.trim())).filter((e=>null!=e&&""!==e));if(e.length){const n=[];for(let t=0;t<e.length/2;t+=2)n.push(e[t],e[t+1]);m=new t({rings:[n],spatialReference:{wkid:4326}})}}return{observation:{phonomenonTime:s,resultTime:l,footprint:m,identifier:o(e,"metaDataProperty/EarthObservationMetaData/identifier"),acquisitionType:o(e,"metaDataProperty/EarthObservationMetaData/acquisitionType"),status:o(e,"metaDataProperty/EarthObservationMetaData/status")}}}function A(e){const t={version:"2.0"};let n,s,r=[];for(let i=0;i<e.childNodes.length;i++){const m=e.childNodes[i];if(1===m.nodeType)if(a(m,"coverageId"))t.coverageId=o(m);else if(a(m,"ServiceParameters"))t.serviceParameters={supportedFormats:l(m,"nativeFormat")};else if(a(m,"boundedBy"))t.boundedBy=R(m);else if(a(m,"rangeType")){const e=T(m,t.boundedBy?.axisLabels.length>2||t.domainSet?.axisLabels.length>2);t.rangeType=e.rangeType,r=e.bandNames,n=e.bandStats;const{bandNoDataValues:i}=e;i?.length&&(s=h(i))}else if(a(m,"domainSet"))t.domainSet=P(m,t.boundedBy?.axisLabels);else if(a(m,"metadata")){const e=u(m,"EOMetadata");t.eoMetadata=e?E(e):null}}const{coverageId:m,boundedBy:p,domainSet:d,rangeType:c,serviceParameters:f}=t,g=M(c,p,d);!n&&g&&(n=g?.variables[0].statistics),null!=g&&(s=c[0][0].nilValue);return{id:m,title:m,description:m,lonLatEnvelope:null,bandNames:r,rasterInfo:new i({width:d.columns,height:d.rows,pixelSize:d.resolution,extent:p.envelope,spatialReference:p.envelope.spatialReference,bandCount:r.length||1,statistics:n,noDataValue:s,multidimensionalInfo:g}),supportedFormats:f.supportedFormats,supportedInterpolations:null,coverageDescription:t,version:"2.0.1",useEPSGAxis:!1}}function V(e,t){let n=null;if("string"==typeof e){n=(new DOMParser).parseFromString(e,"text/xml")}else n=e;if("1.0.0"===t){return s(n,"CoverageOffering").map((e=>w(e)))}const i=s(n,"CoverageDescription");return"1.1.0"===t||"1.1.1"===t||"1.1.2"===t?i.map((e=>C(e,t))):i.map((e=>A(e)))}export{V as parseCoverages,c as standardizeInterpolations};
