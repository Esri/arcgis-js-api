/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../core/Error.js";import i from"../../../core/Logger.js";import{isSome as s,isNone as n,unwrap as o}from"../../../core/maybe.js";import{isAbortError as r}from"../../../core/promiseUtils.js";import{property as a}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as l}from"../../../core/accessorSupport/decorators/subclass.js";import{isAxesOrderReversedForWkid as c}from"../../ogc/crsUtils.js";import d from"../DimensionalDefinition.js";import p from"./BaseRaster.js";import{parse as h}from"./multipartParser.js";import{parseCapabilities as f}from"./wcsCapabilitiesParser.js";import{standardizeInterpolations as u,parseCoverages as g}from"./wcsCoverageParser.js";import{getFormat as m}from"../rasterFormats/RasterCodec.js";import{clip as v}from"../rasterFunctions/pixelUtils.js";import w from"../../../geometry/Extent.js";const y=["nearest neighbor","bilinear","bicubic"],x=["nearest","linear","cubic"],I=i.getLogger("esri.layers.support.rasterDatasets.WCSRaster"),C="response is not a supported multipart/related mediaType with inline tiff,  switching to compability mode",b="response is not a supported multipart mediaType with inline tiff",$="response is base64 encoded which may impact layer display performance",S="server returns an exception";let T=class extends p{constructor(){super(...arguments),this.datasetFormat="WCSServer"}async open(e){await this.init();const i=e?.signal,s=await this._getCapabilities(i);if(this.capabilities=s,!this.version){let e=s.capabilitiesVersion?.slice(0,3);"2.0"===e||"1.1"===e||"1.0"===e?this.version=s.capabilitiesVersion:(e=s.supportedVersions.find((e=>"2.0.1"===e))||s.supportedVersions.find((e=>"2.0"===e.slice(0,3)))||s.supportedVersions.find((e=>"1.1"===e.slice(0,3)))||s.supportedVersions.find((e=>"1.0"===e.slice(0,3)))||"1.0.0",this.version=e)}const n=s.coverages.filter((e=>null==e.coverageSubType||""===e.coverageSubType||e.coverageSubType?.toLowerCase().startsWith("rectifiedgrid")));null==this.coverageId&&(this.coverageId=n[0].id);const o=n.find((e=>e.id===this.coverageId));if(null==o)throw new t("wcsraster-open",`the coverageId ${this.coverageId} does not exist in capabilities`);const r=await this._describeCoverage(i);this.coverageInfo=r[0],"2.0"===this.version.slice(0,3)&&(this.coverageInfo.lonLatEnvelope=o.lonLatEnvelope,this.coverageInfo.supportedInterpolations=u(s.supportedInterpolations)),this.datasetName=this.coverageInfo.title;const{rasterInfo:a}=this.coverageInfo;if(this.createRemoteDatasetStorageInfo(a,512,512),this._set("rasterInfo",a),null==a.spatialReference)throw new t("wcsraster-open",`coverage without spatial referernce is not supported: ${this.coverageId}`);const{pixelType:l,bandCount:c}=await this._getPixelTypeAndBandCount(i);a.pixelType=l,1===a.bandCount&&c>1&&(a.bandCount=c),this.updateTileInfo()}async fetchRawTile(e,i,o,r={}){if(this.isBlockOutside(e,i,o))return null;const{nativePixelSize:a,spatialReference:l}=this.rasterInfo,c=2**e,d=a.x*c,p=a.y*c,{blockWidth:h,blockHeight:f}=this.getBlockWidthHeight(e),{origin:u}=this.rasterInfo.storageInfo.tileInfo,g=this.getTileExtent({x:d,y:p},i,o,u,l,[h,f]),m=this.rasterInfo.extent,w=g.xmax>m.xmax,y=g.ymin<m.ymin,x=w||y;let I=g,C=h,b=f;if(x&&(I=g.clone().intersection(m),s(I)&&(w&&(C=Math.floor((I.xmax-I.xmin)/d),I.xmax=I.xmin+d*C),y&&(b=Math.floor((I.ymax-I.ymin)/p),I.ymin=I.ymax-p*b))),n(I)||C<=1||b<=1)return null;const $=await this._getCoverage(I,C,b,c,r);if(!$)return null;const{coverageDescription:S}=this.coverageInfo;let{noDataValue:T,multidimensionalInfo:j}=this.rasterInfo;const{multidimensionalDefinition:_}=r;if(s(j)&&s(_)&&_.length){const e=_[0].variableName;if("2.0"===S.version){T=S.rangeType[0].find((t=>t.name===e))?.nilValue}else if("1.1"===S.version){T=S.range.find((t=>t.identifier===e))?.nullValues}}const L=await this.decodePixelBlock($,{width:C,height:b,planes:null,pixelType:null,noDataValue:Array.isArray(T)?T[0]:T});if(L&&(L.width!==C||L.height!==b))throw new t("wcsraster-fetch",`the reponse has unexpected dimension width: ${L.width}, height: {pixelBlock.height}`);return x?v(L,{x:0,y:0},{width:f,height:f}):L}async _getCapabilities(e){const i={service:"WCS",request:"GetCapabilities"};this.version&&(i.version=this.version,i.acceptVersions=this.version);try{const{data:t}=await this.request(this.url,{query:i,responseType:"xml",signal:e});return f(t)}catch(s){if(!r(s))throw new t("wcslayer:open","wcs capabilities is not valid or supported");throw s}}async _describeCoverage(e){const i={service:"WCS",request:"DescribeCoverage",version:this.version},s=this.version.slice(0,3);"1.0"===s?i.coverage=this.coverageId:"1.1"===s?i.identifiers=this.coverageId:"2.0"===s&&(i.coverageId=this.coverageId);try{const{data:t}=await this.request(this.url,{query:i,responseType:"xml",signal:e});return g(t,this.version)}catch(n){if(!r(n))throw new t("wcslayer:open","wcs coverage description is not valid or supported");throw n}}async _getPixelTypeAndBandCount(e){const{pixelSize:i,extent:n,multidimensionalInfo:r}=this.rasterInfo,a=n.center,l=new w({xmin:a.x-i.x,xmax:a.x+i.x,ymin:a.y-i.y,ymax:a.y+i.y,spatialReference:n.spatialReference});let c;if(s(r)){const e=r.variables[0];c=[],e.dimensions.forEach((t=>{c.push(new d({variableName:e.name,dimensionName:t.name,values:t.hasRegularIntervals?t.extent[0]:t.values[0],isSlice:!0}))}))}const{coverageDescription:p}=this.coverageInfo,h={interpolation:"nearest",multidimensionalDefinition:c,signal:o(e)},{version:f}=p,{ioConfig:u}=this,g="2.0"===f&&null==u.allowAnyMediaType||"1.1"===f&&null==u.use2GridOffsets;let m;try{m=await this._getCoverage(l,2,2,1,h,!0)}catch(y){if(!g)throw y;if("1.1"===f){if(!y.details?.isResolutionMismatch)throw y;u.use2GridOffsets=!0}}if(!m&&g&&("2.0"===f&&(u.allowAnyMediaType=!0),m=await this._getCoverage(l,2,2,1,h),m&&I.warn("wcsraster:getcoverage",C)),!m)throw new t("wcsraster-open","unable to determine pixel type");const v=await this.decodePixelBlock(m,{width:2,height:2,planes:null,pixelType:null});return{pixelType:v.pixelType,bandCount:v.getPlaneCount()}}async _getCoverage(e,i,s,n,o,r=!1){const{coverageDescription:a}=this.coverageInfo,{version:l}=a,c="2.0"===l?this._getCoverage201Parameters(e,i,s,n,o,a):"1.1"===l?this._getCoverage110Parameters(e,i,s,o,a):this._getCoverage100Parameters(e,i,s,o),d="2.0"===l?await this.request(this._constructWCS201Url(c),{signal:o.signal,responseType:"array-buffer"}):await this.request(this.url,{query:c,signal:o.signal,responseType:"array-buffer"});if("1.0"===l)return d.data;if("2.0"===l&&!1!==this.ioConfig.allowAnyMediaType){if("tiff"===m(d.data))return r&&(this.ioConfig.allowAnyMediaType=!0,I.warn("wcsraster:getcoverage",C)),d.data}const p=h(d);if(p.isMultipart&&p.data){const e=p.data.find((e=>e.contentType?.toLowerCase().includes("image")&&null!=e.contentData));return r&&"base64"===e.contentTransferEncoding&&I.warn("wcsraster:getcoverage",$),e?.contentData}const f=new Uint8Array(d.data,0,Math.min(d.data.byteLength,2e3)),u=String.fromCharCode.apply(null,f).toLowerCase().includes("exception"),g=u&&String.fromCharCode.apply(null,f).includes("A non-zero RESX/RESY or WIDTH/HEIGHT is required but neither was provided");if(u)throw new t("wcsraster:getcoverage",S,{isResolutionMismatch:g});throw new t("wcsraster:getcoverage",b)}_getInterpolationIndex(e){return this.coverageInfo.supportedInterpolations.includes(e)?"nearest"===e?0:"bilinear"===e?1:"cubic"===e?2:0:0}_getCoverage100Parameters(e,t,i,n){const o=`${e.xmin},${e.ymin},${e.xmax},${e.ymax}`,r=e.spatialReference.wkid,a=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().includes("tiff")))||"GEOTIFF",{bandIds:l,interpolation:c}=n,d=this._getInterpolationIndex(c),p=l?l.map((e=>this.coverageInfo.bandNames[e])):null,h=y[d],{multidimensionalDefinition:f}=n;let u;if(s(f)&&s(this.rasterInfo.multidimensionalInfo)){const e=f.find((e=>"StdTime"===e.dimensionName));if(e?.values?.length>0){let t=e.values;t[0]instanceof Array&&(t=t[0]),u=t.map((e=>this._convertToISOTime(e))).join(",")}}return{service:"WCS",request:"GetCoverage",version:this.version,coverage:this.coverageId,format:a,crs:`EPSG:${r}`,bbox:o,width:t,height:i,time:u,interpolation:h,band:p?.join(",")}}_getCoverage110Parameters(e,t,i,n,o){const{multidimensionalDefinition:r,bandIds:a,interpolation:l}=n,d=e.spatialReference.wkid,p=`urn:ogc:def:crs:EPSG::${d}`,h=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().includes("tiff")))||"image/tiff",f=this._getInterpolationIndex(l),u=x[f],g=null==l||0===this.coverageInfo.supportedInterpolations?.indexOf(l),m=o.domain.spatialDomain,v=m.origin.x<=m.envelope.xmin&&m.origin.y<=m.envelope.ymin,w=e.width/t,y=e.height/i*(v?1:-1),I=v?[e.xmin,e.ymin]:[e.xmin,e.ymax],C=m.useEPSGAxis&&c(d),b=C?`${I[1]},${I[0]}`:`${I[0]},${I[1]}`,$=this.ioConfig.use2GridOffsets,S=C?$?`${y},${w}`:`${y},0,0,${w}`:$?`${w},${y}`:`${w},0,0,${y}`,T=w/2,j=e.xmin+T,_=e.xmax-T,L=Math.abs(y)/2,D=e.ymin+L,R=e.ymax-L,E=C?`${D},${j},${R},${_},${p}`:`${j},${D},${_},${R},${p}`,P=o.range.find((e=>e.axis.some((e=>e.identifier.toLowerCase().includes("band")))));let A,G=P&&u&&a?g?`${P.identifier}[${P.axis[0].identifier}[${a.join(",")}]]`:`${P.identifier}:${u}[${P.axis[0].identifier}[${a.join(",")}]]`:null;if(s(r)&&r.length)for(let s=0;s<r.length;s++){let e=r[s].values;const t=r[s].dimensionName.toLowerCase(),i=r[s].variableName.toLowerCase();if(e.length>0)if(e[0]instanceof Array&&(e=e[0]),"stdtime"===t)A=e.map((e=>this._convertToISOTime(e))).join(",");else{const s=o.range.find((e=>e.identifier.toLowerCase()===i));if(s){const i=s.axis.find((e=>e.identifier.toLowerCase()===t));i&&(G=g?s.identifier+"["+i.identifier+"["+e.join(",")+"]]":s.identifier+":"+u+"["+i.identifier+"["+e.join(",")+"]]")}}}return{service:"WCS",request:"GetCoverage",version:this.version,identifier:this.coverageId,format:h,crs:`EPSG:${d}`,boundingbox:E,gridCS:"urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS",gridType:"urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs",gridOrigin:b,gridOffsets:S,gridBaseCRS:p,timeSequence:A,rangeSubset:G}}_convertToISOTime(e,t=!1){return(t?new Date(24*(e-25569)*60*60*1e3):new Date(e)).toISOString()}_getCoverage201Parameters(e,t,i,n,o,r){const{multidimensionalDefinition:a,interpolation:l}=o,c=this._getInterpolationIndex(l);let d=null;const{supportedInterpolations:p}=this.capabilities;if(p?.length)switch(c){case 0:d=p.find((e=>e.toLowerCase().includes("nearest")));break;case 1:d=p.find((e=>e.toLowerCase().includes("linear")));break;case 2:d=p.find((e=>e.toLowerCase().includes("cubic")||e.toLowerCase().includes("quadratic")))}const h=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().includes("tiff")))||"image/tiff",{bandNames:f}=this.coverageInfo,{boundedBy:u,domainSet:g,rangeType:m}=r,v=u.isEastFirst?0:1,w=1-v,{axisLabels:y}=u,x=y[v],I=y[w],C=`http://www.opengis.net/def/crs/EPSG/0/${e.spatialReference.wkid}`,b=C,$=[];$.push(`${x}(${e.xmin},${e.xmax})`),$.push(`${I}(${e.ymin},${e.ymax})`);const S=[];if(y.length>2)for(let s=2;s<y.length;s++){const e=g.origin[s];if(y[s].toLowerCase().includes("time")){let t=e.toString();u.uomLabels[s].toLowerCase().includes("ole")&&(S.push(y[s]),t=this._convertToISOTime(e,!0)),$.push(y[s]+",http://www.opengis.net("+t+")")}else $.push(y[s]+",http://www.opengis.net("+e+")")}let T=null;if(s(a)&&a.length){const e=[];m.forEach((t=>t.forEach((t=>e.push(t.name)))));const t=[];for(let i=0;i<a.length;i++){const s=y.find((e=>e===a[i].dimensionName)),n=e.find((e=>e===a[i].variableName));if(t.includes(n)||t.push(n),s){let e=a[i].values;if(e.length>0){Array.isArray(e[0])&&(e=e[0]);let t="";t=s.toLowerCase().includes("time")?e.map((e=>this._convertToISOTime(e))).join(","):e.join(",");const i=$.findIndex((e=>0===e.indexOf(s+",http://www.opengis.net")));-1===i&&$.push(s+",http://www.opengis.net("+t+")"),-1===i||$[i].includes("("+t+")")||$.splice(i,1,s+",http://www.opengis.net("+t+")")}}}t.length&&(T=t.join(","))}else if(f?.length>=2){T=(o.bandIds?o.bandIds.map((e=>f[e])):f).join(",")}const j=$.join("&subset="),_=!r.domainSet.hasSameAxisLabelsAsBoundedBy&&!1!==this.ioConfig.allowScaleFactor,L=_?null:`${x}(${t}),${I}(${i})`,D=_?1/n:null;return{service:"WCS",request:"GetCoverage",version:this.version,coverageId:this.coverageId,rangesubset:T,interpolation:d,scaleSize:L,scaleFactor:D,subset:j,format:h,mediaType:this.ioConfig.allowAnyMediaType?null:"multipart/related",outputcrs:C,subsettingcrs:b}}_constructWCS201Url(e){const t={...this.ioConfig.customFetchParameters,...e},i=[];Object.keys(t).forEach((e=>{const s=t[e];null!=s&&("subset"===e?s.split("&subset=").forEach((e=>{e&&i.push(`subset=${encodeURIComponent(e)}`)})):i.push(`${e}=${encodeURIComponent(s)}`))}));return`${encodeURI(this.url)}?${i.join("&")}`}};e([a({type:String,json:{write:!0}})],T.prototype,"datasetFormat",void 0),e([a()],T.prototype,"tileType",void 0),e([a({type:String,json:{write:!0}})],T.prototype,"version",void 0),e([a({type:String,json:{write:!0}})],T.prototype,"coverageId",void 0),T=e([l("esri.layers.support.rasterDatasets.WCSRaster")],T);const j=T;export{j as default};
