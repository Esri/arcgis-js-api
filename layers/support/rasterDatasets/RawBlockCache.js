/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../geometry","../../../core/maybe","./EphemeralBlockCache","../rasterFunctions/rasterProjectionHelper","../../../geometry/Point"],(function(e,t,n,o,l,r){"use strict";const c=new Map,i=new o;function u(e,t){return null==t?e:`${e}?sliceId=${t}`}function a(e,t){const n={extent:null,rasterInfo:t,cache:new Map},o=c.get(e);return o?(o.push(n),o.length-1):(c.set(e,[n]),0)}function s(e,t){const n=c.get(e);n&&(n[t]=null,n.some((e=>null!=e))||c.delete(e))}function f(e){c.delete(e)}function m(e,t,n){const o=c.get(e);if(!o)return null==t?i.decreaseRefCount(e,n):0;if(null==t||null==o[t])return i.decreaseRefCount(e,n);const l=o[t]?.cache,r=l?.get(n);if(l&&r){if(r.refCount--,0===r.refCount){l.delete(n);for(let e=0;e<o.length;e++)o[e]?.cache.delete(n);r.controller&&r.controller.abort()}return r.refCount}return 0}function x(e,t,n){const o=c.get(e);if(!o)return null==t?i.getBlock(e,n):null;if(null==t||null==o[t]){for(let e=0;e<o.length;e++){const t=o[e]?.cache.get(n);if(t)return t.refCount++,t.block}return i.getBlock(e,n)}const l=o[t]?.cache.get(n);if(l)return l.refCount++,l.block;for(let r=0;r<o.length;r++){if(r===t||!o[r])continue;const e=o[r]?.cache,l=e?.get(n);if(e&&l)return l.refCount++,e.set(n,l),l.block}return null}function d(e,t,n,o,l=null){const r=c.get(e);if(!r)return void(null==t&&i.putBlock(e,n,o,l));if(null==t||null==r[t])return void i.putBlock(e,n,o,l);const u={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:l};o.then((()=>u.isResolved=!0)).catch((()=>u.isRejected=!0)),r[t]?.cache.set(n,u)}function h(e,t,n){const o=c.get(e);o?null!=t&&null!=o[t]?o[t]?.cache.delete(n):i.deleteBlock(e,n):null==t&&i.deleteBlock(e,n)}function g(e,t){const n=c.get(e);return n?n[t]??null:null}function y(e,t,o,c,i,u,a=null){const s=g(e,t);if(!s)return;const f=s.extent,{cache:m,rasterInfo:x}=s;if(f&&f.xmin===o.xmin&&f.xmax===o.xmax&&f.ymin===o.ymin&&f.ymax===o.ymax)return;c=c??0;const d=o.clone().normalize(),{spatialReference:h,transform:y}=x,p=new Set;for(let g=0;g<d.length;g++){const e=d[g];if(e.xmax-e.xmin<=c||e.ymax-e.ymin<=c)continue;let t=l.projectExtent(e,h,a);n.isSome(y)&&(t=y.inverseTransform(t));const o=new r({x:c,y:c,spatialReference:e.spatialReference});if(null==i&&!(i=l.projectResolution(o,h,e,a)))return;const{pyramidLevel:s,pyramidResolution:f,excessiveReading:m}=l.snapPyramid(i,x,u||"closest");if(m)return;const{storageInfo:k}=x,{origin:R}=k,M={x:Math.max(0,Math.floor((t.xmin-R.x)/f.x)),y:Math.max(0,Math.floor((R.y-t.ymax)/f.y))},B=Math.ceil((t.xmax-t.xmin)/f.x-.1),C=Math.ceil((t.ymax-t.ymin)/f.y-.1),b=s>0?k.pyramidBlockWidth:k.blockWidth,v=s>0?k.pyramidBlockHeight:k.blockHeight,j=1,w=Math.max(0,Math.floor(M.x/b)-j),I=Math.max(0,Math.floor(M.y/v)-j),$=Math.floor((M.x+B-1)/b)+j,P=Math.floor((M.y+C-1)/v)+j;for(let n=I;n<=P;n++)for(let e=w;e<=$;e++)p.add(`${s}/${n}/${e}`)}m.forEach(((e,t)=>{if(!p.has(t)){const e=m.get(t);(null==e||e.isResolved||e.isRejected)&&m.delete(t)}})),s.extent={xmin:o.xmin,ymin:o.ymin,xmax:o.xmax,ymax:o.ymax}}e.decreaseRefCount=m,e.deleteBlock=h,e.deleteRaster=f,e.getBlock=x,e.getRasterId=u,e.putBlock=d,e.register=a,e.unregister=s,e.update=y,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
