/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["exports","../../../geometry","../../../core/maybe","./EphemeralBlockCache","../rasterFunctions/rasterProjectionHelper","../../../geometry/Point"],(function(e,t,n,o,r,l){"use strict";const c=new Map,a=new o;function i(e,t){return null==t?e:`${e}?sliceId=${t}`}function s(e,t){const n={extent:null,rasterInfo:t,cache:new Map};if(c.has(e)){const t=c.get(e);return t.push(n),t.length-1}return c.set(e,[n]),0}function u(e,t){if(c.has(e)){const n=c.get(e);n[t]=null,n.some((e=>null!=e))||c.delete(e)}}function f(e){c.delete(e)}function h(e,t,n){if(!c.has(e))return null==t?a.decreaseRefCount(e,n):0;const o=c.get(e);if(null==o[t])return a.decreaseRefCount(e,n);const r=o[t].cache;if(r.has(n)){const e=r.get(n);if(e.refCount--,0===e.refCount){r.delete(n);for(let e=0;e<o.length;e++)o[e]&&o[e].cache.has(n)&&o[e].cache.delete(n);e.controller&&e.controller.abort()}return e.refCount}return 0}function m(e,t,n){if(!c.has(e))return null==t?a.getBlock(e,n):null;const o=c.get(e);if(null==o[t]){for(let e=0;e<o.length;e++)if(o[e]&&o[e].cache.has(n)){const t=o[e].cache.get(n);return t.refCount++,t.block}return a.getBlock(e,n)}const r=o[t].cache;if(r.has(n)){const e=r.get(n);return e.refCount++,e.block}for(let l=0;l<o.length;l++)if(l!==t&&o[l]&&o[l]&&o[l].cache.has(n)){const e=o[l].cache.get(n);return e.refCount++,r.set(n,e),e.block}return null}function x(e,t,n,o,r=null){if(!c.has(e))return void(null==t&&a.putBlock(e,n,o,r));const l=c.get(e);if(null==l[t])return void a.putBlock(e,n,o,r);const i={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:r};o.then((()=>i.isResolved=!0)).catch((()=>i.isRejected=!0)),l[t].cache.set(n,i)}function d(e,t,n){if(!c.has(e))return void(null==t&&a.deleteBlock(e,n));const o=c.get(e);null!=o[t]?o[t].cache.delete(n):a.deleteBlock(e,n)}function g(e,t){if(!c.has(e))return null;const n=c.get(e);return null==n[t]?null:n[t]}function y(e,t,o,c,a,i,s=null){const u=g(e,t),f=u.extent,{cache:h,rasterInfo:m}=u;if(f&&f.xmin===o.xmin&&f.xmax===o.xmax&&f.ymin===o.ymin&&f.ymax===o.ymax)return;const x=o.clone().normalize(),{spatialReference:d,transform:y}=m,p=new Set;for(let g=0;g<x.length;g++){const e=x[g];if(e.xmax-e.xmin<=c||e.ymax-e.ymin<=c)continue;let t=r.projectExtent(e,d,s);n.isSome(y)&&(t=y.inverseTransform(t));const o=new l({x:c,y:c,spatialReference:e.spatialReference});if(null==a&&!(a=r.projectResolution(o,d,e,s)))return;const{pyramidLevel:u,pyramidResolution:f,excessiveReading:h}=r.snapPyramid(a,m,i||"closest");if(h)return;const{storageInfo:k}=m,{origin:R}=k,M={x:Math.max(0,Math.floor((t.xmin-R.x)/f.x)),y:Math.max(0,Math.floor((R.y-t.ymax)/f.y))},B=Math.ceil((t.xmax-t.xmin)/f.x-.1),C=Math.ceil((t.ymax-t.ymin)/f.y-.1),v=u>0?k.pyramidBlockWidth:k.blockWidth,b=u>0?k.pyramidBlockHeight:k.blockHeight,j=1,w=Math.max(0,Math.floor(M.x/v)-j),I=Math.max(0,Math.floor(M.y/b)-j),$=Math.floor((M.x+B-1)/v)+j,P=Math.floor((M.y+C-1)/b)+j;for(let n=I;n<=P;n++)for(let e=w;e<=$;e++)p.add(`${u}/${n}/${e}`)}h.forEach(((e,t)=>{if(!p.has(t)){const e=h.get(t);(null==e||e.isResolved||e.isRejected)&&h.delete(t)}})),u.extent={xmin:o.xmin,ymin:o.ymin,xmax:o.xmax,ymax:o.ymax}}e.decreaseRefCount=h,e.deleteBlock=d,e.deleteRaster=f,e.getBlock=m,e.getRasterId=i,e.putBlock=x,e.register=s,e.unregister=u,e.update=y,Object.defineProperty(e,"__esModule",{value:!0})}));
