/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../core/maybe","../../../geometry/Point","../../../geometry","./EphemeralBlockCache","../rasterFunctions/rasterProjectionHelper"],(function(e,t,n,o,r,l){"use strict";const c=new Map,a=new r;e.decreaseRefCount=function(e,t,n){if(!c.has(e))return null==t?a.decreaseRefCount(e,n):0;const o=c.get(e);if(null==o[t])return a.decreaseRefCount(e,n);const r=o[t].cache;if(r.has(n)){const e=r.get(n);if(e.refCount--,0===e.refCount){r.delete(n);for(let e=0;e<o.length;e++)o[e]&&o[e].cache.has(n)&&o[e].cache.delete(n);e.controller&&e.controller.abort()}return e.refCount}return 0},e.deleteBlock=function(e,t,n){if(!c.has(e))return void(null==t&&a.deleteBlock(e,n));const o=c.get(e);null!=o[t]?o[t].cache.delete(n):a.deleteBlock(e,n)},e.deleteRaster=function(e){c.delete(e)},e.getBlock=function(e,t,n){if(!c.has(e))return null==t?a.getBlock(e,n):null;const o=c.get(e);if(null==o[t]){for(let e=0;e<o.length;e++)if(o[e]&&o[e].cache.has(n)){const t=o[e].cache.get(n);return t.refCount++,t.block}return a.getBlock(e,n)}const r=o[t].cache;if(r.has(n)){const e=r.get(n);return e.refCount++,e.block}for(let e=0;e<o.length;e++)if(e!==t&&o[e]&&o[e]&&o[e].cache.has(n)){const t=o[e].cache.get(n);return t.refCount++,r.set(n,t),t.block}return null},e.getRasterId=function(e,t){return null==t?e:`${e}?sliceId=${t}`},e.putBlock=function(e,t,n,o,r=null){if(!c.has(e))return void(null==t&&a.putBlock(e,n,o,r));const l=c.get(e);if(null==l[t])return void a.putBlock(e,n,o,r);const i={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:r};o.then((()=>i.isResolved=!0)).catch((()=>i.isRejected=!0)),l[t].cache.set(n,i)},e.register=function(e,t){const n={extent:null,rasterInfo:t,cache:new Map};if(c.has(e)){const t=c.get(e);return t.push(n),t.length-1}return c.set(e,[n]),0},e.unregister=function(e,t){if(c.has(e)){c.get(e)[t]=null}},e.update=function(e,o,r,a,i,s,u=null){const f=function(e,t){if(!c.has(e))return null;const n=c.get(e);return null==n[t]?null:n[t]}(e,o),h=f.extent,{cache:m,rasterInfo:x}=f;if(h&&h.xmin===r.xmin&&h.xmax===r.xmax&&h.ymin===r.ymin&&h.ymax===r.ymax)return;const d=r.clone().normalize(),{spatialReference:g,transform:y}=x,p=new Set;for(let e=0;e<d.length;e++){const o=d[e];if(o.xmax-o.xmin<=a||o.ymax-o.ymin<=a)continue;let r=l.projectExtent(o,g,u);t.isSome(y)&&(r=y.inverseTransform(r));const c=new n({x:a,y:a,spatialReference:o.spatialReference});if(null===i&&!(i=l.projectResolution(c,g,o,u)))return;const{pyramidLevel:f,pyramidResolution:h,excessiveReading:m}=l.snapPyramid(i,x,s||"closest");if(m)return;const{storageInfo:k}=x,{origin:R}=k,M={x:Math.max(0,Math.floor((r.xmin-R.x)/h.x)),y:Math.max(0,Math.floor((R.y-r.ymax)/h.y))},B=Math.ceil((r.xmax-r.xmin)/h.x-.1),C=Math.ceil((r.ymax-r.ymin)/h.y-.1),v=f>0?k.pyramidBlockWidth:k.blockWidth,b=f>0?k.pyramidBlockHeight:k.blockHeight,j=1,w=Math.max(0,Math.floor(M.x/v)-j),I=Math.max(0,Math.floor(M.y/b)-j),$=Math.floor((M.x+B-1)/v)+j,P=Math.floor((M.y+C-1)/b)+j;for(let e=I;e<=P;e++)for(let t=w;t<=$;t++)p.add(`${f}/${e}/${t}`)}m.forEach(((e,t)=>{if(!p.has(t)){const e=m.get(t);(null==e||e.isResolved||e.isRejected)&&m.delete(t)}})),f.extent={xmin:r.xmin,ymin:r.ymin,xmax:r.xmax,ymax:r.ymax}},Object.defineProperty(e,"__esModule",{value:!0})}));
