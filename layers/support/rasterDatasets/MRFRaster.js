/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../core/has","../../../core/maybe","../../../core/Logger","../../../core/accessorSupport/ensureType","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/decorators/subclass","../../../core/Error","../../../core/urlUtils","../../../core/uuid","../../../portal/support/resourceExtension","../../../core/promiseUtils","../../../geometry/SpatialReference","../../../geometry/Point","../../../geometry/Extent","../../../geometry","../PixelBlock","../RasterInfo","../rasterFormats/utils","../rasterFunctions/pixelUtils","../RasterStorageInfo","./BaseRaster","./xmlUtilities","./pamParser"],(function(t,e,r,s,a,n,o,i,l,c,u,p,f,h,g,m,d,y,w,x,I,b,_,M,A){"use strict";const F=new Map;F.set("Int8","s8"),F.set("UInt8","u8"),F.set("Int16","s16"),F.set("UInt16","u16"),F.set("Int32","s32"),F.set("UInt32","u32"),F.set("Float32","f32"),F.set("Float64","f32"),F.set("Double64","f32");const R=new Map;R.set("lerc",".lrc"),R.set("none",".til"),R.set("deflate",".pzp"),R.set("jpeg",".jzp");let T=function(e){function r(){var t;return(t=e.apply(this,arguments)||this)._files=null,t._storageIndex=null,t.datasetFormat="MRF",t}t._inheritsLoose(r,e);var a=r.prototype;return a.open=async function(t){var e;await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const r=t?s.unwrap(t.signal):null,a=await this.request(this.url,{responseType:"xml",signal:r}),{rasterInfo:n,files:o}=this._parseHeader(a.data);if(-1===(null==(e=this.ioConfig.skipExtensions)?void 0:e.indexOf("aux.xml"))){const e=await this._fetchAuxiliaryData(t);var i;if(null!=e)n.statistics=null!=(i=e.statistics)?i:n.statistics,n.histograms=e.histograms,e.histograms&&!s.isSome(n.statistics)&&(n.statistics=I.estimateStatisticsFromHistograms(e.histograms))}this._set("rasterInfo",n),this._files=o;const l=await this.request(o.index,{responseType:"array-buffer",signal:r});this._storageIndex=this._parseIndex(l.data);let c,u,p=0,f=-1;const{blockWidth:h,blockHeight:g,compression:m}=this.rasterInfo.storageInfo,d=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:y,height:w,bandCount:x}=this.rasterInfo,b=[],_="none"===m?1:x;for(;p<this._storageIndex.length;)f++,c=Math.ceil(y/h/Math.pow(d,f)),u=Math.ceil(w/g/Math.pow(d,f)),p+=c*u*_*4,b.push({maxRow:u,maxCol:c,minCol:0,minRow:0});this.rasterInfo.storageInfo.blockBoundary=b,f>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=f),this.updateTileInfo()},a.fetchRawTile=async function(t,e,r,s={}){const{blockWidth:a,blockHeight:n,blockBoundary:o,compression:i}=this.rasterInfo.storageInfo,l=o[t];if(!l||l.maxRow<e||l.maxCol<r||l.minRow>e||l.minCol>r)return null;const{bandCount:c,pixelType:u}=this.rasterInfo,{ranges:p,actualTileWidth:h,actualTileHeight:g}=this._getTileLocation(t,e,r);if(!p||0===p.length)return null;if(0===p[0].from&&0===p[0].to){const t=new Uint8Array(a*n);return new y({width:a,height:n,pixels:null,mask:t,validPixelCount:0})}const{bandIds:m}=this.ioConfig,d="none"===i?1:c,w=[];let x=0;for(x=0;x<d;x++)(!m||m.indexOf[x]>-1)&&w.push(this.request(this._files.data,{range:{from:p[x].from,to:p[x].to},responseType:"array-buffer",signal:s.signal}));const I=await f.all(w),b=I.map((t=>t.data.byteLength)).reduce(((t,e)=>t+e)),_=new Uint8Array(b);let M=0;for(x=0;x<d;x++)_.set(new Uint8Array(I[x].data),M),M+=I[x].data.byteLength;const A="lerc"===this.rasterInfo.storageInfo.compression?"lerc":"bip",F=await this.decodePixelBlock(_.buffer,{width:a,height:n,format:A,pixelType:u});let R=0,T=0;if(h!==a||g!==n){let t=F.mask;if(t)for(x=0;x<n;x++)if(T=x*a,x<g)for(R=h;R<a;R++)t[T+R]=0;else for(R=0;R<a;R++)t[T+R]=0;else for(t=new Uint8Array(a*n),F.mask=t,x=0;x<g;x++)for(T=x*a,R=0;R<h;R++)t[T+R]=1}return F},a._parseIndex=function(t){if(t.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let e,r,s,a,n,o;if(x.isPlatformLittleEndian){for(r=new Uint8Array(t),a=new ArrayBuffer(t.byteLength),s=new Uint8Array(a),n=0;n<t.byteLength/4;n++)for(o=0;o<4;o++)s[4*n+o]=r[4*n+3-o];e=new Uint32Array(a)}else e=new Uint32Array(t);return e},a._getTileLocation=function(t,e,r){const{blockWidth:s,blockHeight:a,pyramidScalingFactor:n,compression:o}=this.rasterInfo.storageInfo,{width:i,height:l,bandCount:c}=this.rasterInfo,u="none"===o?1:c;let p,f,h,g=0,m=0;for(h=0;h<t;h++)m=Math.pow(n,h),p=Math.ceil(i/s/m),f=Math.ceil(l/a/m),g+=p*f;m=Math.pow(n,t),p=Math.ceil(i/s/m),f=Math.ceil(l/a/m),g+=e*p+r,g*=4*u;const d=this._storageIndex.subarray(g,g+4*u);let y=0,w=0;const x=[];for(let t=0;t<u;t++)y=d[4*t+0]*Math.pow(2,32)+d[4*t+1],w=y+d[4*t+2]*Math.pow(2,32)+d[4*t+3],x.push({from:y,to:w});return{ranges:x,actualTileWidth:r<p-1?s:Math.ceil(i/m)-s*(p-1),actualTileHeight:e<f-1?a:Math.ceil(l/m)-a*(f-1)}},a._parseHeader=function(t){const e=M.getElement(t,"MRF_META/Raster");if(!e)throw new l("mrf:open","not a valid MRF format");const r=M.getElement(e,"Size"),s=parseInt(r.getAttribute("x"),10),a=parseInt(r.getAttribute("y"),10),n=parseInt(r.getAttribute("c"),10),o=(M.getElementValue(e,"Compression")||"none").toLowerCase();if(!o||-1===["none","lerc"].indexOf(o))throw new l("mrf:open","currently does not support compression "+o);const i=M.getElementValue(e,"DataType")||"UInt8",c=F.get(i);if(null==c)throw new l("mrf:open","currently does not support pixel type "+i);const u=M.getElement(e,"PageSize"),p=parseInt(u.getAttribute("x"),10),f=parseInt(u.getAttribute("y"),10),d=M.getElement(e,"DataValues");let y,x;d&&(x=d.getAttribute("NoData"),null!=x&&(y=x.trim().split(" ").map((t=>parseFloat(t)))));if(M.getElement(t,"MRF_META/CachedSource"))throw new l("mrf:open","currently does not support MRF referencing other data files");const I=M.getElement(t,"MRF_META/GeoTags"),_=M.getElement(I,"BoundingBox");if(null==_)throw new l("mrf:open","missing node MRF_META/GeoTags/BoundingBox");const A=parseFloat(_.getAttribute("minx")),T=parseFloat(_.getAttribute("miny")),E=parseFloat(_.getAttribute("maxx")),k=parseFloat(_.getAttribute("maxy")),C=M.getElementValue(I,"Projection"),S=M.getElementValue(t,"datafile"),U=M.getElementValue(t,"IndexFile");let L;"LOCAL_CS[]"!==C&&(L=new h({wkt:C}));const v=new m(A,T,E,k);v.spatialReference=L;const B=M.getElement(t,"MRF_META/Rsets"),P=parseInt(B&&B.getAttribute("scale")||"2",10),H=new b({origin:new g({x:v.xmin,y:v.ymax,spatialReference:L}),blockWidth:p,blockHeight:f,pyramidBlockWidth:p,pyramidBlockHeight:f,compression:o,pyramidScalingFactor:P}),D=new g({x:(E-A)/s,y:(k-T)/a,spatialReference:L});return{rasterInfo:new w({width:s,height:a,extent:v,spatialReference:L,bandCount:n,pixelType:c,pixelSize:D,noDataValue:y,storageInfo:H}),files:{mrf:this.url,index:U||this.url.replace(".mrf",".idx"),data:S||this.url.replace(".mrf",R.get(o))}}},a._fetchAuxiliaryData=async function(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null==t?void 0:t.signal});return A.parsePAMInfo(e)}catch{return null}},r}(_);return e.__decorate([o.property()],T.prototype,"_files",void 0),e.__decorate([o.property()],T.prototype,"_storageIndex",void 0),e.__decorate([o.property({type:String,json:{write:!0}})],T.prototype,"datasetFormat",void 0),T=e.__decorate([i.subclass("esri.layers.support.rasterIO.MRFRaster")],T),T}));
