/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../core/has","../../../core/maybe","../../../core/Logger","../../../core/accessorSupport/ensureType","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/decorators/subclass","../../../core/Error","../../../core/urlUtils","../../../core/uuid","../../../portal/support/resourceExtension","../../../geometry/SpatialReference","../../../geometry/Point","../../../geometry/Extent","../../../geometry","../PixelBlock","../RasterInfo","../rasterFormats/utils","../rasterFunctions/pixelUtils","../RasterStorageInfo","./BaseRaster","./xmlUtilities","./pamParser"],(function(e,t,r,s,n,a,i,o,l,c,u,f,p,h,g,m,d,y,x,w,I,b,_,A){"use strict";const R=new Map;R.set("Int8","s8"),R.set("UInt8","u8"),R.set("Int16","s16"),R.set("UInt16","u16"),R.set("Int32","s32"),R.set("UInt32","u32"),R.set("Float32","f32"),R.set("Float64","f32"),R.set("Double64","f32");const F=new Map;F.set("lerc",".lrc"),F.set("none",".til"),F.set("deflate",".pzp"),F.set("jpeg",".jzp");let M=function(t){function r(){var e;return(e=t.apply(this,arguments)||this)._files=null,e._storageIndex=null,e.datasetFormat="MRF",e}e._inheritsLoose(r,t);var n=r.prototype;return n.open=async function(e){var t;await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const r=e?s.unwrap(e.signal):null,n=await this.request(this.url,{responseType:"xml",signal:r}),{rasterInfo:a,files:i}=this._parseHeader(n.data);if(-1===(null==(t=this.ioConfig.skipExtensions)?void 0:t.indexOf("aux.xml"))){const t=await this._fetchAuxiliaryData(e);var o;if(null!=t)a.statistics=null!=(o=t.statistics)?o:a.statistics,a.histograms=t.histograms,t.histograms&&!s.isSome(a.statistics)&&(a.statistics=w.estimateStatisticsFromHistograms(t.histograms))}this._set("rasterInfo",a),this._files=i;const l=await this.request(i.index,{responseType:"array-buffer",signal:r});this._storageIndex=this._parseIndex(l.data);let c,u,f=0,p=-1;const{blockWidth:h,blockHeight:g,compression:m}=this.rasterInfo.storageInfo,d=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:y,height:x,bandCount:I}=this.rasterInfo,b=[],_="none"===m?1:I;for(;f<this._storageIndex.length;)p++,c=Math.ceil(y/h/d**p),u=Math.ceil(x/g/d**p),f+=c*u*_*4,b.push({maxRow:u,maxCol:c,minCol:0,minRow:0});this.rasterInfo.storageInfo.blockBoundary=b,p>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=p),this.updateTileInfo()},n.fetchRawTile=async function(e,t,r,s={}){const{blockWidth:n,blockHeight:a,blockBoundary:i,compression:o}=this.rasterInfo.storageInfo,l=i[e];if(!l||l.maxRow<t||l.maxCol<r||l.minRow>t||l.minCol>r)return null;const{bandCount:c,pixelType:u}=this.rasterInfo,{ranges:f,actualTileWidth:p,actualTileHeight:h}=this._getTileLocation(e,t,r);if(!f||0===f.length)return null;if(0===f[0].from&&0===f[0].to){const e=new Uint8Array(n*a);return new d({width:n,height:a,pixels:null,mask:e,validPixelCount:0})}const{bandIds:g}=this.ioConfig,m="none"===o?1:c,y=[];let x=0;for(x=0;x<m;x++)(!g||g.indexOf[x]>-1)&&y.push(this.request(this._files.data,{range:{from:f[x].from,to:f[x].to},responseType:"array-buffer",signal:s.signal}));const w=await Promise.all(y),I=w.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),b=new Uint8Array(I);let _=0;for(x=0;x<m;x++)b.set(new Uint8Array(w[x].data),_),_+=w[x].data.byteLength;const A="lerc"===this.rasterInfo.storageInfo.compression?"lerc":"bip",R=await this.decodePixelBlock(b.buffer,{width:n,height:a,format:A,pixelType:u});let F=0,M=0;if(p!==n||h!==a){let e=R.mask;if(e)for(x=0;x<a;x++)if(M=x*n,x<h)for(F=p;F<n;F++)e[M+F]=0;else for(F=0;F<n;F++)e[M+F]=0;else for(e=new Uint8Array(n*a),R.mask=e,x=0;x<h;x++)for(M=x*n,F=0;F<p;F++)e[M+F]=1}return R},n._parseIndex=function(e){if(e.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let t,r,s,n,a,i;if(x.isPlatformLittleEndian){for(r=new Uint8Array(e),n=new ArrayBuffer(e.byteLength),s=new Uint8Array(n),a=0;a<e.byteLength/4;a++)for(i=0;i<4;i++)s[4*a+i]=r[4*a+3-i];t=new Uint32Array(n)}else t=new Uint32Array(e);return t},n._getTileLocation=function(e,t,r){const{blockWidth:s,blockHeight:n,pyramidScalingFactor:a,compression:i}=this.rasterInfo.storageInfo,{width:o,height:l,bandCount:c}=this.rasterInfo,u="none"===i?1:c;let f,p,h,g=0,m=0;for(h=0;h<e;h++)m=a**h,f=Math.ceil(o/s/m),p=Math.ceil(l/n/m),g+=f*p;m=a**e,f=Math.ceil(o/s/m),p=Math.ceil(l/n/m),g+=t*f+r,g*=4*u;const d=this._storageIndex.subarray(g,g+4*u);let y=0,x=0;const w=[];for(let I=0;I<u;I++)y=d[4*I+0]*2**32+d[4*I+1],x=y+d[4*I+2]*2**32+d[4*I+3],w.push({from:y,to:x});return{ranges:w,actualTileWidth:r<f-1?s:Math.ceil(o/m)-s*(f-1),actualTileHeight:t<p-1?n:Math.ceil(l/m)-n*(p-1)}},n._parseHeader=function(e){const t=_.getElement(e,"MRF_META/Raster");if(!t)throw new l("mrf:open","not a valid MRF format");const r=_.getElement(t,"Size"),s=parseInt(r.getAttribute("x"),10),n=parseInt(r.getAttribute("y"),10),a=parseInt(r.getAttribute("c"),10),i=(_.getElementValue(t,"Compression")||"none").toLowerCase();if(!i||-1===["none","lerc"].indexOf(i))throw new l("mrf:open","currently does not support compression "+i);const o=_.getElementValue(t,"DataType")||"UInt8",c=R.get(o);if(null==c)throw new l("mrf:open","currently does not support pixel type "+o);const u=_.getElement(t,"PageSize"),f=parseInt(u.getAttribute("x"),10),m=parseInt(u.getAttribute("y"),10),d=_.getElement(t,"DataValues");let x,w;d&&(w=d.getAttribute("NoData"),null!=w&&(x=w.trim().split(" ").map((e=>parseFloat(e)))));if(_.getElement(e,"MRF_META/CachedSource"))throw new l("mrf:open","currently does not support MRF referencing other data files");const b=_.getElement(e,"MRF_META/GeoTags"),M=_.getElement(b,"BoundingBox");if(null==M)throw new l("mrf:open","missing node MRF_META/GeoTags/BoundingBox");const T=parseFloat(M.getAttribute("minx")),E=parseFloat(M.getAttribute("miny")),k=parseFloat(M.getAttribute("maxx")),C=parseFloat(M.getAttribute("maxy")),S=_.getElementValue(b,"Projection")||"",L=_.getElementValue(e,"datafile"),U=_.getElementValue(e,"IndexFile");let v;if("LOCAL_CS[]"!==S)if(S.toLowerCase().startsWith("epsg:")){const e=Number(S.slice(5));isNaN(e)||0===e||(v=new p({wkid:e}))}else v=A.parseSpatialReference(S);const B=new g(T,E,k,C);B.spatialReference=v;const P=_.getElement(e,"MRF_META/Rsets"),H=parseInt(P&&P.getAttribute("scale")||"2",10),W=new I({origin:new h({x:B.xmin,y:B.ymax,spatialReference:v}),blockWidth:f,blockHeight:m,pyramidBlockWidth:f,pyramidBlockHeight:m,compression:i,pyramidScalingFactor:H}),D=new h({x:(k-T)/s,y:(C-E)/n,spatialReference:v});return{rasterInfo:new y({width:s,height:n,extent:B,spatialReference:v,bandCount:a,pixelType:c,pixelSize:D,noDataValue:x,storageInfo:W}),files:{mrf:this.url,index:U||this.url.replace(".mrf",".idx"),data:L||this.url.replace(".mrf",F.get(i))}}},n._fetchAuxiliaryData=async function(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null==e?void 0:e.signal});return A.parsePAMInfo(t)}catch{return null}},r}(b);return t.__decorate([i.property()],M.prototype,"_files",void 0),t.__decorate([i.property()],M.prototype,"_storageIndex",void 0),t.__decorate([i.property({type:String,json:{write:!0}})],M.prototype,"datasetFormat",void 0),M=t.__decorate([o.subclass("esri.layers.support.rasterIO.MRFRaster")],M),M}));
