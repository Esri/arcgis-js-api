/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import e from"../../../core/Error.js";import{unwrap as r,isNone as s,isSome as o}from"../../../core/maybe.js";import{property as i}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as a}from"../../../core/accessorSupport/decorators/subclass.js";import n from"../PixelBlock.js";import l from"../RasterInfo.js";import f from"../RasterStorageInfo.js";import c from"./BaseRaster.js";import{parseSpatialReference as m,parsePAMInfo as p}from"./pamParser.js";import{getElement as h,getElementValue as u}from"./xmlUtilities.js";import{isPlatformLittleEndian as g}from"../rasterFormats/utils.js";import{estimateStatisticsFromHistograms as d}from"../rasterFunctions/stretchUtils.js";import y from"../../../geometry/SpatialReference.js";import x from"../../../geometry/Extent.js";import w from"../../../geometry/Point.js";const I=new Map;I.set("Int8","s8"),I.set("UInt8","u8"),I.set("Int16","s16"),I.set("UInt16","u16"),I.set("Int32","s32"),I.set("UInt32","u32"),I.set("Float32","f32"),I.set("Float64","f32"),I.set("Double64","f32");const b=new Map;b.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),b.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),b.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),b.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let A=class extends c{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(t){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const e=t?r(t.signal):null,o=await this.request(this.url,{responseType:"xml",signal:e}),{rasterInfo:i,files:a}=this._parseHeader(o.data);if(-1===this.ioConfig.skipExtensions?.indexOf("aux.xml")){const e=await this._fetchAuxiliaryData(t);null!=e&&(i.statistics=e.statistics??i.statistics,i.histograms=e.histograms,e.histograms&&s(i.statistics)&&(i.statistics=d(e.histograms)))}this._set("rasterInfo",i),this._files=a;const n=await this.request(a.index,{responseType:"array-buffer",signal:e});this._storageIndex=this._parseIndex(n.data);const{blockWidth:l,blockHeight:f}=this.rasterInfo.storageInfo,c=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:m,height:p}=this.rasterInfo,h=[],u=this._getBandSegmentCount();let g=0,y=-1;for(;g<this._storageIndex.length;){y++;const t=Math.ceil(m/l/c**y)-1,e=Math.ceil(p/f/c**y)-1;g+=(t+1)*(e+1)*u*4,h.push({maxRow:e,maxCol:t,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=h,y>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=y),this.updateTileInfo()}async fetchRawTile(t,e,r,s={}){const{blockWidth:i,blockHeight:a,blockBoundary:l}=this.rasterInfo.storageInfo,f=l[t];if(!f||f.maxRow<e||f.maxCol<r||f.minRow>e||f.minCol>r)return null;const{bandCount:c,pixelType:m}=this.rasterInfo,{ranges:p,actualTileWidth:h,actualTileHeight:u}=this._getTileLocation(t,e,r);if(!p||0===p.length)return null;if(0===p[0].from&&0===p[0].to){const t=new Uint8Array(i*a);return new n({width:i,height:a,pixels:null,mask:t,validPixelCount:0})}const{bandIds:g}=this.ioConfig,d=this._getBandSegmentCount(),y=[];let x=0;for(x=0;x<d;x++)(!g||g.indexOf[x]>-1)&&y.push(this.request(this._files.data,{range:{from:p[x].from,to:p[x].to},responseType:"array-buffer",signal:s.signal}));const w=await Promise.all(y),I=w.map((t=>t.data.byteLength)).reduce(((t,e)=>t+e)),A=new Uint8Array(I);let F=0;for(x=0;x<d;x++)A.set(new Uint8Array(w[x].data),F),F+=w[x].data.byteLength;const _=b.get(this.rasterInfo.storageInfo.compression).decoderFormat,R=await this.decodePixelBlock(A.buffer,{width:i,height:a,format:_,planes:g?.length||c,pixelType:m});if(o(this.rasterInfo.noDataValue)&&"lerc"!==_&&!R.mask){const t=this.rasterInfo.noDataValue[0];if(null!=t){const e=R.width*R.height,r=new Uint8Array(e);if(Math.abs(t)>1e24)for(x=0;x<e;x++)Math.abs((R.pixels[0][x]-t)/t)>1e-6&&(r[x]=1);else for(x=0;x<e;x++)R.pixels[0][x]!==t&&(r[x]=1);R.mask=r}}let j=0,k=0;if(h!==i||u!==a){let t=R.mask;if(t)for(x=0;x<a;x++)if(k=x*i,x<u)for(j=h;j<i;j++)t[k+j]=0;else for(j=0;j<i;j++)t[k+j]=0;else for(t=new Uint8Array(i*a),R.mask=t,x=0;x<u;x++)for(k=x*i,j=0;j<h;j++)t[k+j]=1}return R}_parseIndex(t){if(t.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let e,r,s,o,i,a;if(g){for(r=new Uint8Array(t),o=new ArrayBuffer(t.byteLength),s=new Uint8Array(o),i=0;i<t.byteLength/4;i++)for(a=0;a<4;a++)s[4*i+a]=r[4*i+3-a];e=new Uint32Array(o)}else e=new Uint32Array(t);return e}_getBandSegmentCount(){return b.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(t,e,r){const{blockWidth:s,blockHeight:o,pyramidScalingFactor:i}=this.rasterInfo.storageInfo,{width:a,height:n}=this.rasterInfo,l=this._getBandSegmentCount();let f,c,m,p=0,h=0;for(m=0;m<t;m++)h=i**m,f=Math.ceil(a/s/h),c=Math.ceil(n/o/h),p+=f*c;h=i**t,f=Math.ceil(a/s/h),c=Math.ceil(n/o/h),p+=e*f+r,p*=4*l;const u=this._storageIndex.subarray(p,p+4*l);let g=0,d=0;const y=[];for(let x=0;x<l;x++)g=u[4*x+0]*2**32+u[4*x+1],d=g+u[4*x+2]*2**32+u[4*x+3],y.push({from:g,to:d});return{ranges:y,actualTileWidth:r<f-1?s:Math.ceil(a/h)-s*(f-1),actualTileHeight:e<c-1?o:Math.ceil(n/h)-o*(c-1)}}_parseHeader(t){const r=h(t,"MRF_META/Raster");if(!r)throw new e("mrf:open","not a valid MRF format");const s=h(r,"Size"),o=parseInt(s.getAttribute("x"),10),i=parseInt(s.getAttribute("y"),10),a=parseInt(s.getAttribute("c"),10),n=(u(r,"Compression")||"none").toLowerCase();if(!b.has(n))throw new e("mrf:open","currently does not support compression "+n);const c=u(r,"DataType")||"UInt8",p=I.get(c);if(null==p)throw new e("mrf:open","currently does not support pixel type "+c);const g=h(r,"PageSize"),d=parseInt(g.getAttribute("x"),10),A=parseInt(g.getAttribute("y"),10),F=h(r,"DataValues");let _,R;F&&(R=F.getAttribute("NoData"),null!=R&&(_=R.trim().split(" ").map((t=>parseFloat(t)))));if(h(t,"MRF_META/CachedSource"))throw new e("mrf:open","currently does not support MRF referencing other data files");const j=h(t,"MRF_META/GeoTags"),k=h(j,"BoundingBox");let M,S=!1;if(null!=k){const t=parseFloat(k.getAttribute("minx")),e=parseFloat(k.getAttribute("miny")),r=parseFloat(k.getAttribute("maxx")),s=parseFloat(k.getAttribute("maxy")),o=u(j,"Projection")||"";let i;if("LOCAL_CS[]"!==o)if(o.toLowerCase().startsWith("epsg:")){const t=Number(o.slice(5));isNaN(t)||0===t||(i=new y({wkid:t}))}else i=m(o);else S=!0,i=new y({wkid:3857});M=new x(t,e,r,s),M.spatialReference=i}else S=!0,M=new x({xmin:-.5,ymin:.5-i,xmax:o-.5,ymax:.5,spatialReference:new y({wkid:3857})});const T=h(t,"MRF_META/Rsets"),C=parseInt(T&&T.getAttribute("scale")||"2",10),U=M.spatialReference,B=new f({origin:new w({x:M.xmin,y:M.ymax,spatialReference:U}),blockWidth:d,blockHeight:A,pyramidBlockWidth:d,pyramidBlockHeight:A,compression:n,pyramidScalingFactor:C}),L=new w({x:M.width/o,y:M.height/i,spatialReference:U}),E=new l({width:o,height:i,extent:M,isPseudoSpatialReference:S,spatialReference:U,bandCount:a,pixelType:p,pixelSize:L,noDataValue:_,storageInfo:B}),P=u(t,"datafile"),O=u(t,"IndexFile");return{rasterInfo:E,files:{mrf:this.url,index:O||this.url.replace(".mrf",".idx"),data:P||this.url.replace(".mrf",b.get(n).blobExtension)}}}async _fetchAuxiliaryData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t?.signal});return p(e)}catch{return null}}};t([i()],A.prototype,"_files",void 0),t([i()],A.prototype,"_storageIndex",void 0),t([i({type:String,json:{write:!0}})],A.prototype,"datasetFormat",void 0),A=t([a("esri.layers.support.rasterIO.MRFRaster")],A);const F=A;export{F as default};
