/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../geometry","../../../request","../../../core/Error","../../../core/JSONSupport","../../../core/Logger","../../../core/maybe","../../../core/Promise","../../../core/promiseUtils","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/accessorSupport/decorators/subclass","../arcgisLayerUrl","../commonProperties","../DimensionalDefinition","../LOD","../RasterStorageInfo","../TileInfo","./multidimensionalUtils","./RawBlockCache","../rasterFormats/pixelRangeUtils","../rasterFormats/RasterCodec","../rasterFunctions/pixelUtils","../rasterFunctions/rasterProjectionHelper","../rasterFunctions/vectorFieldUtils","../../../geometry/Point","../../../geometry/Extent"],(function(e,t,i,n,o,r,s,a,l,c,u,f,h,m,p,d,x,y,g,I,R,S,k,v,T,w,_,b,B){"use strict";const P=8,W=256;let M=function(t){function i(){var e;return(e=t.apply(this,arguments)||this).rasterJobHandler=null,e.datasetName=null,e.datasetFormat=null,e.hasUniqueSourceStorageInfo=!0,e.rasterInfo=null,e.ioConfig={sampling:"closest"},e}e._inheritsLoose(i,t);var r=i.prototype;return r.init=function(){var t=e._asyncToGenerator((function*(){const e=w.load();this.addResolvingPromise(e),yield this.when()}));function i(){return t.apply(this,arguments)}return i}(),r.normalizeCtorArgs=function(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:I.create(),...e.ioConfig}}),e},r.open=function(){var t=e._asyncToGenerator((function*(e){throw new o("BaseRaster:open-not-implemented","open() is not implemented")}));function i(e){return t.apply(this,arguments)}return i}(),r.fetchTile=function(){var t=e._asyncToGenerator((function*(e,t,i,n={}){const o=n.tileInfo||this.rasterInfo.storageInfo.tileInfo,r=this.getTileExtentFromTileInfo(e,t,i,o);return this.fetchPixels(r,o.size[0],o.size[1],n)}));function i(e,i,n){return t.apply(this,arguments)}return i}(),r.identify=function(){var t=e._asyncToGenerator((function*(e,t={}){e=f.ensureClass(b,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:n}=t,{rasterInfo:o}=this,{hasMultidimensionalTranspose:r,multidimensionalInfo:s}=o;let{transposedVariableName:l}=t;const c=a.isSome(s)&&r&&(null!=n||R.isMultiSliceOrRangeDefinition(i));if(c&&!l){l=a.isSome(i)&&i.length>0?i[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:l}}t=this._getRequestOptionsWithSliceId(t);const{spatialReference:u,extent:h}=o,{datumTransformation:m}=t;let p=w.projectPoint(e,u,m);if(!h.intersects(p))return{location:p,value:null};if(a.isSome(o.transform)){const e=o.transform.inverseTransform(p);if(!o.nativeExtent.intersects(e))return{location:e,value:null};p=e}let d=0;const x=a.isSome(l)&&a.isSome(s)&&o.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(x)return e.identify(p,t);const{pixelSize:i}=o,n=3,r=i.x*n/2,s=i.y*n/2,l=new B({xmin:p.x-r,xmax:p.x+r,ymin:p.y-s,ymax:p.y+s,spatialReference:u}),c={interpolation:"nearest"},{pixelBlock:f}=yield e.fetchPixels(l,n,n,c),{pixelBlock:h}=yield this.fetchPixels(l,n,n,c);if(a.isNone(f))return{location:p,value:null};const m=Math.floor(n*n*.5),d=!f.mask||f.mask[m]?f.pixels.map((e=>e[m])):null;let y;return a.isSome(h)&&(y=!h.mask||h.mask[m]?h.pixels.map((e=>e[m])):void 0),{location:p,value:d,processedValue:y,pyramidLevel:0}}if(!x)if(t.srcResolution){d=w.snapPyramid(t.srcResolution,o,this.ioConfig.sampling).pyramidLevel}else if(d=yield this.computeBestPyramidLevelForLocation(e,t),null==d)return{location:p,value:null};const y=this.identifyPixelLocation(p,d,null,x);if(null===y)return{location:p,value:null};const{row:g,col:I,rowOffset:k,colOffset:v,blockWidth:T}=y,_=l??a.unwrap(t.sliceId),P=S.getRasterId(this.url,_),W=`${d}/${g}/${I}`;let M=S.getBlock(P,null,W);a.isNone(M)&&(M=this.fetchRawTile(d,g,I,t),S.putBlock(P,null,W,M));const C=yield M;if(a.isNone(C)||!C.pixels?.length)return{location:p,value:null};const E=k*T+v;return this._processIdentifyResult(C,{srcLocation:p,position:E,pyramidLevel:d,useTransposedTile:!!x,requestSomeSlices:c,identifyOptions:t})}));function i(e){return t.apply(this,arguments)}return i}(),r.fetchPixels=function(){var t=e._asyncToGenerator((function*(e,t,i,n={}){if(e=w.snapExtent(e),(n=this._getRequestOptionsWithSliceId(n)).requestRawData)return this._fetchPixels(e,t,i,n);const o=w.getWorldWidth(e.spatialReference),r=w.getWorldWrapCount(e);if(a.isNone(o)||0===r||1===r&&this._isGlobalWrappableSource)return this._fetchPixels(e,t,i,n);if(r>=3)return{extent:e,pixelBlock:null};const s=[],{xmin:l,xmax:c}=e,u=Math.round(o/(c-l)*t),f=u-Math.round((o/2-l)/(c-l)*t);let h=0;const m=[];for(let a=0;a<=r;a++){const p=new B({xmin:0===a?l:-o/2,xmax:a===r?c-o*a:o/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),d=0===a?u-f:a===r?t-h:u;h+=d,m.push(d);const x=n.disableWrapAround&&a>0?null:this._fetchPixels(p,d,i,n);s.push(x)}const p=(yield Promise.all(s)).map((e=>e?.pixelBlock));let d=null;const x={width:t,height:i};if(this.rasterJobHandler){d=(yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},n)).pixelBlock}else d=T.mosaic(p,x,{blockWidths:m});return{extent:e,srcExtent:w.projectExtent(e,this.rasterInfo.spatialReference,n.datumTransformation),pixelBlock:d}}));function i(e,i,n){return t.apply(this,arguments)}return i}(),r.fetchRawPixels=function(){var t=e._asyncToGenerator((function*(e,t,i,n={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const o=yield this._fetchRawTiles(e,t,i,n),{nativeExtent:r,nativePixelSize:s,storageInfo:l}=this.rasterInfo,c=2**e,u=s.x*c,f=s.y*c,h=new B({xmin:r.xmin+u*t.x,xmax:r.xmin+u*(t.x+i.width-1),ymin:r.ymax-f*(t.y+i.height-1),ymax:r.ymax-f*t.y,spatialReference:r.spatialReference});if(!o)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:m,mosaicSize:p}=o;if(1===m.length&&a.isSome(m[0])&&m[0].width===i.width&&m[0].height===i.height)return{extent:h,srcExtent:h,pixelBlock:o.pixelBlocks[0]};const d=e>0?l.pyramidBlockWidth:l.blockWidth,x=e>0?l.pyramidBlockHeight:l.blockHeight,y={x:t.x%d,y:t.y%x};let g;if(this.rasterJobHandler){g=(yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:p,destDimension:i,clipOffset:y,clipSize:i,coefs:null,sampleSpacing:null,interpolation:n.interpolation,alignmentInfo:null,blockWidths:null},n)).pixelBlock}else g=T.mosaic(m,p,{clipOffset:y,clipSize:i});return{extent:h,srcExtent:h,pixelBlock:g}}));function i(e,i,n){return t.apply(this,arguments)}return i}(),r.fetchRawTile=function(e,t,i,n){throw new o("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")},r.computeExtent=function(e){return w.projectExtent(this.rasterInfo.extent,e)},r.decodePixelBlock=function(e,t){return!this.rasterJobHandler||t.useCanvas?v.decode(e,t):this.rasterJobHandler.decode({data:e,options:t})},r.request=function(){var t=e._asyncToGenerator((function*(e,t,i=0){const{customFetchParameters:o}=this.ioConfig,{range:r,query:s,headers:a}=t;i=i??t.retryCount??this.ioConfig.retryCount;const l=r?{Range:`bytes=${r.from}-${r.to}`}:null;try{return yield n(e,{...t,query:{...s,...o},headers:{...a,...l}})}catch(c){if(i>0)return i--,this.request(e,t,i);throw c}}));function i(e,i){return t.apply(this,arguments)}return i}(),r.getSliceIndex=function(e){const{multidimensionalInfo:t}=this.rasterInfo;return a.isNone(t)||a.isNone(e)||0===e.length?null:R.getSliceIndex(e,t)},r.getTileExtentFromTileInfo=function(e,t,i,n){const o=a.unwrapOrThrow(n.lodAt(e));return this.getTileExtent({x:o.resolution,y:o.resolution},t,i,n.origin,n.spatialReference,n.size)},r.updateTileInfo=function(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:n}=this.rasterInfo;if(!e.tileInfo){const o=[],r=e.maximumPyramidLevel||0;let s=Math.max(n.x,n.y),a=1/.0254*96*s;for(let e=0;e<=r;e++)o.push(new y({level:r-e,resolution:s,scale:a})),s*=2,a*=2;const l=new b({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new I({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:o}),e.isVirtualTileInfo=!0}},r.createRemoteDatasetStorageInfo=function(e,t=512,i=512,n){const{width:o,height:r,nativeExtent:s,pixelSize:a,spatialReference:l}=e,c=new b({x:s.xmin,y:s.ymax,spatialReference:l});null==n&&(n=Math.max(0,Math.round(Math.log(Math.max(o,r))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[a],n);e.storageInfo=new g({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:u})},r.computeBestPyramidLevelForLocation=function(){var t=e._asyncToGenerator((function*(e,t={}){return 0}));function i(e){return t.apply(this,arguments)}return i}(),r.computeBlockBoundary=function(e,t,i,n,o,r=0,s=2){if(1===o.length&&r>0){o=[...o];let{x:e,y:t}=o[0];for(let i=0;i<r;i++)e*=s,t*=s,o.push({x:e,y:t})}const a=[],{x:l,y:c}=n;for(let u=0;u<o.length;u++){const{x:n,y:r}=o[u];a.push({minCol:Math.floor((e.xmin-l+.1*n)/t/n),maxCol:Math.floor((e.xmax-l-.1*n)/t/n),minRow:Math.floor((c-e.ymax+.1*r)/i/r),maxRow:Math.floor((c-e.ymin-.1*r)/i/r)})}return a},r.getPyramidPixelSize=function(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:n}=this.rasterInfo.storageInfo;if(0===e)return t;if(a.isSome(i)&&i.length)return i[e-1];const o=n**e;return{x:t.x*o,y:t.y*o}},r.identifyPixelLocation=function(e,t,i,n){const{spatialReference:o,nativeExtent:r,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:l,origin:c,transposeInfo:u}=s,f=n&&a.isSome(u)?u.tileSize[0]:s.blockWidth,h=n&&a.isSome(u)?u.tileSize[1]:s.blockHeight,m=w.projectPoint(e,o,i);if(!r.intersects(m))return null;if(t<0||t>l)return null;const p=this.getPyramidPixelSize(t),{x:d,y:x}=p,y=(c.y-m.y)/x/h,g=(m.x-c.x)/d/f,I=Math.min(h-1,Math.floor((y-Math.floor(y))*h)),R=Math.min(f-1,Math.floor((g-Math.floor(g))*f));return{pyramidLevel:t,row:Math.floor(y),col:Math.floor(g),rowOffset:I,colOffset:R,blockWidth:f,srcLocation:m}},r.getTileExtent=function(e,t,i,n,o,r){const[s,a]=r,l=n.x+i*s*e.x,c=l+s*e.x,u=n.y-t*a*e.y,f=u-a*e.y;return new B({xmin:l,xmax:c,ymin:f,ymax:u,spatialReference:o})},r.getBlockWidthHeight=function(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}},r.isBlockOutside=function(e,t,i){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<t||n.maxCol<i||n.minRow>t||n.minCol>i},r._fetchPixels=function(){var t=e._asyncToGenerator((function*(e,t,i,n={}){let o=w.getWorldWrapCount(e);if(o>=2)return{extent:e,pixelBlock:null};const r=this._getSourceDataInfo(e,t,i,n),{pyramidLevel:s,pyramidResolution:l,srcResolution:c,srcExtent:u,srcWidth:f,srcHeight:h}=r;if(0===f||0===h)return{extent:e,srcExtent:u,pixelBlock:null};const m=a.unwrap(this.rasterInfo.transform),p="gcs-shift"===m?.type,d=a.isSome(w.getWorldWidth(e.spatialReference));!p&&d||(o=w.getWorldWrapCount(r.srcExtent,p));const x=this.rasterInfo.storageInfo,y={x:Math.floor((u.xmin-x.origin.x)/l.x+.1),y:Math.floor((x.origin.y-u.ymax)/l.y+.1)},g=yield this._fetchRawTiles(s,y,{width:f,height:h,wrapCount:o},n);if(!g)return{extent:e,srcExtent:u,pixelBlock:null};const I=s>0?x.pyramidBlockWidth:x.blockWidth,R=s>0?x.pyramidBlockHeight:x.blockHeight,S=I===f&&R===h&&y.x%I==0&&y.y%R==0,k=new b({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),v=!e.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:B}=n;if(!v&&S&&1===g.pixelBlocks.length&&I===t&&R===i&&c.x===k.x&&c.y===k.y)return{extent:e,srcExtent:u,pixelBlock:g.pixelBlocks[0]};const P=d&&a.isSome(w.getWorldWidth(u.spatialReference)),W=n.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");W&&!this.rasterJobHandler&&(yield w.load());const M=this.rasterJobHandler?yield this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:g.extent,pixelSize:k.toJSON(),datumTransformation:B,rasterTransform:m,hasWrapAround:o>0||P,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:W},n):w.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:g.extent,pixelSize:k,datumTransformation:B,rasterTransform:m,hasWrapAround:o>0||P,isAdaptive:!1,includeGCSGrid:W});let C;const E=!n.requestRawData,L={rows:M.spacing[0],cols:M.spacing[1]},H=a.unwrap(this._getRasterTileAlignmentInfo(s,g.extent.xmin)),{pixelBlocks:D,mosaicSize:z,isPartiallyFilled:A}=g;let G=null;if(this.rasterJobHandler){const e=yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:D,srcMosaicSize:z,destDimension:E?{width:t,height:i}:null,coefs:E?M.coefficients:null,sampleSpacing:E?L:null,projectDirections:W,gcsGrid:W?M.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:n.interpolation,alignmentInfo:H,blockWidths:null},n);({pixelBlock:C,localNorthDirections:G}=e)}else{const e=T.mosaic(D,z,{alignmentInfo:H});C=E?T.approximateTransform(e,{width:t,height:i},M.coefficients,L,n.interpolation):e,W&&M.gcsGrid&&(G=T.getLocalArithmeticNorthRotations({width:t,height:i},M.gcsGrid),C=_.convertToLocalDirections(C,this.rasterInfo.dataType,G))}return n.requestRawData||W?{srcExtent:u,pixelBlock:C,transformGrid:M,localNorthDirections:G,extent:e,isPartiallyFilled:A}:{srcExtent:u,extent:e,pixelBlock:C}}));function i(e,i,n){return t.apply(this,arguments)}return i}(),r._fetchRawTiles=function(){var t=e._asyncToGenerator((function*(e,t,i,n){const{origin:o,blockBoundary:r}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:c,y:u}=t,{width:f,height:h,wrapCount:m}=i;const p=this._getRasterTileAlignmentInfo(e,0);n.buffer&&(c-=n.buffer.cols,u-=n.buffer.rows,f+=2*n.buffer.cols,h+=2*n.buffer.rows);let d=0,x=0,y=0;if(m&&a.isSome(p)){({worldColumnCountFromOrigin:x,originColumnOffset:y,rightPadding:d}=p);x*p.blockWidth-d>=c+f&&(d=0)}const g=Math.floor(c/s),I=Math.floor(u/l),R=Math.floor((c+f+d-1)/s),S=Math.floor((u+h+d-1)/l),k=r[e];if(!k)return null;const{minRow:v,minCol:T,maxCol:w,maxRow:_}=k;if(0===m&&(S<v||R<T||I>_||g>w))return null;const b=new Array;let P=!1;const W=null==this.ioConfig.allowPartialFill?n.allowPartialFill:this.ioConfig.allowPartialFill;for(let B=I;B<=S;B++)for(let t=g;t<=R;t++){let i=t;if(!n.disableWrapAround&&m&&a.isSome(p)&&x<=t&&(i=t-x-y),B>=v&&i>=T&&_>=B&&w>=i){const t=this._fetchRawTile(e,B,i,n);W?b.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{P=!0,e(null)}))}))):b.push(t)}else b.push(Promise.resolve(null))}if(0===b.length)return null;const M=yield Promise.all(b),C={height:(S-I+1)*l,width:(R-g+1)*s},{spatialReference:E}=this.rasterInfo,L=this.getPyramidPixelSize(e),{x:H,y:D}=L;return{extent:new B({xmin:o.x+g*s*H,xmax:o.x+(R+1)*s*H,ymin:o.y-(S+1)*l*D,ymax:o.y-I*l*D,spatialReference:E}),pixelBlocks:M,mosaicSize:C,isPartiallyFilled:P}}));function i(e,i,n,o){return t.apply(this,arguments)}return i}(),r._fetchRawTile=function(e,t,i,n){const o=this.rasterInfo.storageInfo.blockBoundary[e];if(!o)return Promise.resolve(null);const{minRow:r,minCol:s,maxCol:l,maxRow:u}=o;if(t<r||i<s||t>u||i>l)return Promise.resolve(null);const f=S.getRasterId(this.url,n.sliceId),h=`${e}/${t}/${i}`;let m=S.getBlock(f,n.registryId,h);if(a.isNone(m)){const o=new AbortController;m=this.fetchRawTile(e,t,i,{...n,signal:o.signal}),S.putBlock(f,n.registryId,h,m,o),m.catch((()=>S.deleteBlock(f,n.registryId,h)))}return n.signal&&c.onAbort(n,(()=>{S.decreaseRefCount(f,n.registryId,h)})),m},r._computeMagDirValues=function(e){const{bandCount:t,dataType:i}=this.rasterInfo;if(!(2===t&&"vector-magdir"===i||"vector-uv"===i)||2!==e?.length||!e[0]?.length)return null;const n=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[o,r]=e,s=[],a=[];for(let l=0;l<n;l++){const[e,t]=_.uvComponentToVector([o[l],r[l]]);s.push(e),a.push(t)}return[s,a]},r._getRasterTileAlignmentInfo=function(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=w.getRasterDatasetAlignmentInfo(this.rasterInfo)),a.isNone(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}},r._getSourceDataInfo=function(e,t,i,n={}){const o={datumTransformation:n.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};n.srcResolution&&(o.srcResolution=n.srcResolution,this._updateSourceDataInfo(e,o));const r=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:a,pyramidLevel:l}=o,c=s/t,u=a/i,f=l<r&&c*u>=16,h=l===r&&this._requireTooManySrcTiles(s,a,t,i);if(f||h||(0===s||0===a)){const s=new b({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let a=w.projectResolution(s,this.rasterInfo.spatialReference,e,o.datumTransformation);const h=!a||n.srcResolution&&a.x+a.y<n.srcResolution.x+n.srcResolution.y;if(f&&n.srcResolution&&h){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(r-l+3>=e){const t=2**e;a={x:n.srcResolution.x*t,y:n.srcResolution.y*t}}}a&&(o.srcResolution=a,this._updateSourceDataInfo(e,o))}return this._requireTooManySrcTiles(o.srcWidth,o.srcHeight,t,i)&&(o.srcWidth=0,o.srcHeight=0),o},r._requireTooManySrcTiles=function(e,t,i,n){const{tileInfo:o}=this.rasterInfo.storageInfo;return Math.ceil(e/o.size[0])*Math.ceil(t/o.size[1])>=W||e/i>P||t/n>P},r._updateSourceDataInfo=function(e,t){t.srcWidth=0,t.srcHeight=0;const i=this.rasterInfo.spatialReference,{srcResolution:n,datumTransformation:o}=t,{pyramidLevel:r,pyramidResolution:s,excessiveReading:l}=w.snapPyramid(n,this.rasterInfo,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||w.projectExtent(e,i,o);if(null==c)return;const u=a.unwrap(this.rasterInfo.transform);u&&(c=u.inverseTransform(c)),t.srcExtent=c;const f=Math.ceil((c.xmax-c.xmin)/s.x-.1),h=Math.ceil((c.ymax-c.ymin)/s.y-.1);t.pyramidLevel=r,t.pyramidResolution=s,t.srcWidth=f,t.srcHeight=h},r._getRequestOptionsWithSliceId=function(e){return a.isSome(this.rasterInfo.multidimensionalInfo)&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e},r._processIdentifyResult=function(e,t){const{srcLocation:i,position:n,pyramidLevel:o,useTransposedTile:r}=t,s=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[n]))return{location:i,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(a.isNone(l)||!r){const t=e.pixels.map((e=>e[n])),r={location:i,value:t,pyramidLevel:o},s=this._computeMagDirValues(t.map((e=>[e])));return s?.length&&(r.magdirValue=s.map((e=>e[0]))),r}let c=e.pixels.map((e=>e.slice(n*s,n*s+s))),u=this._computeMagDirValues(c);const{requestSomeSlices:f,identifyOptions:h}=t;let m=R.createSlices(l,h.transposedVariableName);if(f){const e=R.getSliceIds(m,a.unwrap(h.multidimensionalDefinition),a.unwrap(h.timeExtent));c=c.map((t=>e.map((e=>t[e])))),u=u?.map((t=>e.map((e=>t[e])))),m=e.map((e=>m[e]))}const p=e.noDataValues||this.rasterInfo.noDataValue,d={pixels:c,pixelType:e.pixelType};let y;a.isSome(p)&&(k.convertNoDataToMask(d,p),y=d.mask);return{location:i,value:null,dataSeries:m.map(((e,t)=>{const i={value:0===y?.[t]?null:c.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new x({...e,isSlice:!0})))};return u?.length&&(i.magdirValue=[u[0][t],u[1][t]]),i})),pyramidLevel:o}},e._createClass(i,[{key:"_isGlobalWrappableSource",get:function(){const{rasterInfo:e}=this,t=w.getWorldWidth(e.spatialReference);return a.isSome(t)&&e.extent.width>=t/2}},{key:"url",set:function(e){this._set("url",p.sanitizeUrl(e,s.getLogger(this.declaredClass)))}}]),i}(l.EsriPromiseMixin(r.JSONSupport));t.__decorate([u.property()],M.prototype,"_rasterTileAlighmentInfo",void 0),t.__decorate([u.property({readOnly:!0})],M.prototype,"_isGlobalWrappableSource",null),t.__decorate([u.property(d.url)],M.prototype,"url",null),t.__decorate([u.property({type:String,json:{write:!0}})],M.prototype,"datasetName",void 0),t.__decorate([u.property({type:String,json:{write:!0}})],M.prototype,"datasetFormat",void 0),t.__decorate([u.property()],M.prototype,"hasUniqueSourceStorageInfo",void 0),t.__decorate([u.property()],M.prototype,"rasterInfo",void 0),t.__decorate([u.property()],M.prototype,"ioConfig",void 0),t.__decorate([u.property()],M.prototype,"sourceJSON",void 0),M=t.__decorate([m.subclass("esri.layers.support.rasterDatasets.BaseRaster")],M);return M}));
