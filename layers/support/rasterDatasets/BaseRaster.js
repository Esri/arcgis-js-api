/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../core/has","../../../core/maybe","../../../core/Logger","../../../core/accessorSupport/ensureType","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/decorators/subclass","../../../core/Error","../../../core/urlUtils","../../../core/uuid","../../../portal/support/resourceExtension","../../../core/promiseUtils","../../../core/JSONSupport","../../../geometry/Point","../../../geometry/Extent","../../../geometry","../../../request","../../../core/Promise","../arcgisLayerUrl","../commonProperties","../TileInfo","../rasterFormats/RasterCodec","../rasterFunctions/pixelUtils","../RasterStorageInfo","../rasterFunctions/rasterProjectionHelper","./RawBlockCache"],(function(e,t,o,n,r,i,a,s,l,c,u,f,h,m,d,p,x,y,g,w,I,k,v,R,b,M,C){"use strict";let B=function(t){function o(){var e;return(e=t.apply(this,arguments)||this).rasterJobHandler=null,e.datasetName=null,e.datasetFormat=null,e.rasterInfo=null,e.ioConfig={sampling:"closest"},e}e._inheritsLoose(o,t);var i=o.prototype;return i.init=async function(){const e=M.load();this.addResolvingPromise(e),await this.when()},i.normalizeCtorArgs=function(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:k.create(),...e.ioConfig}}),e},i.open=async function(e){throw new l("BaseRaster:open-not-implemented","open() is not implemented")},i.fetchTile=async function(e,t,o,r={}){var i;const{tileInfo:a}=r,s=a.lodAt(e),l=this.getTileExtent({x:s.resolution,y:s.resolution},t,o,a.origin,a.spatialReference,a.size);return null!=(i=r.multidimensionalDefinition)&&i.length&&n.isSome(this.rasterInfo.multidimensionalInfo)&&null==r.sliceId&&(r={...r,sliceId:this.getSliceIndex(r.multidimensionalDefinition)||0}),this.fetchPixels(l,a.size[0],a.size[1],r)},i.identify=async function(e,t={}){const{spatialReference:o,extent:r}=this.rasterInfo,{datumTransformation:i}=t;let a=M.projectPoint(e,o,i);if(!r.intersects(a))return{location:a,value:null};if(n.isSome(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(a);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};a=e}let s=0;if(t.srcResolution){s=M.snapPyramid(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(s=await this.computeBestPyramidLevelForLocation(e,t),null==s)return{location:a,value:null};const l=this.identifyPixelLocation(a,s,null);if(null===l)return{location:a,value:null};const{row:c,col:u,rowOffset:f,colOffset:h}=l,m=C.getRasterId(this.url,t.sliceId),d=`${s}/${c}/${u}`;let p=C.getBlock(m,null,d);n.isSome(p)||(p=this.fetchRawTile(s,c,u,t),C.putBlock(m,null,d,p));const x=await p;if(!(x&&x.pixels&&x.pixels.length>0))return{location:a,value:null};const y=f*this.rasterInfo.storageInfo.blockHeight+h;return{location:a,value:!x.mask||x.mask[y]?x.pixels.map((e=>e[y])):null,pyramidLevel:s}},i.fetchPixels=async function(e,t,o,r={}){const i=e.clone().normalize();e=i[0];const a=this.rasterInfo.spatialReference,s=!e.spatialReference.equals(a),{datumTransformation:l}=r,c=new d({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/o,spatialReference:e.spatialReference}),u=r.srcResolution||(s?M.projectResolution(c,a,e,l):c);if(!u)return null;const{pyramidLevel:f,pyramidResolution:h,excessiveReading:m}=M.snapPyramid(u,this.rasterInfo,this.ioConfig.sampling);if(m)return null;const p=this.rasterInfo.storageInfo;let x=s?M.projectExtent(e,a,l):e;const y=n.unwrap(this.rasterInfo.transform);if(y&&(x=y.inverseTransform(x)),null==x)return null;const g={x:Math.floor((x.xmin-p.origin.x)/h.x+.1),y:Math.floor((p.origin.y-x.ymax)/h.y+.1)},w=Math.ceil((x.xmax-x.xmin)/h.x-.1),I=Math.ceil((x.ymax-x.ymin)/h.y-.1);if(w/t>8||I/o>8)return null;const k=await this.fetchRawPixels(f,g,{width:w,height:I},r);if(!k)return null;const v=f>0?p.pyramidBlockWidth:p.blockWidth,b=f>0?p.pyramidBlockHeight:p.blockHeight;if(!s&&1===k.pixelBlocks.length&&v===t&&b===o&&u.x===c.x&&u.y===c.y)return{extent:e,srcExtent:x,pixelBlock:k.pixelBlocks[0]};const C=M.getProjectionOffsetGrid(e,k.extent,c,l,y);let B;const P=!r.requestRawData,S={rows:C.spacing[0],cols:C.spacing[1]},{pixelBlocks:T,mosaicSize:_,isPartiallyFilled:F}=k;if(this.rasterJobHandler)B=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:T,srcMosaicSize:_,destDimension:P?{width:t,height:o}:null,coefs:P?C.coefficients:null,sampleSpacing:P?S:null,interpolation:r.interpolation},r);else{const e=R.mosaic(T,_);B=P?R.approximateTransform(e,{width:t,height:o},C.coefficients,S,r.interpolation):e}return r.requestRawData?{srcExtent:x,pixelBlock:B,transformGrid:C,extent:e,isPartiallyFilled:F}:{srcExtent:x,extent:e,pixelBlock:B}},i.fetchRawPixels=async function(e,t,o,n){const{origin:r,blockBoundary:i}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:s}=this.getBlockWidthHeight(e);let{x:l,y:c}=t,{width:u,height:f}=o;n.buffer&&(l-=n.buffer.cols,c-=n.buffer.rows,u+=2*n.buffer.cols,f+=2*n.buffer.rows);const h=Math.floor(l/a),m=Math.floor(c/s),d=Math.floor((l+u-1)/a),x=Math.floor((c+f-1)/s),y=i[e];if(!y)return null;const{minRow:g,minCol:w,maxCol:I,maxRow:k}=y;if(x<g||d<w||m>k||h>I)return null;const v=[];let R,b=!1;for(let p=m;p<=x;p++)for(let t=h;t<=d;t++)p>=g&&t>=w&&k>=p&&I>=t?(R=this._fetchRawTile(e,p,t,n),this.ioConfig.allowPartialFill&&(R=new Promise((e=>{R.then((t=>e(t))).catch((()=>{b=!0,e(null)}))}))),v.push(R)):v.push(null);if(0===v.length)return null;const M=await Promise.all(v),C={height:(x-m+1)*a,width:(d-h+1)*s},{nativePixelSize:B,spatialReference:P}=this.rasterInfo,S=B.x*2**e,T=B.y*2**e;return{extent:new p({xmin:r.x+h*a*S,xmax:r.x+(d+1)*a*S,ymin:r.y-(x+1)*s*T,ymax:r.y-m*s*T,spatialReference:P}),pixelBlocks:M,mosaicSize:C,isPartiallyFilled:b}},i.fetchRawTile=async function(e,t,o,n){throw new l("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")},i.computeExtent=function(e){return M.projectExtent(this.rasterInfo.extent,e)},i.decodePixelBlock=function(e,t){return!this.rasterJobHandler||t.useCanvas?v.decode(e,t):this.rasterJobHandler.decode({data:e,options:t})},i.request=async function(e,t,o){var n,r;const{customFetchParameters:i}=this.ioConfig,{range:a,query:s,headers:l}=t;o=null!=(n=null!=(r=o)?r:t.retryCount)?n:this.ioConfig.retryCount;const c=a?{Range:`bytes=${a.from}-${a.to}`}:null;try{return await y(e,{...t,query:{...s,...i},headers:{...l,...c}})}catch(u){if(o>0)return o--,this.request(e,t,o);throw u}},i.getSliceIndex=function(e){const{multidimensionalInfo:t}=this.rasterInfo;if(!n.isSome(t)||null==e||!e.length)return null;let o=0;const r=e[0].variableName;for(let n=0;n<t.variables.length;n++){const i=t.variables[n],a=i.dimensions;if(i.name!==r){o+=a.map((e=>this._getDimensionValuesCount(e))).reduce(((e,t)=>e+t));break}const s=a.map((e=>this._getDimensionValuesCount(e))),l=a.length;for(let t=0;t<l;t++){const n=e.filter((e=>e.dimensionName===a[t].name))[0];if(null==n)return null;const r=Array.isArray(n.values[0])?n.values[0][0]:n.values[0],i=this._getIndexFromDimensions(r,a[t]);if(-1===i)return null;s.shift(),o+=t===l-1?i:i*s.reduce(((e,t)=>e+t))}}return o},i.updateTileInfo=function(){const{storageInfo:e,spatialReference:t,extent:o,pixelSize:n}=this.rasterInfo;if(!e.tileInfo){const r=[],i=e.maximumPyramidLevel||0;let a=Math.max(n.x,n.y),s=1/.0254*96*a;for(let e=0;e<=i;e++)r.push({level:i-e,resolution:a,scale:s}),a*=2,s*=2;const l=new d({x:o.xmin,y:o.ymax,spatialReference:t});e.tileInfo=new k({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:r}),e.isVirtualTileInfo=!0}},i.createRemoteDatasetStorageInfo=function(e,t=512,o=512,n){const{width:r,height:i,nativeExtent:a,pixelSize:s,spatialReference:l}=e,c=new d({x:a.xmin,y:a.ymax,spatialReference:l});null==n&&(n=Math.max(0,Math.round(Math.log(Math.max(r,i))/Math.LN2-8)));const u=this._computeBlockBoundary(a,s,n,512,512);e.storageInfo=new b({blockWidth:t,blockHeight:o,pyramidBlockWidth:t,pyramidBlockHeight:o,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:u})},i.computeBestPyramidLevelForLocation=async function(e,t={}){return 0},i.identifyPixelLocation=function(e,t,o){const{spatialReference:n,nativePixelSize:r,nativeExtent:i}=this.rasterInfo,{blockWidth:a,blockHeight:s,maximumPyramidLevel:l,pyramidScalingFactor:c,origin:u}=this.rasterInfo.storageInfo,f=M.projectPoint(e,n,o);if(!i.intersects(f))return null;if(t<0||t>l)return null;const h=c**t,m=h*r.x,d=h*r.y,p=(u.y-f.y)/d/s,x=(f.x-u.x)/m/a,y=Math.min(s-1,Math.floor((p-Math.floor(p))*s)),g=Math.min(a-1,Math.floor((x-Math.floor(x))*a));return{pyramidLevel:t,row:Math.floor(p),col:Math.floor(x),rowOffset:y,colOffset:g,srcLocation:f}},i.getTileExtent=function(e,t,o,n,r,i){const[a,s]=i,l=n.x+o*a*e.x,c=l+a*e.x,u=n.y-t*s*e.y,f=u-s*e.y;return new p({xmin:l,xmax:c,ymin:f,ymax:u,spatialReference:r})},i.getBlockWidthHeight=function(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}},i.isBlockOutside=function(e,t,o){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<t||n.maxCol<o||n.minRow>t||n.minCol>o},i._computeBlockBoundary=function(e,t,o,n,r){let{x:i,y:a}=t;const s=e.xmin,l=e.ymax,c=[{minCol:Math.floor((e.xmin-s+.1*i)/n/i),maxCol:Math.floor((e.xmax-s-.1*i)/n/i),minRow:Math.floor((l-e.ymax+.1*a)/r/a),maxRow:Math.floor((l-e.ymin-.1*a)/r/a)}];if(o>0)for(let u=0;u<o;u++)i*=2,a*=2,c.push({minCol:Math.floor((e.xmin-s+.1*i)/n/i),maxCol:Math.floor((e.xmax-s-.1*i)/n/i),minRow:Math.floor((l-e.ymax+.1*a)/r/i),maxRow:Math.floor((l-e.ymin-.1*a)/r/i)});return c},i._fetchRawTile=function(e,t,o,r){const i=this.rasterInfo.storageInfo.blockBoundary[e];if(!i)return Promise.resolve(null);const{minRow:a,minCol:s,maxCol:l,maxRow:c}=i;if(t<a||o<s||t>c||o>l)return Promise.resolve(null);const u=C.getRasterId(this.url,r.sliceId),f=`${e}/${t}/${o}`;let m=C.getBlock(u,r.registryId,f);if(!n.isSome(m)){const n=h.createAbortController();m=this.fetchRawTile(e,t,o,{...r,signal:n.signal}),C.putBlock(u,r.registryId,f,m,n),m.catch((()=>{C.deleteBlock(u,r.registryId,f)}))}return r.signal&&h.onAbort(r,(()=>{C.decreaseRefCount(u,r.registryId,f)})),m},i._getIndexFromDimensions=function(e,t){const{extent:o,interval:n,unit:r,values:i}=t;if(null!=i&&i.length)return Array.isArray(i[0])?i.findIndex((t=>t[0]<=e&&t[1]>=e)):i.indexOf(e);if(e>o[1])return-1;const a=o[0];let s=-1;if("ISO8601"===r){var l;switch((null==(l=t.intervalUnit)?void 0:l.toLowerCase())||"seconds"){case"seconds":s=Math.round((e-a)/1e3/n);break;case"minutes":s=Math.round((e-a)/6e4/n);break;case"hours":s=Math.round((e-a)/36e5/n);break;case"days":s=Math.round((e-a)/864e5/n);break;case"years":s=Math.round((new Date(e).getUTCFullYear()-new Date(a).getUTCFullYear())/n);break;case"decades":s=Math.round((new Date(e).getUTCFullYear()-new Date(a).getUTCFullYear())/10/n)}return s}return Math.round((e-a)/n)},i._getDimensionValuesCount=function(e){const{extent:t,interval:o,unit:n,values:r}=e;let i=(null==r?void 0:r.length)||0;if(i)return i;const a=t[0];if(0===i&&"ISO8601"===n){var s;switch((null==(s=e.intervalUnit)?void 0:s.toLowerCase())||"seconds"){case"seconds":i=Math.round((t[1]-t[0])/1e3/o);break;case"minutes":i=Math.round((t[1]-t[0])/6e4/o);break;case"hours":i=Math.round((t[1]-t[0])/36e5/o);break;case"days":i=Math.round((t[1]-t[0])/864e5/o);break;case"years":i=Math.round((new Date(t[1]).getUTCFullYear()-new Date(a).getUTCFullYear())/o);break;case"decades":i=Math.round((new Date(t[1]).getUTCFullYear()-new Date(a).getUTCFullYear())/10/o)}return i}return Math.round((t[1]-t[0])/o)},e._createClass(o,[{key:"url",set:function(e){this._set("url",w.sanitizeUrl(e,r.getLogger(this.declaredClass)))}}]),o}(g.EsriPromiseMixin(m.JSONSupport));return t.__decorate([a.property(I.url)],B.prototype,"url",null),t.__decorate([a.property({type:String,json:{write:!0}})],B.prototype,"datasetName",void 0),t.__decorate([a.property({type:String,json:{write:!0}})],B.prototype,"datasetFormat",void 0),t.__decorate([a.property()],B.prototype,"rasterInfo",void 0),t.__decorate([a.property()],B.prototype,"ioConfig",void 0),t.__decorate([a.property()],B.prototype,"sourceJSON",void 0),B=t.__decorate([s.subclass("esri.layers.support.rasterDatasets.BaseRaster")],B),B}));
