/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../geometry","../../../request","../../../core/Error","../../../core/JSONSupport","../../../core/Logger","../../../core/maybe","../../../core/Promise","../../../core/promiseUtils","../../../core/accessorSupport/decorators/property","../../../core/arrayUtils","../../../core/accessorSupport/ensureType","../../../core/accessorSupport/decorators/subclass","../arcgisLayerUrl","../commonProperties","../DimensionalDefinition","../RasterStorageInfo","../TileInfo","./multidimensionalUtils","./RawBlockCache","../rasterFormats/RasterCodec","../rasterFunctions/pixelUtils","../rasterFunctions/rasterProjectionHelper","../rasterFunctions/vectorFieldUtils","../../../geometry/Point","../../../geometry/Extent"],(function(e,t,i,n,o,r,s,l,a,c,u,f,h,m,p,d,x,y,g,I,R,S,w,k,v,T,b){"use strict";const _=8;let B=function(t){function i(){var e;return(e=t.apply(this,arguments)||this).rasterJobHandler=null,e.datasetName=null,e.datasetFormat=null,e.rasterInfo=null,e.ioConfig={sampling:"closest"},e}e._inheritsLoose(i,t);var r=i.prototype;return r.init=function(){var t=e._asyncToGenerator((function*(){const e=k.load();this.addResolvingPromise(e),yield this.when()}));function i(){return t.apply(this,arguments)}return i}(),r.normalizeCtorArgs=function(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:g.create(),...e.ioConfig}}),e},r.open=function(){var t=e._asyncToGenerator((function*(e){throw new o("BaseRaster:open-not-implemented","open() is not implemented")}));function i(e){return t.apply(this,arguments)}return i}(),r.fetchTile=function(){var t=e._asyncToGenerator((function*(e,t,i,n={}){const o=n.tileInfo||this.rasterInfo.storageInfo.tileInfo,r=this.getTileExtentFromTileInfo(e,t,i,o);return this.fetchPixels(r,o.size[0],o.size[1],n)}));function i(e,i,n){return t.apply(this,arguments)}return i}(),r.identify=function(){var t=e._asyncToGenerator((function*(e,t={}){e=h.ensureClass(T,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:n}=t,{hasMultidimensionalTranspose:o,multidimensionalInfo:r}=this.rasterInfo;let{transposedVariableName:s}=t;const a=l.isSome(r)&&o&&(null!=n||I.isMultiSliceOrRangeDefinition(i));if(a&&!s){s=l.isSome(i)&&i.length>0?i[0].variableName??void 0:r.variables[0].name,t={...t,transposedVariableName:s}}t=this._getRequestOptionsWithSliceId(t);const{spatialReference:c,extent:u}=this.rasterInfo,{datumTransformation:f}=t;let m=k.projectPoint(e,c,f);if(!u.intersects(m))return{location:m,value:null};if(l.isSome(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(m);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};m=e}let p=0;const d=l.isSome(s)&&l.isSome(r)&&this.rasterInfo.hasMultidimensionalTranspose;if(!d)if(t.srcResolution){p=k.snapPyramid(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(p=yield this.computeBestPyramidLevelForLocation(e,t),null==p)return{location:m,value:null};const x=this.identifyPixelLocation(m,p,null,d);if(null===x)return{location:m,value:null};const{row:y,col:g,rowOffset:S,colOffset:w,blockWidth:v}=x,b=s??l.unwrap(t.sliceId),_=R.getRasterId(this.url,b),B=`${p}/${y}/${g}`;let P=R.getBlock(_,null,B);l.isNone(P)&&(P=this.fetchRawTile(p,y,g,t),R.putBlock(_,null,B,P));const W=yield P;if(l.isNone(W)||!W.pixels?.length)return{location:m,value:null};const C=S*v+w;return this._processIdentifyResult(W,{srcLocation:m,position:C,pyramidLevel:p,useTransposedTile:!!d,requestSomeSlices:a,identifyOptions:t})}));function i(e){return t.apply(this,arguments)}return i}(),r.fetchPixels=function(){var t=e._asyncToGenerator((function*(e,t,i,n={}){if(e=k.snapExtent(e),(n=this._getRequestOptionsWithSliceId(n)).requestRawData)return this._fetchPixels(e,t,i,n);const o=k.getWorldWidth(e.spatialReference),r=k.getWorldWrapCount(e);if(l.isNone(o)||0===r||1===r&&this._isGlobalWrappableSource)return this._fetchPixels(e,t,i,n);if(r>=3)return{extent:e,pixelBlock:null};const s=[],{xmin:a,xmax:c}=e,u=Math.round(o/(c-a)*t),f=u-Math.round((o/2-a)/(c-a)*t);let h=0;const m=[];for(let l=0;l<=r;l++){const p=new b({xmin:0===l?a:-o/2,xmax:l===r?c-o*l:o/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),d=0===l?u-f:l===r?t-h:u;h+=d,m.push(d);const x=n.disableWrapAround&&l>0?null:this._fetchPixels(p,d,i,n);s.push(x)}const p=(yield Promise.all(s)).map((e=>e?.pixelBlock));let d=null;const x={width:t,height:i};if(this.rasterJobHandler){d=(yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},n)).pixelBlock}else d=w.mosaic(p,x,{blockWidths:m});return{extent:e,srcExtent:k.projectExtent(e,this.rasterInfo.spatialReference,n.datumTransformation),pixelBlock:d}}));function i(e,i,n){return t.apply(this,arguments)}return i}(),r.fetchRawPixels=function(){var t=e._asyncToGenerator((function*(e,t,i,n={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const o=yield this._fetchRawTiles(e,t,i,n),{nativeExtent:r,nativePixelSize:s,storageInfo:a}=this.rasterInfo,c=2**e,u=s.x*c,f=s.y*c,h=new b({xmin:r.xmin+u*t.x,xmax:r.xmin+u*(t.x+i.width-1),ymin:r.ymax-f*(t.y+i.height-1),ymax:r.ymax-f*t.y,spatialReference:r.spatialReference});if(!o)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:m,mosaicSize:p}=o;if(1===m.length&&l.isSome(m[0])&&m[0].width===i.width&&m[0].height===i.height)return{extent:h,srcExtent:h,pixelBlock:o.pixelBlocks[0]};const d=e>0?a.pyramidBlockWidth:a.blockWidth,x=e>0?a.pyramidBlockHeight:a.blockHeight,y={x:t.x%d,y:t.y%x};let g;if(this.rasterJobHandler){g=(yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:p,destDimension:i,clipOffset:y,clipSize:i,coefs:null,sampleSpacing:null,interpolation:n.interpolation,alignmentInfo:null,blockWidths:null},n)).pixelBlock}else g=w.mosaic(m,p,{clipOffset:y,clipSize:i});return{extent:h,srcExtent:h,pixelBlock:g}}));function i(e,i,n){return t.apply(this,arguments)}return i}(),r.fetchRawTile=function(e,t,i,n){throw new o("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")},r.computeExtent=function(e){return k.projectExtent(this.rasterInfo.extent,e)},r.decodePixelBlock=function(e,t){return!this.rasterJobHandler||t.useCanvas?S.decode(e,t):this.rasterJobHandler.decode({data:e,options:t})},r.request=function(){var t=e._asyncToGenerator((function*(e,t,i=0){const{customFetchParameters:o}=this.ioConfig,{range:r,query:s,headers:l}=t;i=i??t.retryCount??this.ioConfig.retryCount;const a=r?{Range:`bytes=${r.from}-${r.to}`}:null;try{return yield n(e,{...t,query:{...s,...o},headers:{...l,...a}})}catch(c){if(i>0)return i--,this.request(e,t,i);throw c}}));function i(e,i){return t.apply(this,arguments)}return i}(),r.getSliceIndex=function(e){const{multidimensionalInfo:t}=this.rasterInfo;return l.isNone(t)||l.isNone(e)||0===e.length?null:I.getSliceIndex(e,t)},r.getTileExtentFromTileInfo=function(e,t,i,n){const o=l.unwrapOrThrow(n.lodAt(e));return this.getTileExtent({x:o.resolution,y:o.resolution},t,i,n.origin,n.spatialReference,n.size)},r.updateTileInfo=function(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:n}=this.rasterInfo;if(!e.tileInfo){const o=[],r=e.maximumPyramidLevel||0;let s=Math.max(n.x,n.y),l=1/.0254*96*s;for(let e=0;e<=r;e++)o.push({level:r-e,resolution:s,scale:l}),s*=2,l*=2;const a=new T({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new g({origin:a,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:o}),e.isVirtualTileInfo=!0}},r.createRemoteDatasetStorageInfo=function(e,t=512,i=512,n){const{width:o,height:r,nativeExtent:s,pixelSize:l,spatialReference:a}=e,c=new T({x:s.xmin,y:s.ymax,spatialReference:a});null==n&&(n=Math.max(0,Math.round(Math.log(Math.max(o,r))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[l],n);e.storageInfo=new y({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:u})},r.computeBestPyramidLevelForLocation=function(){var t=e._asyncToGenerator((function*(e,t={}){return 0}));function i(e){return t.apply(this,arguments)}return i}(),r.computeBlockBoundary=function(e,t,i,n,o,r=0,s=2){if(1===o.length&&r>0){o=[...o];let{x:e,y:t}=o[0];for(let i=0;i<r;i++)e*=s,t*=s,o.push({x:e,y:t})}const l=[],{x:a,y:c}=n;for(let u=0;u<o.length;u++){const{x:n,y:r}=o[u];l.push({minCol:Math.floor((e.xmin-a+.1*n)/t/n),maxCol:Math.floor((e.xmax-a-.1*n)/t/n),minRow:Math.floor((c-e.ymax+.1*r)/i/r),maxRow:Math.floor((c-e.ymin-.1*r)/i/r)})}return l},r.getPyramidPixelSize=function(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:n}=this.rasterInfo.storageInfo;if(0===e)return t;if(l.isSome(i)&&i.length)return i[e-1];const o=n**e;return{x:t.x*o,y:t.y*o}},r.identifyPixelLocation=function(e,t,i,n){const{spatialReference:o,nativeExtent:r,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:a,origin:c,transposeInfo:u}=s,f=n&&l.isSome(u)?u.tileSize[0]:s.blockWidth,h=n&&l.isSome(u)?u.tileSize[1]:s.blockHeight,m=k.projectPoint(e,o,i);if(!r.intersects(m))return null;if(t<0||t>a)return null;const p=this.getPyramidPixelSize(t),{x:d,y:x}=p,y=(c.y-m.y)/x/h,g=(m.x-c.x)/d/f,I=Math.min(h-1,Math.floor((y-Math.floor(y))*h)),R=Math.min(f-1,Math.floor((g-Math.floor(g))*f));return{pyramidLevel:t,row:Math.floor(y),col:Math.floor(g),rowOffset:I,colOffset:R,blockWidth:f,srcLocation:m}},r.getTileExtent=function(e,t,i,n,o,r){const[s,l]=r,a=n.x+i*s*e.x,c=a+s*e.x,u=n.y-t*l*e.y,f=u-l*e.y;return new b({xmin:a,xmax:c,ymin:f,ymax:u,spatialReference:o})},r.getBlockWidthHeight=function(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}},r.isBlockOutside=function(e,t,i){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<t||n.maxCol<i||n.minRow>t||n.minCol>i},r._fetchPixels=function(){var t=e._asyncToGenerator((function*(e,t,i,n={}){let o=k.getWorldWrapCount(e);if(o>=2)return{extent:e,pixelBlock:null};const r=this._getSourceDataInfo(e,t,i,n),{pyramidLevel:s,pyramidResolution:a,srcResolution:c,srcExtent:u,srcWidth:f,srcHeight:h}=r;if(0===f||0===h)return{extent:e,srcExtent:u,pixelBlock:null};const m=l.unwrap(this.rasterInfo.transform),p="gcs-shift"===m?.type,d=l.isSome(k.getWorldWidth(e.spatialReference));!p&&d||(o=k.getWorldWrapCount(r.srcExtent,p));const x=this.rasterInfo.storageInfo,y={x:Math.floor((u.xmin-x.origin.x)/a.x+.1),y:Math.floor((x.origin.y-u.ymax)/a.y+.1)},g=yield this._fetchRawTiles(s,y,{width:f,height:h,wrapCount:o},n);if(!g)return{extent:e,srcExtent:u,pixelBlock:null};const I=s>0?x.pyramidBlockWidth:x.blockWidth,R=s>0?x.pyramidBlockHeight:x.blockHeight,S=I===f&&R===h&&y.x%I==0&&y.y%R==0,b=new T({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),_=!e.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:B}=n;if(!_&&S&&1===g.pixelBlocks.length&&I===t&&R===i&&c.x===b.x&&c.y===b.y)return{extent:e,srcExtent:u,pixelBlock:g.pixelBlocks[0]};const P=d&&l.isSome(k.getWorldWidth(u.spatialReference)),W=n.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");W&&!this.rasterJobHandler&&(yield k.load());const C=this.rasterJobHandler?yield this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:g.extent,pixelSize:b.toJSON(),datumTransformation:B,rasterTransform:m,hasWrapAround:o>0||P,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:W},n):k.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:g.extent,pixelSize:b,datumTransformation:B,rasterTransform:m,hasWrapAround:o>0||P,isAdaptive:!1,includeGCSGrid:W});let M;const E=!n.requestRawData,H={rows:C.spacing[0],cols:C.spacing[1]},L=l.unwrap(this._getRasterTileAlignmentInfo(s,g.extent.xmin)),{pixelBlocks:D,mosaicSize:A,isPartiallyFilled:z}=g;let G=null;if(this.rasterJobHandler){const e=yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:D,srcMosaicSize:A,destDimension:E?{width:t,height:i}:null,coefs:E?C.coefficients:null,sampleSpacing:E?H:null,projectDirections:W,gcsGrid:W?C.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:n.interpolation,alignmentInfo:L,blockWidths:null},n);({pixelBlock:M,localNorthDirections:G}=e)}else{const e=w.mosaic(D,A,{alignmentInfo:L});M=E?w.approximateTransform(e,{width:t,height:i},C.coefficients,H,n.interpolation):e,W&&C.gcsGrid&&(G=w.getLocalArithmeticNorthRotations({width:t,height:i},C.gcsGrid),M=v.convertToLocalDirections(M,this.rasterInfo.dataType,G))}return n.requestRawData||W?{srcExtent:u,pixelBlock:M,transformGrid:C,localNorthDirections:G,extent:e,isPartiallyFilled:z}:{srcExtent:u,extent:e,pixelBlock:M}}));function i(e,i,n){return t.apply(this,arguments)}return i}(),r._fetchRawTiles=function(){var t=e._asyncToGenerator((function*(e,t,i,n){const{origin:o,blockBoundary:r}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:a}=this.getBlockWidthHeight(e);let{x:c,y:u}=t,{width:f,height:h,wrapCount:m}=i;const p=this._getRasterTileAlignmentInfo(e,0);n.buffer&&(c-=n.buffer.cols,u-=n.buffer.rows,f+=2*n.buffer.cols,h+=2*n.buffer.rows);let d=0,x=0,y=0;if(m&&l.isSome(p)){({worldColumnCountFromOrigin:x,originColumnOffset:y,rightPadding:d}=p);x*p.blockWidth-d>=c+f&&(d=0)}const g=Math.floor(c/s),I=Math.floor(u/a),R=Math.floor((c+f+d-1)/s),S=Math.floor((u+h+d-1)/a),w=r[e];if(!w)return null;const{minRow:k,minCol:v,maxCol:T,maxRow:_}=w;if(0===m&&(S<k||R<v||I>_||g>T))return null;const B=new Array;let P=!1;const W=null==this.ioConfig.allowPartialFill?n.allowPartialFill:this.ioConfig.allowPartialFill;for(let b=I;b<=S;b++)for(let t=g;t<=R;t++){let i=t;if(!n.disableWrapAround&&m&&l.isSome(p)&&x<=t&&(i=t-x-y),b>=k&&i>=v&&_>=b&&T>=i){const t=this._fetchRawTile(e,b,i,n);W?B.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{P=!0,e(null)}))}))):B.push(t)}else B.push(Promise.resolve(null))}if(0===B.length)return null;const C=yield Promise.all(B),M={height:(S-I+1)*a,width:(R-g+1)*s},{spatialReference:E}=this.rasterInfo,H=this.getPyramidPixelSize(e),{x:L,y:D}=H;return{extent:new b({xmin:o.x+g*s*L,xmax:o.x+(R+1)*s*L,ymin:o.y-(S+1)*a*D,ymax:o.y-I*a*D,spatialReference:E}),pixelBlocks:C,mosaicSize:M,isPartiallyFilled:P}}));function i(e,i,n,o){return t.apply(this,arguments)}return i}(),r._fetchRawTile=function(e,t,i,n){const o=this.rasterInfo.storageInfo.blockBoundary[e];if(!o)return Promise.resolve(null);const{minRow:r,minCol:s,maxCol:a,maxRow:u}=o;if(t<r||i<s||t>u||i>a)return Promise.resolve(null);const f=R.getRasterId(this.url,n.sliceId),h=`${e}/${t}/${i}`;let m=R.getBlock(f,n.registryId,h);if(l.isNone(m)){const o=new AbortController;m=this.fetchRawTile(e,t,i,{...n,signal:o.signal}),R.putBlock(f,n.registryId,h,m,o),m.catch((()=>R.deleteBlock(f,n.registryId,h)))}return n.signal&&c.onAbort(n,(()=>{R.decreaseRefCount(f,n.registryId,h)})),m},r._computeMagDirValues=function(e){const{bandCount:t,dataType:i}=this.rasterInfo;if(!(2===t&&"vector-magdir"===i||"vector-uv"===i)||2!==e?.length||!e[0]?.length)return null;const n=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[o,r]=e,s=[],l=[];for(let a=0;a<n;a++){const[e,t]=v.uvComponentToVector([o[a],r[a]]);s.push(e),l.push(t)}return[s,l]},r._getRasterTileAlignmentInfo=function(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=k.getRasterDatasetAlignmentInfo(this.rasterInfo)),l.isNone(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}},r._getSourceDataInfo=function(e,t,i,n={}){const o={datumTransformation:n.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};n.srcResolution&&(o.srcResolution=n.srcResolution,this._updateSourceDataInfo(e,o));const r=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:l,pyramidLevel:a}=o,c=s/t,u=l/i,f=a<r&&c*u>=16;if(f||a===r&&(c>_||u>_)||(0===s||0===l)){const s=new T({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let l=k.projectResolution(s,this.rasterInfo.spatialReference,e,o.datumTransformation);const h=!l||n.srcResolution&&l.x+l.y<n.srcResolution.x+n.srcResolution.y;if(f&&n.srcResolution&&h){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(r-a+3>=e){const t=2**e;l={x:n.srcResolution.x*t,y:n.srcResolution.y*t}}}l&&(o.srcResolution=l,this._updateSourceDataInfo(e,o))}return(o.srcWidth/t>_||o.srcHeight/i>_)&&(o.srcWidth=0,o.srcHeight=0),o},r._updateSourceDataInfo=function(e,t){t.srcWidth=0,t.srcHeight=0;const i=this.rasterInfo.spatialReference,{srcResolution:n,datumTransformation:o}=t,{pyramidLevel:r,pyramidResolution:s,excessiveReading:a}=k.snapPyramid(n,this.rasterInfo,this.ioConfig.sampling);if(a)return;let c=t.srcExtent||k.projectExtent(e,i,o);if(null==c)return;const u=l.unwrap(this.rasterInfo.transform);u&&(c=u.inverseTransform(c)),t.srcExtent=c;const f=Math.ceil((c.xmax-c.xmin)/s.x-.1),h=Math.ceil((c.ymax-c.ymin)/s.y-.1);t.pyramidLevel=r,t.pyramidResolution=s,t.srcWidth=f,t.srcHeight=h},r._getRequestOptionsWithSliceId=function(e){return l.isSome(this.rasterInfo.multidimensionalInfo)&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e},r._processIdentifyResult=function(e,t){const{srcLocation:i,position:n,pyramidLevel:o,useTransposedTile:r}=t,s=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[n]))return{location:i,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(l.isNone(a)||!r){const t=e.pixels.map((e=>e[n])),r={location:i,value:t,pyramidLevel:o},s=this._computeMagDirValues(t.map((e=>[e])));return s?.length&&(r.magdirValue=s.map((e=>e[0]))),r}let c=e.pixels.map((e=>Array.prototype.slice.call(e,n*s,n*s+s))),u=this._computeMagDirValues(c);const{requestSomeSlices:f,identifyOptions:h}=t;let m=I.createSlices(a,h.transposedVariableName);if(f){const e=I.getSliceIds(m,l.unwrap(h.multidimensionalDefinition),l.unwrap(h.timeExtent));c=c.map((t=>e.map((e=>t[e])))),u=u?.map((t=>e.map((e=>t[e])))),m=e.map((e=>m[e]))}return{location:i,value:null,dataSeries:m.map(((e,t)=>{const i={value:c.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new x({...e,isSlice:!0})))};return u?.length&&(i.magdirValue=[u[0][t],u[1][t]]),i})),pyramidLevel:o}},e._createClass(i,[{key:"_isGlobalWrappableSource",get:function(){const{rasterInfo:e}=this,t=k.getWorldWidth(e.spatialReference);return l.isSome(t)&&e.extent.width>=t/2}},{key:"url",set:function(e){this._set("url",p.sanitizeUrl(e,s.getLogger(this.declaredClass)))}}]),i}(a.EsriPromiseMixin(r.JSONSupport));t.__decorate([u.property()],B.prototype,"_rasterTileAlighmentInfo",void 0),t.__decorate([u.property({readOnly:!0})],B.prototype,"_isGlobalWrappableSource",null),t.__decorate([u.property(d.url)],B.prototype,"url",null),t.__decorate([u.property({type:String,json:{write:!0}})],B.prototype,"datasetName",void 0),t.__decorate([u.property({type:String,json:{write:!0}})],B.prototype,"datasetFormat",void 0),t.__decorate([u.property()],B.prototype,"rasterInfo",void 0),t.__decorate([u.property()],B.prototype,"ioConfig",void 0),t.__decorate([u.property()],B.prototype,"sourceJSON",void 0),B=t.__decorate([m.subclass("esri.layers.support.rasterDatasets.BaseRaster")],B);return B}));
