/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../request.js";import i from"../../core/Accessor.js";import{ByteSizeUnit as r}from"../../core/byteSizeEstimations.js";import s from"../../core/Error.js";import{HandleOwnerMixin as l}from"../../core/HandleOwner.js";import a from"../../core/Logger.js";import o from"../../core/LRUCache.js";import n from"../../core/PooledArray.js";import{onAbort as c,isAbortError as h,isAborted as p,createAbortError as m}from"../../core/promiseUtils.js";import{watch as f,syncAndInitial as u}from"../../core/reactiveUtils.js";import{waitTicks as v}from"../../core/scheduling.js";import{objectToQuery as y}from"../../core/urlUtils.js";import{property as b}from"../../core/accessorSupport/decorators/property.js";import"../../core/arrayUtils.js";import"../../core/has.js";import{cast as _}from"../../core/accessorSupport/decorators/cast.js";import{subclass as d}from"../../core/accessorSupport/decorators/subclass.js";import{tilemapDefinitionId as g,Tilemap as w}from"./Tilemap.js";var T;const j=a.getLogger("esri.layers.support.TilemapCache");let z=T=class extends(l(i)){constructor(e){super(e),this._pendingTilemapRequests={},this._availableLevels={},this.levels=5,this.cacheByteSize=2*r.MEGABYTES,this.request=t,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new o(this.cacheByteSize),this.own([f((()=>{const{layer:e}=this;return[e?.parsedUrl,e?.tileServers,e?.apiKey,e?.customParameters]}),(()=>this._initializeTilemapDefinition())),f((()=>this.layer?.tileInfo?.lods),(e=>this._initializeAvailableLevels(e)),u)]),this._initializeTilemapDefinition()}castLevels(e){return e<=2?(j.error("Minimum levels for Tilemap is 3, but got ",e),3):e}get size(){return 1<<this.levels}fetchTilemap(e,t,i,r){if(!this._availableLevels[e])return Promise.reject(new s("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const l=this._tmpTilemapDefinition,a=this._tilemapFromCache(e,t,i,l);if(a)return Promise.resolve(a);const o=r&&r.signal;return r={...r,signal:null},new Promise(((e,t)=>{c(o,(()=>t(m())));const i=g(l);let s=this._pendingTilemapRequests[i];if(!s){s=w.fromDefinition(l,r).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>delete this._pendingTilemapRequests[i];this._pendingTilemapRequests[i]=s,s.then(e,e)}s.then(e,t)}))}getAvailability(e,t,i){if(!this._availableLevels[e])return"unavailable";const r=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return r?r.getAvailability(t,i):"unknown"}fetchAvailability(e,t,i,r){return this._availableLevels[e]?this.fetchTilemap(e,t,i,r).catch((e=>e)).then((r=>{if(r instanceof w){const l=r.getAvailability(t,i);if("unavailable"===l)throw new s("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i});return l}if(h(r))throw r;return"unknown"})):Promise.reject(new s("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`))}fetchAvailabilityUpsample(e,t,i,r,s){r.level=e,r.row=t,r.col=i;const l=this.layer.tileInfo;l.updateTileInfo(r);const a=this.fetchAvailability(e,t,i,s).catch((e=>{if(h(e))throw e;if(l.upsampleTile(r))return this.fetchAvailabilityUpsample(r.level,r.row,r.col,r);throw e}));return this._fetchAvailabilityUpsamplePrefetch(r.id,e,t,i,s,a),a}async _fetchAvailabilityUpsamplePrefetch(e,t,i,r,s,l){if(!this._prefetchingEnabled)return;const a=`prefetch-${e}`;if(this.handles.has(a))return;const o=new AbortController;l.then((()=>o.abort()),(()=>o.abort()));let n=!1;const c={remove(){n||(n=!0,o.abort())}};if(this.handles.add(c,a),await v(10,o.signal).catch((()=>{})),n||(n=!0,this.handles.remove(a)),p(o))return;const h={id:e,level:t,row:i,col:r},m={...s,signal:o.signal},f=this.layer.tileInfo;for(let p=0;T._prefetches.length<T._maxPrefetch&&f.upsampleTile(h);++p){const e=this.fetchAvailability(h.level,h.row,h.col,m);T._prefetches.push(e);const t=()=>{T._prefetches.removeUnordered(e)};e.then(t,t)}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:t,customParameters:i}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:y({...e.query,...i,token:t??e.query?.token}),tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,i,r){r.level=e,r.row=t-t%this.size,r.col=i-i%this.size;const s=g(r);return this._tilemapCache.get(s)}_initializeAvailableLevels(e){this._availableLevels={},e&&e.forEach((e=>this._availableLevels[e.level]=!0))}get test(){const e=this;return{get prefetchingEnabled(){return e._prefetchingEnabled},set prefetchingEnabled(t){e._prefetchingEnabled=t},hasTilemap:(t,i,r)=>!!e._tilemapFromCache(t,i,r,e._tmpTilemapDefinition)}}};z._maxPrefetch=4,z._prefetches=new n({initialSize:T._maxPrefetch}),e([b({constructOnly:!0,type:Number})],z.prototype,"levels",void 0),e([_("levels")],z.prototype,"castLevels",null),e([b({readOnly:!0,type:Number})],z.prototype,"size",null),e([b({constructOnly:!0,type:Number})],z.prototype,"cacheByteSize",void 0),e([b({constructOnly:!0})],z.prototype,"layer",void 0),e([b({constructOnly:!0})],z.prototype,"request",void 0),z=T=e([d("esri.layers.support.TilemapCache")],z);export{z as TilemapCache};
