/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../core/Error","../../core/JSONSupport","../../core/lang","../../core/Logger","../../core/maybe","../../core/accessorSupport/decorators/property","../../core/accessorSupport/decorators/cast","../../core/accessorSupport/decorators/subclass","./SimpleBandStatistics"],(function(t,e,s,i,r,l,o,a,n,h,c){"use strict";var p;let u=p=function(e){function i(t){var s;return(s=e.call(this,t)||this).width=null,s.height=null,s.pixelType="f32",s.validPixelCount=null,s.mask=null,s.maskIsAlpha=!1,s.statistics=null,s}t._inheritsLoose(i,e),i.createEmptyBand=function(t,e){return new(p.getPixelArrayConstructor(t))(e)},i.getPixelArrayConstructor=function(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e};var a=i.prototype;return a.castPixelType=function(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e},a.getPlaneCount=function(){return this.pixels?.length},a.addData=function(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new s("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new c.SimpleBandStatistics)},a.getAsRGBA=function(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)},a.getAsRGBAFloat=function(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t},a.updateStatistics=function(){if(!this.pixels)return;this.statistics=this.pixels.map((t=>this._calculateBandStatistics(t,this.mask)));const t=this.mask;let e=0;if(o.isSome(t))for(let s=0;s<t.length;s++)t[s]&&e++;else e=this.width*this.height;this.validPixelCount=e},a.clamp=function(t){if(!t||"f64"===t||"f32"===t||!this.pixels)return;let e;switch(t){case"u8":e=[0,255];break;case"u16":e=[0,65535];break;case"u32":e=[0,4294967295];break;case"s8":e=[-128,127];break;case"s16":e=[-32768,32767];break;case"s32":e=[-2147483648,2147483647];break;default:e=[-34e38,34e38]}const[s,i]=e,r=this.pixels,l=this.width*this.height,o=r.length;let a,n,h;const c=[];for(let u=0;u<o;u++){h=p.createEmptyBand(t,l),a=r[u];for(let t=0;t<l;t++)n=a[t],h[t]=n>i?i:n<s?s:n;c.push(h)}this.pixels=c,this.pixelType=t},a.extractBands=function(t){const{pixels:e,statistics:s}=this;if(o.isNone(t)||0===t.length||!e||0===e.length)return this;const i=e.length,r=t.some((t=>t>=e.length)),l=i===t.length&&!t.some(((t,e)=>t!==e));return r||l?this:new p({pixelType:this.pixelType,width:this.width,height:this.height,mask:this.mask,validPixelCount:this.validPixelCount,maskIsAlpha:this.maskIsAlpha,pixels:t.map((t=>e[t])),statistics:s&&t.map((t=>s[t]))})},a.clone=function(){const t=new p({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let e;o.isSome(this.mask)&&(this.mask instanceof Uint8Array?t.mask=new Uint8Array(this.mask):t.mask=this.mask.slice(0));const s=p.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const i=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=i?this.pixels[e].slice(0,this.pixels[e].length):new s(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=r.clone(this.statistics[e]);return t},a._fillFrom8Bit=function(t){const{mask:e,maskIsAlpha:s,pixels:i}=this;if(!t||!i||!i.length)return void l.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let r,a,n,h;r=a=n=i[0],i.length>=3?(a=i[1],n=i[2]):2===i.length&&(a=i[1]);const c=new Uint32Array(t),p=this.width*this.height;if(r.length===p)if(o.isSome(e)&&e.length===p)if(s)for(h=0;h<p;h++)e[h]&&(c[h]=e[h]<<24|n[h]<<16|a[h]<<8|r[h]);else for(h=0;h<p;h++)e[h]&&(c[h]=255<<24|n[h]<<16|a[h]<<8|r[h]);else for(h=0;h<p;h++)c[h]=255<<24|n[h]<<16|a[h]<<8|r[h];else l.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")},a._fillFromNon8Bit=function(t){const{pixels:e,mask:s,statistics:i}=this;if(!t||!e||!e.length)return void l.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const r=this.pixelType;let a=1,n=0,h=1;if(i&&i.length>0){for(const t of i)if(null!=t.minValue&&(n=Math.min(n,t.minValue)),null!=t.maxValue&&null!=t.minValue){const e=t.maxValue-t.minValue;h=Math.max(h,e)}a=255/h}else{let t=255;"s8"===r?(n=-128,t=127):"u16"===r?t=65535:"s16"===r?(n=-32768,t=32767):"u32"===r?t=4294967295:"s32"===r?(n=-2147483648,t=2147483647):"f32"===r?(n=-34e38,t=34e38):"f64"===r&&(n=-Number.MAX_VALUE,t=Number.MAX_VALUE),a=255/(t-n)}const c=new Uint32Array(t),p=this.width*this.height;let u,f,d,g,x;if(u=f=d=e[0],u.length!==p)return l.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(f=e[1],e.length>=3&&(d=e[2]),o.isSome(s)&&s.length===p)for(g=0;g<p;g++)s[g]&&(c[g]=255<<24|(d[g]-n)*a<<16|(f[g]-n)*a<<8|(u[g]-n)*a);else for(g=0;g<p;g++)c[g]=255<<24|(d[g]-n)*a<<16|(f[g]-n)*a<<8|(u[g]-n)*a;else if(o.isSome(s)&&s.length===p)for(g=0;g<p;g++)x=(u[g]-n)*a,s[g]&&(c[g]=255<<24|x<<16|x<<8|x);else for(g=0;g<p;g++)x=(u[g]-n)*a,c[g]=255<<24|x<<16|x<<8|x},a._fillFrom32Bit=function(t){const{pixels:e,mask:s}=this;if(!t||!e||!e.length)return l.getLogger(this.declaredClass).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let i,r,a,n;i=r=a=e[0],e.length>=3?(r=e[1],a=e[2]):2===e.length&&(r=e[1]);const h=this.width*this.height;if(i.length!==h)return l.getLogger(this.declaredClass).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let c=0;if(o.isSome(s)&&s.length===h)for(n=0;n<h;n++)t[c++]=i[n],t[c++]=r[n],t[c++]=a[n],t[c++]=1&s[n];else for(n=0;n<h;n++)t[c++]=i[n],t[c++]=r[n],t[c++]=a[n],t[c++]=1},a._calculateBandStatistics=function(t,e){let s=1/0,i=-1/0;const r=t.length;let l,a=0;if(o.isSome(e))for(l=0;l<r;l++)e[l]&&(a=t[l],s=a<s?a:s,i=a>i?a:i);else for(l=0;l<r;l++)a=t[l],s=a<s?a:s,i=a>i?a:i;return new c.SimpleBandStatistics(s,i)},i}(i.JSONSupport);e.__decorate([a.property({json:{write:!0}})],u.prototype,"width",void 0),e.__decorate([a.property({json:{write:!0}})],u.prototype,"height",void 0),e.__decorate([a.property({json:{write:!0}})],u.prototype,"pixelType",void 0),e.__decorate([n.cast("pixelType")],u.prototype,"castPixelType",null),e.__decorate([a.property({json:{write:!0}})],u.prototype,"validPixelCount",void 0),e.__decorate([a.property({json:{write:!0}})],u.prototype,"mask",void 0),e.__decorate([a.property({json:{write:!0}})],u.prototype,"maskIsAlpha",void 0),e.__decorate([a.property({json:{write:!0}})],u.prototype,"pixels",void 0),e.__decorate([a.property({json:{write:!0}})],u.prototype,"statistics",void 0),u=p=e.__decorate([h.subclass("esri.layers.support.PixelBlock")],u);return u}));
