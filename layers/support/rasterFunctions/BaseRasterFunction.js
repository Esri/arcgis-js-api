/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../core/JSONSupport","../../../core/maybe","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/decorators/cast","../../../core/arrayUtils","../../../core/accessorSupport/decorators/subclass","../PixelBlock","../RasterInfo"],(function(t,e,s,r,n,o,i,a,u,p){"use strict";let c=function(e){function s(){var t;return(t=e.apply(this,arguments)||this).functionArguments=null,t.readingBufferSize=0,t.id=-1,t.isNoopProcess=!1,t.rawInputBandIds=[],t.isInputBandIdsSwizzled=!1,t.swizzledBandSelection=[],t.isBranch=!1,t._bindingResult=null,t}t._inheritsLoose(s,e);var n=s.prototype;return n.bind=function(t,e=!1,s=-1){this.id=s+1;const n=this._getRasterValues();let o=!0;for(let i=0;i<n.length;i++){const s=n[i];if(r.isSome(s)&&this._isRasterFunctionValue(s)){const r=s.bind(t,e,this.id+i);if(!r.success)return this._bindingResult=r,r;o=o&&r.supportsGPU}}return!this.rasterInfo||e?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),this._bindingResult.supportsGPU=o&&this._bindingResult.supportsGPU,this.processInputBandIds(),this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this.processInputBandIds(),this._bindingResult)},n.process=function(t){const e=this._getRasterValues(),s=0===e.length?t.pixelBlocks??t.primaryPixelBlocks:e.map((e=>this._readRasterValue(e,t)));return this._processPixels({...t,pixelBlocks:s})},n.processInputBandIds=function(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);let e;if(t.length>1){const e=t.map((t=>t.processInputBandIds()[0]));this.rawInputBandIds=e,this.isInputBandIdsSwizzled=this.rawInputBandIds.some(((t,e)=>t!==e));const s=t.filter((t=>"ExtractBand"===t.functionName));return s.length&&s.forEach(((t,e)=>{t.isInputBandIdsSwizzled=!0,t.swizzledBandSelection=[e,e,e]})),this.rawInputBandIds}const s=t[0];if(s){if(e=s.processInputBandIds(),s.isInputBandIdsSwizzled)return this.rawInputBandIds=e,e}else{e=[];const{bandCount:t}=this.sourceRasterInfos[0];for(let s=0;s<t;s++)e.push(s)}const r=this._getInputBandIds(e);return this.isInputBandIdsSwizzled=r.some(((t,e)=>t!==e)),this.rawInputBandIds=r,this.rawInputBandIds},n.getPrimaryRasters=function(){const t=[],e=[];return this._getPrimaryRasters(this,t,e),{rasters:t,rasterIds:e}},n.getWebGLProcessorDefinition=function(){const t=this._getWebGLParameters(),{raster:e,rasters:s}=this.functionArguments;return s&&Array.isArray(s)&&s.length?(t.rasters=s.map((t=>this._isRasterFunctionValue(t)?t.getWebGLProcessorDefinition():"number"==typeof t?{name:"Constant",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1})),t.rasters.some((t=>null!=t))||(t.rasters=null)):this._isRasterFunctionValue(e)&&(t.raster=e.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}},n.getFlatWebGLFunctionChain=function(){const t=this.getWebGLProcessorDefinition();if(!t)return null;const e=[t],{parameters:s}=t;let r=s.rasters||s.raster&&[s.raster];for(;r?.length;){e.unshift(...r);const t=[];for(let e=0;e<r.length;e++){const{parameters:s}=r[e],n=s.rasters||s.raster&&[s.raster];n?.length&&t.push(...n)}r=t}for(let o=e.length-1;o>=0;o--)e[o].isNoopProcess&&e.splice(o,1);let n=!1;for(let o=0;o<e.length;o++){const t=e[o];t.id=e.length-o-1;const{rasters:s}=t.parameters;n=n||null!=s&&s.length>1}return{hasBranches:n,functions:e}},n._getOutputPixelType=function(t){return"unknown"===this.outputPixelType?t:this.outputPixelType??t},n._getWebGLParameters=function(){return{}},n._getInputBandIds=function(t){return t},n._isOutputRoundingNeeded=function(){const{outputPixelType:t}=this;return(t?.startsWith("u")||t?.startsWith("s"))??!1},n._getRasterValues=function(){const{rasterArgumentNames:t}=this;return"rasters"===t[0]?this.functionArguments.rasters??[]:t.map((t=>this.functionArguments[t]))},n._getSourceRasterInfos=function(t){const e=this._getRasterValues(),{rasterInfos:s,rasterIds:r}=t;if(0===e.length)return s;const n=e.map((t=>t&&"object"==typeof t&&"bind"in t&&t.rasterInfo?t.rasterInfo:"string"==typeof t&&r.includes(t)?s[r.indexOf(t)]:"number"!=typeof t?s[0]:void 0)),o=n.find((t=>t))??s[0];return n.forEach(((t,e)=>{void 0===t&&(n[e]=o)})),n},n._getPrimaryRasterId=function(t){return t?.url},n._getPrimaryRasters=function(t,e=[],s=[]){for(let r=0;r<t.sourceRasters.length;r++){const n=t.sourceRasters[r];if("number"!=typeof n)if("bind"in n)this._getPrimaryRasters(n,e,s);else{const t=n,r=this._getPrimaryRasterId(t);if(null==r)continue;s.includes(r)||(this.mainPrimaryRasterId===r?(e.unshift(t),s.unshift(r)):(e.push(t),s.push(r)))}}},n._isRasterFunctionValue=function(t){return null!=t&&"object"==typeof t&&"getWebGLProcessorDefinition"in t},n._readRasterValue=function(t,e){const{primaryPixelBlocks:s}=e;if(r.isNone(t)||"$$"===t){const t=s[0];return r.isNone(t)?null:t.clone()}if("string"==typeof t){const r=e.primaryRasterIds.indexOf(t);return-1===r?null:s[r]}if("number"==typeof t){const e=s[0];if(r.isNone(e))return null;const{width:n,height:o,pixelType:i,mask:a}=e,p=a?new Uint8Array(a):null,c=new Float32Array(n*o);c.fill(t);const d=this.sourceRasterInfos[0].bandCount,l=new Array(d).fill(c);return new u({width:n,height:o,pixelType:i,pixels:l,mask:p})}return t.process(e)},t._createClass(s,[{key:"supportsGPU",get:function(){return this._bindingResult.supportsGPU}}]),s}(s.JSONSupport);e.__decorate([n.property({json:{write:!0}})],c.prototype,"functionName",void 0),e.__decorate([n.property({json:{write:!0}})],c.prototype,"functionArguments",void 0),e.__decorate([n.property()],c.prototype,"rasterArgumentNames",void 0),e.__decorate([n.property({json:{write:!0}}),o.cast((t=>t?.toLowerCase()))],c.prototype,"outputPixelType",void 0),e.__decorate([n.property({json:{write:!0}})],c.prototype,"mainPrimaryRasterId",void 0),e.__decorate([n.property()],c.prototype,"sourceRasters",void 0),e.__decorate([n.property({type:[p],json:{write:!0}})],c.prototype,"sourceRasterInfos",void 0),e.__decorate([n.property({json:{write:!0}})],c.prototype,"rasterInfo",void 0),e.__decorate([n.property({json:{write:!0}})],c.prototype,"readingBufferSize",void 0),e.__decorate([n.property({json:{write:!0}})],c.prototype,"id",void 0),e.__decorate([n.property()],c.prototype,"isNoopProcess",void 0),e.__decorate([n.property()],c.prototype,"supportsGPU",null),e.__decorate([n.property()],c.prototype,"rawInputBandIds",void 0),e.__decorate([n.property()],c.prototype,"isInputBandIdsSwizzled",void 0),e.__decorate([n.property()],c.prototype,"swizzledBandSelection",void 0),e.__decorate([n.property()],c.prototype,"isBranch",void 0),e.__decorate([n.property()],c.prototype,"_bindingResult",void 0),c=e.__decorate([a.subclass("esri.layers.support.rasterFunctions.BaseRasterFunction")],c);return c}));
