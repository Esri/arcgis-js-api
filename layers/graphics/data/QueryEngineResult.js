/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["require","exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/maybe","../../../geometry/support/centroid","../../../geometry/support/extentUtils","../../../geometry/support/quantizationUtils","../../../geometry/support/spatialReferenceUtils","./AttributesBuilder","./projectionSupport","./SnappingCandidate","./utils","../../support/fieldUtils","../../../statistics/utils","../../../support/arcadeOnDemand"],(function(e,t,i,s,n,a,r,o,l,u,c,d,m,f,p){"use strict";let g=function(){function g(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}var x=g.prototype;return x.createQueryResponseForCount=function(){const e=new l(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,n=t?.length;if(!!!n)return 1;const a=new Map,r=new Map,o=new Set;for(const l of s){const{statisticType:s}=l,n="exceedslimit"!==s?l.onStatisticField:void 0;if(!r.has(n)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,a);i.push(t)}r.set(n,this._calculateUniqueValues(i,e.returnDistinctValues))}const u=r.get(n);for(const t in u){const{data:s,items:n}=u[t],a=s.join(",");i&&!e.validateItems(n,i)||o.add(a)}}return o.size},x.createQueryResponse=function(){var e=i._asyncToGenerator((function*(){let e;if(this.query.outStatistics){e=this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):yield this._createStatisticsQueryResponse(this.query)}else e=this._createFeatureQueryResponse(this.query);if(this.query.returnQueryGeometry){const t=this.query.geometry;o.isValid(this.query.outSR)&&!o.equals(t.spatialReference,this.query.outSR)?e.queryGeometry=d.cleanFromGeometryEngine({spatialReference:this.query.outSR,...u.project(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=d.cleanFromGeometryEngine({spatialReference:this.query.outSR,...t})}return e}));function t(){return e.apply(this,arguments)}return t}(),x.createSnappingResponse=function(e,i){const n=this.featureAdapter,a=y(this.hasZ,this.hasM),{point:r,mode:o}=e,l="number"==typeof e.distance?e.distance:e.distance.x,u="number"==typeof e.distance?e.distance:e.distance.y,d={candidates:[]},m="esriGeometryPolygon"===this.geometryType,f=this._getPointCreator(o,this.spatialReference,i),p=new T(null,0),g=new T(null,0),x={x:0,y:0,z:0};for(const y of this.items){const i=n.getGeometry(y);if(s.isNone(i))continue;const{coords:o,lengths:T}=i;if(p.coords=o,g.coords=o,e.types&t.SnappingTypes.EDGE){let e=0;for(let t=0;t<T.length;t++){const i=T[t];for(let t=0;t<i;t++,e+=a){const s=p;if(s.coordsIndex=e,t!==i-1){const t=g;t.coordsIndex=e+a;const i=x;h(x,r,s,t);const o=(r.x-i.x)/l,m=(r.y-i.y)/u,p=o*o+m*m;p<=1&&d.candidates.push(c.makeEdgeCandidate(n.getObjectId(y),f(i),Math.sqrt(p),f(s),f(t)))}}}}if(e.types&t.SnappingTypes.VERTEX){const e=m?o.length-a:o.length;for(let t=0;t<e;t+=a){const e=p;e.coordsIndex=t;const i=(r.x-e.x)/l,s=(r.y-e.y)/u,a=i*i+s*s;a<=1&&d.candidates.push(c.makeVertexCandidate(n.getObjectId(y),f(e),Math.sqrt(a)))}}}return d.candidates.sort(((e,t)=>e.distance-t.distance)),d},x._getPointCreator=function(e,t,i){const n=s.isSome(i)&&!o.equals(t,i)?e=>u.project(e,t,i):e=>e,{hasZ:a}=this,r=0;return"3d"===e?a?({x:e,y:t,z:i})=>n({x:e,y:t,z:i}):({x:e,y:t})=>n({x:e,y:t,z:r}):({x:e,y:t})=>n({x:e,y:t})},x.createSummaryStatisticsResponse=function(){var e=i._asyncToGenerator((function*(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,minValue:r,maxValue:o,scale:l}=e,u=this.fieldsIndex.isDateField(t),c=yield this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:l}),d=f.isNullCountSupported({normalizationType:n,normalizationField:s,minValue:r,maxValue:o}),p=this.fieldsIndex.get(t),g={value:.5,fieldType:p?.type},h=m.isStringField(p)?f.calculateStringStatistics({values:c,supportsNullCount:d,percentileParams:g}):f.calculateStatistics({values:c,minValue:r,maxValue:o,useSampleStdDev:!n,supportsNullCount:d,percentileParams:g});return f.processSummaryStatisticsResult(h,u)}));function t(t){return e.apply(this,arguments)}return t}(),x.createUniqueValuesResponse=function(){var e=i._asyncToGenerator((function*(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:n,scale:a}=e,r=yield this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:a}),o=f.calculateUniqueValuesCount(r);return f.createUVResult(o,s,n,e.fieldDelimiter)}));function t(t){return e.apply(this,arguments)}return t}(),x.createClassBreaksResponse=function(){var e=i._asyncToGenerator((function*(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:d}=e,m=yield this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:d}),p=f.calculateClassBreaks(m,{field:t,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return f.resolveCBResult(p,r)}));function t(t){return e.apply(this,arguments)}return t}(),x.createHistogramResponse=function(){var e=i._asyncToGenerator((function*(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:d}=e,m=yield this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:d});return f.calculateHistogram(m,{field:t,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}));function t(t){return e.apply(this,arguments)}return t}(),x._sortFeatures=function(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),n=t[0],a=this.fieldsIndex.get(n),r=!!t[1]&&"desc"===t[1].toLowerCase(),o=f.getAttributeComparator(a?.type,r);e.sort(((e,t)=>{const s=i(e,n,a),r=i(t,n,a);return o(s,r)}))}},x._createFeatureQueryResponse=function(e){const t=this.items,{geometryType:i,hasM:s,hasZ:n,objectIdField:a,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:m,resultOffset:f,returnZ:p,returnM:g}=e,h=null!=m&&t.length>(f||0)+m,y=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:h,features:this._createFeatures(e,t),fields:y,geometryType:i,hasM:s&&g,hasZ:n&&p,objectIdFieldName:a,spatialReference:d.cleanFromGeometryEngine(u||o),transform:c&&r.toQuantizationTransform(c)||null}},x._createFeatures=function(e,t){const i=new l(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:n}=this,{orderByFields:a,quantizationParameters:o,returnGeometry:u,returnCentroid:c,maxAllowableOffset:m,resultOffset:f,resultRecordCount:p,returnZ:g=!1,returnM:h=!1}=e,y=n&&g,x=s&&h;let T=[],S=0;const I=[...t];if(this._sortFeatures(I,a,((e,t,s)=>i.getFieldValue(e,t,s))),u||c){const e=r.toQuantizationTransform(o)??void 0;if(u&&!c)for(const t of I)T[S++]={attributes:i.getAttributes(t),geometry:d.getGeometry(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,y,x)};else if(!u&&c)for(const t of I)T[S++]={attributes:i.getAttributes(t),centroid:d.transformCentroid(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of I)T[S++]={attributes:i.getAttributes(t),centroid:d.transformCentroid(this,this.featureAdapter.getCentroid(t,this),e),geometry:d.getGeometry(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,y,x)}}else for(const r of I){const e=i.getAttributes(r);e&&(T[S++]={attributes:e})}const V=f||0;if(null!=p){const e=V+p;T=T.slice(V,Math.min(T.length,e))}return T},x._createExceedsLimitQueryResponse=function(e){let t=!1,i=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const s of e.outStatistics??[])if("exceedslimit"===s.statisticType){i=null!=s.maxPointCount?s.maxPointCount:Number.POSITIVE_INFINITY,n=null!=s.maxRecordCount?s.maxRecordCount:Number.POSITIVE_INFINITY,a=null!=s.maxVertexCount?s.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)t=this.items.length>i;else if(this.items.length>n)t=!0;else{const e=y(this.hasZ,this.hasM),i=this.featureAdapter;t=this.items.reduce(((e,t)=>{const n=i.getGeometry(t);return e+(s.isSome(n)&&n.coords.length||0)}),0)/e>a}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}},x._createStatisticsQueryResponse=function(){var e=i._asyncToGenerator((function*(e){const t={attributes:{}},i=[],s=new Map,n=new Map,a=new Map,r=new Map,o=new l(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:d,orderByFields:m}=e,f=c&&c.length,p=!!f,g=p?c[0]:null,h=p&&!this.fieldsIndex.get(g);for(const l of u??[]){const{outStatisticFieldName:e,statisticType:u}=l,m=l,y="exceedslimit"!==u?l.onStatisticField:void 0,x="percentile_disc"===u||"percentile_cont"===u,T="EnvelopeAggregate"===u||"CentroidAggregate"===u||"ConvexHullAggregate"===u,S=p&&1===f&&(y===g||h)&&"count"===u;if(p){if(!a.has(y)){const e=[];for(const t of c){const i=this._getAttributeValues(o,t,s);e.push(i)}a.set(y,this._calculateUniqueValues(e,!T&&o.returnDistinctValues))}const t=a.get(y);for(const i in t){const{count:n,data:a,items:l,itemPositions:u}=t[i],f=a.join(",");if(!d||o.validateItems(l,d)){const t=r.get(f)||{attributes:{}};if(T){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=yield this._getAggregateGeometry(m,l);t.aggregateGeometries[i]=e}else{let i=null;if(S)i=n;else{const e=this._getAttributeValues(o,y,s),t=u.map((t=>e[t]));i=x&&"statisticParameters"in m?this._getPercentileValue(m,t):this._getStatisticValue(m,t,null,o.returnDistinctValues)}t.attributes[e]=i}let i=0;c.forEach(((e,s)=>t.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++i]=a[s])),r.set(f,t)}}}else if(T){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=yield this._getAggregateGeometry(m,this.items);t.aggregateGeometries[i]=e}else{const i=this._getAttributeValues(o,y,s);t.attributes[e]=x&&"statisticParameters"in m?this._getPercentileValue(m,i):this._getStatisticValue(m,i,n,o.returnDistinctValues)}i.push({name:e,alias:e,type:"esriFieldTypeDouble"})}const y=p?Array.from(r.values()):[t];return this._sortFeatures(y,m,((e,t)=>e.attributes[t])),{fields:i,features:y}}));function t(t){return e.apply(this,arguments)}return t}(),x._getAggregateGeometry=function(){var t=i._asyncToGenerator((function*(t,i){const s=yield new Promise(((t,i)=>e(["../../../geometry/geometryEngineJSON"],t,i))),{statisticType:r,outStatisticFieldName:o}=t,{featureAdapter:l,spatialReference:u,geometryType:c,hasZ:m,hasM:f}=this,p=i.map((e=>d.getGeometry(c,m,f,l.getGeometry(e)))),g=s.convexHull(u,p,!0)[0],h={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===r){const e=g?a.getPolygonExtent(g):a.getGeometryExtent(s.union(u,p));h.aggregateGeometries={...e,spatialReference:u},h.outStatisticFieldName=o||"extent"}else if("CentroidAggregate"===r){const e=g?n.polygonCentroid(g):n.extentCentroid(a.getGeometryExtent(s.union(u,p)));h.aggregateGeometries={x:e[0],y:e[1],spatialReference:u},h.outStatisticFieldName=o||"centroid"}else"ConvexHullAggregate"===r&&(h.aggregateGeometries=g,h.outStatisticFieldName=o||"convexHull");return h}));function s(e,i){return t.apply(this,arguments)}return s}(),x._getStatisticValue=function(e,t,i,s){const{onStatisticField:n,statisticType:a}=e;let r=null;r=i?.has(n)?i.get(n):m.isStringField(this.fieldsIndex.get(n))?f.calculateStringStatistics({values:t,returnDistinct:s}):f.calculateStatistics({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(n,r);return r["var"===a?"variance":a]},x._getPercentileValue=function(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:n}=e,{value:a,orderBy:r}=s,o={value:a,orderBy:r,fieldType:this.fieldsIndex.get(i)?.type,isDiscrete:"percentile_disc"===n};return f.calculatePercentile(t,o)},x._getAttributeValues=function(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),n=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,n),n},x._getAttributeDataValues=function(e,t){return this.items.map((i=>e.getDataValue(i,{field:t.field,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:t.normalizationField,normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal})))},x._getAttributeExpressionValues=function(){var e=i._asyncToGenerator((function*(e,t,i){const{arcadeUtils:s}=yield p.loadArcade(),n=s.createFunction(t),a=i&&s.getViewInfo(i);return e.getExpressionValues(this.items,n,a,s)}));function t(t,i,s){return e.apply(this,arguments)}return t}(),x._calculateUniqueValues=function(e,t){const i={},s=this.items,n=s.length;for(let a=0;a<n;a++){const n=s[a],r=[];for(const t of e)r.push(t[a]);const o=r.join(",");null==i[o]?i[o]={count:1,data:r,items:[n],itemPositions:[a]}:(t||i[o].count++,i[o].items.push(n),i[o].itemPositions.push(a))}return i},x._getDataValues=function(){var e=i._asyncToGenerator((function*(e){const t=new l(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:s,normalizationField:n,normalizationType:a,normalizationTotal:r,scale:o}=e,u=i?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(t,i,u):this._getAttributeDataValues(t,{field:s,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:n,normalizationType:a,normalizationTotal:r})}));function t(t){return e.apply(this,arguments)}return t}(),i._createClass(g,[{key:"size",get:function(){return this.items.length}}]),g}();function h(e,t,i,s){const n=s.x-i.x,a=s.y-i.y,r=n*n+a*a,o=(t.x-i.x)*n+(t.y-i.y)*a,l=Math.min(1,Math.max(0,o/r));e.x=i.x+n*l,e.y=i.y+a*l}function y(e,t){return e?t?4:3:t?3:2}var x;t.SnappingTypes=void 0,(x=t.SnappingTypes||(t.SnappingTypes={}))[x.NONE=0]="NONE",x[x.EDGE=1]="EDGE",x[x.VERTEX=2]="VERTEX";let T=function(){function e(e,t){this.coords=e,this.coordsIndex=t}return i._createClass(e,[{key:"x",get:function(){return this.coords[this.coordsIndex]}},{key:"y",get:function(){return this.coords[this.coordsIndex+1]}},{key:"z",get:function(){return this.coords[this.coordsIndex+2]}}]),e}();t.QueryEngineResult=g,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
