/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/lang","../../../core/maybe","../../../core/Error","../../../geometry/support/spatialReferenceUtils","../../../geometry/support/boundsUtils","../../../geometry/support/jsonUtils","../../../core/unitUtils","../../../geometry/support/aaBoundingRect","../../support/PromiseQueue","../../../geometry/support/normalizeUtils","../../../core/MemCache","../../support/FieldsIndex","./QueryEngineCapabilities","../../../geometry/support/aaBoundingBox","./projectionSupport","./attributeSupport","./utils","./spatialQuerySupport","./timeSupport","./QueryEngineResult"],(function(e,t,i,s,r,a,n,u,c,o,h,l,d,y,f,p,m,_,g,x,Q,w){"use strict";function S(e){return e.every((e=>"exceedslimit"!==e.statisticType))}const R="feature-store:unsupported-query";let I=function(e,t=null,i,s,r){this.attributes=e,this.geometry=i,this.centroid=s,this.filterFlags=r,this.groupId=-1,this.displayId=t};const E=new Set,F=new d.MemCacheStorage(2e6);let b=0,T=function(){function e(e){this.capabilities={query:f.queryCapabilities},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new d.MemCache(b+++"$$",F)),this.fieldsIndex=new y(e.fields),e.scheduler&&e.task&&(this._frameQueue=new h,this._frameTask=e.scheduler.registerTask(e.task,(e=>this._update(e)),(()=>this._frameQueue.length>0)))}var I=e.prototype;return I.destroy=function(){this._frameTask&&(this._frameTask.remove(),this._frameTask=null,this._frameQueue.cancelAll(),this._frameQueue=null),this.clearCache(),this._geometryQueryCache&&this._geometryQueryCache.destroy(),this._changeHandle&&(this._changeHandle.remove(),this._changeHandle=null),this.fieldsIndex.destroy()},I.clearCache=function(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null},I.executeQuery=async function(e={},t){let s,r=i.clone(e);try{r=await this._schedule((()=>g.normalizeQuery(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t)}catch(a){if(a!==g.QUERY_ENGINE_EMPTY_RESULT)throw a;s=new w([],null,this)}return s.createQueryResponse(r)},I.executeQueryForCount=async function(e={},t){let s,r=i.clone(e);r.returnGeometry=!1,r.returnCentroid=!1,r.outSR=null;try{r=await this._schedule((()=>g.normalizeQuery(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t)}catch(a){if(a!==g.QUERY_ENGINE_EMPTY_RESULT)throw a;return 0}return s.createQueryResponseForCount(r)},I.executeQueryForExtent=async function(e={},t){let s,r=i.clone(e);const a=r.outSR;try{r=await this._schedule((()=>g.normalizeQuery(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),r.returnGeometry=!0,r.returnCentroid=!1,r.outSR=null,s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t);const e=s.size;if(!e)return{count:e,extent:null};p.set(C,p.NEGATIVE_INFINITY),this.featureStore.forEachBounds(s.items,(e=>p.expandWithAABB(C,e)),A);const i={xmin:C[0],ymin:C[1],xmax:C[3],ymax:C[4],spatialReference:g.cleanFromGeometryEngine(this.spatialReference)};this.hasZ&&isFinite(C[2])&&isFinite(C[5])&&(i.zmin=C[2],i.zmax=C[5]);const n=m.project(i,s.spatialReference,a);if(n.spatialReference=g.cleanFromGeometryEngine(a||this.spatialReference),n.xmax-n.xmin==0){const e=c.getMetersPerUnitForSR(n.spatialReference);n.xmin-=e,n.xmax+=e}if(n.ymax-n.ymin==0){const e=c.getMetersPerUnitForSR(n.spatialReference);n.ymin-=e,n.ymax+=e}if(this.hasZ&&null!=n.zmin&&null!=n.zmax&&n.zmax-n.zmin==0){const e=c.getMetersPerUnitForSR(n.spatialReference);n.zmin-=e,n.zmax+=e}return{count:e,extent:n}}catch(n){if(n===g.QUERY_ENGINE_EMPTY_RESULT)return{count:0,extent:null};throw n}},I.executeQueryForIds=async function(e={},t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))},I.executeQueryForIdSet=async function(e={},t){let s,r=i.clone(e);r.returnGeometry=!1,r.returnCentroid=!1,r.outSR=null;try{r=await this._schedule((()=>g.normalizeQuery(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t);const e=s.items,i=new Set;return await this._reschedule((()=>{for(const t of e)i.add(s.featureAdapter.getObjectId(t))}),t),i}catch(a){if(a===g.QUERY_ENGINE_EMPTY_RESULT)return new Set;throw a}},I.executeQueryForSnapping=async function(e,t){const{point:i,distance:r,types:n}=e;if(0===n)return{candidates:[]};const c=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),o=!a.equals(i.spatialReference,this.spatialReference);o&&await m.checkProjectionSupport(i.spatialReference,this.spatialReference);const h="number"==typeof r?r:r.x,d="number"==typeof r?r:r.y,y={xmin:i.x-h,xmax:i.x+h,ymin:i.y-d,ymax:i.y+d,spatialReference:i.spatialReference},f=o?m.project(y,this.spatialReference):y;if(!f)return{candidates:[]};const p=(await l.normalizeCentralMeridian(u.fromJSON(i),null,{signal:t}))[0],_=(await l.normalizeCentralMeridian(u.fromJSON(f),null,{signal:t}))[0];if(s.isNone(p)||s.isNone(_))return{candidates:[]};let g=new w(this._searchFeatures(this._getQueryBBoxes(_.toJSON())),null,this);g=await this._reschedule((()=>g.executeObjectIdsQuery(c)),t),g=await this._reschedule((()=>g.executeTimeQuery(c)),t),g=await this._reschedule((()=>g.executeAttributesQuery(c)),t);const x=p.toJSON(),Q=o?m.project(x,this.spatialReference):x,S=o?Math.max(f.xmax-f.xmin,f.ymax-f.ymin)/2:r;return g.createSnappingResponse({...e,point:Q,distance:S},i.spatialReference)},I.executeQueryForLatestObservations=async function(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new r(R,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let s,a=i.clone(e);try{a=await this._schedule((()=>g.normalizeQuery(a,this.definitionExpression,this.spatialReference)),t),a=await this._reschedule((()=>this._checkQuerySupport(a)),t),s=await this._reschedule((()=>this._executeGeometryQuery(a,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(a)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(a)),t),s=await this._reschedule((()=>s.executeTimeQuery(a)),t),s=await this._reschedule((()=>s.executeAttributesQuery(a)),t),s=await this._reschedule((()=>s.filterLatest()),t)}catch(n){if(n!==g.QUERY_ENGINE_EMPTY_RESULT)throw n;s=new w([],null,this)}return s.createQueryResponse(a)},I._schedule=async function(e,t){return this._frameQueue?this._frameQueue.push(e,t):e()},I._reschedule=async function(e,t){return this._frameQueue?this._frameQueue.unshift(e,t):e()},I._update=function(e){for(this._budget=e;!e.done&&this._frameQueue&&this._frameQueue.process();)e.madeProgress();this._budget=null},I._getAll=function(){if(!this._allItems){const e=[];this.featureStore.forEach((t=>e.push(t))),this._allItems=new w(e,null,this)}return this._allItems},I._executeGeometryQuery=async function(e,t){const{geometry:i,outSR:r,spatialRel:n,returnGeometry:u,returnCentroid:c}=e,o=u||c,h=a.isValid(r)&&!a.equals(this.spatialReference,r),l=this._geometryQueryCache?h&&o?JSON.stringify({geometry:i,spatialRelationship:n,outSpatialReference:r}):JSON.stringify({geometry:i,spatialRelationship:n}):null;if(l){const e=this._geometryQueryCache.get(l);if(!s.isUndefined(e))return e}const d=async e=>{if(h&&o){const t=await e.project(r);return l&&this._geometryQueryCache.put(l,t,t.size||1),t}return l&&this._geometryQueryCache.put(l,e,e.size||1),e};if(!i)return d(this._getAll());const y=this.featureAdapter;if("esriSpatialRelDisjoint"===n){const e=this._searchFeatures(this._getQueryBBoxes(i));if(!e.length)return d(this._getAll());let s,r;const a=new Set;for(const t of e)a.add(y.getObjectId(t));await this._reschedule((()=>{let e=0;s=new Array(a.size),this.featureStore.forEach((t=>s[e++]=t)),r=a}),t);return d(await this._reschedule((async()=>{const e=await x.getSpatialQueryOperator(n,i,this.geometryType,this.hasZ,this.hasM),a=t=>!r.has(y.getObjectId(t))||e(y.getGeometry(t));return new w(await this._runSpatialFilter(s,a,t),i,this)}),t))}const f=this._searchFeatures(this._getQueryBBoxes(i));if(!f.length){const e=new w([],i,this);return l&&this._geometryQueryCache.put(l,e,e.size||1),e}if(this._canExecuteSoloPass(i,e))return d(new w(f,i,this));const p=await x.getSpatialQueryOperator(n,i,this.geometryType,this.hasZ,this.hasM),m=await this._runSpatialFilter(f,(e=>p(y.getGeometry(e))),t);return d(new w(m,i,this))},I._runSpatialFilter=async function(e,t,i){if(!t)return e;if(!this._budget)return e.filter((e=>t(e)));let s=0;const r=new Array,a=async()=>{for(;s<e.length;){const n=e[s];t(n)&&r.push(n),this._budget.done&&await this._reschedule((()=>a()),i),++s}};return this._reschedule((()=>a()),i).then((()=>r))},I._canExecuteSoloPass=function(e,t){const{geometryType:i}=this,{spatialRel:s}=t;return x.canQueryWithRBush(e)&&("esriSpatialRelEnvelopeIntersects"===s||"esriGeometryPoint"===i&&("esriSpatialRelIntersects"===s||"esriSpatialRelContains"===s||"esriSpatialRelWithin"===s))},I._getQueryBBoxes=function(e){if(x.canQueryWithRBush(e)){if(u.isExtent(e))return[o.fromValues(e.xmin,e.ymin,e.xmax,e.ymax)];if(u.isPolygon(e))return e.rings.map((e=>o.fromValues(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[n.getBoundsXY(o.create(),e)]},I._searchFeatures=function(e){for(const s of e)this.featureStore.forEachInBounds(s,(e=>{E.add(e)}));const t=new Array(E.size);let i=0;return E.forEach((e=>t[i++]=e)),E.clear(),t},I._checkQuerySupport=async function(e){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new r(R,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),x.checkSpatialQuerySupport(e,this.geometryType,this.spatialReference),m.checkProjectionSupport(this.spatialReference,e.outSR)]).then((()=>e))},I._checkAttributesQuerySupport=function(e){const{outFields:t,orderByFields:i,returnDistinctValues:s,outStatistics:a}=e,n=a?a.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())):[];if(i&&i.length>0){const e=" asc",t=" desc",s=i.map((i=>{const s=i.toLowerCase();return s.indexOf(e)>-1?s.split(e)[0]:s.indexOf(t)>-1?s.split(t)[0]:i})).filter((e=>-1===n.indexOf(e)));_.validateFields(this.fieldsIndex,s,"orderByFields contains missing fields")}if(t&&t.length>0)_.validateFields(this.fieldsIndex,t,"outFields contains missing fields");else if(s)throw new r(R,"outFields should be specified for returnDistinctValues",{query:e});_.validateWhere(this.fieldsIndex,e.where)},I._checkStatisticsQuerySupport=async function(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:s}=e,a=i&&i.length,n=t&&t.length;if(s){if(!a||!n)throw new r(R,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});_.validateHaving(this.fieldsIndex,s,t)}if(n){if(!S(t))return;const s=t.map((e=>e.onStatisticField));_.validateFields(this.fieldsIndex,s,"onStatisticFields contains missing fields"),a&&_.validateFields(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const i of t){const{onStatisticField:t,statisticType:s}=i;if(("percentile_disc"===s||"percentile_cont"===s)&&"statisticParameters"in i){const{statisticParameters:t}=i;if(!t)throw new r(R,"statisticParamters should be set for percentile type",{definition:i,query:e})}else if("count"!==s&&t&&_.hasInvalidFieldType(t,this.fieldsIndex))throw new r(R,"outStatistics contains non-numeric fields",{definition:i,query:e})}}},t._createClass(e,[{key:"featureAdapter",get:function(){return this.featureStore.featureAdapter}},{key:"fullExtent",get:function(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:g.cleanFromGeometryEngine(this.spatialReference)}:null}},{key:"timeExtent",get:function(){return this.timeInfo?(this._timeExtent||(this._timeExtent=Q.getTimeExtent(this.timeInfo,this.featureStore)),this._timeExtent):null}}]),e}();const A=p.create(),C=p.create();e.Feature=I,e.default=T,Object.defineProperty(e,"__esModule",{value:!0})}));
