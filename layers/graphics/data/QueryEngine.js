/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/lang","../../../core/maybe","../../../core/Error","../../../core/promiseUtils","../../../geometry/support/spatialReferenceUtils","../../../geometry/support/boundsUtils","../../../geometry/support/jsonUtils","../../../core/unitUtils","../../../geometry/support/aaBoundingRect","../../../core/MemCache","../../support/PromiseQueue","../../support/FieldsIndex","./QueryEngineCapabilities","../../../geometry/support/aaBoundingBox","./projectionSupport","./attributeSupport","../../../chunks/spatialQuerySupport","./timeSupport","./QueryEngineResult"],(function(e,t,i,s,r,n,a,u,c,o,h,l,d,y,f,p,m,_,g,x,Q){"use strict";const w="feature-store:unsupported-query";const S=new Set,I=new l.MemCacheStorage(2e6);let E=0,R=function(){function e(e){this.capabilities={query:f.queryCapabilities},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new l.MemCache(E+++"$$",I)),this.fieldsIndex=new y(e.fields),e.scheduler&&e.task&&(this._frameQueue=new d,this._frameTask=e.scheduler.registerTask(e.task,(e=>this._update(e)),(()=>this._frameQueue.length>0)))}var R=e.prototype;return R.destroy=function(){this._frameTask&&(this._frameTask.remove(),this._frameTask=null,this._frameQueue.cancelAll(),this._frameQueue=null),this.clearCache(),this._geometryQueryCache&&this._geometryQueryCache.destroy(),this._changeHandle&&(this._changeHandle.remove(),this._changeHandle=null),this.fieldsIndex.destroy()},R.clearCache=function(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null},R.executeQuery=async function(e={},t){let s,r=i.clone(e);try{r=await this._schedule((()=>g.normalizeQuery(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t)}catch(e){if(e!==g.QUERY_ENGINE_EMPTY_RESULT)throw e;s=new Q([],null,this)}return s.createQueryResponse(r)},R.executeQueryForCount=async function(e={},t){let s,r=i.clone(e);r.returnGeometry=!1,r.returnCentroid=!1,r.outSR=null;try{r=await this._schedule((()=>g.normalizeQuery(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t)}catch(e){if(e!==g.QUERY_ENGINE_EMPTY_RESULT)throw e;return 0}return s.createQueryResponseForCount(r)},R.executeQueryForExtent=async function(e={},t){let s,r=i.clone(e);const n=r.outSR;try{r=await this._schedule((()=>g.normalizeQuery(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),r.returnGeometry=!0,r.returnCentroid=!1,r.outSR=null,s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t);const e=s.size;if(!e)return{count:e,extent:null};p.set(b,p.NEGATIVE_INFINITY),this.featureStore.forEachBounds(s.items,(e=>p.expandWithAABB(b,e)),F);const i={xmin:b[0],ymin:b[1],xmax:b[3],ymax:b[4],spatialReference:g.cleanFromGeometryEngine(this.spatialReference)};this.hasZ&&isFinite(b[2])&&isFinite(b[5])&&(i.zmin=b[2],i.zmax=b[5]);const a=m.project(i,s.spatialReference,n);if(a.spatialReference=g.cleanFromGeometryEngine(n||this.spatialReference),a.xmax-a.xmin==0){const e=o.getMetersPerUnitForSR(a.spatialReference);a.xmin-=e,a.xmax+=e}if(a.ymax-a.ymin==0){const e=o.getMetersPerUnitForSR(a.spatialReference);a.ymin-=e,a.ymax+=e}if(this.hasZ&&null!=a.zmin&&null!=a.zmax&&a.zmax-a.zmin==0){const e=o.getMetersPerUnitForSR(a.spatialReference);a.zmin-=e,a.zmax+=e}return{count:e,extent:a}}catch(e){if(e===g.QUERY_ENGINE_EMPTY_RESULT)return{count:0,extent:null};throw e}},R.executeQueryForIds=async function(e={},t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))},R.executeQueryForIdSet=async function(e={},t){let s,r=i.clone(e);r.returnGeometry=!1,r.returnCentroid=!1,r.outSR=null;try{r=await this._schedule((()=>g.normalizeQuery(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t);const e=s.items,i=new Set;return await this._reschedule((()=>{for(const t of e)i.add(s.featureAdapter.getObjectId(t))}),t),i}catch(e){if(e===g.QUERY_ENGINE_EMPTY_RESULT)return new Set;throw e}},R.executeQueryForLatestObservations=async function(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new r(w,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let s,n=i.clone(e);try{n=await this._schedule((()=>g.normalizeQuery(n,this.definitionExpression,this.spatialReference)),t),n=await this._reschedule((()=>this._checkQuerySupport(n)),t),s=await this._reschedule((()=>this._executeGeometryQuery(n,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(n)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(n)),t),s=await this._reschedule((()=>s.executeTimeQuery(n)),t),s=await this._reschedule((()=>s.executeAttributesQuery(n)),t),s=await this._reschedule((()=>s.filterLatest()),t)}catch(e){if(e!==g.QUERY_ENGINE_EMPTY_RESULT)throw e;s=new Q([],null,this)}return s.createQueryResponse(n)},R._schedule=async function(e,t){return this._frameQueue?this._frameQueue.push(e,t):e()},R._reschedule=async function(e,t){return this._frameQueue?this._frameQueue.unshift(e,t):e()},R._update=function(e){for(this._budget=e;!e.done&&this._frameQueue&&this._frameQueue.process();)e.madeProgress();this._budget=null},R._getAll=function(){if(!this._allItems){const e=[];this.featureStore.forEach((t=>e.push(t))),this._allItems=new Q(e,null,this)}return this._allItems},R._executeGeometryQuery=async function(e,t){const{geometry:i,outSR:r,spatialRel:n}=e,u=a.isValid(r)&&!a.equals(this.spatialReference,r),c=this._geometryQueryCache?u?JSON.stringify({geometry:i,spatialRelationship:n,outSpatialReference:r}):JSON.stringify({geometry:i,spatialRelationship:n}):null;if(c){const e=this._geometryQueryCache.get(c);if(!s.isUndefined(e))return e}const o=async t=>{if(u&&(e.returnGeometry||e.returnCentroid)){const e=await t.project(r);return c&&this._geometryQueryCache.put(c,e,e.size||1),e}return c&&this._geometryQueryCache.put(c,t,t.size||1),t};if(!i)return o(this._getAll());const h=this.featureAdapter;if("esriSpatialRelDisjoint"===n){const e=this._searchFeatures(this._getQueryBBoxes(i));if(!e.length)return o(this._getAll());let s,r;const a=new Set;for(const t of e)a.add(h.getObjectId(t));await this._reschedule((()=>{let e=0;s=new Array(a.size),this.featureStore.forEach((t=>s[e++]=t)),r=a}),t);return o(await this._reschedule((async()=>{const e=await g.getSpatialQueryOperator(n,i,this.geometryType,this.hasZ,this.hasM);return new Q(await this._runSpatialFilter(s,(t=>!r.has(h.getObjectId(t))||e(h.getGeometry(t))),t),i,this)}),t))}const l=this._searchFeatures(this._getQueryBBoxes(i));if(!l.length){const e=new Q([],i,this);return c&&this._geometryQueryCache.put(c,e,e.size||1),e}if(this._canExecuteSoloPass(i,e))return o(new Q(l,i,this));const d=await g.getSpatialQueryOperator(n,i,this.geometryType,this.hasZ,this.hasM),y=await this._runSpatialFilter(l,(e=>d(h.getGeometry(e))),t);return o(new Q(y,i,this))},R._runSpatialFilter=async function(e,t,i){if(!t)return e;if(!this._budget)return e.filter((e=>t(e)));let s=0;const r=new Array,n=async()=>{for(;s<e.length;){const a=e[s];t(a)&&r.push(a),this._budget.done&&await this._reschedule((()=>n()),i),++s}};return this._reschedule((()=>n()),i).then((()=>r))},R._canExecuteSoloPass=function(e,t){const{geometryType:i}=this,{spatialRel:s}=t;return g.canQueryWithRBush(e)&&("esriSpatialRelEnvelopeIntersects"===s||"esriGeometryPoint"===i&&("esriSpatialRelIntersects"===s||"esriSpatialRelContains"===s||"esriSpatialRelWithin"===s))},R._getQueryBBoxes=function(e){if(g.canQueryWithRBush(e)){if(c.isExtent(e))return[h.fromValues(e.xmin,e.ymin,e.xmax,e.ymax)];if(c.isPolygon(e))return e.rings.map((e=>h.fromValues(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[u.getBoundsXY(h.create(),e)]},R._searchFeatures=function(e){for(const t of e)this.featureStore.forEachInBounds(t,(e=>{S.add(e)}));const t=new Array(S.size);let i=0;return S.forEach((e=>t[i++]=e)),S.clear(),t},R._checkQuerySupport=async function(e){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new r(w,"Unsupported query options",{query:e});return n.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),g.checkSpatialQuerySupport(e,this.geometryType,this.spatialReference),m.checkProjectionSupport(this.spatialReference,e.outSR)]).then((()=>e))},R._checkAttributesQuerySupport=function(e){const{outFields:t,orderByFields:i,returnDistinctValues:s,outStatistics:n}=e,a=n?n.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())):[];if(i&&i.length>0){const e=" asc",t=" desc",s=i.map((i=>{const s=i.toLowerCase();return s.indexOf(e)>-1?s.split(e)[0]:s.indexOf(t)>-1?s.split(t)[0]:i})).filter((e=>-1===a.indexOf(e)));_.validateFields(this.fieldsIndex,s,"orderByFields contains missing fields")}if(t&&t.length>0)_.validateFields(this.fieldsIndex,t,"outFields contains missing fields");else if(s)throw new r(w,"outFields should be specified for returnDistinctValues",{query:e});_.validateWhere(this.fieldsIndex,e.where)},R._checkStatisticsQuerySupport=async function(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:s}=e,n=i&&i.length,a=t&&t.length;if(s){if(!n||!a)throw new r(w,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});_.validateHaving(this.fieldsIndex,s,t)}if(a){if(!function(e){return e.every((e=>"exceedslimit"!==e.statisticType))}(t))return;const s=t.map((e=>e.onStatisticField));_.validateFields(this.fieldsIndex,s,"onStatisticFields contains missing fields"),n&&_.validateFields(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const i of t){const{onStatisticField:t,statisticType:s}=i;if(("percentile_disc"===s||"percentile_cont"===s)&&"statisticParameters"in i){const{statisticParameters:t}=i;if(!t)throw new r(w,"statisticParamters should be set for percentile type",{definition:i,query:e})}else if("count"!==s&&t&&_.hasInvalidFieldType(t,this.fieldsIndex))throw new r(w,"outStatistics contains non-numeric fields",{definition:i,query:e})}}},t._createClass(e,[{key:"featureAdapter",get:function(){return this.featureStore.featureAdapter}},{key:"fullExtent",get:function(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:g.cleanFromGeometryEngine(this.spatialReference)}:null}},{key:"timeExtent",get:function(){return this.timeInfo?(this._timeExtent||(this._timeExtent=x.getTimeExtent(this.timeInfo,this.featureStore)),this._timeExtent):null}}]),e}();const F=p.create(),b=p.create();e.Feature=function(e,t=null,i,s,r){this.attributes=e,this.geometry=i,this.centroid=s,this.filterFlags=r,this.groupId=-1,this.displayId=t},e.default=R,Object.defineProperty(e,"__esModule",{value:!0})}));
