/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../core/has","../../../core/lang","../../../core/maybe","../../../core/Logger","../../../core/accessorSupport/ensureType","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/decorators/subclass","../../../core/Error","../../../core/urlUtils","../../../core/uuid","../../../portal/support/resourceExtension","../../../core/promiseUtils","../../../core/Accessor","../../../core/Collection","../../../core/Promise","../../../core/asyncUtils","../../../core/Handles","../../../core/watchUtils","../../support/arcgisLayerUrl","../../../tasks/support/StatisticDefinition","../../../views/support/WatchUpdatingTracking","../../../views/3d/support/debugFlags","../../../portal/support/geometryServiceUtils","../../../views/3d/layers/support/FeatureTileFetcher3D","../../../views/3d/layers/support/FeatureTileFetcher3DDebugger"],(function(e,t,i,r,s,a,n,o,c,l,u,h,d,p,m,y,f,g,F,x,v,_,T,E,w,S,C){"use strict";var b;const D=a.getLogger("esri.layers.graphics.controllers.FeatureTileController3D");let O=b=function(t){function i(e){var i;return(i=t.call(this,e)||this).type="feature-tile-3d",i.watchUpdatingTracking=new T.WatchUpdatingTracking,i.serviceDataExtent=null,i.serviceDataCount=b.constants.NO_SERVICE_DATA_COUNT,i.vertexLimitExceeded=!1,i.displayFeatureLimit=null,i.suspended=!1,i.tileFetcher=null,i.handles=new F,i.fetchDataInfoPromise=null,i.fetchDataInfoAbortController=null,i.lifeCycleAbortController=p.createAbortController(),i}e._inheritsLoose(i,t);var a=i.prototype;return a.approximateExtentSizeAtScale=function(e,t){const i=this.layerView.view,r=Math.ceil((i.width/t.pixelSize+i.height/t.pixelSize)/2),s=t.levels[0];return r*((s.tileSize[0]/(s.scale/e)+s.tileSize[1]/(s.scale/e))/2)},a.initialize=function(){this.watchUpdatingTracking.add(this,"vertexLimitInfo",(()=>this.watchUpdatingTracking.addPromise(this.updateVertexLimitExceeded(null,this.lifeCycleAbortController.signal)))),this.watchUpdatingTracking.add(this,"mode",(()=>this.modeChanged()),2),this.addResolvingPromise(p.resolve().then((()=>this.verifyCapabilities())).then((()=>this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo()))).then((()=>this.initializeTileFetcher())))},a.verifyCapabilities=function(){const e=this.layerView.layer;if(!e.get("capabilities.operations.supportsQuery"))throw new l("graphicscontroller:query-capability-required","Service requires query capabilities to be used as a feature layer",{layer:e})},a.destroy=function(){this.cancelFetchServiceDataInfo(),this.tileFetcher=s.destroyMaybe(this.tileFetcher),this.handles=s.destroyMaybe(this.handles),this.tilesHandle=s.removeMaybe(this.tilesHandle),this.lifeCycleAbortController&&(this.lifeCycleAbortController.abort(),this.lifeCycleAbortController=null),this.watchUpdatingTracking.destroy(),this._set("watchUpdatingTracking",null)},a.suspend=function(){this.suspended||(this.suspended=!0,s.isSome(this.tileFetcher)&&this.tileFetcher.suspend())},a.resume=function(){this.suspended&&(this.suspended=!1,s.isSome(this.tileFetcher)&&this.tileFetcher.resume())},a.restart=function(){const e=()=>{s.isSome(this.tileFetcher)&&this.tileFetcher.restart()};this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo().then(e,e))},a.refetch=function(){const e=()=>{s.isSome(this.tileFetcher)&&this.tileFetcher.refetch()};this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo().then(e,e))},a.initializeTileFetcher=function(){const e=this.layerView.view;if(!e)return;const t=x.whenOnce(e.featureTiles,"tilingScheme",this.lifeCycleAbortController.signal);this.watchUpdatingTracking.addPromise(t),t.then((()=>{const{layerView:t,tileDescriptors:i}=this,r=t.layer,s=new S.FeatureTileFetcher3D({context:this.context,filterExtent:this.filteredDataExtent,tileDescriptors:i,features:this.graphics});this.tileFetcher=s,this.suspended?this.tileFetcher.suspend():this.tileFetcher.resume();const a=this.layerView.view.resourceController;a&&(this.handles.add(a.memoryController.events.on("quality-changed",(e=>{s.memoryFactor=e}))),this.tileFetcher.memoryFactor=a.memoryController.memoryFactor);const n="polygon"===this.context.geometryType?"polygonLodFactor":"polyline"===this.context.geometryType?"polylineLodFactor":null;n&&this.handles.add(x.init(this.layerView.view,"qualitySettings.graphics3D."+n,(e=>{s.lodFactor=e||1})));this.watchUpdatingTracking.add(r,"createQueryVersion",(()=>this.dataFilterChanged())),this.watchUpdatingTracking.add(t,"availableFields",((e,t)=>this.availableFieldsChanged(t,e))),this.watchUpdatingTracking.add(t,"requiredFields",((e,t)=>this.requiredFieldsChanged(t,e))),this.handles.add([r.on("apply-edits",(e=>this.applyEdits(e))),this.watch("filteredDataExtent",(e=>s.filterExtent=e),!0),this.watch("tileDescriptors",(e=>s.tileDescriptors=e),!0),x.init(this,"maximumNumberOfFeatures",(e=>{s.maximumNumberOfFeatures=e,s.useTileCount=this.serviceDataCount>e}),!0),x.init(this,"serviceDataCount",(e=>s.useTileCount=e>this.maximumNumberOfFeatures),!0),x.init(E,"FEATURE_TILE_FETCH_SHOW_TILES",(t=>{t&&s&&!s.debugger?(s.debugger=new C.FeatureTileFetcher3DDebugger(s,e.featureTiles.tilingScheme.toTileInfo(),e),s.debugger.update()):!t&&this.tileFetcher&&s.debugger&&(s.debugger.destroy(),s.debugger=null)}))]),this.supportsExceedsLimitQuery||this.watchUpdatingTracking.add(this,"maxTotalSnapshotVertices",(()=>this.watchUpdatingTracking.addPromise(this.updateVertexLimitExceeded(null,this.lifeCycleAbortController.signal))))})).catch((()=>{}))},a.modeChanged=function(){switch(this.mode){case"tiles":this.tilesHandle||(this.tilesHandle=this.layerView.view.featureTiles.addClient());break;default:D.warn("Unhandled feature layer mode "+this.mode);case"snapshot":s.isSome(this.tilesHandle)&&(this.tilesHandle.remove(),this.tilesHandle=null)}},a.dataFilterChanged=function(){this._set("maxTotalSnapshotVertices",0),this.notifyChange("maxTotalSnapshotVertices"),this.refetch()},a.applyEdits=function(e){s.isNone(this.tileFetcher)||this.tileFetcher.applyEdits(e).then((e=>{e&&(e.deletedFeatures.length||e.updatedFeatures.length||e.addedFeatures.length)&&this.watchUpdatingTracking.addPromise(this.updateServiceDataExtent(this.lifeCycleAbortController.signal))})).catch((e=>{if(!p.isAbortError(e))throw e}))},a.availableFieldsChanged=function(e,t){s.isSome(this.tileFetcher)&&V(this.tileFetcher.availableFields,t)&&this.refetch()},a.requiredFieldsChanged=function(e,t){s.isSome(this.tileFetcher)&&V(this.tileFetcher.availableFields,t)&&this.restart()},a.createVertexLimitExceededQuery=function(e){const t=this.layerView.layer,i=t.createQuery();return i.outStatistics=[new _({statisticType:"exceedslimit",maxVertexCount:e,outStatisticFieldName:"exceedslimit",maxPointCount:1e8,maxRecordCount:1e8})],t.capabilities.query.supportsCacheHint&&(i.cacheHint=!0),i},a.createDataInfoQuery=function(){const e=this.layerView.layer,t=e.createQuery();return t.outSpatialReference=this.layerView.view.spatialReference,e.capabilities.query.supportsCacheHint&&(t.cacheHint=!0),t},a.fullExtentIsAccurate=function(){const e=this.layerView.layer;if(e.definitionExpression)return!1;switch(e.type){case"feature":return v.isHostedAgolService(e.url);case"csv":case"geojson":case"ogc-feature":return!0;default:return}},a.updateServiceDataExtent=async function(e){try{await this.tryUpdateServiceDataExtent(e)}catch(e){p.isAbortError(e)||this._set("serviceDataExtent",r.clone(this.layerView.fullExtentInLocalViewSpatialReference))}},a.tryUpdateServiceDataExtent=async function(e){const t=this.layerView,i=t.layer,s=i.capabilities.query.supportsExtent,a=r.clone(t.fullExtentInLocalViewSpatialReference),n=i.fullExtent,o=this.fullExtentIsAccurate(),c=this.serviceDataCount;if(s&&c<=b.constants.MAX_FEATURE_COUNT_FOR_EXTENT&&(!a||!o)&&"queryExtent"in i){const t=this.createDataInfoQuery(),r=await i.queryExtent(t,{timeout:b.constants.QUERY_EXTENT_TIMEOUT,signal:e});this._set("serviceDataExtent",r.extent)}else if(a)this._set("serviceDataExtent",a);else if(n){const r="portalItem"in i?i.portalItem:null,s=await w.projectGeometry(n,t.view.spatialReference,r,e);this._set("serviceDataExtent",s)}else this._set("serviceDataExtent",null)},a.updateServiceDataCount=async function(e){const t=this.layerView.layer;if(!("queryFeatureCount"in t)){const{NO_SERVICE_DATA_COUNT:e}=b.constants;return void this._set("serviceDataCount",e)}const i=await g.result(t.queryFeatureCount(this.createDataInfoQuery(),{timeout:b.constants.QUERY_STATISTICS_TIMEOUT,signal:e}));if(!0===i.ok)this._set("serviceDataCount",i.value);else{if(p.isAbortError(i.error))throw i.error;const{NO_SERVICE_DATA_COUNT:e}=b.constants;this._set("serviceDataCount",e)}},a.updateVertexLimitExceeded=async function(e,t){const i=this.vertexLimitInfo;if(s.isNone(i))return void this._set("vertexLimitExceeded",!1);const r=i.primitivesPerFeature<=0,a=this.minimumNumberOfVerticesForGeometry>1;if(!r&&!a)return void this._set("vertexLimitExceeded",!1);const{primitivesPerFeature:n,primitivesPerCoordinate:o,maximumTotalNumberOfPrimitives:c}=i;let l;0!==n&&s.isSome(e)&&await e;const u=this.serviceDataCount,h=u!==b.constants.NO_SERVICE_DATA_COUNT;if(l=h?Math.ceil((c-u*n)/(o||1)):Math.ceil(c/(o||1)),a&&(l=Math.min(l,I)),h&&this.minimumNumberOfVerticesForGeometry*u>l)return void this._set("vertexLimitExceeded",!0);if(!this.supportsExceedsLimitQuery)return void this._set("vertexLimitExceeded",this.maxTotalSnapshotVertices>l);const d=await g.result(this.layerView.layer.queryFeatures(this.createVertexLimitExceededQuery(l),{timeout:b.constants.QUERY_STATISTICS_TIMEOUT,signal:t}));if(!1===d.ok){if(p.isAbortError(d.error))throw d.error;return void this._set("vertexLimitExceeded",!1)}const m=d.value.features[0];m&&m.attributes?this._set("vertexLimitExceeded",!!m.attributes.exceedslimit):this._set("vertexLimitExceeded",!1)},a.fetchServiceDataInfo=async function(){this.cancelFetchServiceDataInfo();let e=p.createAbortController();const t=e.signal,i=this.updateServiceDataCount(t),r=p.eachAlways([i,this.updateVertexLimitExceeded(i,t)]),s=r.then((()=>this.updateServiceDataExtent(t))).catch((e=>{p.isAbortError(e)||D.error("#fetchServiceDataInfo()",e)})).then((()=>{s===this.fetchDataInfoPromise&&(this.fetchDataInfoPromise=null,this.fetchDataInfoAbortController=null),e=null}));return e&&(this.fetchDataInfoPromise=s),this.fetchDataInfoAbortController=e,r.then((()=>{}),(()=>{}))},a.cancelFetchServiceDataInfo=function(){const e=this.fetchDataInfoAbortController;e&&(this.fetchDataInfoAbortController=null,this.fetchDataInfoPromise=null,e.abort())},e._createClass(i,[{key:"extent",set:function(e){if(e&&!e.spatialReference.equals(this.layerView.view.spatialReference))return void D.error("#extent=","extent needs to be in the same spatial reference as the view");const t=this._get("extent");if(t===e)return;if(t&&e&&t.equals(e))return;const i=e?e.clone():null;this._set("extent",i)}},{key:"updating",get:function(){return!!(s.isSome(this.tileFetcher)&&this.tileFetcher.updating||null!=this.fetchDataInfoPromise||"tiles"===this.mode&&this.layerView.view.featureTiles&&this.layerView.view.featureTiles.updating||this.watchUpdatingTracking&&this.watchUpdatingTracking.updating)}},{key:"updatingTotal",get:function(){return this.updating&&s.isSome(this.tileFetcher)?this.tileFetcher.updatingTotal:0}},{key:"updatingRemaining",get:function(){return this.updating&&s.isSome(this.tileFetcher)?this.tileFetcher.updatingRemaining:0}},{key:"expectedFeatureDiff",get:function(){return this.updating&&s.isSome(this.tileFetcher)?this.tileFetcher.expectedFeatureDiff:0}},{key:"memoryForUnusedFeatures",get:function(){return s.isSome(this.tileFetcher)?this.tileFetcher.memoryForUnusedFeatures:0}},{key:"maximumNumberOfFeaturesExceeded",get:function(){return!(!s.isSome(this.tileFetcher)||!this.tileFetcher.maximumNumberOfFeaturesExceeded)}},{key:"filteredDataExtent",get:function(){return this.extent}},{key:"maximumNumberOfFeatures",get:function(){return s.isSome(this.displayFeatureLimit)?this.displayFeatureLimit.maximumNumberOfFeatures:0},set:function(e){e!==this.maximumNumberOfFeatures&&(null==e?this._clearOverride("maximumNumberOfFeatures"):this._override("maximumNumberOfFeatures",e))}},{key:"hasMaximumNumberOfFeaturesOverride",get:function(){return this._isOverridden("maximumNumberOfFeatures")}},{key:"mode",get:function(){if(this.serviceDataCount===b.constants.NO_SERVICE_DATA_COUNT||this.vertexLimitExceeded)return"tiles";const{layer:e,view:t}=this.layerView,i=t&&t.featureTiles,r=i&&i.tilingScheme;if(e&&e.minScale&&this.serviceDataExtent&&r){const t=this.approximateExtentSizeAtScale(e.minScale,r);if((this.serviceDataExtent.width/t+this.serviceDataExtent.height/t)/2>b.constants.MAX_SNAPSHOT_MIN_SCALE_FACTOR)return"tiles"}return!this.maximumNumberOfFeatures||this.serviceDataCount<=this.maximumNumberOfFeatures?"snapshot":"tiles"}},{key:"maxTotalSnapshotVertices",get:function(){const e=this._get("maxTotalSnapshotVertices")||0,t="snapshot"===this.mode&&s.isSome(this.tileFetcher)&&this.tileFetcher.totalVertices||0;return Math.max(e,t)}},{key:"tileDescriptors",get:function(){return"snapshot"===this.mode?new y([{id:"dummy-tile-full-extent",lij:[0,0,0]}]):this.layerView.view.featureTiles?this.layerView.view.featureTiles.tiles:new y}},{key:"test",get:function(){return{fetchDataInfoPromise:this.fetchDataInfoPromise,tileFetcher:this.tileFetcher}}},{key:"vertexLimitInfo",get:function(){if(s.isNone(this.displayFeatureLimit)||s.isNone(this.displayFeatureLimit.averageSymbolComplexity))return null;const{averageSymbolComplexity:e,maximumTotalNumberOfPrimitives:t}=this.displayFeatureLimit,{primitivesPerCoordinate:i,primitivesPerFeature:r}=e,a=this._get("vertexLimitInfo");return s.isNone(a)||a.maximumTotalNumberOfPrimitives!==t||a.primitivesPerCoordinate!==i||a.primitivesPerFeature!==r?{primitivesPerCoordinate:i,primitivesPerFeature:r,maximumTotalNumberOfPrimitives:t}:a}},{key:"supportsExceedsLimitQuery",get:function(){const e=this.layerView.layer;return e.capabilities&&e.capabilities.operations&&e.capabilities.operations.supportsExceedsLimitStatistics}},{key:"minimumNumberOfVerticesForGeometry",get:function(){switch(this.layerView.layer.geometryType){case"point":case"multipoint":return 1;case"polygon":return 4;case"polyline":return 2;case"multipatch":case"mesh":return 3;default:return 0}}},{key:"debug",get:function(){return{storedFeatures:s.isSome(this.tileFetcher)?this.tileFetcher.storedFeatures:0,totalFeatures:s.isSome(this.tileFetcher)?this.tileFetcher.totalFeatures:0,totalVertices:s.isSome(this.tileFetcher)?this.tileFetcher.totalVertices:0}}}]),i}(f.EsriPromiseMixin(m));t.__decorate([o.property({readOnly:!0})],O.prototype,"type",void 0),t.__decorate([o.property({constructOnly:!0})],O.prototype,"graphics",void 0),t.__decorate([o.property({constructOnly:!0})],O.prototype,"layerView",void 0),t.__decorate([o.property({constructOnly:!0})],O.prototype,"context",void 0),t.__decorate([o.property()],O.prototype,"extent",null),t.__decorate([o.property({dependsOn:["tileFetcher.updating","mode","layerView.view.featureTiles.updating","fetchDataInfoPromise","watchUpdatingTracking.updating"]})],O.prototype,"updating",null),t.__decorate([o.property({readOnly:!0})],O.prototype,"watchUpdatingTracking",void 0),t.__decorate([o.property({dependsOn:["updating","tileFetcher.updatingTotal"]})],O.prototype,"updatingTotal",null),t.__decorate([o.property({dependsOn:["updating","tileFetcher.updatingRemaining"]})],O.prototype,"updatingRemaining",null),t.__decorate([o.property({dependsOn:["updating","tileFetcher.expectedFeatureDiff"]})],O.prototype,"expectedFeatureDiff",null),t.__decorate([o.property({dependsOn:["tileFetcher.memoryForUnusedFeatures"]})],O.prototype,"memoryForUnusedFeatures",null),t.__decorate([o.property({dependsOn:["tileFetcher.maximumNumberOfFeaturesExceeded"]})],O.prototype,"maximumNumberOfFeaturesExceeded",null),t.__decorate([o.property({readOnly:!0})],O.prototype,"serviceDataExtent",void 0),t.__decorate([o.property({readOnly:!0})],O.prototype,"serviceDataCount",void 0),t.__decorate([o.property({readOnly:!0})],O.prototype,"vertexLimitExceeded",void 0),t.__decorate([o.property({readOnly:!0,dependsOn:["extent"]})],O.prototype,"filteredDataExtent",null),t.__decorate([o.property()],O.prototype,"displayFeatureLimit",void 0),t.__decorate([o.property({type:Number,dependsOn:["displayFeatureLimit"]})],O.prototype,"maximumNumberOfFeatures",null),t.__decorate([o.property({readOnly:!0,dependsOn:["serviceDataCount","displayFeatureLimit","maximumNumberOfFeatures","vertexLimitExceeded","serviceDataExtent","layerView.layer.minScale","layerView.view.featureTiles.tilingScheme"]})],O.prototype,"mode",null),t.__decorate([o.property({readOnly:!0,dependsOn:["mode","tileFetcher.totalVertices"]})],O.prototype,"maxTotalSnapshotVertices",null),t.__decorate([o.property({readOnly:!0,dependsOn:["mode"],autoTracked:!1})],O.prototype,"tileDescriptors",null),t.__decorate([o.property()],O.prototype,"tileFetcher",void 0),t.__decorate([o.property()],O.prototype,"fetchDataInfoPromise",void 0),t.__decorate([o.property({readOnly:!0,dependsOn:["displayFeatureLimit"]})],O.prototype,"vertexLimitInfo",null),O=b=t.__decorate([c.subclass("esri.layers.graphics.controllers.FeatureTileController3D")],O);const I=5e6;function V(e,t){if(!t)return!1;for(const i of t)if(!e.has(i))return!0;return!1}return function(e){let t;!function(e){e.NO_SERVICE_DATA_COUNT=1/0,e.MAX_SNAPSHOT_MIN_SCALE_FACTOR=5,e.reset=function(){e.MAX_FEATURE_COUNT_FOR_EXTENT=1e4,e.QUERY_STATISTICS_TIMEOUT=12e3,e.QUERY_EXTENT_TIMEOUT=1e4}}(t=e.constants||(e.constants={}))}(O||(O={})),O.constants.reset(),O}));
