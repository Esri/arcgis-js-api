/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import t from"./Dictionary.js";import e from"./ImmutableArray.js";import{i,a as s,b as r,t as a,e as o,j as n,c as l}from"../chunks/languageUtils.js";import u from"../geometry/Geometry.js";import h from"../geometry/Point.js";import{fromJSON as f}from"../geometry/support/jsonUtils.js";import{convertToGeometry as y}from"../layers/graphics/featureConversionUtils.js";import{isSome as c,unwrap as m}from"../core/maybe.js";class d{constructor(){this.arcadeDeclaredClass="esri.arcade.Feature",this._optimizedGeomDefinition=null,this._geometry=null,this.attributes=null,this._layer=null,this._datesfixed=!0,this.immutable=!0,this._datefields=null,this.immutable=!0}static createFromGraphic(t){const e=new d;return e._geometry=c(t.geometry)?t.geometry:null,void 0===t.attributes||null===t.attributes?e.attributes={}:e.attributes=t.attributes,t._sourceLayer?(e._layer=t._sourceLayer,e._datesfixed=!1):t._layer?(e._layer=t._layer,e._datesfixed=!1):t.layer&&"fields"in t.layer?(e._layer=t.layer,e._datesfixed=!1):t.sourceLayer&&"fields"in t.sourceLayer&&(e._layer=t.sourceLayer,e._datesfixed=!1),e}static createFromArcadeFeature(t){const e=new d;return e._datesfixed=t._datesfixed,e.attributes=t.attributes,e._geometry=t._geometry,e._optimizedGeomDefinition=t._optimizedGeomDefinition,t._layer&&(e._layer=t._layer),e}static createFromOptimisedFeature(t,e,i){const s=new d;return s._geometry=t.geometry?{geometry:t.geometry}:null,s._optimizedGeomDefinition=i,s.attributes=t.attributes||{},s._layer=e,s._datesfixed=!1,s}static createFromArcadeDictionary(e){const i=new d;return i.attributes=e.field("attributes"),null!==i.attributes&&i.attributes instanceof t?(i.attributes=i.attributes.attributes,null===i.attributes&&(i.attributes={})):i.attributes={},i._geometry=e.field("geometry"),null!==i._geometry&&(i._geometry instanceof t?i._geometry=d.parseGeometryFromDictionary(i._geometry):i._geometry instanceof u||(i._geometry=null)),i}static createFromGraphicLikeObject(t,e,i=null){const s=new d;return null===e&&(e={}),s.attributes=e,s._geometry=c(t)?t:null,s._layer=i,s._layer&&(s._datesfixed=!1),s}repurposeFromGraphicLikeObject(t,e,i=null){null===e&&(e={}),this.attributes=e,this._geometry=t||null,this._layer=i,this._layer?this._datesfixed=!1:this._datesfixed=!0}castToText(){let t="";!1===this._datesfixed&&this._fixDates();for(const o in this.attributes){""!==t&&(t+=",");const n=this.attributes[o];null==n?t+=JSON.stringify(o)+":null":i(n)||s(n)||r(n)?t+=JSON.stringify(o)+":"+JSON.stringify(n):n instanceof u||n instanceof e||n instanceof Array?t+=JSON.stringify(o)+":"+a(n):n instanceof Date?t+=JSON.stringify(o)+":"+JSON.stringify(n):null!==n&&"object"==typeof n&&void 0!==n.castToText&&(t+=JSON.stringify(o)+":"+n.castToText())}return'{"geometry":'+(null===this.geometry()?"null":a(this.geometry()))+',"attributes":{'+t+"}}"}_fixDates(){if(null!==this._datefields)return this._datefields.length>0&&this._fixDateFields(this._datefields),void(this._datesfixed=!0);const t=[];for(let e=0;e<this._layer.fields.length;e++){const i=this._layer.fields[e];"date"!==i.type&&"esriFieldTypeDate"!==i.type||t.push(i.name)}this._datefields=t,t.length>0&&this._fixDateFields(t),this._datesfixed=!0}_fixDateFields(t){this.attributes={...this.attributes};for(let e=0;e<t.length;e++){let i=this.attributes[t[e]];if(null===i);else if(void 0===i){for(const s in this.attributes)if(s.toLowerCase()===t[e].toLowerCase()){i=this.attributes[s],null!==i&&(i instanceof Date||(this.attributes[s]=new Date(i)));break}}else i instanceof Date||(this.attributes[t[e]]=new Date(i))}}geometry(){return null===this._geometry||this._geometry instanceof u||(this._optimizedGeomDefinition?(this._geometry=m(f(y(this._geometry,this._optimizedGeomDefinition.geometryType,this._optimizedGeomDefinition.hasZ,this._optimizedGeomDefinition.hasM))),this._geometry.spatialReference=this._optimizedGeomDefinition.spatialReference):this._geometry=m(f(this._geometry))),this._geometry}field(t){!1===this._datesfixed&&this._fixDates();const e=this.attributes[t];if(void 0!==e)return e;const i=t.toLowerCase();for(const s in this.attributes)if(s.toLowerCase()===i)return this.attributes[s];if(this._hasFieldDefinition(i))return null;throw new Error("Field not Found : "+t)}_hasFieldDefinition(t){if(null===this._layer)return!1;for(let e=0;e<this._layer.fields.length;e++){if(this._layer.fields[e].name.toLowerCase()===t)return!0}return!1}setField(t,e){if(this.immutable)throw new Error("Feature is Immutable");if(!1===o(e))throw new Error("Illegal Value Assignment to Feature");const i=t.toLowerCase();if(void 0===this.attributes[t]){for(const t in this.attributes)if(t.toLowerCase()===i)return void(this.attributes[t]=e);this.attributes[t]=e}else this.attributes[t]=e}hasField(t){const e=t.toLowerCase();if(void 0!==this.attributes[t])return!0;for(const i in this.attributes)if(i.toLowerCase()===e)return!0;return!!this._hasFieldDefinition(e)}keys(){let t=[];const e={};for(const i in this.attributes)t.push(i),e[i.toLowerCase()]=1;if(null!==this._layer)for(let i=0;i<this._layer.fields.length;i++){const s=this._layer.fields[i];1!==e[s.name.toLowerCase()]&&t.push(s.name)}return t=t.sort(),t}static parseGeometryFromDictionary(t){const e=d._convertDictionaryToJson(t,!0);return void 0!==e.hasm&&(e.hasM=e.hasm,delete e.hasm),void 0!==e.hasz&&(e.hasZ=e.hasz,delete e.hasz),void 0!==e.spatialreference&&(e.spatialReference=e.spatialreference,delete e.spatialreference),void 0!==e.rings&&(e.rings=this._fixPathArrays(e.rings,!0===e.hasZ,!0===e.hasZ)),void 0!==e.paths&&(e.paths=this._fixPathArrays(e.paths,!0===e.hasZ,!0===e.hasM)),void 0!==e.points&&(e.points=this._fixPointArrays(e.points,!0===e.hasZ,!0===e.hasM)),f(e)}static _fixPathArrays(t,i,s){const r=[];if(t instanceof Array)for(let e=0;e<t.length;e++)r.push(this._fixPointArrays(t[e],i,s));else if(t instanceof e)for(let e=0;e<t.length();e++)r.push(this._fixPointArrays(t.get(e),i,s));return r}static _fixPointArrays(t,i,s){const r=[];if(t instanceof Array)for(let a=0;a<t.length;a++){const o=t[a];o instanceof h?i&&s?r.push([o.x,o.y,o.z,o.m]):i?r.push([o.x,o.y,o.z]):s?r.push([o.x,o.y,o.m]):r.push([o.x,o.y]):o instanceof e?r.push(o.toArray()):r.push(o)}else if(t instanceof e)for(let a=0;a<t.length();a++){const o=t.get(a);o instanceof h?i&&s?r.push([o.x,o.y,o.z,o.m]):i?r.push([o.x,o.y,o.z]):s?r.push([o.x,o.y,o.m]):r.push([o.x,o.y]):o instanceof e?r.push(o.toArray()):r.push(o)}return r}static _convertDictionaryToJson(e,i=!1){const s={};for(const r in e.attributes){let a=e.attributes[r];a instanceof t&&(a=d._convertDictionaryToJson(a)),i?s[r.toLowerCase()]=a:s[r]=a}return s}static parseAttributesFromDictionary(t){const e={};for(const i in t.attributes){const s=t.attributes[i];if(!o(s))throw new Error("Illegal Argument");e[i]=s}return e}static fromJson(t){let e=null;null!==t.geometry&&void 0!==t.geometry&&(e=f(t.geometry));const a={};if(null!==t.attributes&&void 0!==t.attributes)for(const o in t.attributes){const e=t.attributes[o];if(null===e)a[o]=e;else{if(!(r(e)||s(e)||i(e)||n(e)))throw new Error("Illegal Argument");a[o]=e}}return d.createFromGraphicLikeObject(e,a,null)}fullSchema(){return this._layer}gdbVersion(){if(null===this._layer)return"";const t=this._layer.gdbVersion;return void 0===t?"":""===t&&this._layer.capabilities&&this._layer.capabilities.isVersioned?"SDE.DEFAULT":t}castAsJson(t){const e={attributes:{},geometry:!0===t?.keepGeometryType?this.geometry():this.geometry().toJSON()};for(const i in this.attributes){const s=this.attributes[i];void 0!==s&&(e.attributes[i]=l(s,t))}return e}async castAsJsonAsync(t=null,e){return this.castAsJson(e)}}export{d as default};
