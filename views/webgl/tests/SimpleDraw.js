/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{BufferObject as t}from"../BufferObject.js";import{BlendFactor as e,PrimitiveType as i,DataType as s,Usage as r,TextureType as a,PixelFormat as o,PixelType as h}from"../enums.js";import{RenderingContext as n}from"../RenderingContext.js";import{Texture as _}from"../Texture.js";import{VertexArrayObject as c}from"../VertexArrayObject.js";import{VertexElementDescriptor as g}from"../VertexElementDescriptor.js";class m{constructor(t,e,i,s,r){this._vertexAttributeLocations=new Map([["position",0],["uv0",1]]),this._context=void 0,this._glslProgram=void 0,this._vertexAttributes=void 0,this._vertexArrayObject=void 0,this._texture=void 0,this._geometryData=void 0,this._initialized=!1,t||console.error("WebGL rendering context is not initialized!"),this._context=new n(t,{}),this._posX=e,this._posY=i,this._dx=.05*Math.random()*s*(Math.random()<.5?-1:1),this._dy=.05*Math.random()*r*(Math.random()<.5?-1:1),this._canvasWidth=s,this._canvasHieght=r}draw(){if(!this._initialize())return;this._updatePos();const t=this._context;t.setBlendingEnabled(!0),t.setBlendFunction(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),t.setClearColor(1,1,1,1),t.clear(t.gl.COLOR_BUFFER_BIT),t.bindVAO(this._vertexArrayObject),t.useProgram(this._glslProgram),t.bindTexture(this._texture,0),t.drawArrays(i.TRIANGLE_STRIP,0,4)}_updatePos(){this._posX+=this._dx,this._posY+=this._dy,(this._posX<0||this._posX>this._canvasWidth)&&(this._dx=-this._dx),(this._posY<0||this._posY>this._canvasHieght)&&(this._dy=-this._dy);const t=this._vertexArrayObject.vertexBuffers.geometry;t&&(this._populateBuffer(256),t.setData(this._geometryData))}_initialize(){if(this._initialized)return!0;const e="\n      precision highp float;\n\n      // geometry attributes\n      attribute vec2 pos;\n      attribute vec2 tex;\n\n      varying vec2 v_tex;\n\n      void main(void)\n      {\n        gl_Position = vec4(pos, 0.0, 1.0);\n        v_tex = tex;\n      }",i="\n      precision highp float;\n      uniform sampler2D u_texture;\n\n      varying vec2 v_tex;\n      void main(void)\n      {\n        vec4 color = texture2D(u_texture, v_tex);\n        gl_FragColor = color;\n      }";this._glslProgram=this._context.programCache.acquire(e,i,this._vertexAttributeLocations),this._vertexAttributes={geometry:[new g("pos",2,s.FLOAT,0,16),new g("tex",2,s.FLOAT,8,16)]};const n=document.createElement("canvas"),m=256;n.width=m,n.height=m;const d=n.getContext("2d");d.clearRect(0,0,0,0);const l=n.width/2,x=n.height/2,v=n.height/2-15;d.beginPath(),d.arc(l,x,v,0,2*Math.PI,!1),d.fillStyle="green",d.fill(),d.lineWidth=5,d.strokeStyle="#003300",d.stroke(),this._populateBuffer(256);const p=t.createVertex(this._context,r.DYNAMIC_DRAW,this._geometryData);return this._vertexArrayObject=new c(this._context,this._vertexAttributeLocations,this._vertexAttributes,{geometry:p}),this._texture=new _(this._context,{target:a.TEXTURE_2D,pixelFormat:o.RGBA,dataType:h.UNSIGNED_BYTE,flipped:!0},n),this._initialized=!0,!1}_populateBuffer(t){const e=2*(this._posX/this._canvasWidth-.5),i=2*((this._canvasHieght-this._posY)/this._canvasHieght-.5),s=1*t/this._canvasWidth,r=1*t/this._canvasHieght;this._geometryData||(this._geometryData=new Float32Array(16)),this._geometryData[0]=e+s,this._geometryData[1]=i+r,this._geometryData[2]=1,this._geometryData[3]=1,this._geometryData[4]=e+s,this._geometryData[5]=i-r,this._geometryData[6]=1,this._geometryData[7]=0,this._geometryData[8]=e-s,this._geometryData[9]=i+r,this._geometryData[10]=0,this._geometryData[11]=1,this._geometryData[12]=e-s,this._geometryData[13]=i-r,this._geometryData[14]=0,this._geometryData[15]=0}}export{m as default};
