/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{deg2rad as t}from"../../../../core/mathUtils.js";import{isSome as i,isNone as e}from"../../../../core/maybe.js";import{g as s,i as n,h as r}from"../../../../chunks/vec2.js";import{a as h}from"../../../../chunks/vec2f64.js";import{r as a,e as o,o as c,f as _,n as l,a as p,g,z as d,c as f}from"../../../../chunks/vec3.js";import{c as m,f as u}from"../../../../chunks/vec3f64.js";import{create as D,fromPositionAndNormal as E,signedDistance as x,copy as b,intersectLine as I,normal as V}from"../../../../geometry/support/plane.js";import{angle as M,projectPointSignedLength as N}from"../../../../geometry/support/vector.js";import{intersectLineAndRay as y,LineType as P}from"../../../support/geometry2dUtils.js";class X{constructor(t,i,e,s=0,n=Z.IMMEDIATE){this.helper=t,this.planeType=i,this.edge=e,this.distance=s,this._plane=D(),this._offsetPlane=D(),this._minDistance=-1/0,this._maxDistance=1/0,n===Z.IMMEDIATE&&this._initialize()}get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){const t=this._toXYZ(this.edge.leftVertex.pos),i=this._toXYZ(this.edge.leftVertex.leftEdge?.leftVertex?.pos),e=this._toXYZ(this.edge.rightVertex.pos),s=this._toXYZ(this.edge.rightVertex.rightEdge?.rightVertex?.pos);this._edgeDirection=a(m(),t,e),this._left=this._computeNeighbor(t,i,this._edgeDirection),this._right=this._computeNeighbor(e,s,this._edgeDirection)}_toXYZ(t){return i(t)?this.helper.toXYZ(t):null}_computeNeighbor(t,i,s){if(e(i))return{start:t,end:i,direction:u(-s[1],s[0],0),isOriginalDirection:!0};const n=a(m(),t,i),r=!this._passesBisectingAngleThreshold(n,s);return{start:t,end:i,direction:r?this._bisectVectorsPerpendicular(s,n):n,isOriginalDirection:!r}}_passesBisectingAngleThreshold(t,i){const e=Math.abs(M(i,t));return e>=Y&&e<=Math.PI-Y}_bisectVectorsPerpendicular(t,i){const e=o(t,i)<0?t:c(m(),t),s=Math.abs(o(e,i));if(!(s<.001||s>.999))return this._bisectDirection(e,i);const n=_(m(),e,[0,0,1]);return l(n,n)}_bisectDirection(t,i){const e=p(m(),t,i);return l(e,e)}_initializePlane(){const t=this._computeNormalDirection(this._left),i=this._computeNormalDirection(this._right);o(t,i)<0&&c(i,i),E(this._left.start,this._bisectDirection(t,i),this._plane)}_computeNormalDirection(t){const i=_(m(),t.direction,this._edgeDirection);l(i,i);const e=_(m(),this._edgeDirection,i);return this.planeType===T.XY&&(e[2]=0),l(e,e)}_initializeDistanceConstraints(){i(this._left.end)&&!this.requiresSplitEdgeLeft&&this._updateDistanceConstraint(x(this._plane,this._left.end)),i(this._right.end)&&!this.requiresSplitEdgeRight&&this._updateDistanceConstraint(x(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))}_updateIntersectDistanceConstraint(t){const i=V(t),e=this._edgeDirection,a=p(m(),this._left.start,this._left.direction),o=p(m(),this._right.start,this._right.direction),c=this._pointInBasis2D(h(),i,e,this._left.start),_=this._pointInBasis2D(h(),i,e,a),l=this._pointInBasis2D(h(),i,e,this._right.start),d=this._pointInBasis2D(h(),i,e,o),[f]=y({start:_,end:c,type:P.LINE},{start:d,end:l,type:P.LINE});if(!f)return;const u=s(h(),c,_);n(u,u);const D=s(h(),f,_),E=r(u,D),b=p(m(),a,g(m(),this._left.direction,-E)),I=x(t,b);this._updateDistanceConstraint(I)}_pointInBasis2D(t,i,e,s){return t[0]=N(i,s),t[1]=N(e,s),t}_offset(t,e){Number.isFinite(this._minDistance)&&(e=Math.max(this._minDistance,e)),Number.isFinite(this._maxDistance)&&(e=Math.min(this._maxDistance,e)),b(this._offsetPlane,this._plane),this._offsetPlane[3]-=e;const s=(t,e,s)=>i(e)&&I(this._offsetPlane,t,p(m(),t,e),s),n=m();(t===this.edge.leftVertex?s(this._left.start,this._left.direction,n):s(this._right.start,this._right.direction,n))&&this.helper.copy(this.helper.fromXYZ(n,void 0,this.helper.getM(t.pos)),t.pos)}signedDistanceToPoint(t){return x(this.plane,this.helper.toXYZ(this.helper.pointToVector(t)))}apply(t){this._offset(t,this.distance)}undo(t){this._offset(t,0)}canAccumulate(t){return t instanceof X&&this.edge.leftVertex.index===t.edge.leftVertex.index&&this.edge.rightVertex.index===t.edge.rightVertex.index&&this.edge.component===t.edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&d(V(this._plane),V(t._plane))}accumulate(t,i){const e=this._plane[3]-i._plane[3]+i.distance;this._offset(t,e)}accumulateParams(t){const i=t.distance-t._plane[3];this.distance=i+this._plane[3]}clone(){const t=new X(this.helper,this.planeType,this.edge,this.distance,Z.DEFERRED);return b(t._plane,this._plane),b(t._offsetPlane,this._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=f(m(),this._edgeDirection),t}_maybeEqualsVec3(t,s){return e(t)&&e(s)||i(t)&&i(s)&&d(t,s)}_cloneNeighbor({start:t,end:e,direction:s,isOriginalDirection:n}){return{start:f(m(),t),end:i(e)?f(m(),e):null,direction:f(m(),s),isOriginalDirection:n}}}const Y=t(15);var T,Z;!function(t){t[t.XYZ=0]="XYZ",t[t.XY=1]="XY"}(T||(T={})),function(t){t[t.IMMEDIATE=0]="IMMEDIATE",t[t.DEFERRED=1]="DEFERRED"}(Z||(Z={}));export{X as OffsetEdgeVertex,T as PlaneType};
