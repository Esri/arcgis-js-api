/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/mathUtils","../../../../core/maybe","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/vector","../../../support/geometry2dUtils"],(function(t,e,i,n,s,r,o,a,c,h,l){"use strict";let _=function(){function i(t,e,i,n=0,s=p.IMMEDIATE){this.helper=t,this.planeType=e,this.edge=i,this.distance=n,this._plane=c.create(),this._offsetPlane=c.create(),this._minDistance=-1/0,this._maxDistance=1/0,s===p.IMMEDIATE&&this._initialize()}var _=i.prototype;return _._initialize=function(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()},_._initializeNeighbors=function(){var t,e,i,n;const s=this._toXYZ(this.edge.leftVertex.pos),r=this._toXYZ(null==(t=this.edge.leftVertex.leftEdge)||null==(e=t.leftVertex)?void 0:e.pos),c=this._toXYZ(this.edge.rightVertex.pos),h=this._toXYZ(null==(i=this.edge.rightVertex.rightEdge)||null==(n=i.rightVertex)?void 0:n.pos);this._edgeDirection=o.direction(a.create(),s,c),this._left=this._computeNeighbor(s,r,this._edgeDirection),this._right=this._computeNeighbor(c,h,this._edgeDirection)},_._toXYZ=function(t){return n.isSome(t)?this.helper.toXYZ(t):null},_._computeNeighbor=function(t,e,i){if(n.isNone(e))return{start:t,end:e,direction:a.fromValues(-i[1],i[0],0),isOriginalDirection:!0};const s=o.direction(a.create(),t,e),r=!this._passesBisectingAngleThreshold(s,i);return{start:t,end:e,direction:r?this._bisectVectorsPerpendicular(i,s):s,isOriginalDirection:!r}},_._passesBisectingAngleThreshold=function(t,e){const i=Math.abs(h.angle(e,t));return i>=d&&i<=Math.PI-d},_._bisectVectorsPerpendicular=function(t,e){const i=o.dot(t,e)<0?t:o.negate(a.create(),t),n=Math.abs(o.dot(i,e));if(!(n<.001||n>.999))return this._bisectDirection(i,e);const s=o.cross(a.create(),i,[0,0,1]);return o.normalize(s,s)},_._bisectDirection=function(t,e){const i=o.add(a.create(),t,e);return o.normalize(i,i)},_._initializePlane=function(){const t=this._computeNormalDirection(this._left),e=this._computeNormalDirection(this._right);o.dot(t,e)<0&&o.negate(e,e),c.fromPositionAndNormal(this._left.start,this._bisectDirection(t,e),this._plane)},_._computeNormalDirection=function(e){const i=o.cross(a.create(),e.direction,this._edgeDirection);o.normalize(i,i);const n=o.cross(a.create(),this._edgeDirection,i);return this.planeType===t.PlaneType.XY&&(n[2]=0),o.normalize(n,n)},_._initializeDistanceConstraints=function(){n.isSome(this._left.end)&&!this.requiresSplitEdgeLeft&&this._updateDistanceConstraint(c.signedDistance(this._plane,this._left.end)),n.isSome(this._right.end)&&!this.requiresSplitEdgeRight&&this._updateDistanceConstraint(c.signedDistance(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)},_._updateDistanceConstraint=function(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))},_._updateIntersectDistanceConstraint=function(t){const e=c.normal(t),i=this._edgeDirection,n=o.add(a.create(),this._left.start,this._left.direction),h=o.add(a.create(),this._right.start,this._right.direction),_=this._pointInBasis2D(r.create(),e,i,this._left.start),d=this._pointInBasis2D(r.create(),e,i,n),u=this._pointInBasis2D(r.create(),e,i,this._right.start),p=this._pointInBasis2D(r.create(),e,i,h),[g]=l.intersectLineAndRay({start:d,end:_,type:l.LineType.LINE},{start:p,end:u,type:l.LineType.LINE});if(!g)return;const f=s.subtract(r.create(),_,d);s.normalize(f,f);const D=s.subtract(r.create(),g,d),m=s.dot(f,D),y=o.add(a.create(),n,o.scale(a.create(),this._left.direction,-m)),E=c.signedDistance(t,y);this._updateDistanceConstraint(E)},_._pointInBasis2D=function(t,e,i,n){return t[0]=h.projectPointSignedLength(e,n),t[1]=h.projectPointSignedLength(i,n),t},_._offset=function(t,e){Number.isFinite(this._minDistance)&&(e=Math.max(this._minDistance,e)),Number.isFinite(this._maxDistance)&&(e=Math.min(this._maxDistance,e)),c.copy(this._offsetPlane,this._plane),this._offsetPlane[3]-=e;const i=(t,e,i)=>n.isSome(e)&&c.intersectLine(this._offsetPlane,t,o.add(a.create(),t,e),i),s=a.create();(t===this.edge.leftVertex?i(this._left.start,this._left.direction,s):i(this._right.start,this._right.direction,s))&&this.helper.copy(this.helper.fromXYZ(s,void 0,this.helper.getM(t.pos)),t.pos)},_.signedDistanceToPoint=function(t){return c.signedDistance(this.plane,this.helper.toXYZ(this.helper.pointToVector(t)))},_.apply=function(t){this._offset(t,this.distance)},_.undo=function(t){this._offset(t,0)},_.canAccumulate=function(t){return t instanceof i&&this.edge.leftVertex.index===t.edge.leftVertex.index&&this.edge.rightVertex.index===t.edge.rightVertex.index&&this.edge.component===t.edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&o.equals(c.normal(this._plane),c.normal(t._plane))},_.accumulate=function(t,e){const i=this._plane[3]-e._plane[3]+e.distance;this._offset(t,i)},_.accumulateParams=function(t){const e=t.distance-t._plane[3];this.distance=e+this._plane[3]},_.clone=function(){const t=new i(this.helper,this.planeType,this.edge,this.distance,p.DEFERRED);return c.copy(t._plane,this._plane),c.copy(t._offsetPlane,this._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=o.copy(a.create(),this._edgeDirection),t},_._maybeEqualsVec3=function(t,e){return n.isNone(t)&&n.isNone(e)||n.isSome(t)&&n.isSome(e)&&o.equals(t,e)},_._cloneNeighbor=function({start:t,end:e,direction:i,isOriginalDirection:s}){return{start:o.copy(a.create(),t),end:n.isSome(e)?o.copy(a.create(),e):null,direction:o.copy(a.create(),i),isOriginalDirection:s}},e._createClass(i,[{key:"plane",get:function(){return this._plane}},{key:"requiresSplitEdgeLeft",get:function(){return!this._left.isOriginalDirection}},{key:"requiresSplitEdgeRight",get:function(){return!this._right.isOriginalDirection}},{key:"edgeDirection",get:function(){return this._edgeDirection}}]),i}();const d=i.deg2rad(15);var u,p;t.PlaneType=void 0,(u=t.PlaneType||(t.PlaneType={}))[u.XYZ=0]="XYZ",u[u.XY=1]="XY",function(t){t[t.IMMEDIATE=0]="IMMEDIATE",t[t.DEFERRED=1]="DEFERRED"}(p||(p={})),t.OffsetEdgeVertex=_,Object.defineProperties(t,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
