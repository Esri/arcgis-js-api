/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../core/lang","../../core/maybe","../../core/handleUtils","../../geometry/support/webMercatorUtils","../../core/mathUtils","../../core/screenUtils","../draw/support/drawUtils"],(function(e,t,n,r,a,o,c,s){"use strict";function l(e,t){let r=null,a=null;return o=>{if("cancel"===o.action)return void(n.isSome(a)&&(a.execute({action:"cancel"}),r=null,a=null));const c={action:o.action,screenStart:o.start,screenEnd:o.screenPoint};"start"===o.action&&n.isNone(r)&&(r=new f,a=new f,t(e,r,a,o.pointerType,c)),n.isSome(r)&&r.execute(c),"end"===o.action&&n.isSome(r)&&(r=null,a=null)}}function i(e,t){return e.events.on("drag",l(e,t))}function u(e,t){let r=null;const o=n.isSome(e[t])?e[t].spatialReference:null;return c=>{var l,i;if("start"===c.action&&n.isSome(e[t])&&(l=e[t],i=c.mapStart.spatialReference,r=n.isNone(l)||"mesh"===l.type?null:l.spatialReference.equals(i)?l.clone():a.canProject(l,i)?a.project(l,i):null),n.isNone(r))return null;const u=c.mapEnd.x-c.mapStart.x,p=c.mapEnd.y-c.mapStart.y,m=c.mapEnd.z-c.mapStart.z,d=s.move(r.clone(),u,p,m);return d.spatialReference.equals(o)?e[t]=d:e[t]=a.project(d,o),{...c,translationX:u,translationY:p,translationZ:m}}}function p(e){return u(e,"geometry")}function m(e,n){const r=new Map;for(const a of n)r.set(a,t.clone(e[a]));return t=>(r.forEach(((t,n)=>{e[n]=t})),t)}function d(e){return m(e,["geometry"])}let f=function(){function e(){this.execute=()=>{}}return e.prototype.next=function(t,r=new e){return n.isSome(t)&&(this.execute=e=>{const a=t(e);n.isSome(a)&&r.execute(a)}),r},e}();e.EventPipeline=f,e.addMapDelta=function(){let e=0,t=0,n=0;return r=>{"start"===r.action&&(e=r.mapStart.x,t=r.mapStart.y,n=r.mapStart.z);const a=r.mapEnd.x-e,o=r.mapEnd.y-t,c=r.mapEnd.z-n;return e=r.mapEnd.x,t=r.mapEnd.y,n=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:o,mapDeltaZ:c,mapDeltaSpatialReference:r.mapStart.spatialReference}}},e.addScreenDelta=function(){let e=0,t=0;return n=>{"start"===n.action&&(e=n.screenStart.x,t=n.screenStart.y);const r=n.screenEnd.x-e,a=n.screenEnd.y-t;return e=n.screenEnd.x,t=n.screenEnd.y,{...n,screenDeltaX:r,screenDeltaY:a}}},e.constrainToMapAxis=function(e,t){const n=[e.x,e.y,e.z],r=t,a=[Math.cos(r),Math.sin(r)],o=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===o)return null;a[0]/=o,a[1]/=o;const c=e=>{const t=(e.x-n[0])*a[0]+(e.y-n[1])*a[1];e.x=n[0]+t*a[0],e.y=n[1]+t*a[1]};return e=>(c(e.mapStart),c(e.mapEnd),e)},e.createDragEventPipelineCallback=l,e.createManipulatorDragEventPipeline=i,e.createManipulatorDragEventPipelineMany=function(e,t){const n=[];for(const r of e)n.push(i(r,t));return r.handlesGroup(n)},e.dragAtLocation=function(e,t){let n=null,r=0,a=0;return s=>{if("start"===s.action&&(n=e.toScreen(t),n.x<0||n.x>e.width||n.y<0||n.y>e.height?n=null:(r=s.screenStart.x-n.x,a=s.screenStart.y-n.y)),null==n)return null;const l=o.clamp(s.screenEnd.x-r,0,e.width),i=o.clamp(s.screenEnd.y-a,0,e.height),u=c.createScreenPoint(l,i);return s.screenStart=n,s.screenEnd=u,s}},e.dragGeometry=u,e.dragGraphic=p,e.dragGraphicMany=function(e){const t=e.map((e=>n.unwrap(p(e)))).filter((e=>n.isSome(e)));return e=>{const n=e.mapEnd.x-e.mapStart.x,r=e.mapEnd.y-e.mapStart.y,a=e.mapEnd.z-e.mapStart.z;return t.forEach((t=>t(e))),{...e,translationX:n,translationY:r,translationZ:a}}},e.resetGraphic=d,e.resetGraphicMany=function(e){const t=e.map((e=>n.unwrap(d(e)))).filter((e=>n.isSome(e)));return e=>(t.forEach((t=>t(e))),e)},e.resetProperties=m,e.resetSymbol=function(e){const t=n.isSome(e.symbol)?e.symbol.clone():null;return n=>(e.symbol=t,n)},e.screenToMap=function(e,t=null,r){let o=null;const c=n.isSome(t)&&!e.spatialReference.equals(t)?e=>n.isSome(e)?a.project(e,t):e:e=>e,s={exclude:[],...r};return t=>{if("start"===t.action&&(o=c(e.toMap(t.screenStart,s))),n.isNone(o))return null;const r=c(e.toMap(t.screenEnd,s));return n.isSome(r)?{...t,mapStart:o,mapEnd:r}:null}},Object.defineProperty(e,"__esModule",{value:!0})}));
