/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../geometry","../../core/has","../../core/lang","../../core/mathUtils","../../core/maybe","../../core/screenUtils","../../chunks/vec3f64","../../geometry/projection","../../layers/graphics/hydratedFeatures","../../support/elevationInfoUtils","../ViewingMode","../draw/support/drawUtils","../../geometry/Point"],(function(e,t,n,r,a,o,i,c,s,l,u,p,m,f){"use strict";function d(e,t){let n=null,r=null;return a=>{if("cancel"===a.action)return void(o.isSome(r)&&(r.execute({action:"cancel"}),n=null,r=null));const i={action:a.action,screenStart:a.start,screenEnd:a.screenPoint};"start"===a.action&&o.isNone(n)&&(n=new A,r=new A,t(e,n,r,a.pointerType,i)),o.isSome(n)&&n.execute(i),"end"===a.action&&o.isSome(n)&&(n=null,r=null)}}function y(e,t){return e.events.on("drag",d(e,t))}function S(e,t){const n=[e.x,e.y,e.z??0],r=t,a=[Math.cos(r),Math.sin(r)],o=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===o)return null;a[0]/=o,a[1]/=o;const i=e=>{const t=(e.x-n[0])*a[0]+(e.y-n[1])*a[1];e.x=n[0]+t*a[0],e.y=n[1]+t*a[1]};return e=>(i(e.mapStart),i(e.mapEnd),{...e,axis:a})}function g(e,t){let n=null;return r=>{if("start"===r.action&&(n=x(e,r.mapStart.spatialReference,t)),o.isNone(n))return null;const a=r.mapEnd.x-r.mapStart.x,i=r.mapEnd.y-r.mapStart.y,c=r.mapEnd.z-r.mapStart.z;return n.move(a,i,c),{...r,translationX:a,translationY:i,translationZ:c}}}function E(e,t){return o.isNone(e)?null:e.spatialReference.equals(t)?e.clone():s.project(e,t)}function x(e,t,n){const r=e.geometry,a=l.hydratedSpatialReference(t);if(o.isNone(r))return null;if("mesh"===r.type)return h(e,r,a,n);const i=E(r,a),c=r.spatialReference;return o.isNone(i)?null:{move:(t,n,r)=>{const a=m.move(i.clone(),t,n,r);a.spatialReference.equals(c)?e.geometry=a:e.geometry=s.project(a,c)}}}function h(e,t,n,r){if(o.isSome(t.transform))return v(e,t,t.transform,n);if(!t.spatialReference.equals(n))return null;let a=0,i=0,c=0;return{move:(n,o,s)=>{const l=n-a,u=o-i,m=s-c;if(l||u||m){const d=new f(t.origin.x+l,t.origin.y+u,t.origin.z+m,t.origin.spatialReference);t.centerAt(d,{geographic:r===p.ViewingMode.Global}),e.notifyGeometryChanged(),a=n,i=o,c=s}}}}function v(e,t,n,r){const a=E(n.getOriginPoint(t.spatialReference),r),i=t.spatialReference;return o.isNone(a)?null:{move:(t,r,l)=>{const u=m.move(a.clone(),t,r,l);if(u.spatialReference.equals(i))n.origin=c.fromValues(u.x,u.y,u.z);else{const e=s.project(u,i);o.isSome(e)&&(n.origin=c.fromValues(e.x,e.y,e.z))}e.notifyMeshTransformChanged(),e.notifyGeometryChanged()}}}function M(e,t=null,n){let r=null;const a=o.isSome(t)&&!e.spatialReference?.equals(t)?e=>o.isSome(e)?s.project(e,t):e:e=>e,i={exclude:[],...n};return t=>{if("start"===t.action&&(r=a(e.toMap(t.screenStart,i))),o.isNone(r))return null;const n=a(e.toMap(t.screenEnd,i));return o.isSome(n)?{...t,mapStart:r,mapEnd:n}:null}}function z(e,t){const n=e.map((e=>o.unwrap(g(e,t)))).filter((e=>o.isSome(e)));return e=>{const t=e.mapEnd.x-e.mapStart.x,r=e.mapEnd.y-e.mapStart.y,a=e.mapEnd.z-e.mapStart.z;return n.forEach((t=>t(e))),{...e,translationX:t,translationY:r,translationZ:a}}}function P(e,t){const n=new Map;for(const a of t)n.set(a,r.clone(e[a]));return t=>(n.forEach(((t,n)=>{e[n]=t})),t)}function R(e){return o.isSome(e.geometry)&&"mesh"===e.geometry.type?w(e,e.geometry):P(e,["geometry"])}function w(e,t){const n=o.isSome(t.transform)?t.transform.clone():null,r=t.vertexAttributes.clonePositional();return a=>(t.transform=n,t.vertexAttributes=r,e.notifyGeometryChanged(),a)}function D(e){const t=e.map((e=>o.unwrap(R(e)))).filter((e=>o.isSome(e)));return e=>(t.forEach((t=>t(e))),e)}function b(){let e=0,t=0,n=0;return r=>{"start"===r.action&&(e=r.mapStart.x,t=r.mapStart.y,n=r.mapStart.z);const a=r.mapEnd.x-e,o=r.mapEnd.y-t,i=r.mapEnd.z-n;return e=r.mapEnd.x,t=r.mapEnd.y,n=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:o,mapDeltaZ:i,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function G(){let e=0,t=0;return n=>{"start"===n.action&&(e=n.screenStart.x,t=n.screenStart.y);const r=n.screenEnd.x-e,a=n.screenEnd.y-t;return e=n.screenEnd.x,t=n.screenEnd.y,{...n,screenDeltaX:r,screenDeltaY:a}}}function N(e,t){let n=null,r=0,o=0;return c=>{if("start"===c.action&&(n=e.toScreen?.(t),null!=n&&(n.x<0||n.x>e.width||n.y<0||n.y>e.height?n=null:(r=c.screenStart.x-n.x,o=c.screenStart.y-n.y))),null==n)return null;const s=a.clamp(c.screenEnd.x-r,0,e.width),l=a.clamp(c.screenEnd.y-o,0,e.height),u=i.createScreenPoint(s,l);return c.screenStart=n,c.screenEnd=u,c}}const j=()=>{};let A=function(){function e(){this.execute=j}return e.prototype.next=function(t,n=new e){return o.isSome(t)&&(this.execute=e=>{const r=t(e);o.isSome(r)&&n.execute(r)}),n},e}();function Z(e,t,n=[]){if("2d"===e.type)return e=>e;let r=null;return a=>{"start"===a.action&&(r=e.toMap(a.screenStart,{exclude:n}),o.isSome(r)&&(r.z=u.getZForElevationMode(r,e,t)));const i=e.toMap(a.screenEnd,{exclude:n});o.isSome(i)&&(i.z=u.getZForElevationMode(i,e,t));const c=o.isSome(r)&&o.isSome(i)?{sceneStart:r,sceneEnd:i}:null;return{...a,scenePoints:c}}}function q(e,t,n){const r=o.toNullable(t.elevationProvider.getElevation(e.x,e.y,e.z??0,e.spatialReference,"scene"))??0,a=l.clonePoint(e);return a.z=r,a.hasZ=!0,a.z=u.getZForElevationMode(a,t,n),a}function C(e,t){if("2d"===e.type)return e=>e;let n=null;return r=>{"start"===r.action&&(n=q(r.mapStart,e,t));const a=q(r.mapEnd,e,t),i=o.isSome(n)&&o.isSome(a)?{sceneStart:n,sceneEnd:a}:null;return{...r,scenePoints:i}}}e.EventPipeline=A,e.addMapDelta=b,e.addScreenDelta=G,e.constrainToMapAxis=S,e.createDragEventPipelineCallback=d,e.createManipulatorDragEventPipeline=y,e.dragAtLocation=N,e.dragGraphic=g,e.dragGraphicMany=z,e.resetGraphic=R,e.resetGraphicMany=D,e.resetProperties=P,e.sceneSnappingAtLocation=Z,e.sceneSnappingAtProjectedLocation=C,e.screenToMap=M,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
