/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import"../../geometry.js";import{handlesGroup as t}from"../../core/handleUtils.js";import{clone as n}from"../../core/lang.js";import{clamp as e}from"../../core/mathUtils.js";import{isSome as r,isNone as o,unwrap as a}from"../../core/maybe.js";import{createScreenPoint as c}from"../../core/screenUtils.js";import{f as s}from"../../chunks/vec3f64.js";import{project as i}from"../../geometry/projection.js";import{ViewingMode as l}from"../ViewingMode.js";import{move as u}from"../draw/support/drawUtils.js";import m from"../../geometry/Point.js";function f(t,n){let e=null,a=null;return c=>{if("cancel"===c.action)return void(r(a)&&(a.execute({action:"cancel"}),e=null,a=null));const s={action:c.action,screenStart:c.start,screenEnd:c.screenPoint};"start"===c.action&&o(e)&&(e=new G,a=new G,n(t,e,a,c.pointerType,s)),r(e)&&e.execute(s),"end"===c.action&&r(e)&&(e=null,a=null)}}function p(t,n){return t.events.on("drag",f(t,n))}function y(n,e){const r=[];for(const t of n)r.push(p(t,e));return t(r)}function d(t,n){const e=[t.x,t.y,t.z],r=n,o=[Math.cos(r),Math.sin(r)],a=Math.sqrt(o[0]*o[0]+o[1]*o[1]);if(0===a)return null;o[0]/=a,o[1]/=a;const c=t=>{const n=(t.x-e[0])*o[0]+(t.y-e[1])*o[1];t.x=e[0]+n*o[0],t.y=e[1]+n*o[1]};return t=>(c(t.mapStart),c(t.mapEnd),t)}function x(t,n){let e=null;return r=>{if("start"===r.action&&(e=h(t,r.mapStart.spatialReference,n)),o(e))return null;const a=r.mapEnd.x-r.mapStart.x,c=r.mapEnd.y-r.mapStart.y,s=r.mapEnd.z-r.mapStart.z;return e.move(a,c,s),{...r,translationX:a,translationY:c,translationZ:s}}}function g(t,n){return o(t)?null:t.spatialReference.equals(n)?t.clone():i(t,n)}function h(t,n,e){const r=t.geometry;if(o(r))return null;if("mesh"===r.type)return E(t,r,n,e);const a=g(r,n),c=r.spatialReference;return o(a)?null:{move:(n,e,r)=>{const o=u(a.clone(),n,e,r);o.spatialReference.equals(c)?t.geometry=o:t.geometry=i(o,c)}}}function E(t,n,e,o){if(r(n.transform))return S(t,n,n.transform,e);if(!n.spatialReference.equals(e))return null;let a=0,c=0,s=0;return{move:(e,r,i)=>{const u=e-a,f=r-c,p=i-s;if(u||f||p){const y=new m(n.origin.x+u,n.origin.y+f,n.origin.z+p,n.origin.spatialReference);n.centerAt(y,{geographic:o===l.Global}),t.notifyGeometryChanged(),a=e,c=r,s=i}}}}function S(t,n,e,a){const c=g(e.getOriginPoint(n.spatialReference),a),l=n.spatialReference;return o(c)?null:{move:(n,o,a)=>{const m=u(c.clone(),n,o,a);if(m.spatialReference.equals(l))e.origin=s(m.x,m.y,m.z);else{const t=i(m,l);r(t)&&(e.origin=s(t.x,t.y,t.z))}t.notifyMeshTransformChanged(),t.notifyGeometryChanged()}}}function j(t,n=null,e){let a=null;const c=r(n)&&!t.spatialReference.equals(n)?t=>r(t)?i(t,n):t:t=>t,s={exclude:[],...e};return n=>{if("start"===n.action&&(a=c(t.toMap(n.screenStart,s))),o(a))return null;const e=c(t.toMap(n.screenEnd,s));return r(e)?{...n,mapStart:a,mapEnd:e}:null}}function R(t,n){const e=t.map((t=>a(x(t,n)))).filter((t=>r(t)));return t=>{const n=t.mapEnd.x-t.mapStart.x,r=t.mapEnd.y-t.mapStart.y,o=t.mapEnd.z-t.mapStart.z;return e.forEach((n=>n(t))),{...t,translationX:n,translationY:r,translationZ:o}}}function z(t,e){const r=new Map;for(const o of e)r.set(o,n(t[o]));return n=>(r.forEach(((n,e)=>{t[e]=n})),n)}function w(t){return r(t.geometry)&&"mesh"===t.geometry.type?v(t,t.geometry):z(t,["geometry"])}function v(t,n){const e=r(n.transform)?n.transform.clone():null,o=n.vertexAttributes.clonePositional();return r=>(n.transform=e,n.vertexAttributes=o,t.notifyGeometryChanged(),r)}function M(t){const n=t.map((t=>a(w(t)))).filter((t=>r(t)));return t=>(n.forEach((n=>n(t))),t)}function q(t){return z(t,["symbol"])}function D(){let t=0,n=0,e=0;return r=>{"start"===r.action&&(t=r.mapStart.x,n=r.mapStart.y,e=r.mapStart.z);const o=r.mapEnd.x-t,a=r.mapEnd.y-n,c=r.mapEnd.z-e;return t=r.mapEnd.x,n=r.mapEnd.y,e=r.mapEnd.z,{...r,mapDeltaX:o,mapDeltaY:a,mapDeltaZ:c,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function b(){let t=0,n=0;return e=>{"start"===e.action&&(t=e.screenStart.x,n=e.screenStart.y);const r=e.screenEnd.x-t,o=e.screenEnd.y-n;return t=e.screenEnd.x,n=e.screenEnd.y,{...e,screenDeltaX:r,screenDeltaY:o}}}function C(t,n){let r=null,o=0,a=0;return s=>{if("start"===s.action&&(r=t.toScreen(n),r.x<0||r.x>t.width||r.y<0||r.y>t.height?r=null:(o=s.screenStart.x-r.x,a=s.screenStart.y-r.y)),null==r)return null;const i=e(s.screenEnd.x-o,0,t.width),l=e(s.screenEnd.y-a,0,t.height),u=c(i,l);return s.screenStart=r,s.screenEnd=u,s}}class G{constructor(){this.execute=()=>{}}next(t,n=new G){return r(t)&&(this.execute=e=>{const o=t(e);r(o)&&n.execute(o)}),n}}export{G as EventPipeline,D as addMapDelta,b as addScreenDelta,d as constrainToMapAxis,f as createDragEventPipelineCallback,p as createManipulatorDragEventPipeline,y as createManipulatorDragEventPipelineMany,C as dragAtLocation,x as dragGraphic,R as dragGraphicMany,w as resetGraphic,M as resetGraphicMany,z as resetProperties,q as resetSymbol,j as screenToMap};
