/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../core/maybe","../../../core/handleUtils","../../../core/Collection","../../../core/watchUtils","../../../chunks/vec2f64","../../../chunks/vec2","./Settings","./snappingUtils","../../3d/support/geometryUtils/vector2d","./SnappingConstraint","./IntersectionSnappingCandidate","./LineSnapper","./ParallelLineSnapper","./RightAngleSnapper","./RightAngleTriangleSnapper"],(function(n,t,e,i,a,r,o,s,c,d,p,l,u,h,f,g){"use strict";let S=function(){function n(n){this._snapper=new i,this._currentSnappingCandidate=null,this._visualElementHandles=e.makeHandle(),this._optionsHandle=e.makeHandle(),this._squaredMouseProximityTreshold=s.defaults.pointProximityThreshold*s.defaults.pointProximityThreshold,this._squaredTouchProximityThreshold=s.defaults.pointProximityThreshold*s.defaults.pointProximityThreshold*s.defaults.touchSensitivityMultiplier*s.defaults.touchSensitivityMultiplier,this._snapper.push(new h.ParallelLineSnapper({enabled:n.effectiveSelfEnabled})),this._snapper.push(new u.LineSnapper({enabled:n.effectiveSelfEnabled})),this._snapper.push(new f.RightAngleSnapper({enabled:n.effectiveSelfEnabled})),this._snapper.push(new g.RightAngleTriangleSnapper({enabled:n.effectiveSelfEnabled})),this._optionsHandle=a.watch(n,"effectiveSelfEnabled",(()=>{for(const t of this._snapper)t.enabled=n.effectiveSelfEnabled;this.doneSnapping()}))}var S=n.prototype;return S.snap=function(n,t){const e=[];for(const i of this._snapper.items)e.push(...i.snap(n,t));return this._aggregateSnappingCandidates(e,n,t)},S.destroy=function(){this.doneSnapping(),this._optionsHandle.remove()},S.doneSnapping=function(){this._visualElementHandles.remove(),this._currentSnappingCandidate=null},S._aggregateSnappingCandidates=function(n,e,i){const a=n.length,r=i.geometry.data.coordinateHelper.fromPoint(e);if(t.isSome(this._currentSnappingCandidate)){if(this.isCurrentIntersectionConstraintStillActive(n)&&o.distance(r,this._currentSnappingCandidate.targetPoint)<this.squaredPointProximityThreshold(i.pointer))return i.geometry.data.coordinateHelper.createDehydratedPoint(this._currentSnappingCandidate.targetPoint);const e=_(n,this._currentSnappingCandidate);if(this.doneSnapping(),e>=0){const o=n[e],s=[];if(o.constraint instanceof p.LineLikeConstraint){for(let d=0;d<a;++d){if(d===e)continue;const a=n[d];if(a.constraint instanceof p.LineLikeConstraint){const n=this._intersectRaysAndLines(o,a,i);if(t.isSome(n)){const t=c.squareDistance(c.anyMapPointToScreenPoint(r,i.geometry.data.coordinateHelper,i.elevationInfo,i.view),c.anyMapPointToScreenPoint(n.targetPoint,i.geometry.data.coordinateHelper,i.elevationInfo,i.view));s.push([n,t])}}}if(s.length>0&&(s.sort(((n,t)=>n[1]-t[1])),s[0][1]<this.squaredPointProximityThreshold(i.pointer)))return this.updateSnappingCandidate(s[0][0],n,i)}return this.updateSnappingCandidate(o,n,i)}}if(a>0){let t=0,e=o.distance(r,n[0].targetPoint);for(let i=1;i<a;++i){const a=o.distance(r,n[i].targetPoint);a<e&&(e=a,t=i)}return this.updateSnappingCandidate(n[t],n,i)}return e},S._intersectRaysAndLines=function(n,t,e){const i=n.constraint.start,a=n.constraint.end,c=t.constraint.start,u=t.constraint.end,h=o.subtract(r.create(),a,i),f=o.subtract(r.create(),u,c),g=d.cross(h,f);if(Math.abs(g)<=s.defaults.intersectionParallelLineThreshold)return null;const S=o.subtract(r.create(),i,c),_=d.cross(f,S)/g,C=d.cross(h,S)/g,P=e.geometry.data.coordinateHelper;if(_>=0){if(C>=0||t.constraint instanceof p.LineConstraint){const e=P.clone(n.targetPoint);return o.scaleAndAdd(e,i,h,_),new l.IntersectionSnappingCandidate(P,e,n,t)}}else if(n.constraint instanceof p.LineConstraint&&(C>=0||t.constraint instanceof p.LineConstraint)){const e=P.clone(n.targetPoint);return o.scaleAndAdd(e,i,h,_),new l.IntersectionSnappingCandidate(P,e,n,t)}return null},S.isCurrentIntersectionConstraintStillActive=function(n){if(this._currentSnappingCandidate instanceof l.IntersectionSnappingCandidate){const t=this._currentSnappingCandidate.left,e=this._currentSnappingCandidate.right,i=_(n,t),a=_(n,e);return i>=0&&a>=0}return!1},S.updateSnappingCandidate=function(n,t,i){this._currentSnappingCandidate=n;const a=this._currentSnappingCandidate.targetPoint,r=[n.visualize(i.view,i.elevationInfo,a)];for(const e of t){if(n instanceof l.IntersectionSnappingCandidate){if(e.constraint.objectEqual(n.left.constraint)||e.constraint.objectEqual(n.right.constraint))continue}else if(e.constraint.objectEqual(n.constraint))continue;e.constraint.check(a)&&r.push(e.visualizeReferenceHints(i.view,i.elevationInfo,a))}return this._visualElementHandles=e.handlesGroup(r),i.geometry.data.coordinateHelper.createDehydratedPoint(a)},S.squaredPointProximityThreshold=function(n){return"touch"===n?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold},n}();function _(n,t){let e=-1;for(let i=0;i<n.length;++i)if(t.constraint.objectEqual(n[i].constraint)){e=i;break}return e}n.SnappingEngine=S,Object.defineProperty(n,"__esModule",{value:!0})}));
