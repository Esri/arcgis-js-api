/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/maybe","../../../chunks/vec2","../../../chunks/vec2f64","../../../chunks/vec3","../../../chunks/vec3f64","../../../support/elevationInfoUtils","./SnappingAlgorithm","./SnappingConstraint","./SnappingPoint","./snappingUtils","./candidates/RightAngleSnappingCandidate","../support/viewUtils"],(function(e,t,n,i,o,r,a,s,p,c,h,g,d,l){"use strict";let f=function(e){function o(){return e.apply(this,arguments)||this}t._inheritsLoose(o,e);var p=o.prototype;return p.snapNewVertex=function(e,t){const n=t.editGeometryOperations.data.components[0],i=n.vertices.length,o=[];if(i<2)return o;const{view:r}=this,a=l.vectorToScreenPoint(e,t.spatialReference,s.absoluteHeightElevationInfo,r),p=n.vertices[i-1];if(this.edgeExceedsShortLineThreshold(p.leftEdge,t)){const n=h.anyMapPointToSnappingPoint(p.pos,r,t),i=h.anyMapPointToSnappingPoint(p.leftEdge.leftVertex.pos,r,t);this._checkForSnappingCandidate(o,i,n,e,a,t)}const c=n.vertices[0];if(this.edgeExceedsShortLineThreshold(c.rightEdge,t)){const n=h.anyMapPointToSnappingPoint(c.pos,r,t),i=h.anyMapPointToSnappingPoint(c.rightEdge.rightVertex.pos,r,t);this._checkForSnappingCandidate(o,i,n,e,a,t)}return o},p.snapExistingVertex=function(e,t){const i=[],o=n.unwrap(t.vertexHandle);if(o.component.vertices.length<3)return i;const{view:r}=this,a=l.vectorToScreenPoint(e,t.spatialReference,s.absoluteHeightElevationInfo,r),p=o.leftEdge,c=o.rightEdge;if(p&&p.leftVertex.leftEdge){const n=p.leftVertex.leftEdge;if(this.edgeExceedsShortLineThreshold(n,t)){const o=h.anyMapPointToSnappingPoint(n.rightVertex.pos,r,t),s=h.anyMapPointToSnappingPoint(n.leftVertex.pos,r,t);this._checkForSnappingCandidate(i,s,o,e,a,t)}}if(c&&c.rightVertex.rightEdge){const n=c.rightVertex.rightEdge;if(this.edgeExceedsShortLineThreshold(n,t)){const o=h.anyMapPointToSnappingPoint(n.leftVertex.pos,r,t),s=h.anyMapPointToSnappingPoint(n.rightVertex.pos,r,t);this._checkForSnappingCandidate(i,s,o,e,a,t)}}return i},p._checkForSnappingCandidate=function(e,t,n,o,p,f){const{spatialReference:P,pointer:v}=f;i.subtract(u,n,t);const x=r.set(S,u[1],-u[0],0),E=i.dot(x,i.subtract(u,o,n))/i.squaredLength(x),T=h.asSnappingPoint(i.scaleAndAdd(a.clone(o),n,x,E));if(g.squaredScreenDistance(p,l.vectorToScreenPoint(T,P,s.absoluteHeightElevationInfo,this.view))<this.squaredProximityThreshold(v)){if(this.isVertical(T,n)||this.isVertical(n,t))return;const i=r.scaleAndAdd(a.create(),n,x,Math.sign(E));e.push(new d.RightAngleSnappingCandidate({targetPoint:T,constraint:new c.VerticalHalfPlaneConstraint(n,h.asSnappingPoint(i)),previousVertex:t,otherVertex:n,otherVertexType:d.OtherVertexType.CENTER,isDraped:"on-the-ground"===f.elevationInfo?.mode}))}},o}(p.SnappingAlgorithm);const u=o.create(),S=a.create();e.RightAngleSnapper=f,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
