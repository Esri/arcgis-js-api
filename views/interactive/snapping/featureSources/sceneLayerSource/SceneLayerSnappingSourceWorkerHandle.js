/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{HandleOwner as t}from"../../../../../core/HandleOwner.js";import{property as r}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as o}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as s}from"../../../../../chunks/vec3f64.js";import{WorkerHandle as i}from"../../../../../core/workers/WorkerHandle.js";import{f as n}from"../../../../../chunks/sphere.js";import{absoluteHeightElevationInfo as a}from"../../../../../support/elevationInfoUtils.js";import{EdgeSnappingCandidate as d}from"../../candidates/EdgeSnappingCandidate.js";import{VertexSnappingCandidate as c}from"../../candidates/VertexSnappingCandidate.js";let p=class extends t{constructor(e){super(e),this.availability=0,this._ids=new Set,this.tmpP=s()}destroy(){this.workerHandle.destroy(),this.workerHandle=null}initialize(){this.workerHandle=new l(this.schedule,{fetchAllEdgeLocations:(e,t)=>this._fetchAllEdgeLocations(e,t)})}async fetchCandidates(e,t){const r=e.coordinateHelper.toXYZ(e.point);this.view.renderCoordsHelper.toRenderCoords(r,e.coordinateHelper.spatialReference,r);const o="number"==typeof e.distance?e.distance:e.distance.pixelSize,s=await this.workerHandle.invoke({bounds:n(r[0],r[1],r[2],o),types:e.types},t),i=e.coordinateHelper;return s.candidates.sort(((e,t)=>e.distance-t.distance)),s.candidates.map((e=>this._convertCandidate(i,e)))}async add(e,t){this._ids.add(e.id),await this.workerHandle.invokeMethod("add",e,t)}async remove(e,t){this._ids.delete(e.id),await this.workerHandle.invokeMethod("remove",e,t)}_convertCandidate(e,t){switch(t.type){case"edge":return new d({coordinateHelper:e,objectId:t.objectId,targetPoint:this._convertRenderCoordinate(e,t.target),edgeStart:this._convertRenderCoordinate(e,t.start),edgeEnd:this._convertRenderCoordinate(e,t.end),elevationInfo:a});case"vertex":return new c({coordinateHelper:e,objectId:t.objectId,targetPoint:this._convertRenderCoordinate(e,t.target),elevationInfo:a})}}_convertRenderCoordinate(e,t){return this.view.renderCoordsHelper.fromRenderCoords(t,this.tmpP,e.spatialReference),e.fromXYZ(this.tmpP)}async _fetchAllEdgeLocations(e,t){const r=[],o=[];for(const{id:s,uid:i}of e.components)this._ids.has(s)&&r.push((async()=>{const e=await this.fetchEdgeLocations(s,t.signal);return o.push(e.locations.buffer),{id:s,uid:i,objectIds:e.objectIds,locations:e.locations.buffer,origin:e.origin,type:e.type}})());return{result:{components:(await Promise.all(r)).filter((({id:e})=>this._ids.has(e)))},transferList:o}}};e([r({constructOnly:!0})],p.prototype,"view",void 0),e([r({constructOnly:!0})],p.prototype,"fetchEdgeLocations",void 0),e([r({constructOnly:!0})],p.prototype,"schedule",void 0),e([r({readOnly:!0})],p.prototype,"availability",void 0),p=e([o("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],p);class l extends i{constructor(e,t){super("SceneLayerSnappingSourceWorker","fetchCandidates",{},e,{strategy:"dedicated",client:t})}}export{p as SceneLayerSnappingSourceWorkerHandle};
