/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t,abortMaybe as n}from"../../../core/maybe.js";import{ignoreAbortErrors as r,debounce as a}from"../../../core/promiseUtils.js";import{pointEquals as o}from"../../../layers/graphics/dehydratedFeatureComparison.js";import{EventPipeline as i}from"../dragEventPipeline.js";import{SnappingContext as s}from"./SnappingContext.js";import{TaskPriority as p,ImmediateTask as l}from"../../support/Scheduler.js";class d{constructor(){this.next=new i}createSnapDragEventPipelineStep({predicate:d=(()=>!0),cancel:c,snappingManager:m,snappingContext:x,updatingHandles:u}){if(e(m))return e=>e;let y=null,f=null;const g=()=>{y=n(y),m.doneSnapping(),t(f)&&f.frameTask.remove(),f=null};c.next((e=>(g(),e))),this.next=new i;const v=a((async({frameTask:e,point:t,context:n,event:r,dx:a,dy:i},s)=>{const p=await e.schedule((()=>m.snap(t,n,s)),s);if(p.valid){let l=await e.schedule((()=>p.apply()),s);t!==P&&(l=m.update(P,n)),o(l,h)||(r.mapEnd.x=l.x+a,r.mapEnd.y=l.y+i,this.next.execute(r))}}));let P,h;return e=>{if(!d(e))return e;if("start"===e.action){const n="3d"===m.view.type?m.view.resourceController.scheduler.registerTask(p.SNAPPING):l;f={context:new s({editGeometryOperations:x.editGeometryOperations,elevationInfo:x.elevationInfo,pointer:x.pointer,vertexHandle:t(e.info)?e.info.handle:null,excludeFeature:x.excludeFeature,visualizer:x.visualizer}),originalPos:t(e.snapOrigin)?x.coordinateHelper.vectorToDehydratedPoint(e.snapOrigin):e.mapStart,frameTask:n}}if(t(f)){const n=f.context.coordinateHelper.vectorToDehydratedPoint(f.context.coordinateHelper.arrayToVector([f.originalPos.x,f.originalPos.y,f.originalPos.z]));n.x+=e.mapEnd.x-e.mapStart.x,n.y+=e.mapEnd.y-e.mapStart.y;const a=e.mapStart.x-f.originalPos.x,o=e.mapStart.y-f.originalPos.y,i={...e,action:"update"},s=f.context,p=m.update(n,f.context);if(h=p,e.mapEnd.x=p.x+a,e.mapEnd.y=p.y+o,P=n,"end"!==e.action){const e=f.frameTask;t(y)||(y=new AbortController),u.addPromise(r(v({frameTask:e,event:i,context:s,point:n,dx:a,dy:o},y.signal)))}}return"end"===e.action&&g(),e}}}export{d as SnappingPipeline};
