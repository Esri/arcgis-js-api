/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/maybe","../../../core/promiseUtils","../../../layers/graphics/dehydratedFeatureComparison","../../../layers/graphics/hydratedFeatures","../dragEventPipeline","./SnappingContext","../../support/Scheduler"],(function(e,n,t,o,i,a,s,r,p){"use strict";let l=function(){function e(){this.next=new s.EventPipeline}var l=e.prototype;return l.createSnapDragEventPipelineStep=function({predicate:e=(()=>!0),cancel:n,snappingManager:i,snappingContext:a,updatingHandles:r,useZ:p=!0}){if(t.isNone(i))return e=>e;let l=null,c=null;const u=()=>{l=t.abortMaybe(l),i.doneSnapping(),t.isSome(c)&&c.frameTask.remove(),c=null};n.next((e=>(u(),e))),this.next=new s.EventPipeline;const d=this._createSnapFunction(i,p);let f=null,S=null,m=null;return n=>{if(!e(n))return n;if("start"===n.action){const e=this._createFrameTask(i.view);if(c=this._createSnappingInfo(a,n,e),c.context.selfSnappingZ=null,!p&&t.isSome(n.info)){const e=this._extractSelfSnappingZ(a.coordinateHelper,n.info.handle.component);t.isSome(e)&&(c.context.selfSnappingZ={value:e,elevationInfo:a.elevationInfo})}}if(t.isSome(c)){const{context:e,originalScenePos:a,originalPos:s}=c,{mapEnd:u,mapStart:h,action:P,scenePoints:g}=n,x=this._updatePosition(s,this._computeMapDelta(u,h)),y=this._computeMapDelta(h,s),v={...n,action:"update"},_=c.context,T=this._updateScenePosition(a,g),Z=i.update({point:x,scenePoint:T,context:e});if(m=Z,this._applySnappedUpdate(u,Z,y,p),f=x,S=T,"end"!==P){const{frameTask:e}=c;t.isNone(l)&&(l=new AbortController),r.addPromise(o.ignoreAbortErrors(d({frameTask:e,event:v,context:_,point:x,scenePoint:T,delta:y,lastPos:f,lastScenePos:S,lastUpdate:m},l.signal)))}}return"end"===n.action&&u(),n}},l._createSnapFunction=function(e,a){var s=this;return o.debounce(function(){var o=n._asyncToGenerator((function*({frameTask:n,point:o,scenePoint:r,context:p,event:l,delta:c,lastPos:u,lastScenePos:d,lastUpdate:f},S){const m=yield n.schedule((()=>e.snap({point:o,scenePoint:r,context:p,signal:S})),S);if(m.valid){let r=yield n.schedule((()=>m.apply()),S);o!==u&&t.isSome(u)&&(r=e.update({point:u,scenePoint:d,context:p})),i.pointEquals(r,f)||(s._applySnappedUpdate(l.mapEnd,r,c,a),s.next.execute(l))}}));return function(e,n){return o.apply(this,arguments)}}())},l._createFrameTask=function(e){return"3d"===e.type?e.resourceController.scheduler.registerTask(p.TaskPriority.SNAPPING):p.ImmediateTask},l._createSnappingInfo=function(e,n,o){return{context:new r.SnappingContext({editGeometryOperations:e.editGeometryOperations,elevationInfo:e.elevationInfo,pointer:e.pointer,vertexHandle:t.isSome(n.info)?n.info.handle:null,excludeFeature:e.excludeFeature,visualizer:e.visualizer}),originalPos:t.isSome(n.snapOrigin)?e.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:t.isSome(n.scenePoints)?n.scenePoints.sceneStart:null,frameTask:o}},l._updatePosition=function(e,[n,t,o]){const i=a.clonePoint(e);return i.x+=n,i.y+=t,i.hasZ&&(i.z+=o),i},l._updateScenePosition=function(e,n){return t.isNone(e)||t.isNone(n)?null:this._updatePosition(e,this._computeMapDelta(n.sceneEnd,n.sceneStart))},l._computeMapDelta=function(e,n){const t=e.hasZ&&n.hasZ?e.z-n.z:0;return[e.x-n.x,e.y-n.y,t]},l._applySnappedUpdate=function(e,n,[t,o,i],a){e.x=n.x+t,e.y=n.y+o,a&&e.hasZ&&n.hasZ&&(e.z=n.z+i)},l._extractSelfSnappingZ=function(e,n){if(!e.hasZ())return null;const o=n.vertices;let i=null;for(const a of o){const n=e.getZ(a.pos);if(t.isSome(i)&&Math.abs(n-i)>1e-6)return null;t.isNone(i)&&(i=n)}return i},e}();e.SnappingPipeline=l,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
