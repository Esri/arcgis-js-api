/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["require","../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../core/has","../../core/Logger","../../core/accessorSupport/ensureType","../../core/accessorSupport/decorators/property","../../core/accessorSupport/decorators/subclass","../../core/urlUtils","../../core/uuid","../../portal/support/resourceExtension","../../core/arrayUtils","../../core/promiseUtils","../../core/Accessor","../../geometry/support/webMercatorUtils","../../core/Handles","../../core/watchUtils","../../geometry/support/heightModelInfoUtils"],(function(e,t,i,o,n,s,a,l,r,c,d,h,u,p,f,_,g,y){"use strict";var I;const S=n.getLogger("esri.views.support.DefaultsFromMap");let m=I=function(i){function o(){var e;return(e=i.apply(this,arguments)||this)._handles=new _,e._waitTask=null,e._extentProjectController=null,e._spatialReferenceCandidates=null,e._extentCandidates=null,e.logDebugInformation=!1,e.isSpatialReferenceDone=!1,e.isTileInfoDone=!1,e.isHeightModelInfoSearching=!1,e.spatialReference=null,e.extent=null,e.heightModelInfo=null,e.vcsWkid=null,e.latestVcsWkid=null,e.mapCollectionPaths=I.DefaultMapCollectionPaths.slice(),e.tileInfo=null,e}t._inheritsLoose(o,i);var n=o.prototype;return n.initialize=function(){this.watch("mapCollectionPaths",(()=>{this._running&&(this.reset(),this.start())}))},n.destroy=function(){this._set("view",null),this._handles&&(this._handles.destroy(),this._handles=null),this._cancelLoading()},n.reset=function(){this._handles.removeAll(),this._set("isSpatialReferenceDone",!1),this._set("isTileInfoDone",!1),this._set("isHeightModelInfoSearching",!1),this._set("spatialReference",null),this._set("extent",null),this._set("heightModelInfo",null),this._set("vcsWkid",null),this._set("latestVcsWkid",null),this._set("tileInfo",null),this._spatialReferenceCandidates=null,this._extentCandidates=null},n.start=function(){this._handles.removeAll();const e=this._updateLayerChange.bind(this);for(const t of this.mapCollectionPaths)this._handles.add(g.on(this.view,`map.${t}`,"change",e,e,e,!0));this._handles.add(g.when(this,"isSpatialReferenceDone",(()=>this._updateTileInfo()),!0))},n._ownerNameFromCollectionName=function(e){const t=e.lastIndexOf(".");return-1===t?"view":"view."+e.slice(0,t)},n._ensureLoadedOwnersFromCollectionName=function(e){const t=this._ownerNameFromCollectionName(e).split(".");let i;for(let o=0;o<t.length&&(i=this.get(t.slice(0,o+1).join(".")),i);o++)if(i.load&&!i.isFulfilled())return{collectionName:e,owner:null,loading:i.load().catch((()=>{}))};return{collectionName:e,owner:i}},n._cancelLoading=function(){this._waitTask=null,this._extentProjectController&&(this._extentProjectController.abort(),this._extentProjectController=null)},n._updateWhen=function(e){let t=!0,i=!1;const o=e.catch((()=>{})).then((()=>{t?i=!0:o===this._waitTask&&this._update()}));return t=!1,i||(this._waitTask=o),i},n._updateLayerChange=function(){this.isSpatialReferenceDone&&!this.spatialReference&&this._set("isSpatialReferenceDone",!1),this._update()},n._update=function(){if(this._cancelLoading(),this.view){if(!this.isSpatialReferenceDone){this._debugLog("Starting search for spatial reference...");const e=this._processMapCollections((e=>this._processSpatialReferenceSource(e)));if(this._debugLog(`Search ended with status '${R(e)}'`),0!==e){let e=null,t=this._spatialReferenceCandidates;if(!t||t.length<1?(e=this.defaultSpatialReference,this._debugLog(`No spatial reference found, locking to default (${b(e)})`)):(this.defaultSpatialReference&&t.length>1&&t.findIndex((e=>e.equals(this.defaultSpatialReference)))>-1&&(t=[this.defaultSpatialReference]),e=t[0],this._debugLog(`Locking to ${b(e)}`)),this._set("spatialReference",e),e)if(this.extent)this._set("isSpatialReferenceDone",!0);else{const t=this.logDebugInformation;this.logDebugInformation=!1,this._processMapCollections((t=>this._findExtent(t,e))),this.logDebugInformation=t,this._projectExtentCandidate().catch((()=>{})).then((()=>this._set("isSpatialReferenceDone",!0)))}else this._set("isSpatialReferenceDone",!0)}}if(null==this.heightModelInfo&&this.view.isHeightModelInfoRequired){this._debugLog("Starting search for height model info...");const e=this._processMapCollections((e=>this._processHeightModelInfoSource(e)),(e=>y.mayHaveHeightModelInfo(e)));this._debugLog(`Search ended with status ${R(e)}`),this._set("isHeightModelInfoSearching",0===e)}this._updateTileInfo()}},n._processMapCollections=function(e,t){this._preloadMapCollections(t);let i=2;return this._forAllMapCollectionSources((e=>{if(2!==i)return!1;const{collectionName:t}=e;return this._debugLog(`Processing collection ${t}...`),!(e.loading&&!this._updateWhen(e.loading))||(this._debugLog(`Collection ${e.collectionName} owner is loading -> wait`),i=0,!1)}),(o=>{if(2!==i)return!1;return null!=t&&!t(o)?(this._debugLog(`Source ${o.id} is skipped due to predicate`),!1):!o.load||o.isFulfilled()||this._updateWhen(o.load())?!((!o.load||o.isResolved())&&e(o))||(i=1,!1):(this._debugLog(`Source ${o.id} is loading -> wait`),i=0,!1)})),i},n._preloadMapCollections=function(e){let t=10;const i=this.logDebugInformation;this.logDebugInformation=!1,this._forAllMapCollectionSources((()=>!0),(o=>{if(0===t)return!1;return!(null!=e&&!e(o))&&(o.load&&!o.isFulfilled()&&(this.logDebugInformation=i,this._debugLog(`Pre-loading source ${o.id}`),this.logDebugInformation=!1,o.load().catch((()=>{})),t--),!0)})),this.logDebugInformation=i},n._forAllMapCollectionSources=function(e,t){for(const i of this.mapCollectionPaths){const o=`map.${i}`,n=this._ensureLoadedOwnersFromCollectionName(o);if(!1===e(n))continue;const s=n.owner;if(!s||s.isRejected&&s.isRejected()){this._debugLog(`Collection ${o} owner is invalid or rejected -> skip`);continue}const a=this.view.get(o);a?this._forEachSource(a,t):this._debugLog(`Collection ${o} does not exist -> skip`)}},n._forEachSource=function(e,t){for(const i of e.items)!1!==t(i)&&"layers"in i&&i.layers&&this._forEachSource(i.layers,t)},n._processSpatialReferenceSource=function(e){let t=this._getSupportedSpatialReferences(e);return 0!==t.length&&(this._spatialReferenceCandidates?(t=h.intersect(t,this._spatialReferenceCandidates,((e,t)=>e.equals(t))),t.length>0?this._spatialReferenceCandidates=t:this._debugLog(`Layer ${e.id} is ignored because its supported spatial\n          references are not compatible with the previous candidates`)):this._spatialReferenceCandidates=t,1===this._spatialReferenceCandidates.length)},n._findExtent=function(e,t){const i="fullExtents"in e&&e.fullExtents||(e.fullExtent?[e.fullExtent]:[]),o=i.find((e=>e.spatialReference.equals(t)));if(o)return this._set("extent",o),!0;if(this._getSupportedSpatialReferences(e).length>0){const t=i.map((t=>({extent:t,layer:e}))),o=this._extentCandidates||[];this._extentCandidates=o.concat(t)}return!1},n._projectExtentCandidate=async function(){if(!this._extentCandidates||!this._extentCandidates.length)return;const t=this.spatialReference,i=this._extentCandidates.find((e=>f.canProject(e.extent.spatialReference,t)));if(i)this._set("extent",f.project(i.extent,t));else{const i=this._extentCandidates[0];this._extentProjectController=u.createAbortController();const o=await new Promise((function(t,i){e(["../../portal/support/geometryServiceUtils"],t,i)}));try{const e=await o.projectGeometry(i.extent,t,i.layer.portalItem,this._extentProjectController.signal);this._set("extent",e)}catch{}this._extentProjectController=null}},n._getSupportedSpatialReferences=function(e){const t="supportedSpatialReferences"in e&&e.supportedSpatialReferences||(e.spatialReference?[e.spatialReference]:[]);if(0===t.length)return this._debugLog(`Layer ${e.id} is ignored because it does not have any spatial references`),[];const i=t.filter((t=>this.view.isSpatialReferenceSupported(t,e,(e=>this._debugLog(e)))));return 0===i.length?this._debugLog(`Layer ${e.id} has spatial references but none of them are supported (or layer doesn't require locking)`):this._debugLog(`Layer ${e.id} has spatial references. Resulting candidate set: ${i.map(b).join(", ")}`),i},n._processHeightModelInfoSource=function(e){const t=y.deriveHeightModelInfoFromLayer(e);return!!t&&(this._set("heightModelInfo",t),this._set("isHeightModelInfoSearching",!1),e.spatialReference&&(this._set("vcsWkid",e.spatialReference.vcsWkid),this._set("latestVcsWkid",e.spatialReference.latestVcsWkid)),!0)},n._updateTileInfo=function(){if(null!=this.tileInfo)return;if(!this.view.isTileInfoRequired())return void this._set("isTileInfoDone",!0);if(!this.isSpatialReferenceDone)return;const e=this.get("view.map");if(!e)return void this._debugLog("updateTileInfo: no map");const t=e.basemap,i=e.get("layers.0");let o=null;if(t&&"failed"!==t.loadStatus){if(!t.loaded)return this._updateWhen(t.load()),void this._debugLog("updateTileInfo: basemap still loading");const e=t&&t.get("baseLayers.0");if(e&&"failed"!==e.loadStatus){if(!e.loaded)return this._updateWhen(e.load()),void this._debugLog("updateTileInfo: first basemap layer still loading");o="tileInfo"in e&&e.tileInfo}else{if(!i||"failed"===i.loadStatus)return this._debugLog("updateTileInfo: no tileInfo"),void this._set("isTileInfoDone",!0);if(!i.loaded)return this._updateWhen(i.load()),void this._debugLog("updateTileInfo: first operational layer still loading");o="tileInfo"in i&&i.tileInfo}}else if(i&&"failed"!==i.loadStatus){if(!i.loaded)return this._updateWhen(i.load()),void this._debugLog("updateTileInfo: first operational layer still loading");o="tileInfo"in i&&i.tileInfo}o&&!o.spatialReference.equals(this.spatialReference)&&(o=null),this._debugLog(`updateTileInfo: setting ${o}`),this._set("tileInfo",o),this._set("isTileInfoDone",!0)},n._debugLog=function(e){this.logDebugInformation&&S.info(e)},t._createClass(o,[{key:"_running",get:function(){return!!(this._handles&&this._handles.size>0)}}]),o}(p);function b(e){return e?JSON.stringify(e.toJSON()):"undefined"}function R(e){switch(e){case 0:return"Waiting";case 1:return"Found";case 2:return"Exhausted"}}return m.DefaultMapCollectionPaths=["basemap.baseLayers","layers","ground.layers","basemap.referenceLayers"],i.__decorate([a.property()],m.prototype,"logDebugInformation",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"isSpatialReferenceDone",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"isTileInfoDone",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"isHeightModelInfoSearching",void 0),i.__decorate([a.property({constructOnly:!0})],m.prototype,"view",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"spatialReference",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"extent",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"heightModelInfo",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"vcsWkid",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"latestVcsWkid",void 0),i.__decorate([a.property()],m.prototype,"mapCollectionPaths",void 0),i.__decorate([a.property()],m.prototype,"defaultSpatialReference",void 0),i.__decorate([a.property({readOnly:!0})],m.prototype,"tileInfo",void 0),m=I=i.__decorate([l.subclass("esri.views.support.DefaultsFromMap")],m),m}));
