/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../core/compilerUtils","../../../core/mathUtils","../../../chunks/vec3f64","../../../chunks/vec3","./mathUtils","../../../geometry/projectionEllipsoid","../../../chunks/mat4","../../../geometry/support/aaBoundingRect","../../../geometry/projection","../../../chunks/mat4f64","../../../geometry/support/aaBoundingBox","./geometryUtils","./intersectionUtils"],(function(e,t,i,n,r,o,s,a,c,l,h,d,p,u){"use strict";const g=.5*Math.PI,x=g/Math.PI*180;let f=function(){function e(e){this.renderCoordsHelper=e.renderCoordsHelper,this.extent=new Array(4),this.planes=new Array(6),this.maxSpan=0,this.center={origin:n.create(),direction:n.create()};for(let e=0;e<4;e++)this.extent[e]={origin:n.create(),direction:n.create(),cap:{next:null,direction:n.create()}},this.planes[e]=p.plane.create();this.planes[4]=p.plane.create(),this.planes[5]=p.plane.create(),this.planesWithoutFar=this.planes.slice(0,5)}var h=e.prototype;return h.update=function(e,t,i,n=!0){const a=this.extent;this.toRenderBoundingExtent(e,t,i),r.add(this.center.origin,a[0].origin,a[2].origin),r.scale(this.center.origin,this.center.origin,.5),this.renderCoordsHelper.worldUpAtPosition(this.center.origin,this.center.direction),n||r.scale(this.center.direction,this.center.direction,-1);for(let e=0;e<4;e++){const t=a[e];this.renderCoordsHelper.worldUpAtPosition(t.origin,t.direction);const i=a[3===e?0:e+1];t.cap.next=i.origin,o.directionFromTo(t.cap.direction,t.origin,i.origin),p.plane.fromVectorsAndPoint(t.direction,t.cap.direction,t.origin,this.planes[e]),n||r.scale(t.direction,t.direction,-1)}p.plane.fromVectorsAndPoint(a[0].cap.direction,a[1].cap.direction,a[0].origin,this.planes[4]),n?p.plane.negate(this.planes[4],this.planes[5]):(p.plane.copy(this.planes[4],this.planes[5]),p.plane.negate(this.planes[4],this.planes[4])),this.maxSpan=Math.max(Math.abs(e[0]-e[2]),Math.abs(e[1]-e[3])),this.maxSpanSpatialReference=t,this.minGlobalAltitude=.9*s.getReferenceEllipsoid(this.maxSpanSpatialReference).radius},h.isVisibleInFrustum=function(e,t,i=!1){if(null==e)return!1;if(1===this.renderCoordsHelper.viewingMode){const i=this.maxSpanSpatialReference.isGeographic?x:g*t;if(this.maxSpan>i)return!0;if(e.altitude>=this.minGlobalAltitude)return this.isVisibleInFrustumGlobal(e)}if(0===this.maxSpan){const t=this.extent[0];return!(i||!e.intersectsRay(p.ray.wrap(t.origin,t.direction)))}for(let t=0;t<this.extent.length;t++){const n=this.extent[t];if(!i&&e.intersectsRay(p.ray.wrap(n.origin,n.direction)))return!0;if(e.intersectsLineSegment(p.lineSegment.fromPoints(n.origin,n.cap.next,M),n.cap.direction))return!0}const n=i?this.planes:this.planesWithoutFar;for(let t=0;t<e.lines.length;t++){const i=e.lines[t];if(u.frustumLineSegment(n,i.origin,i.endpoint,i.direction))return!0}return!1},h.toRenderBoundingExtentGlobal=function(e,t,n){c.center(e,y),y[2]=n,l.computeLinearTransformation(t,y,R,this.renderCoordsHelper.spatialReference),a.invert(b,R),d.empty(S);for(const{x0:o,x1:s,y0:a,y1:c}of m)for(let h=0;h<5;h++){const p=h/4;y[0]=i.lerp(e[o],e[s],p),y[1]=i.lerp(e[a],e[c],p),y[2]=n,l.projectVectorToVector(y,t,y,this.renderCoordsHelper.spatialReference),r.transformMat4(y,y,b),d.expandWithVec3(S,y)}r.set(this.extent[0].origin,S[0],S[1],S[2]),r.set(this.extent[1].origin,S[3],S[1],S[2]),r.set(this.extent[2].origin,S[3],S[4],S[2]),r.set(this.extent[3].origin,S[0],S[4],S[2]);for(let e=0;e<4;++e)r.transformMat4(this.extent[e].origin,this.extent[e].origin,R)},h.toRenderBoundingExtentLocal=function(e,t){r.set(this.extent[0].origin,e[0],e[1],t),r.set(this.extent[1].origin,e[2],e[1],t),r.set(this.extent[2].origin,e[2],e[3],t),r.set(this.extent[3].origin,e[0],e[3],t)},h.toRenderBoundingExtent=function(e,i,n){switch(this.renderCoordsHelper.viewingMode){case 1:this.toRenderBoundingExtentGlobal(e,i,n);break;case 2:this.toRenderBoundingExtentLocal(e,n);break;default:t.neverReached(this.renderCoordsHelper.viewingMode)}},h.isVisibleInFrustumGlobal=function(e){if(r.dot(this.center.direction,e.direction)<0)return!0;for(let t=0;t<4;t++){const i=this.extent[t];if(r.dot(i.direction,e.direction)<0)return!0}return!1},e}();const m=[{x0:0,y0:1,x1:2,y1:1},{x0:0,y0:3,x1:2,y1:3},{x0:0,y0:1,x1:0,y1:3},{x0:2,y0:1,x1:2,y1:3}],y=n.create(),R=h.create(),b=h.create(),S=d.create(),M=p.lineSegment.create();e.FrustumExtentIntersection=f,e.default=f,Object.defineProperty(e,"__esModule",{value:!0})}));
