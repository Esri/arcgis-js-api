/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../Camera","../../../geometry","../../../Graphic","../../../Viewpoint","../../../core/asyncUtils","../../../core/has","../../../core/Error","../../../core/maybe","../../../core/promiseUtils","../../../chunks/mat3","../../../chunks/mat3f64","../../../chunks/mat4f64","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/projection","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/frustum","../../../geometry/support/webMercatorUtils","../camera/intersectionUtils","./cameraUtils","./ElevationProvider","./mathUtils","../../../geometry/Point","../../../geometry/SpatialReference","../../../geometry/Extent","../../../geometry/Geometry"],(function(e,t,n,r,o,a,i,c,s,l,u,m,p,f,y,g,h,d,x,v,w,T,G,b,R,S,z,A,j){"use strict";const B=.66;function P(e){return 360-R.cyclicalDeg.normalize(e)}function M(e){return R.cyclicalDeg.normalize(360-e)}function V(e){return l.isSome(e)&&e.resolver&&e.resolver.reject(),null}function C(e,t){return l.isSome(e)&&e.resolver&&e.resolver.resolve(t),t}function k(e,t,n,r=null){if(!t)return V(r);const o=e.spatialReference||z.WGS84;if(l.isSome(t.camera)){const e=w.project(t.camera.position,o);if(l.isNone(e))return V(r);const n=t.camera.clone();return n.position=e,C(r,n)}if(l.isNone(t.targetGeometry))return V(r);const a=t.get("targetGeometry.spatialReference");if(a&&!w.canProject(a,o))return V(r);const i=G.internalToExternal(e,e.state.camera);let c=1;if(null!=t.rotation&&(i.heading=P(t.rotation),c=0),null!=n&&(i.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let o;const a=t.targetGeometry.clone();return o=null!=t.scale?G.scaleToDistance(e,t.scale,n.latitude):e.state.camera.distance,G.fromCenterDistance(e,a,o,i,c,r)}const s=t.targetGeometry.extent;return G.fromExtent(e,s,i.heading,i.tilt,c,r)}function E(e,t,n=null){return l.isNone(n)&&(n=new a),D(e,null,t.clone(),n)}function Z(e,t,n){return O.apply(this,arguments)}function O(){return(O=t._asyncToGenerator((function*(e,t,r){const o=ce(e,t);if(!o)throw new s("viewpointutils-create:no-target","Missing target for creating viewpoint");const i=new n({fov:e.camera.fov}),c=new a({camera:i});if(o.target instanceof a){return se(yield $(e,o.target,o,r,c))}if(o.target instanceof n)return se(X(e,o.target,c));const l=null!=o.scale||null!=o.zoom;if(o.target instanceof A){const t=o.target.xmin===o.target.xmax||o.target.ymin===o.target.ymax;return se(l||t?yield K(e,o,o.target.center,i,r,c):yield ne(e,o,o.target,i,r,c))}const u={boundingBox:d.empty(),hasZ:!1,screenSpaceObjects:[]},m=l?F(e,o):void 0;if(yield H(e,o.target,m,u),isFinite(u.boundingBox[0])){let t;if(d.center(u.boundingBox,ue),ve.x=ue[0],ve.y=ue[1],ve.z=ue[2],ve.spatialReference=e.spatialReference,isFinite(ve.z)&&u.hasZ?t=d.isPoint(u.boundingBox):(ve.z=void 0,t=x.isPoint(d.toRect(u.boundingBox,ye))),l||t)return se(yield K(e,o,ve,i,r,c));const n=le(e,u.screenSpaceObjects);return se(yield ae(e,o,ve,u.boundingBox,n,i,r,c))}return o.position?se(Q(e,o,i,c)):se(yield ee(e,o,i,r,c))}))).apply(this,arguments)}function _(e,t){return null==t.scale&&null!=t.zoom?G.zoomToScale(e,t.zoom):t.scale}function F(e,t){return G.scaleToResolution(e,_(e,t))}function N(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=P(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function D(e,t,n,r){const o=e.spatialReference||z.WGS84;return t=l.isSome(t)?t:G.externalToInternal(e,n),l.isNone(t)||(r.targetGeometry=h.projectVectorToPoint(t.center,e.renderSpatialReference,o),r.scale=G.computeScale(e,t),r.rotation=M(n.heading),r.camera=n),r}function U(e,t,n){if(!t)return;if(!w.canProject(t.spatialReference,e.spatialReference))throw new s("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference.wkid})`,{geometry:t});const r=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&w.canProject(n,e.basemapTerrain.spatialReference)?ue[2]=l.unwrapOr(b.getElevationAtPoint(e.elevationProvider,n),0):ue[2]=0}(0,we[t.type])(t,(e=>{r.push(e[0],e[1],e[2])}),ue);const o=r.length/3;if(0===o)return;const a=new Array(r.length);if(h.projectBuffer(r,t.spatialReference,0,a,e.spatialReference,0,o)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<a.length;e+=3)t.hasZ?(ue[0]=a[e+0],ue[1]=a[e+1],ue[2]=a[e+2]):(ue[0]=a[e+0],ue[1]=a[e+1]),d.expandWithVec3(n.boundingBox,ue)}}function W(e,t,n,r){return I.apply(this,arguments)}function I(){return(I=t._asyncToGenerator((function*(e,t,n,r){const o=yield i.result(e.whenViewForGraphic(t));if(!1===o.ok||l.isNone(o.value)||!("whenGraphicBounds"in o.value))return void U(e,t.geometry,r);const a=o.value,c=yield i.result(a.whenGraphicBounds(t,{minDemResolution:n}));if(!1===c.ok)return void U(e,t.geometry,r);const{screenSpaceObjects:s,boundingBox:u}=c.value;d.expandWithAABB(r.boundingBox,u),s&&s.forEach((e=>{r.screenSpaceObjects.push(e)})),isFinite(u[2])&&(r.hasZ=!0)}))).apply(this,arguments)}function H(e,t,n,r){return Y.apply(this,arguments)}function Y(){return(Y=t._asyncToGenerator((function*(e,t,n,r){if(Array.isArray(t)&&2===t.length){const n=t[0],o=t[1];if("number"==typeof n&&"number"==typeof o)return ve.x=n,ve.y=o,ve.z=void 0,ve.spatialReference=e.spatialReference.isGeographic?e.spatialReference:z.WGS84,void U(e,ve,r)}t&&"function"==typeof t.map?yield u.eachAlways(t.map((t=>H(e,t,n,r)))):t instanceof j?U(e,t,r):t instanceof o&&(yield W(e,t,n,r))}))).apply(this,arguments)}function $(e,t,n,r,o){return q.apply(this,arguments)}function q(){return(q=t._asyncToGenerator((function*(e,t,n,r,o){if(l.isSome(t.camera))return X(e,t.camera,o);o.scale=t.scale,o.rotation=t.rotation,o.targetGeometry=l.isSome(t.targetGeometry)?t.targetGeometry.clone():null,o.camera=null,null!=n.heading?o.rotation=M(n.heading):null!=n.rotation&&(o.rotation=n.rotation);const a=_(e,n);null!=a&&(o.scale=a);const i=new G.AsyncContext(r);return k(e,o,n.tilt,i),o.camera=yield i.resolver.promise,o}))).apply(this,arguments)}function X(e,t,n){const r=e.spatialReference,o=w.project(t.position,r);return l.isNone(o)?null:((t=t.clone()).fov=e.camera.fov,t.position=o,D(e,null,t,n))}function J(e,t,n,r,o,a){const i=e.renderSpatialReference;return h.projectPointToVector(n.position,he,i),h.projectPointToVector(t,de,i),a.targetGeometry=new S(t),o.position=new S(n.position),y.subtract(ge,de,he),G.directionToHeadingTilt(e,he,ge,r.up,o),a.scale=G.distanceToScale(e,y.distance(he,de),a.targetGeometry.latitude),a.rotation=M(o.heading),a.camera=o,a}function K(e,t,n,r,o,a){return L.apply(this,arguments)}function L(){return(L=t._asyncToGenerator((function*(e,t,n,r,o,a){if(l.isNone(n))throw new s("createfromcenter","invalid point");a.targetGeometry=n.clone();const i=T.cameraOnContentAlongViewDirection(e);if(t.position)return J(e,a.targetGeometry,t,i,r,a);if(t.zoomFactor){const r=i.distance/t.zoomFactor,o=y.scale(ue,i.viewForward,-r);i.eye=y.add(ue,i.center,o),a.scale=G.distanceToScale(e,r,n.latitude)}G.internalToExternal(e,i,r);const c=N(r,t)?0:1;if(!t.zoomFactor){a.scale=_(e,t),null==a.scale&&(h.projectPointToVector(n,ue,e.renderSpatialReference),v.intersectsPoint(i.frustum,ue)?a.scale=G.distanceToScale(e,y.distance(i.eye,ue),n.latitude):a.scale=G.computeScale(e,i));const s=new G.AsyncContext(o);G.fromCenterScale(e,a.targetGeometry,a.scale,r,c,s),a.camera=yield s.resolver.promise}return a}))).apply(this,arguments)}function Q(e,t,n,r){const o=T.cameraOnContentAlongViewDirection(e);return y.copy(ge,o.viewForward),G.directionToHeadingTilt(e,o.eye,ge,o.up,xe),n.position=new S(t.position),n.heading=null!=t.heading?t.heading:xe.heading,n.tilt=null!=t.tilt?t.tilt:xe.tilt,D(e,null,n,r)}function ee(e,t,n,r,o){return te.apply(this,arguments)}function te(){return(te=t._asyncToGenerator((function*(e,t,n,r,o){const a=T.cameraOnContentAlongViewDirection(e);return K(e,t,h.projectVectorToPoint(a.center,e.renderSpatialReference,e.spatialReference),n,r,o)}))).apply(this,arguments)}function ne(e,t,n,r,o,a){return re.apply(this,arguments)}function re(){return(re=t._asyncToGenerator((function*(e,t,n,r,o,a){a.targetGeometry=n.clone();const i=T.cameraOnContentAlongViewDirection(e);G.internalToExternal(e,i,r);const c=N(r,t)?0:1,s=new G.AsyncContext(o);return G.fromExtent(e,n,r.heading,r.tilt,c,s),a.camera=yield s.resolver.promise,a}))).apply(this,arguments)}function oe(e,t,n,r,o){let a=0;n.hasZ?a=n.z:e.basemapTerrain&&(a=l.unwrap(b.getElevationAtPoint(e.elevationProvider,n))),y.set(ue,n.x,n.y,a),h.computeTranslationToOriginAndRotation(e.spatialReference,ue,me,e.renderSpatialReference),m.fromMat4(pe,me),m.transpose(pe,pe),d.empty(fe);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let l=0;l<i.length;l++){const t=i[l];let n=r[t[2]];isFinite(n)||(n=a),y.set(ue,r[t[0]],r[t[1]],n),h.projectVectorToVector(ue,e.spatialReference,ue,e.renderSpatialReference),d.expandWithVec3(fe,y.transformMat3(ue,ue,pe))}const c=d.width(fe),s=d.height(fe),u=d.depth(fe),p=1/Math.tan(t.fovX/2),f=1/Math.tan(t.fovY/2),g=.5*Math.sqrt(c*c+u*u)*Math.max(f,p)+.5*s,x=.5*s*f+.5*Math.max(c,u);return Math.max(g,x)/o}function ae(e,t,n,r,o,a,i,c){return ie.apply(this,arguments)}function ie(){return(ie=t._asyncToGenerator((function*(e,t,n,r,o,a,i,c){c.targetGeometry=n.clone();const s=T.cameraOnContentAlongViewDirection(e),l=oe(e,s,n,r,o);G.internalToExternal(e,s,a);const u=N(a,t)?0:1;c.scale=G.distanceToScale(e,l,c.targetGeometry.latitude);const m=new G.AsyncContext(i);return G.fromCenterScale(e,c.targetGeometry,c.scale,a,u,m),c.camera=yield m.resolver.promise,c}))).apply(this,arguments)}function ce(e,t){if(!t||!e.spatialReference)return null;const n={target:null};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}function se(e){return e&&l.isSome(e.camera)&&(e.rotation=M(e.camera.heading)),e}function le(e,t){const n=B;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let o=0;o<t.length;o++){const e=t[o].screenSpaceBoundingRect;r=Math.max(r,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-r/Math.min(e.width,e.height)*2}const ue=g.create(),me=f.create(),pe=p.create(),fe=d.create(),ye=x.create(),ge=g.create(),he=g.create(),de=g.create(),xe={heading:0,tilt:0},ve=new S,we={point(e,t,n){n[0]=e.x,n[1]=e.y,e.hasZ&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let o=0;o<e.rings.length;o++){const a=e.rings[o];for(let e=0;e<a.length;e++)n[0]=a[e][0],n[1]=a[e][1],r&&(n[2]=a[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let o=0;o<e.paths.length;o++){const a=e.paths[o];for(let e=0;e<a.length;e++)n[0]=a[e][0],n[1]=a[e][1],r&&(n[2]=a[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,o=e.hasZ;for(let a=0;a<r.length;a++)n[0]=r[a][0],n[1]=r[a][1],o&&(n[2]=r[a][2]),t(n)},extent(e,t,n){e.hasZ?(t(y.set(n,e.xmin,e.ymin,e.zmin)),t(y.set(n,e.xmax,e.ymin,e.zmin)),t(y.set(n,e.xmin,e.ymax,e.zmin)),t(y.set(n,e.xmax,e.ymax,e.zmin)),t(y.set(n,e.xmin,e.ymin,e.zmax)),t(y.set(n,e.xmax,e.ymin,e.zmax)),t(y.set(n,e.xmin,e.ymax,e.zmax)),t(y.set(n,e.xmax,e.ymax,e.zmax))):(t(y.set(n,e.xmin,e.ymin,n[2])),t(y.set(n,e.xmax,e.ymin,n[2])),t(y.set(n,e.xmin,e.ymax,n[2])),t(y.set(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let o=0;o<r.length;o+=3)t(y.set(n,r[o+0],r[o+1],r[o+2]))}};e.create=Z,e.fromCamera=E,e.headingToRotation=M,e.rotationToHeading=P,e.toCamera=k,Object.defineProperty(e,"__esModule",{value:!0})}));
