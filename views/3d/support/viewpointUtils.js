/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../Camera","../../../geometry","../../../Graphic","../../../Viewpoint","../../../core/asyncUtils","../../../core/has","../../../core/Cyclical","../../../core/Error","../../../core/maybe","../../../core/promiseUtils","../../../chunks/mat3","../../../chunks/mat3f64","../../../chunks/mat4f64","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/projection","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/frustum","../../../geometry/support/scaleUtils","../../../geometry/support/webMercatorUtils","../camera/intersectionUtils","./cameraUtils","./ElevationProvider","../../../geometry/Point","../../../geometry/SpatialReference","../../../geometry/Extent","../../../geometry/Geometry"],(function(e,t,n,r,o,i,a,c,s,l,u,m,p,f,g,y,d,h,x,v,w,T,S,b,G,R,z,A,M,O){"use strict";const C=.66;function P(e){return 360-s.cyclicalDegrees.normalize(e)}function j(e){return s.cyclicalDegrees.normalize(360-e)}function B(e){return u.isSome(e)&&e.resolver&&e.resolver.reject(),null}function D(e,t){return u.isSome(e)&&e.resolver&&e.resolver.resolve(t),t}function E(e,t,n,r=null){if(!t)return B(r);const o=e.spatialReference||A.WGS84;if(u.isSome(t.camera)){const e=S.project(t.camera.position,o);if(u.isNone(e))return B(r);const n=t.camera.clone();return n.position=e,D(r,n)}if(u.isNone(t.targetGeometry))return B(r);const i=t.get("targetGeometry.spatialReference");if(i&&!S.canProject(i,o))return B(r);const a=G.internalToExternal(e,e.state.camera);let c=G.OrientationMode.ADJUST;if(null!=t.rotation&&(a.heading=P(t.rotation),c=G.OrientationMode.LOCKED),null!=n&&(a.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let o;const i=t.targetGeometry.clone();return o=null!=t.scale?G.scaleToDistance(e,t.scale,n.latitude):e.state.camera.distance,G.fromCenterDistance(e,i,o,a,c,r)}const s=t.targetGeometry.extent;return s?G.fromExtent(e,s,a.heading,a.tilt,c,r):B(r)}function V(e,t,n=null){return u.isNone(n)&&(n=new i),_(e,null,t.clone(),n)}function k(e,t,n){return F.apply(this,arguments)}function F(){return(F=t._asyncToGenerator((function*(e,t,r){const o=se(e,t);if(!o)throw new l("viewpointutils-create:no-target","Missing target for creating viewpoint");const a=new n({fov:e.camera.fov}),c=new i({camera:a});if(o.target instanceof i){return le(yield L(e,o.target,o,r,c))}if(o.target instanceof n)return le($(e,o.target,c));const s=null!=o.scale||null!=o.zoom;if(o.target instanceof M){const t=o.target.xmin===o.target.xmax||o.target.ymin===o.target.ymax;return le(s||t?yield X(e,o,o.target.center,a,r,c):yield re(e,o,o.target,a,r,c))}const u={boundingBox:x.empty(),hasZ:!1,screenSpaceObjects:[]},m=s?U(e,o):void 0;if(yield J(e,o.target,m,u),isFinite(u.boundingBox[0])){let t;if(x.center(u.boundingBox,me),we.x=me[0],we.y=me[1],we.z=me[2],we.spatialReference=e.spatialReference,isFinite(we.z)&&u.hasZ?t=x.isPoint(u.boundingBox):(we.z=void 0,t=v.isPoint(x.toRect(u.boundingBox,ye))),s||t)return le(yield X(e,o,we,a,r,c));const n=ue(e,u.screenSpaceObjects);return le(yield ae(e,o,we,u.boundingBox,n,a,r,c))}return o.position?le(ee(e,o,a,c)):le(yield te(e,o,a,r,c))}))).apply(this,arguments)}function N(e,t){return null==t.scale&&null!=t.zoom?G.zoomToScale(e,t.zoom):t.scale}function U(e,t){const n=N(e,t);return n?T.getResolutionInMetersForScale(n):void 0}function Z(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=P(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function _(e,t,n,r){const o=e.spatialReference||A.WGS84;return t=u.isSome(t)?t:G.externalToInternal(e,n),u.isNone(t)||(r.targetGeometry=h.projectVectorToPoint(t.center,e.renderSpatialReference,o),r.scale=G.computeScale(e,t),r.rotation=j(n.heading),r.camera=n),r}function I(e,t,n){const r=()=>new l("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw r();if(!S.canProject(t.spatialReference,e.spatialReference))throw new l("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference?.wkid})`,{geometry:t});const o=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&u.isSome(e.basemapTerrain.spatialReference)&&S.canProject(n,e.basemapTerrain.spatialReference)&&e.elevationProvider?me[2]=u.unwrapOr(R.getElevationAtPoint(e.elevationProvider,n),0):me[2]=0}(0,Te[t.type])(t,(e=>{o.push(e[0],e[1],e[2])}),me);const i=o.length/3;if(0===i)throw r();const a=new Array(o.length);if(h.projectBuffer(o,t.spatialReference,0,a,e.spatialReference,0,i)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<a.length;e+=3)t.hasZ?(me[0]=a[e+0],me[1]=a[e+1],me[2]=a[e+2]):(me[0]=a[e+0],me[1]=a[e+1]),x.expandWithVec3(n.boundingBox,me)}}function W(e,t,n,r){return H.apply(this,arguments)}function H(){return(H=t._asyncToGenerator((function*(e,t,n,r){const o=yield a.result(e.whenViewForGraphic(t));if(!1===o.ok||u.isNone(o.value)||!("whenGraphicBounds"in o.value))return void I(e,t.geometry,r);const i=o.value,c=yield a.result(i.whenGraphicBounds(t,{minDemResolution:n}));if(!1===c.ok)return void I(e,t.geometry,r);const{screenSpaceObjects:s,boundingBox:l}=c.value;x.expandWithAABB(r.boundingBox,l),s&&s.forEach((e=>{r.screenSpaceObjects.push(e)})),isFinite(l[2])&&(r.hasZ=!0)}))).apply(this,arguments)}function J(e,t,n,r){return K.apply(this,arguments)}function K(){return(K=t._asyncToGenerator((function*(e,t,n,r){if(Array.isArray(t)&&2===t.length){const n=t[0],o=t[1];if("number"==typeof n&&"number"==typeof o)return we.x=n,we.y=o,we.z=void 0,we.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:A.WGS84,void I(e,we,r)}t&&"function"==typeof t.map?yield m.eachAlways(t.map((t=>J(e,t,n,r)))):t instanceof O?I(e,t,r):t instanceof o&&(yield W(e,t,n,r))}))).apply(this,arguments)}function L(e,t,n,r,o){return Y.apply(this,arguments)}function Y(){return(Y=t._asyncToGenerator((function*(e,t,n,r,o){if(u.isSome(t.camera))return $(e,t.camera,o);o.scale=t.scale,o.rotation=t.rotation,o.targetGeometry=u.isSome(t.targetGeometry)?t.targetGeometry.clone():null,o.camera=null,null!=n.heading?o.rotation=j(n.heading):null!=n.rotation&&(o.rotation=n.rotation);const i=N(e,n);null!=i&&(o.scale=i);const a=new G.AsyncContext(r);return E(e,o,n.tilt,a),o.camera=yield a.resolver.promise,o}))).apply(this,arguments)}function $(e,t,n){const r=e.spatialReference,o=S.project(t.position,r);return u.isNone(o)?null:((t=t.clone()).fov=e.camera.fov,t.position=o,_(e,null,t,n))}function q(e,t,n,r,o,i){const a=e.renderSpatialReference;return h.projectPointToVector(n,he,a),h.projectPointToVector(t,xe,a),i.targetGeometry=new z(t),o.position=new z(n),y.subtract(de,xe,he),G.directionToHeadingTilt(e,he,de,r.up,o),i.scale=G.distanceToScale(e,y.distance(he,xe),i.targetGeometry.latitude),i.rotation=j(o.heading),i.camera=o,i}function X(e,t,n,r,o,i){return Q.apply(this,arguments)}function Q(){return(Q=t._asyncToGenerator((function*(e,t,n,r,o,i){if(u.isNone(n))throw new l("createfromcenter","invalid point");i.targetGeometry=n.clone();const a=b.cameraOnContentAlongViewDirection(e);if(t.position)return q(e,i.targetGeometry,t.position,a,r,i);if(t.zoomFactor){const r=a.distance/t.zoomFactor,o=y.scale(me,a.viewForward,-r);a.eye=y.add(me,a.center,o),i.scale=G.distanceToScale(e,r,n.latitude)}G.internalToExternal(e,a,r);const c=Z(r,t)?G.OrientationMode.LOCKED:G.OrientationMode.ADJUST;if(!t.zoomFactor){const s=N(e,t);null==s?(h.projectPointToVector(n,me,e.renderSpatialReference),w.intersectsPoint(a.frustum,me)?i.scale=G.distanceToScale(e,y.distance(a.eye,me),n.latitude):i.scale=G.computeScale(e,a)):i.scale=s;const l=new G.AsyncContext(o);G.fromCenterScale(e,i.targetGeometry,i.scale,r,c,l),i.camera=yield l.resolver.promise}return i}))).apply(this,arguments)}function ee(e,t,n,r){const o=b.cameraOnContentAlongViewDirection(e);return y.copy(de,o.viewForward),G.directionToHeadingTilt(e,o.eye,de,o.up,ve),n.position=new z(t.position),n.heading=null!=t.heading?t.heading:ve.heading,n.tilt=null!=t.tilt?t.tilt:ve.tilt,_(e,null,n,r)}function te(e,t,n,r,o){return ne.apply(this,arguments)}function ne(){return(ne=t._asyncToGenerator((function*(e,t,n,r,o){const i=b.cameraOnContentAlongViewDirection(e);return X(e,t,h.projectVectorToPoint(i.center,e.renderSpatialReference,e.spatialReference),n,r,o)}))).apply(this,arguments)}function re(e,t,n,r,o,i){return oe.apply(this,arguments)}function oe(){return(oe=t._asyncToGenerator((function*(e,t,n,r,o,i){i.targetGeometry=n.clone();const a=b.cameraOnContentAlongViewDirection(e);G.internalToExternal(e,a,r);const c=Z(r,t)?G.OrientationMode.LOCKED:G.OrientationMode.ADJUST,s=new G.AsyncContext(o);return G.fromExtent(e,n,r.heading,r.tilt,c,s),i.camera=yield s.resolver.promise,i}))).apply(this,arguments)}function ie(e,t,n,r,o){let i=0;null!=n.z?i=n.z:e.basemapTerrain&&e.elevationProvider&&(i=u.unwrap(R.getElevationAtPoint(e.elevationProvider,n))),y.set(me,n.x,n.y,i),h.computeTranslationToOriginAndRotation(e.spatialReference,me,pe,e.renderSpatialReference),p.fromMat4(fe,pe),p.transpose(fe,fe),x.empty(ge);const a=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let u=0;u<a.length;u++){const t=a[u];let n=r[t[2]];isFinite(n)||(n=i),y.set(me,r[t[0]],r[t[1]],n),h.projectVectorToVector(me,e.spatialReference,me,e.renderSpatialReference),x.expandWithVec3(ge,y.transformMat3(me,me,fe))}const c=x.width(ge),s=x.height(ge),l=x.depth(ge),m=1/Math.tan(t.fovX/2),f=1/Math.tan(t.fovY/2),g=.5*Math.sqrt(c*c+l*l)*Math.max(f,m)+.5*s,d=.5*s*f+.5*Math.max(c,l);return Math.max(g,d)/o}function ae(e,t,n,r,o,i,a,c){return ce.apply(this,arguments)}function ce(){return(ce=t._asyncToGenerator((function*(e,t,n,r,o,i,a,c){c.targetGeometry=n.clone();const s=b.cameraOnContentAlongViewDirection(e),l=ie(e,s,n,r,o);G.internalToExternal(e,s,i);const u=Z(i,t)?G.OrientationMode.LOCKED:G.OrientationMode.ADJUST;c.scale=G.distanceToScale(e,l,c.targetGeometry.latitude);const m=new G.AsyncContext(a);return G.fromCenterScale(e,c.targetGeometry,c.scale,i,u,m),c.camera=yield m.resolver.promise,c}))).apply(this,arguments)}function se(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}function le(e){return e&&u.isSome(e.camera)&&(e.rotation=j(e.camera.heading)),e}function ue(e,t){const n=C;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let o=0;o<t.length;o++){const e=t[o].screenSpaceBoundingRect;r=Math.max(r,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-r/Math.min(e.width,e.height)*2}const me=d.create(),pe=g.create(),fe=f.create(),ge=x.create(),ye=v.create(),de=d.create(),he=d.create(),xe=d.create(),ve={heading:0,tilt:0},we=new z,Te={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let o=0;o<e.rings.length;o++){const i=e.rings[o];for(let e=0;e<i.length;e++)n[0]=i[e][0],n[1]=i[e][1],r&&(n[2]=i[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let o=0;o<e.paths.length;o++){const i=e.paths[o];for(let e=0;e<i.length;e++)n[0]=i[e][0],n[1]=i[e][1],r&&(n[2]=i[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,o=e.hasZ;for(let i=0;i<r.length;i++)n[0]=r[i][0],n[1]=r[i][1],o&&(n[2]=r[i][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(y.set(n,e.xmin,e.ymin,e.zmin)),t(y.set(n,e.xmax,e.ymin,e.zmin)),t(y.set(n,e.xmin,e.ymax,e.zmin)),t(y.set(n,e.xmax,e.ymax,e.zmin)),t(y.set(n,e.xmin,e.ymin,e.zmax)),t(y.set(n,e.xmax,e.ymin,e.zmax)),t(y.set(n,e.xmin,e.ymax,e.zmax)),t(y.set(n,e.xmax,e.ymax,e.zmax))):(t(y.set(n,e.xmin,e.ymin,n[2])),t(y.set(n,e.xmax,e.ymin,n[2])),t(y.set(n,e.xmin,e.ymax,n[2])),t(y.set(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let o=0;o<r.length;o+=3)t(y.set(n,r[o+0],r[o+1],r[o+2]))}};e.create=k,e.fromCamera=V,e.headingToRotation=j,e.rotationToHeading=P,e.toCamera=E,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
