/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../core/has","../../../core/maybe","../../../core/Error","../../../core/promiseUtils","../../../geometry/SpatialReference","../../../geometry/Geometry","../../../geometry/support/webMercatorUtils","../../../geometry/Point","../../../geometry/Extent","../../../geometry","../../../Graphic","../../../core/asyncUtils","../../../chunks/vec3f64","../../../chunks/vec3","./mathUtils","../../../Camera","../../../Viewpoint","../../../geometry/support/aaBoundingRect","../../../geometry/projection","../../../chunks/mat3f64","../../../chunks/mat4f64","../../../chunks/mat3","../../../geometry/support/aaBoundingBox","./ElevationProvider","./geometryUtils","../camera/intersectionUtils","./cameraUtils"],(function(e,t,n,a,r,o,i,c,s,l,m,u,f,p,g,h,y,d,x,w,v,R,b,S,T,G,z,A){"use strict";function j(e){return 360-h.cyclicalDeg.normalize(e)}function P(e){return h.cyclicalDeg.normalize(360-e)}function B(e){return n.isSome(e)&&e.resolver&&e.resolver.reject(),null}function V(e,t,a,r=null){if(!t)return B(r);const i=e.spatialReference||o.WGS84;if(n.isSome(t.camera)){const e=t.get("camera.position.spatialReference");if(!c.canProject(e,i))return B(r);const a=t.camera.clone();return e.equals(i)||(a.position=c.project(a.position,i)),function(e,t){return n.isSome(e)&&e.resolver&&e.resolver.resolve(t),t}(r,a)}if(n.isNone(t.targetGeometry))return B(r);const s=t.get("targetGeometry.spatialReference");if(s&&!c.canProject(s,i))return B(r);const l=A.internalToExternal(e,e.state.camera);let m=1;if(null!=t.rotation&&(l.heading=j(t.rotation),m=0),null!=a&&(l.tilt=a),"point"===t.targetGeometry.type){const n=t.targetGeometry;let a;const o=t.targetGeometry.clone();return a=null!=t.scale?A.scaleToDistance(e,t.scale,n.latitude):e.state.camera.distance,A.fromCenterDistance(e,o,a,l,m,r)}const u=t.targetGeometry.extent;return A.fromExtent(e,u,l.heading,l.tilt,m,r)}function M(e,t){return null==t.scale&&null!=t.zoom?A.zoomToScale(e,t.zoom):t.scale}function C(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=j(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function k(e,t,a,r){const i=e.spatialReference||o.WGS84;return t=n.isSome(t)?t:A.externalToInternal(e,a),r.targetGeometry=w.projectVectorToPoint(t.center,e.renderSpatialReference,i),r.scale=A.computeScale(e,t),r.rotation=P(a.heading),r.camera=a,r}function E(e,t,n){if(!t)return;if(!c.canProject(t.spatialReference,e.spatialReference))throw new a("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference.wkid})`,{geometry:t});const r=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":case"mesh":n=t.extent.center;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&c.canProject(n,e.basemapTerrain.spatialReference)?N[2]=T.getElevationAtPoint(e.elevationProvider,n)||0:N[2]=0}(0,X[t.type])(t,(e=>{r.push(e[0],e[1],e[2])}),N);const o=r.length/3;if(0===o)return;const i=new Array(r.length);if(w.projectBuffer(r,t.spatialReference,0,i,e.spatialReference,0,o)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<i.length;e+=3)t.hasZ?(N[0]=i[e+0],N[1]=i[e+1],N[2]=i[e+2]):(N[0]=i[e+0],N[1]=i[e+1]),S.expandWithVec3(n.boundingBox,N)}}async function Z(e,t,a,c){if(Array.isArray(t)&&2===t.length){const n=t[0],a=t[1];if("number"==typeof n&&"number"==typeof a)return L.x=n,L.y=a,L.z=void 0,L.spatialReference=e.spatialReference.isGeographic?e.spatialReference:o.WGS84,void E(e,L,c)}t&&"function"==typeof t.map?await r.eachAlways(t.map((t=>Z(e,t,a,c)))):t instanceof i?E(e,t,c):t instanceof u&&await async function(e,t,a,r){const o=await f.result(e.whenViewForGraphic(t));if(!1===o.ok||n.isNone(o.value)||!("whenGraphicBounds"in o.value))return void E(e,t.geometry,r);const i=o.value,c=await f.result(i.whenGraphicBounds(t,{minDemResolution:a}));if(!1===c.ok)return void E(e,t.geometry,r);const{screenSpaceObjects:s,boundingBox:l}=c.value;S.expandWithAABB(r.boundingBox,l),s&&s.forEach((e=>{r.screenSpaceObjects.push(e)})),isFinite(l[2])&&(r.hasZ=!0)}(e,t,a,c)}function D(e,t,n){const a=e.spatialReference,r=t.position.spatialReference;return c.canProject(r,a)?((t=t.clone()).fov=e.camera.fov,r.equals(a)||(t.position=c.project(t.position,a)),k(e,null,t,n)):null}async function F(e,t,r,o,i,c){if(n.isNone(r))throw new a("createfromcenter","invalid point");c.targetGeometry=r.clone();const l=z.cameraOnContentAlongViewDirection(e);if(t.position)return function(e,t,n,a,r,o){const i=e.renderSpatialReference;return w.projectPointToVector(n.position,_,i),w.projectPointToVector(t,Y,i),o.targetGeometry=new s(t),r.position=new s(n.position),g.subtract(H,Y,_),A.directionToHeadingTilt(e,_,H,a.up,r),o.scale=A.distanceToScale(e,g.distance(_,Y),o.targetGeometry.latitude),o.rotation=P(r.heading),o.camera=r,o}(e,c.targetGeometry,t,l,o,c);if(t.zoomFactor){const n=l.distance/t.zoomFactor,a=g.scale(N,l.viewForward,-n);g.add(l.eye,l.center,a),l.markViewDirty(),c.scale=A.distanceToScale(e,n,r.latitude)}A.internalToExternal(e,l,o);const m=C(o,t)?0:1;if(!t.zoomFactor){c.scale=M(e,t),null==c.scale&&(w.projectPointToVector(r,N,e.renderSpatialReference),G.frustum.intersectsPoint(l.frustum.planes,N)?c.scale=A.distanceToScale(e,g.distance(l.eye,N),r.latitude):c.scale=A.computeScale(e,l));const n=new A.AsyncContext(i);A.fromCenterScale(e,c.targetGeometry,c.scale,o,m,n),c.camera=await n.resolver.promise}return c}function O(e){return e&&n.isSome(e.camera)&&(e.rotation=P(e.camera.heading)),e}const N=p.create(),U=R.create(),W=v.create(),I=S.create(),q=x.create(),H=p.create(),_=p.create(),Y=p.create(),$={heading:0,tilt:0},L=new s,X={point(e,t,n){n[0]=e.x,n[1]=e.y,e.hasZ&&(n[2]=e.z),t(n)},polygon(e,t,n){const a=e.hasZ;for(let r=0;r<e.rings.length;r++){const o=e.rings[r];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],a&&(n[2]=o[e][2]),t(n)}},polyline(e,t,n){const a=e.hasZ;for(let r=0;r<e.paths.length;r++){const o=e.paths[r];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],a&&(n[2]=o[e][2]),t(n)}},multipoint(e,t,n){const a=e.points,r=e.hasZ;for(let e=0;e<a.length;e++)n[0]=a[e][0],n[1]=a[e][1],r&&(n[2]=a[e][2]),t(n)},extent(e,t,n){e.hasZ?(t(g.set(n,e.xmin,e.ymin,e.zmin)),t(g.set(n,e.xmax,e.ymin,e.zmin)),t(g.set(n,e.xmin,e.ymax,e.zmin)),t(g.set(n,e.xmax,e.ymax,e.zmin)),t(g.set(n,e.xmin,e.ymin,e.zmax)),t(g.set(n,e.xmax,e.ymin,e.zmax)),t(g.set(n,e.xmin,e.ymax,e.zmax)),t(g.set(n,e.xmax,e.ymax,e.zmax))):(t(g.set(n,e.xmin,e.ymin,n[2])),t(g.set(n,e.xmax,e.ymin,n[2])),t(g.set(n,e.xmin,e.ymax,n[2])),t(g.set(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const a=e.vertexAttributes&&e.vertexAttributes.position;if(a)for(let e=0;e<a.length;e+=3)t(g.set(n,a[e+0],a[e+1],a[e+2]))}};e.create=async function(e,t,r){const o=function(e,t){if(!t||!e.spatialReference)return null;const n={target:null};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}(e,t);if(!o)throw new a("viewpointutils-create:no-target","Missing target for creating viewpoint");const i=new y({fov:e.camera.fov}),c=new d({camera:i});if(o.target instanceof d){return O(await async function(e,t,a,r,o){if(n.isSome(t.camera))return D(e,t.camera,o);o.scale=t.scale,o.rotation=t.rotation,o.targetGeometry=n.isSome(t.targetGeometry)?t.targetGeometry.clone():null,o.camera=null,null!=a.heading?o.rotation=P(a.heading):null!=a.rotation&&(o.rotation=a.rotation);const i=M(e,a);null!=i&&(o.scale=i);const c=new A.AsyncContext(r);return V(e,o,a.tilt,c),o.camera=await c.resolver.promise,o}(e,o.target,o,r,c))}if(o.target instanceof y)return O(D(e,o.target,c));const m=null!=o.scale||null!=o.zoom;if(o.target instanceof l){const t=o.target.xmin===o.target.xmax||o.target.ymin===o.target.ymax;return O(m||t?await F(e,o,o.target.center,i,r,c):await async function(e,t,n,a,r,o){o.targetGeometry=n.clone();const i=z.cameraOnContentAlongViewDirection(e);A.internalToExternal(e,i,a);const c=C(a,t)?0:1,s=new A.AsyncContext(r);return A.fromExtent(e,n,a.heading,a.tilt,c,s),o.camera=await s.resolver.promise,o}(e,o,o.target,i,r,c))}const u={boundingBox:S.empty(),hasZ:!1,screenSpaceObjects:[]},f=m?function(e,t){return A.scaleToResolution(e,M(e,t))}(e,o):void 0;if(await Z(e,o.target,f,u),isFinite(u.boundingBox[0])){let t;if(S.center(u.boundingBox,N),L.x=N[0],L.y=N[1],L.z=N[2],L.spatialReference=e.spatialReference,isFinite(L.z)&&u.hasZ?t=S.isPoint(u.boundingBox):(L.z=void 0,t=x.isPoint(S.toRect(u.boundingBox,q))),m||t)return O(await F(e,o,L,i,r,c));const n=function(e,t){const n=.66;if(!t.length)return n;let a=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const n=t[e].screenSpaceBoundingRect;a=Math.max(a,Math.abs(n[0]),Math.abs(n[1]),Math.abs(n[2]),Math.abs(n[3]))}const r=Math.min(e.width,e.height);return n-a/r*2}(e,u.screenSpaceObjects);return O(await async function(e,t,n,a,r,o,i,c){c.targetGeometry=n.clone();const s=z.cameraOnContentAlongViewDirection(e),l=function(e,t,n,a,r){let o=0;n.hasZ?o=n.z:e.basemapTerrain&&(o=T.getElevationAtPoint(e.elevationProvider,n));g.set(N,n.x,n.y,o),w.computeLinearTransformation(e.spatialReference,N,U,e.renderSpatialReference),b.fromMat4(W,U),b.transpose(W,W),S.empty(I);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let t=0;t<i.length;t++){const n=i[t];let r=a[n[2]];isFinite(r)||(r=o),g.set(N,a[n[0]],a[n[1]],r),w.projectVectorToVector(N,e.spatialReference,N,e.renderSpatialReference),S.expandWithVec3(I,g.transformMat3(N,N,W))}const c=S.width(I),s=S.height(I),l=S.depth(I),m=1/Math.tan(t.fovX/2),u=1/Math.tan(t.fovY/2),f=.5*Math.sqrt(c*c+l*l)*Math.max(u,m)+.5*s,p=.5*s*u+.5*Math.max(c,l);return Math.max(f,p)/r}(e,s,n,a,r);A.internalToExternal(e,s,o);const m=C(o,t)?0:1;c.scale=A.distanceToScale(e,l,c.targetGeometry.latitude);const u=new A.AsyncContext(i);return A.fromCenterScale(e,c.targetGeometry,c.scale,o,m,u),c.camera=await u.resolver.promise,c}(e,o,L,u.boundingBox,n,i,r,c))}return o.position?O(function(e,t,n,a){const r=z.cameraOnContentAlongViewDirection(e);return g.copy(H,r.viewForward),A.directionToHeadingTilt(e,r.eye,H,r.up,$),n.position=new s(t.position),n.heading=null!=t.heading?t.heading:$.heading,n.tilt=null!=t.tilt?t.tilt:$.tilt,k(e,null,n,a)}(e,o,i,c)):O(await async function(e,t,n,a,r){const o=z.cameraOnContentAlongViewDirection(e),i=w.projectVectorToPoint(o.center,e.renderSpatialReference,e.spatialReference,L);return F(e,t,i,n,a,r)}(e,o,i,r,c))},e.fromCamera=function(e,t,a=null){return n.isNone(a)&&(a=new d),k(e,null,t.clone(),a)},e.headingToRotation=P,e.rotationToHeading=j,e.toCamera=V,Object.defineProperty(e,"__esModule",{value:!0})}));
