/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{neverReached as e}from"../../../../core/compilerUtils.js";import{clamp as t,acosClamped as r,asinClamped as n,deg2rad as i}from"../../../../core/mathUtils.js";import{isSome as s}from"../../../../core/maybe.js";import{d as a}from"../../../../chunks/mat4.js";import{c}from"../../../../chunks/mat4f64.js";import{b as o,m as u,g as l,a as m,i as d,e as f,n as p,l as y,p as h}from"../../../../chunks/vec3.js";import{c as M}from"../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as C}from"../../../../geometry/projectionEllipsoid.js";import{j as I,k as O,t as T}from"../../../../chunks/sphere.js";import{TiltMode as A,defaultApplyOptions as D,InteractionType as S,hasConstraintType as w,ConstraintTypes as R,adjustRangeForInteraction as j}from"./common.js";import{viewAngle as x}from"../../state/utils/viewUtils.js";function P(t,r,n=D,i=!0){W.eyeCenterDistance=0,W.requiresTwoSteps=!1;const s=U(t,r,n,void 0,W);if(0===s)return!1;switch(a(z,-s,r.viewRight),n.tiltMode){case A.LOOK_AROUND:u(_,r.viewForward,z),l(_,_,W.eyeCenterDistance),r.center=m(G,r.eye,_);break;case A.TUMBLE:o(_,r.center,r.eye),u(_,_,z),r.eye=o(G,r.center,_);break;default:e(n.tiltMode)}return r.up=u(G,r.up,z),!W.requiresTwoSteps||!i||P(t,r,n,!1)}function U(e,t,r=D,n=D,i){if(!e.state.constraints.tilt)return 0;const s=t.distance,a=e.state.constraints.tilt(s,Q);return B(e,r,a),n.interactionType===S.TUMBLE&&w(n.selection,R.ALTITUDE)&&K(e,n.interactionStartCamera,a),r.tiltMode===A.LOOK_AROUND||n.tiltMode===A.LOOK_AROUND?L(e,t,a,i):v(e,t,a)}function v(e,r,n){const i=x(e.renderCoordsHelper,r.center,r.eye),s=i-t(i,n.min,n.max);return g(s)?s:0}function L(t,r,n,i){switch(i&&(i.requiresTwoSteps=!1),t.viewingMode){case"global":return q(t,r,n,i);case"local":return k(t,r,n,i);default:return void e(t.viewingMode)}}function k(e,r,n,i){const s=x(e.renderCoordsHelper,r.center,r.eye),a=t(s,n.min,n.max),c=s-a;if(!g(c))return 0;if(i){const t=e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,n=e.renderCoordsHelper.getAltitude(r.eye)-t,s=Math.cos(a);Math.abs(s)>1e-4?i.eyeCenterDistance=n/s:i.eyeCenterDistance=r.distance}return c}function q(e,r,n,i){const s=b(e,r,V),a=t(s.tiltAtCenter,n.min,n.max);if(!g(s.tiltAtCenter-a))return 0;let c,o;return s.centerIsOnSurface?(c=E(s),o=F(s,c)):(c=s.constraints.clampTilt(s.eyeCenterDistance,s.tiltAtCenter),i&&c<Math.PI/2&&(i.requiresTwoSteps=!0,c=Math.PI/2-1e-5),o=N(s,c)),i&&(i.eyeCenterDistance=H(s,c)),o}function b(e,t,n){const i=e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,a=i+C(e.spatialReference).radius,c=e.renderCoordsHelper.intersectManifold(t.ray,i,G);return n.eyeCenterDistance=t.distance,n.centerIsOnSurface=!1,s(c)?(n.eyeCenterDistance=d(t.eye,c),n.tiltAtCenter=x(e.renderCoordsHelper,c,t.eye),n.centerIsOnSurface=!0):e.state.isLocal?n.tiltAtCenter=x(e.renderCoordsHelper,t.center,t.eye):(I(O(T,a),t.ray,G),n.eyeCenterDistance=d(t.eye,G),n.tiltAtCenter=r(-f(t.viewForward,p(G,G)))),n.radius=a,n.eyeRadius=y(t.eye),n.constraints=e.state.constraints,n}function g(e){return Math.abs(e)>1e-9}function E(e){const{constraints:t,eyeCenterDistance:r,tiltAtCenter:n}=e;let i=n,s=t.clampTilt(r,n);const a=H(e,s);if(t.clampTilt(a,n)===s)return s;let c=0;for(;c<10&&g(s-i);){const r=(i+s)/2,n=H(e,r);g(t.clampTilt(n,r)-r)?i=r:s=r,c++}return s}function H(e,r){if(!e.centerIsOnSurface)return e.eyeCenterDistance;const i=Math.PI-t(r,0,Math.PI),s=n(e.radius/e.eyeRadius*Math.sin(i)),a=Math.PI-i-s,c=Math.sin(a)/Math.sin(i);if(e.eyeRadius<e.radius&&c>1){const t=Math.PI-s,r=Math.PI-i-t;return Math.sin(r)/Math.sin(i)*e.eyeRadius}return c*e.eyeRadius}function F(e,t){const r=n(e.radius/e.eyeRadius*Math.sin(e.tiltAtCenter)),i=n(e.radius/e.eyeRadius*Math.sin(t));return e.eyeRadius>e.radius?r-i:i-r}function N(e,t){return e.tiltAtCenter-Math.PI/2-(t-Math.PI/2)}function B(e,t,r){if(t.interactionType===S.NONE)return;const{interactionStartCamera:n,interactionFactor:i}=t,{min:s,max:a}=r,c=U(e,n,D,t),o=0===c?0:x(e.renderCoordsHelper,n.center,n.eye);r.min=s,r.max=a,t.interactionType===S.TUMBLE?(w(t.selection,R.ALTITUDE)&&K(e,n,r),j(c,o,!0,i,J,r)):j(c,o,!1,i,J,r)}function K(e,t,n){if(e.state.isLocal)return;const i=e.state.constraints;if(!i.altitude)return;const s=h(t.center),a=Math.sqrt(s),c=t.distance,o=C(e.spatialReference).radius,u=i.altitude.min+o,l=i.altitude.max+o,m=(u*u-c*c-s)/(-2*a*c),d=(l*l-c*c-s)/(-2*a*c);n.min=Math.max(n.min,Math.min(Math.PI-r(d),n.max)),n.max=Math.min(n.max,Math.PI-r(m))}const _=M(),z=c(),G=M(),J=i(5),Q={min:0,max:0},V={constraints:null,radius:0,eyeRadius:0,centerIsOnSurface:!0,eyeCenterDistance:0,tiltAtCenter:0},W={eyeCenterDistance:0,requiresTwoSteps:!1};export{P as applyTiltConstraint,U as getTiltConstraintError};
