/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import i from"../../../../../core/Collection.js";import e from"../../../../../core/Evented.js";import{HandleOwnerMixin as o}from"../../../../../core/HandleOwner.js";import{makeHandle as n}from"../../../../../core/handleUtils.js";import{destroyMaybe as a,isNone as s,unwrap as r,isSome as p,applySome as l}from"../../../../../core/maybe.js";import{watch as h,syncAndInitial as c}from"../../../../../core/reactiveUtils.js";import{property as m}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as u}from"../../../../../core/accessorSupport/decorators/subclass.js";import{makeDehydratedPoint as d}from"../../../../../layers/graphics/dehydratedFeatures.js";import{getGraphicEffectiveElevationInfo as g,getConvertedElevation as v}from"../../../../../support/elevationInfoUtils.js";import{getGraphicAttachmentOrigin as f}from"../../manipulatorUtils.js";import{SnappingVisualizer3D as y}from"../../SnappingVisualizer3D.js";import{SupportedGraphicResult as M}from"../isSupportedGraphicUtils.js";import{ManipulatorType as _}from"../ManipulatorType.js";import{canMoveZ as w}from"../manipulatorUtils.js";import{createVisualElements as j}from"../visualElementUtils.js";import{DISC_RADIUS as b}from"../manipulations/config.js";import{ManipulationType as S,MoveManipulation as x}from"../manipulations/MoveManipulation.js";import{shapeOrientation as O}from"../manipulations/moveUtils.js";import{MoveXYGraphicManipulation as E}from"../manipulations/MoveXYGraphicManipulation.js";import{isSupportedGraphic as T}from"./isSupportedGraphic.js";import{OutlineVisualElement as A}from"../../visualElements/OutlineVisualElement.js";import{GraphicState as P}from"../../../layers/graphics/GraphicState.js";import{dragGraphicMany as D,resetGraphicMany as X}from"../../../../interactive/dragEventPipeline.js";import{InteractiveToolBase as Y}from"../../../../interactive/InteractiveToolBase.js";import{EditGeometryOperations as G}from"../../../../interactive/editGeometry/EditGeometryOperations.js";import U from"../../../../interactive/sketch/SketchTooltipOptions.js";import{SnappingContext as R}from"../../../../interactive/snapping/SnappingContext.js";import{SnappingPipeline as z}from"../../../../interactive/snapping/SnappingDragPipelineStep.js";import{Tooltip as k}from"../../../../interactive/tooltip/Tooltip.js";import{TranslateGraphicTooltipInfo as I,TranslateZTooltipInfo as Z}from"../../../../interactive/tooltip/TranslateTooltipInfos.js";import{autoHorizontalDistanceByElevationModeBetweenPoints as C}from"../../../../support/automaticLengthMeasurementUtils.js";import{verticalSignedDistanceBetweenPoints as H}from"../../../../support/euclideanLengthMeasurementUtils.js";class V{constructor(t){this.allGraphics=t,this.type="graphic-move-start"}}class L{constructor(t,i,e){this.dx=t,this.dy=i,this.allGraphics=e,this.type="graphic-move"}}class N{constructor(t){this.allGraphics=t,this.type="graphic-move-stop"}}let F=class extends(o(e.EventedMixin(Y))){constructor(t){super(t),this.graphics=new i,this.enableZ=!0,this.tooltipOptions=new U,this.type="move-3d",this._snappingPipeline=new z,this._tooltip=null}initialize(){const{graphics:t,view:i}=this;this.own([t.on("change",(()=>this._refreshManipulators())),h((()=>this.tooltipOptions.enabled),(t=>{this._tooltip=t?new k({view:i}):a(this._tooltip)}),c)]),this._refreshManipulators(),this.finishToolCreation()}destroy(){this._tooltip=a(this._tooltip),this.graphics.removeAll(),this._set("view",null)}get updating(){return this.updatingHandles.updating}reset(){}_refreshManipulators(){this.handles.removeAll(),this._moveManipulation&&this._moveManipulation.destroy(),this.manipulators.removeAll();const t=this.graphics.toArray().filter((t=>T(t)===M.SUPPORTED)).map((t=>new B(t)));t.length&&(this._createManipulators(t),this._createVisualElements(t),this.handles.add(t.map((t=>this.view.trackGraphicState(t.state)))),this._updateMoveManipulation(t))}_createManipulators(t){for(const i of t){const e=i.state;i.manipulationXY=new E({tool:this,view:this.view,graphicState:e}),i.manipulationXY.forEachManipulator((t=>this.handles.add([t.events.on("immediate-click",(t=>{this.emit("immediate-click",{...t,graphic:e.graphic}),t.stopPropagation()})),t.events.on("grab-changed",(({action:t})=>{const{tooltipOptions:i,_tooltip:e}=this;s(e)||("focus"===t?e.info=new I({tooltipOptions:i}):e.clear())}))]))),this.handles.add(i.manipulationXY.createDragPipeline(((i,e,o,n)=>this._buildDragEventPipeline(t,S.XY,i,e,o,n))))}this._createMoveManipulation(t)}_createMoveManipulation(t){const i=new x({tool:this,view:this.view,snapToScene:!1,xyAvailable:!0,xyAxisAvailable:!0,zAvailable:!0,radius:1===t.length?x.radiusForSymbol(t[0].graphic.symbol):b});this._moveManipulation=i,i.elevationInfo={mode:"absolute-height",offset:0},i.forEachManipulator(((t,e)=>{this.handles.add(t.events.on("immediate-click",(e=>{i.zManipulation.hasManipulator(t)||1!==this.graphics.length||this.emit("immediate-click",{...e,graphic:this.graphics.getItemAt(0)}),e.stopPropagation()}))),e===_.TRANSLATE_XY&&this.handles.add(t.events.on("focus-changed",(({action:t})=>{const{tooltipOptions:i,_tooltip:e}=this;s(e)||("focus"===t?e.info=new I({tooltipOptions:i}):e.clear())}))),e===_.TRANSLATE_Z&&this.handles.add(t.events.on("focus-changed",(({action:t})=>{const{tooltipOptions:i,_tooltip:e}=this;s(e)||("focus"===t?e.info=new Z({tooltipOptions:i}):e.clear())})))}));const e=()=>this._updateMoveManipulation(t);for(const n of t)this.handles.add([n.state.on("changed",e),h((()=>n.state.displaying),e)]);const o=t[t.length-1];this.handles.add(o.state.on("changed",(()=>this._updateMoveManipulationAngle(o)))),this.handles.add(i.createDragPipeline(((i,e,o,n,a)=>this._buildDragEventPipeline(t,i,e,o,n,a)),g(o.graphic),r(o.graphic.geometry).spatialReference,o.graphic)),this._updateMoveManipulationAngle(o)}_createVisualElements(t){for(const i of t){const e=i.graphic,o=j({view:this.view,graphic:e,forEachManipulator:t=>{i.manipulationXY.forEachManipulator(t),this._moveManipulation.forEachManipulator(t)},onManipulatorsChanged:()=>n()});s(o)||(i.geometryRepresentation=o.visualElement,i.geometryRepresentation instanceof A&&this.handles.add([i.geometryRepresentation.events.on("attachment-origin-changed",(()=>{i.state.isDraped||this._updateMoveManipulation(t)})),h((()=>i.state.isDraped),(()=>this._updateMoveManipulation(t)))]),this.handles.add(o))}}_updateMoveManipulationAngle(t){this._moveManipulation.angleDeferred=()=>O(t.graphic.geometry)}_updateMoveManipulation(t){const i=d(0,0,0,this.view.spatialReference);let e=0,o=!1;const n=this._moveManipulation;for(const a of t){if(!a.state.displaying)continue;const t=a.state.graphic;this.enableZ&&w(t)&&(o=!0);const n=a.geometryRepresentation instanceof A&&!a.state.isDraped?a.geometryRepresentation.attachmentOrigin:f(this.view,t);p(n)&&(i.x+=n.x,i.y+=n.y,i.z+=n.z,e++)}e>0?(i.x/=e,i.y/=e,i.z/=e,n.location=i,n.xyManipulation.available=!0,n.xyAxisManipulation.available=!0,n.zManipulation.available=o):n.available=!1}_buildDragEventPipeline(t,i,e,o,n,a){const s=[],r=[];let p=null,l=null;const h=()=>{for(const t of s)t.dragging=!1;s.length=0,r.length=0,p=null,l=null,this._moveManipulation.interactive=!0};if(1===t.length&&i===S.XY){const i=t[0].graphic;o=this._buildSnappingPipelineSteps(i,g(i),o,n,a)}const c=o.next((i=>{if("start"===i.action){s.length=0,r.length=0;for(const i of t)i.dragging||!i.manipulationXY.hasManipulator(e)&&i.manipulationXY.grabbing||(s.push(i),r.push(i.graphic),i.dragging=!0);if(0!==r.length&&(this._moveManipulation.interactive=!1,p=D(r,this.view.state.viewingMode),l=X(r),this.emit("graphic-move-start",new V(r)),this.destroyed))return null}return 0!==r.length?i:null})).next((t=>p(t))).next((e=>this._updateMoveTooltip(e,i,t))).next((t=>{switch(t.action){case"start":case"update":if(t.translationX||t.translationY||t.translationZ){const i=this.view.toScreen(t.mapStart),e=this.view.toScreen(t.mapEnd),o=e.x-i.x,n=e.y-i.y;if(this.emit("graphic-move",new L(o,n,r)),this.destroyed)return null}break;case"end":if(this.emit("graphic-move-stop",new N(r)),this.destroyed)return null;h()}}));return n.next((t=>l(t))).next((()=>{if(this.emit("graphic-move-stop",new N(r)),this.destroyed)return null;h()})),c}_updateMoveTooltip(t,i,e){const{tooltipOptions:o,_tooltip:n}=this;if(s(n))return t;if(n.clear(),i===S.XY||i===S.XY_AXIS)if("end"===t.action)n.info=new I({tooltipOptions:o});else{const i=0===e.length?"absolute-height":e[0].state.isDraped?"on-the-ground":"absolute-height",a=C(t.mapStart,t.mapEnd,i);p(a)&&(n.info=new I({tooltipOptions:o,distance:a}))}return i===S.Z&&("end"===t.action?n.info=new Z({tooltipOptions:o}):l(H(t.mapStart,t.mapEnd),(t=>{n.info=new Z({tooltipOptions:o,distance:t})}))),t}_buildSnappingPipelineSteps(t,i,e,o,n){const a=t.geometry;if(s(a)||"point"!==a.type&&"mesh"!==a.type)return e;const r=("point"===a.type?a:a.anchor).clone(),p=new R({elevationInfo:i,pointer:n,editGeometryOperations:G.fromGeometry(r,this.view.state.viewingMode),visualizer:new y,excludeFeature:t}),l=this.snappingManager;return e.next((i=>{r.z=v(this.view,r,g(t),{mode:"absolute-height",offset:0});return{...i,snapOrigin:p.coordinateHelper.pointToVector(r)}})).next(this._snappingPipeline.createSnapDragEventPipelineStep({snappingContext:p,snappingManager:l,cancel:o,updatingHandles:this.updatingHandles}),this._snappingPipeline.next)}get test(){return{tooltip:this._tooltip}}};t([m({constructOnly:!0,nonNullable:!0})],F.prototype,"view",void 0),t([m()],F.prototype,"graphics",void 0),t([m({constructOnly:!0,nonNullable:!0})],F.prototype,"enableZ",void 0),t([m({constructOnly:!0,type:U})],F.prototype,"tooltipOptions",void 0),t([m({constructOnly:!0})],F.prototype,"snappingManager",void 0),t([m()],F.prototype,"type",void 0),t([m()],F.prototype,"updating",null),F=t([u("esri.views.3d.interactive.editingTools.graphicMove3D.GraphicMoveTool")],F);class B{constructor(t){this.state=null,this.geometryRepresentation=null,this.manipulationXY=null,this.dragging=!1,this.state=new P({graphic:t})}get graphic(){return this.state.graphic}}export{L as GraphicMoveEvent,V as GraphicMoveStartEvent,N as GraphicMoveStopEvent,F as GraphicMoveTool};
