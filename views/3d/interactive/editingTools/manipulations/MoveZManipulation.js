/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{darken as t}from"../../../../../core/colorUtils.js";import e from"../../../../../core/Evented.js";import{clamp as r}from"../../../../../core/mathUtils.js";import{unwrap as a}from"../../../../../core/maybe.js";import{j as i,r as o,h as s}from"../../../../../chunks/mat4.js";import{c as n}from"../../../../../chunks/mat4f64.js";import{j as l,b as m,n as c,e as u,f as p,g as d}from"../../../../../chunks/vec3.js";import{c as h,f}from"../../../../../chunks/vec3f64.js";import{Manipulator3D as M}from"../../Manipulator3D.js";import{createManipulatorMaterial as _}from"../../manipulatorUtils.js";import{screenToZConstrained as g}from"../dragEventPipeline3D.js";import{ManipulatorType as j}from"../ManipulatorType.js";import{settings as v}from"../settings.js";import{DISC_RADIUS as y}from"./config.js";import{Manipulation as w}from"./Manipulation.js";import{createGraphicMoveDragPipeline as b}from"./moveUtils.js";import k from"../../../webgl-engine/lib/GeometryUtil.js";import{RenderOccludedFlag as z}from"../../../webgl-engine/lib/Material.js";import{createManipulatorDragEventPipeline as U,addScreenDelta as P}from"../../../../interactive/dragEventPipeline.js";import{ManipulatorStateFlags as T}from"../../../../interactive/interfaces.js";class E extends w{constructor(t){super(),this._radius=y,this.events=new e,this._tool=t.tool,this._view=t.view,null!=t.radius&&(this._radius=t.radius),this._createManipulator(),this.forEachManipulator((t=>this._tool.manipulators.add(t)))}destroy(){this.forEachManipulator((t=>{this._tool.manipulators.remove(t),t.destroy()}))}forEachManipulator(t){t(this._manipulator,j.TRANSLATE_Z)}createGraphicDragPipeline(t,e,r){const i=a(e.graphic.geometry).spatialReference;return b(e,r,(e=>this.createDragPipeline(((r,a,i,o,s)=>e(r,t(r,a,i,o,s),i)),i)),this._view.state.viewingMode)}createDragPipeline(t,e){const r=this._view;return U(this._manipulator,((a,i,o,s,n)=>{const l=i.next((t=>({...t,manipulatorType:j.TRANSLATE_Z}))).next(g(r,a.renderLocation,e)).next(P());t(a,l,o,s,n)}))}get radius(){return this._radius}set radius(t){t!==this._radius&&(this._radius=t,this._updateManipulator())}_updateManipulator(){const e=this._radius/y,r=v.zManipulator.height*e,a=v.zManipulator.coneHeight*e,l=v.zManipulator.coneWidth*e,m=v.zManipulator.width*e,c=[f(0,0,0),f(0,0,r)],u=k.createTubeGeometry(c,m/2,16,!1),p=k.createConeGeometry(a,l/2,16,!1),d=[f(0,0,0),f(0,0,r+a)],h=t=>{const e=n();if(i(e,e,[0,0,r]),o(e,e,Math.PI/2),t){const r=1+2*t/l;s(e,e,[r,r,r])}return e},M=h(0),g=(e,r)=>{const a=t(v.zManipulator.color,r);return[a.r/255,a.g/255,a.b/255,v.zManipulator.color.a*e]},j=_(g(1,.25),z.Occlude),w=_(g(1,0),z.Occlude),b=_(g(.7,0),v.zManipulator.renderOccluded),U=_(g(.85,0),v.zManipulator.renderOccluded);this._manipulator.renderObjects=[{geometry:p,transform:M,material:j,stateMask:T.Unfocused},{geometry:u,material:j,stateMask:T.Unfocused},{geometry:p,transform:M,material:w,stateMask:T.Focused},{geometry:u,material:w,stateMask:T.Focused},{geometry:p,transform:M,material:b,stateMask:T.Unfocused},{geometry:u,material:b,stateMask:T.Unfocused},{geometry:p,transform:M,material:U,stateMask:T.Focused},{geometry:u,material:U,stateMask:T.Focused}],this._manipulator.radius=m/2+2,this._manipulator.collisionType={type:"line",paths:[d]}}_createManipulator(){const t=new M({view:this._view,autoScaleRenderObjects:!1,worldSized:!1,selectable:!1,cursor:"ns-resize",elevationInfo:this.elevationInfo,worldOriented:!0,collisionPriority:1.6});t.applyObjectTransform=t=>{const e=this._view.state.camera,a=O;this._view.renderCoordsHelper.toRenderCoords(this._manipulator.elevationAlignedLocation,a);const i=l(e.eye,a),o=e.computeRenderPixelSizeAtDist(i),s=m(A,a,e.eye);c(s,s);const n=x;this._view.renderCoordsHelper.worldUpAtPosition(O,n);const h=Math.abs(u(s,n)),f=p(A,s,n),M=p(A,f,n),_=r(h,.01,1),g=1-Math.sqrt(1-_*_)/_/e.fullWidth,j=this._radius/y,w=v.zManipulator.width*j;d(M,c(M,M),(1/g-1)*i+o*w),t[12]-=A[0],t[13]-=A[1],t[14]-=A[2]},this._manipulator=t,this._updateManipulator()}get test(){return{manipulator:this._manipulator}}}const O=h(),A=h(),x=h();export{E as MoveZManipulation};
