/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/_rollupPluginBabelHelpers","../../../../../chunks/tslib.es6","../../../../../core/has","../../../../../core/maybe","../../../../../core/Logger","../../../../../core/accessorSupport/ensureType","../../../../../core/handleUtils","../../../../../core/accessorSupport/decorators/property","../../../../../core/accessorSupport/decorators/subclass","../../../../../core/urlUtils","../../../../../core/uuid","../../../../../portal/support/resourceExtension","../../../../../core/Evented","../../../../../core/mathUtils","../../../../../core/screenUtils","../../../../../chunks/vec3f64","../../../../../chunks/vec3","../../../../../core/Handles","../../../../../core/watchUtils","../../../../../core/unitUtils","../../../../../chunks/mat4","../../../../../geometry/support/aaBoundingRect","../../../../../chunks/vec2f64","../../../../../chunks/vec2","../../../../../support/elevationInfoUtils","../../../support/stack","../../../support/geometryUtils","../../../layers/graphics/elevationAlignmentUtils","../../../layers/graphics/ElevationContext","../../../webgl-engine/lib/Texture","../../../../interactive/editGeometry/EditGeometry","../../../../interactive/dragEventPipeline","../../../../interactive/InteractiveToolBase","../dragEventPipeline3D","../../manipulatorUtils","../manipulatorUtils","../../analysisTools/slice/sliceToolUtils","../../analysisTools/slice/images/heading-rotate-png","../../visualElements/OutlineVisualElement","../../../layers/graphics/GraphicState","../visualElementUtils","../manipulations/MoveXYGraphicManipulation","../reshapeGraphic/ReshapeOperation","./PreserveAspectRatio","../../../../interactive/editGeometry/support/editPlaneUtils"],(function(e,t,a,i,n,s,r,o,p,l,h,c,d,u,g,m,y,v,f,S,b,M,B,x,_,E,R,P,w,D,T,H,A,G,z,O,U,k,Z,C,V,I,X,Y,N,F){"use strict";e.ExtentTransformTool=function(e){function a(t){var a;return(a=e.call(this,t)||this).enableZ=!0,a.enableRotation=!0,a.enableScaling=!0,a._preserveAspectRatio=new N.PreserveAspectRatio,a.grabbing=!1,a.inputState=null,a.type="transform-3d",a.handles=new f,a.moveZManipulator=null,a.resizeManipulators=null,a.rotateManipulator=null,a.attachmentOrigin=null,a.outlineVisualElement=null,a.mapBounds=P.boundedPlane.create(),a.mapBoundsStart=P.boundedPlane.create(),a.displayBounds=P.boundedPlane.create(),a.displayBoundsStart=P.boundedPlane.create(),a.displayBoundsMarginStart=0,a.resizeHandles=[{direction:[1,0]},{direction:[1,1]},{direction:[0,1]},{direction:[-1,1]},{direction:[-1,0]},{direction:[-1,-1]},{direction:[0,-1]},{direction:[1,-1]}],a}t._inheritsLoose(a,e);var i=a.prototype;return i.initialize=function(){this.graphicState=new V.GraphicState({graphic:this.graphic});const e=this.graphic.geometry;this.reshapeHelper=new Y.ReshapeGeometryHelper(H.EditGeometry.fromGeometry(e,this.view.viewingMode),e.type),this.graphicMoveManipulation=new X.MoveXYGraphicManipulation({tool:this,view:this.view,graphicState:this.graphicState}),this.handles.add(this._createMoveXYGraphicDragPipeline()),this.moveZManipulator=k.createShiftManipulator(this.view,0),this.moveZManipulator.state|=k.IsShiftEdgeOnScreenFlag,this.handles.add(this.watch("enableZ",(()=>this.updateManipulatorAvailability(this.moveZManipulator,0)))),this.handles.add(this._createMoveZDragPipeline()),this.manipulators.add(this.moveZManipulator),this.resizeManipulators=this.resizeHandles.map((e=>{const t=k.createResizeManipulator(this.view,e);return this.handles.add(this.watch("enableScaling",(()=>this.updateManipulatorAvailability(t,2)))),t.events.on("grab-changed",(e=>this._onResizeGrab(e))),this.handles.add(this._createResizeDragPipeline(t,e)),t})),this.manipulators.addMany(this.resizeManipulators),this.rotateManipulatorTexture=new T.Texture(Z,{width:64,height:64,mipmap:!0,preMultiplyAlpha:!0}),this.view._stage&&this.view._stage.add(this.rotateManipulatorTexture),this.rotateManipulator=k.createRotateManipulator(this.view,this.rotateManipulatorTexture),this.handles.add(this.watch("enableRotation",(()=>this.updateManipulatorAvailability(this.rotateManipulator,3)))),this.rotateManipulator.events.on("grab-changed",(e=>{this._onRotateGrab(e)})),this.handles.add(this._createRotateDragPipeline(this.rotateManipulator)),this.manipulators.add(this.rotateManipulator),this.calculateMapBounds(),this.updateDisplayBounds(this.mapBounds);const t=I.createVisualElements({view:this.view,graphic:this.graphic,forEachManipulator:e=>this.forEachManipulator(e),onManipulatorsChanged:()=>o.makeHandle()});this.outlineVisualElement=t.visualElement instanceof C.OutlineVisualElement?t.visualElement:null,n.isSome(this.outlineVisualElement)&&this.handles.add(this.outlineVisualElement.events.on("attachment-origin-changed",(()=>this.updateDisplayBounds(this.mapBounds)))),this.handles.add(t),this.handles.add([this.graphicState.on("changed",(()=>this.onGeometryChanged())),this.graphicState.watch("displaying",(()=>this.updateAllManipulatorAvailability())),S.init(this.graphicState,"isDraped",(()=>this.graphicDrapedChanged())),this.view.trackGraphicState(this.graphicState)]);const a=this.view.pointsOfInterest;a&&this.handles.add(a.focus.watch("location",(()=>this.updateDisplayBounds(this.mapBounds))));const i=e=>{this.handles.add(e.events.on("grab-changed",(()=>{this.grabbing=e.grabbing,this.updateAllManipulatorAvailability()})))};this.forEachManipulator(i),this.graphicMoveManipulation.forEachManipulator(i);const s=(e,t)=>{this.handles.add(e.events.on("immediate-click",(e=>{1===t&&this.emit("immediate-click",{...e,graphic:this.graphic}),e.stopPropagation()})))};this.forEachManipulator(s),this.graphicMoveManipulation.forEachManipulator(s),this.onGeometryChanged(),this.updateAllManipulatorAvailability()},i.graphicDrapedChanged=function(){this.handles.remove(L),this.updateDisplayBounds(this.mapBounds),this.graphicState.isDraped&&this.handles.add(this.view.elevationProvider.on("elevation-change",(e=>{n.isSome(this.attachmentOrigin)&&B.containsXY(e.extent,this.attachmentOrigin.x,this.attachmentOrigin.y)&&this.updateDisplayBounds(this.mapBounds)})),L)},i.updateAllManipulatorAvailability=function(){this.forEachManipulator(((e,t)=>this.updateManipulatorAvailability(e,t)))},i.updateManipulatorAvailability=function(e,t){const a=this.graphicState.displaying,i=this.grabbing&&!e.grabbing;e.interactive=!i;const n=this.enableZ&&U.canMoveZ(this.graphic);switch(t){case 3:e.available=a&&this.enableRotation;break;case 2:e.available=a&&(this.enableScaling||this.enableRotation||n),e.interactive=!i&&this.enableScaling,e.state=this.enableScaling?k.resizeNormal:k.resizeOutlineOnly;break;case 0:e.available=a&&n;break;default:e.available=a}},i.forEachManipulator=function(e){this.resizeManipulators.forEach((t=>e(t,2))),e(this.rotateManipulator,3),e(this.moveZManipulator,0)},i.destroy=function(){this.view._stage&&this.view._stage.remove(this.rotateManipulatorTexture),this.handles.destroy(),this.graphicMoveManipulation.destroy(),this.reshapeHelper.destroy(),this._set("view",null),this._set("graphic",null)},i.reset=function(){},i.onDetach=function(){this.mapBounds=null,this.displayBounds=null},i.onGeometryChanged=function(){this.updateDisplayBounds(this.mapBounds)},i.calculateMapBounds=function(){const e=this.graphic.geometry,t=this.reshapeHelper.editGeometry,a=t.components[0].edges[0],i=_.subtract(R.sv2d.get(),a.left.pos,a.right.pos);_.normalize(i,i);const s=n.unwrapOr(O.getGraphicAttachmentOrigin(this.view,this.graphic),e.extent.center);let r=q*this.view.pixelSizeAt(s);const o=this.view.spatialReference;o!==e.spatialReference&&(r*=b.getMetersPerUnitForSR(o)/b.getMetersPerUnitForSR(e.spatialReference)),F.calculateOrientedBounds(i,t,r,this.mapBounds)},i.updateDisplayBounds=function(e){const t=this.graphic.geometry,a=n.isSome(this.outlineVisualElement)&&!this.graphicState.isDraped&&n.isSome(this.outlineVisualElement.attachmentOrigin)?this.outlineVisualElement.attachmentOrigin:O.getGraphicAttachmentOrigin(this.view,this.graphic);this.attachmentOrigin=n.unwrapOr(a,t.extent.center);const i=n.isSome(a)?a.z:w.evaluateElevationAlignmentAtPoint(e.origin,this.view.elevationProvider,D.ElevationContext.fromElevationInfo(E.getGraphicEffectiveElevationInfo(this.graphic)),this.view.renderCoordsHelper),s=P.boundedPlane.copy(e);v.set(s.origin,e.origin[0],e.origin[1],i),F.mapPlaneToRenderPlane(s,this.view.renderCoordsHelper,t.spatialReference,this.displayBoundsMargin(),this.displayBounds),this.updateManipulators()},i.displayBoundsMargin=function(){const e=this.view.pointsOfInterest,t=e?e.focus.location:this.reshapeHelper.geometry.extent.center;return j*this.view.pixelSizeAt(t)},i._createMoveXYGraphicDragPipeline=function(){return this.graphicMoveManipulation.createDragPipeline(((e,t,a)=>this.applyGraphicMoveSteps(t,a)))},i._createMoveZDragPipeline=function(){const e=this.view,t=this.reshapeHelper.geometry.spatialReference;return A.createManipulatorDragEventPipeline(this.moveZManipulator,((a,i,n)=>{const s=y.clone(a.renderLocation),r=i.next(z.screenToZConstrained(e,s,t)).next(A.addScreenDelta());this.applyGraphicMoveSteps(r,n)}))},i.applyGraphicMoveSteps=function(e,t){const a=e.next((e=>("start"===e.action&&(this.inputState={type:"move"},P.boundedPlane.copy(this.mapBounds,this.mapBoundsStart),this.emit("graphic-translate-start",{graphic:this.graphic,dxScreen:e.screenDeltaX,dyScreen:e.screenDeltaY})),e))).next(A.addMapDelta()).next(this._moveDragUpdateGeometry()).next((e=>{const t={graphic:this.graphic,dxScreen:e.screenDeltaX,dyScreen:e.screenDeltaY};switch(e.action){case"start":case"update":(e.mapEnd.x-e.mapStart.x||e.mapEnd.y-e.mapStart.y||e.mapEnd.z-e.mapStart.z)&&this.emit("graphic-translate",t);break;case"end":this.inputState=null,this.emit("graphic-translate-stop",t)}return e}));return t.next((()=>{n.isSome(this.inputState)&&this.emit("graphic-translate-stop",{graphic:this.graphic,dxScreen:0,dyScreen:0}),this.cancel()})),a},i._moveDragUpdateGeometry=function(){return e=>{if(n.isNone(this.inputState)||"move"!==this.inputState.type)return e;const t=[];for(const n of this.reshapeHelper.editGeometry.components)t.push(...n.vertices);const a="start"===e.action?0:1,i=this.reshapeHelper.moveVertices(t,e.mapDeltaX,e.mapDeltaY,e.mapDeltaZ,a);return F.apply(i,this.mapBounds),this.graphic.geometry=this.reshapeHelper.geometry,e}},i._onResizeGrab=function(e){if("start"!==e.action)return;const t=this._calculatePickRay(e.screenPoint);P.plane.intersectRay(this.displayBounds.plane,t,R.sv3d.get())&&(P.boundedPlane.copy(this.displayBounds,this.displayBoundsStart),P.boundedPlane.copy(this.mapBounds,this.mapBoundsStart),this.displayBoundsMarginStart=this.displayBoundsMargin(),this.inputState={type:"resize"})},i._createResizeDragPipeline=function(e,t){return A.createManipulatorDragEventPipeline(e,((e,a,i)=>{n.isNone(this.inputState)||(a.next((e=>("start"===e.action&&this.emit("graphic-scale-start",{graphic:this.graphic,xScale:1,yScale:1}),e))).next(z.screenToRenderPlane(this.view,this.displayBoundsStart.plane)).next((e=>({...e,handle:t}))).next(this._resizeDragRenderPlaneToFactors()).next(this._preserveAspectRatio.createDragEventPipelineStep(),this._preserveAspectRatio.next).next(this._resizeDragUpdateGeometry()).next((e=>{const t={graphic:this.graphic,xScale:e.factor1,yScale:e.factor2};switch(e.action){case"start":case"update":this.emit("graphic-scale",t);break;case"end":this.inputState=null,this.emit("graphic-scale-stop",t)}return e})),i.next((()=>{n.isSome(this.inputState)&&this.emit("graphic-scale-stop",{graphic:this.graphic,xScale:1,yScale:1}),this.cancel()})))}))},i._resizeDragRenderPlaneToFactors=function(){return e=>{const t=this.displayBoundsStart,a=e.handle.direction,i=this.displayBoundsMargin(),n=this.displayBoundsMarginStart,s=v.copy(R.sv3d.get(),t.origin);v.scaleAndAdd(s,s,t.basis1,-a[0]),v.scaleAndAdd(s,s,t.basis2,-a[1]);const r=v.subtract(R.sv3d.get(),e.renderEnd,s),o=v.subtract(R.sv3d.get(),e.renderStart,s),p=k.isDiagonalResizeHandle(e.handle),l=k.calculateDiagonalResizeHandleScale(t),h=k.calculateDiagonalResizeHandleScale(this.displayBounds)/l,c=(e,t)=>{if(0===e)return 1;let a=v.length(t),s=.5*e*v.dot(t,r)/a;const l=s<0?-1:1;if(p){s+=(a-.5*e*v.dot(t,o)/a)*l*h}const c=a<1.5*n?1:J;return a=Math.max(a-n,J),l>0&&(s-=i),l*Math.max(l*(s/a),c)};return{...e,factor1:c(a[0],t.basis1),factor2:c(a[1],t.basis2)}}},i._resizeDragUpdateGeometry=function(){return e=>{const t=v.copy(y.create(),this.mapBoundsStart.origin);v.scaleAndAdd(t,t,this.mapBoundsStart.basis1,-e.handle.direction[0]),v.scaleAndAdd(t,t,this.mapBoundsStart.basis2,-e.handle.direction[1]);const a=_.set(x.create(),this.mapBoundsStart.basis1[0],this.mapBoundsStart.basis1[1]);_.normalize(a,a);const i=[];for(const r of this.reshapeHelper.editGeometry.components)i.push(...r.vertices);const n="start"===e.action?0:1,s=this.reshapeHelper.scaleVertices(i,this.reshapeHelper.editGeometry.coordinateHelper.fromXYZ(t),a,e.factor1,e.factor2,n,1);return P.boundedPlane.copy(this.mapBoundsStart,this.mapBounds),F.apply(s,this.mapBounds),this.graphic.geometry=this.reshapeHelper.geometry,e}},i._onRotateGrab=function(e){if("start"!==e.action)return;const t=k.createRotatePlane(this.displayBounds,this.view.renderCoordsHelper,1,P.plane.create()),a=this._calculatePickRay(e.screenPoint);P.plane.intersectRay(t,a,R.sv3d.get())&&(P.boundedPlane.copy(this.displayBounds,this.displayBoundsStart),P.boundedPlane.copy(this.mapBounds,this.mapBoundsStart),this.inputState={type:"rotate",rotatePlane:t})},i._createRotateDragPipeline=function(e){return A.createManipulatorDragEventPipeline(e,((e,t,a)=>{const i=this.inputState;n.isNone(i)||(t.next((e=>("start"===e.action&&this.emit("graphic-rotate-start",{graphic:this.graphic,angle:0}),e))).next(z.screenToRenderPlane(this.view,i.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(i)).next(this._rotateDragUpdateGeometry()).next((e=>{const t={graphic:this.graphic,angle:g.rad2deg(e.rotateAngle)};switch(e.action){case"start":case"update":this.emit("graphic-rotate",t);break;case"end":this.inputState=null,this.emit("graphic-rotate-stop",t)}return e})),a.next((()=>{n.isSome(this.inputState)&&this.emit("graphic-rotate-stop",{graphic:this.graphic,angle:0}),this.cancel()})))}))},i._rotateDragRenderPlaneToRotate=function(e){return t=>{const a=P.plane.normal(e.rotatePlane),i=O.calculateInputRotationTransform(t.renderStart,t.renderEnd,this.displayBounds.origin,a);return{...t,rotateAxis:a,rotateAngle:i}}},i._rotateDragUpdateGeometry=function(){return e=>{const t=v.copy(y.create(),this.mapBoundsStart.origin),a=[];for(const s of this.reshapeHelper.editGeometry.components)a.push(...s.vertices);const i="start"===e.action?0:1,n=this.reshapeHelper.rotateVertices(a,this.reshapeHelper.editGeometry.coordinateHelper.fromXYZ(t),e.rotateAngle,i,1);return P.boundedPlane.copy(this.mapBoundsStart,this.mapBounds),F.apply(n,this.mapBounds),this.graphic.geometry=this.reshapeHelper.geometry,e}},i._calculatePickRay=function(e){const t=P.ray.create(),a=m.screenPointObjectToArray(e);return P.ray.fromScreen(this.view.state.camera,a,t),v.normalize(t.direction,t.direction),t},i.updateManipulators=function(){if(!this.visible)return;const e=k.calculateBoundedPlaneTranslateRotate(this.displayBounds,R.sm4d.get());k.updateRotateHeadingHandle(this.rotateManipulator,e,this.displayBounds,this.view.renderCoordsHelper),this.updateZMoveHandle(this.moveZManipulator,e),this.resizeManipulators.forEach(((t,a)=>{k.updateResizeHandle(t,this.resizeHandles[a],e,this.displayBounds)}))},i.updateZMoveHandle=function(e,t){const a=this.displayBounds,i={basis:a.basis1,direction:-1,position:v.subtract(R.sv3d.get(),a.origin,a.basis1),edge:2},n=R.sm4d.get();M.rotateZ(n,t,i.edge*Math.PI/2),n[12]=0,n[13]=0,n[14]=0,e.modelTransform=n,e.renderLocation=i.position},i.cancel=function(){const e=this.reshapeHelper.editGeometry.lastOperation;n.isNone(e)||(this.reshapeHelper.undo(),this.graphic.geometry=this.reshapeHelper.geometry,F.unapply(e,this.mapBounds),this.updateDisplayBounds(this.mapBounds),this.inputState=null)},i.canUndo=function(){return this.reshapeHelper.canUndo},i.undo=function(){if(n.isSome(this.inputState))this.view.activeTool=null;else if(this.canUndo()){const e=this.reshapeHelper.undo();this.graphic.geometry=this.reshapeHelper.geometry,F.unapply(n.unwrap(e),this.mapBounds),this.updateDisplayBounds(this.mapBounds)}},i.canRedo=function(){return this.reshapeHelper.canRedo},i.redo=function(){if(this.canRedo()){const e=this.reshapeHelper.redo();this.graphic.geometry=this.reshapeHelper.geometry,F.apply(n.unwrap(e),this.mapBounds),this.updateDisplayBounds(this.mapBounds)}},t._createClass(a,[{key:"preserveAspectRatio",get:function(){return this._preserveAspectRatio.enabled},set:function(e){this._preserveAspectRatio.enabled=e,this._set("preserveAspectRatio",e)}}]),a}(u.EventedMixin(G.InteractiveToolBase)),a.__decorate([p.property({constructOnly:!0,nonNullable:!0})],e.ExtentTransformTool.prototype,"view",void 0),a.__decorate([p.property({constructOnly:!0,nonNullable:!0})],e.ExtentTransformTool.prototype,"graphic",void 0),a.__decorate([p.property({constructOnly:!0,nonNullable:!0})],e.ExtentTransformTool.prototype,"enableZ",void 0),a.__decorate([p.property()],e.ExtentTransformTool.prototype,"enableRotation",void 0),a.__decorate([p.property()],e.ExtentTransformTool.prototype,"enableScaling",void 0),a.__decorate([p.property()],e.ExtentTransformTool.prototype,"preserveAspectRatio",null),a.__decorate([p.property()],e.ExtentTransformTool.prototype,"grabbing",void 0),a.__decorate([p.property()],e.ExtentTransformTool.prototype,"inputState",void 0),a.__decorate([p.property({readOnly:!0})],e.ExtentTransformTool.prototype,"type",void 0),e.ExtentTransformTool=a.__decorate([l.subclass("esri.views.3d.interactive.editingTools.graphicTransform3D.ExtentTransformTool")],e.ExtentTransformTool);const L="draped-elevation-changes",j=10,q=80,J=1e-6;e.EPSILON=J,Object.defineProperty(e,"__esModule",{value:!0})}));
