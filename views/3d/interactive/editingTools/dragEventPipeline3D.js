/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../geometry/Point","../../../../geometry","../../../../core/mathUtils","../../../../core/screenUtils","../../../../chunks/vec3f64","../../../../chunks/vec3","../../../../geometry/projection","../../../../support/elevationInfoUtils","../../support/stack","../../support/geometryUtils","../../webgl-engine/lib/intersectorUtils","../../webgl-engine/lib/Intersector","../../../interactive/dragEventPipeline"],(function(e,n,r,t,o,c,s,a,i,l,u,d,p,m,f){"use strict";function S(e,r){const t=s.create(),o=s.create();let a=!1;return s=>{if("start"===s.action){const o=c.screenPointObjectToArray(s.screenStart,c.castScreenPointArray(u.sv2d.get())),i=d.ray.fromScreen(e.state.camera,o,A);n.isSome(i)&&(a=d.plane.intersectRay(r,i,t))}if(!a)return null;const i=c.screenPointObjectToArray(s.screenEnd,c.castScreenPointArray(u.sv2d.get())),l=d.ray.fromScreen(e.state.camera,i,A);return n.isNone(l)?null:d.plane.intersectRay(r,l,o)?{...s,renderStart:t,renderEnd:o,plane:r,ray:l}:null}}function y(e,r,t,o=null){let s=null;return a=>{if("start"===a.action&&(s=e.sceneIntersectionHelper.intersectElevationFromScreen(c.createScreenPointArray(a.screenStart.x,a.screenStart.y),r,t),n.isSome(s)&&n.isSome(o)&&!i.projectPoint(s,s,o)))return null;if(n.isNone(s))return null;const l=e.sceneIntersectionHelper.intersectElevationFromScreen(c.createScreenPointArray(a.screenEnd.x,a.screenEnd.y),r,t);return n.isSome(l)?n.isSome(o)&&!i.projectPoint(l,l,o)?null:{...a,mapStart:s,mapEnd:l}:null}}function g(e,n,r,t=null){return y(e,r,l.getZForElevationMode(n,e,r),t)}function E(e,n,r,t=null){return g(e,r,l.getGraphicEffectiveElevationInfo(n),t)}function P(e,n){const r=s.create(),t=a.length(n);e.renderCoordsHelper.worldUpAtPosition(n,r);const c=s.create(),i=s.create(),l=c=>{if(a.subtract(c,c,n),d.vector.projectPoint(r,c,c),"global"===e.viewingMode){a.length(c)*o.sign(a.dot(r,c))<.001-t&&a.subtract(c,a.scale(c,r,.001),n)}return a.add(c,c,n),c};return e=>(e.renderStart=l(a.copy(c,e.renderStart)),e.renderEnd=l(a.copy(i,e.renderEnd)),e)}function v(e,t){const o=e.renderCoordsHelper;return e=>{const c=o.fromRenderCoords(e.renderStart,new r,t),s=o.fromRenderCoords(e.renderEnd,new r,t);return n.isSome(c)&&n.isSome(s)?{...e,mapStart:c,mapEnd:s}:null}}const T=s.create(),b=s.create(),A=d.ray.create();e.convertToMapCoordinates=v,e.hideManipulatorWhileDragging=function(e){let r=null;return t=>{switch(t.action){case"start":r=e.disableDisplay();break;case"end":case"cancel":n.isSome(r)&&(r.remove(),r=null)}return t}},e.projectToWorldUp=P,e.screenToMap3D=function(e,t=null){let o=null;const a=new m.Intersector(e.state.mode);a.options.selectionMode=!0,a.options.store=0;const i=c.createScreenPointArray(),l={requiresGroundFeedback:!0,enableDraped:!0,exclude:new Set},u=s.create(),d=n.unwrapOr(t,e.spatialReference),f=n=>{e.map.ground&&e.map.ground.opacity<1?l.exclude.add(p.TERRAIN_ID):l.exclude.delete(p.TERRAIN_ID),e.sceneIntersectionHelper.intersectIntersectorScreen(c.screenPointObjectToArray(n,i),a,l);const t=a.results.min;let o;if(t.getIntersectionPoint(u))o="TerrainRenderer"===t.intersector?0:1;else{if(!a.results.ground.getIntersectionPoint(u))return null;o=0}const s=new r({spatialReference:d});return e.renderCoordsHelper.fromRenderCoords(u,s),{location:s,surfaceType:o}};return e=>{if("start"===e.action){const r=f(e.screenStart);o=n.isSome(r)?r.location:null}if(n.isNone(o))return null;const r=f(e.screenEnd);return n.isSome(r)?{...e,mapStart:o,mapEnd:r.location,surfaceType:r.surfaceType}:null}},e.screenToMapXY=y,e.screenToMapXYAtLocation=g,e.screenToMapXYForGraphic=function(e,r,t,o){const c=r.toMap(e.screenStart,{include:[t]});return n.isSome(c)?E(r,t,c,o):null},e.screenToMapXYForGraphicAtLocation=E,e.screenToRenderPlane=S,e.screenToZConstrained=function(e,n,r){let t=null;const o=new f.EventPipeline;return o.next(S(e,function(e,n){const r=T,t=b,o=d.plane.create();e.renderCoordsHelper.worldUpAtPosition(n,r);const c=a.cross(o,r,a.subtract(t,n,e.state.camera.eye));return a.cross(c,c,r),d.plane.fromPositionAndNormal(n,c,o)}(e,n))).next(P(e,n)).next(v(e,r)).next((e=>{e.mapEnd.x=e.mapStart.x,e.mapEnd.y=e.mapStart.y,t=e})),e=>(t=null,o.execute(e),t)},Object.defineProperty(e,"__esModule",{value:!0})}));
