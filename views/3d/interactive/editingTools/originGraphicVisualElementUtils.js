/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{handlesGroup as e,destroyHandle as t,refHandle as n}from"../../../../core/handleUtils.js";import{deg2rad as i}from"../../../../core/mathUtils.js";import{isNone as o,isSome as a}from"../../../../core/maybe.js";import{watch as r,initial as s}from"../../../../core/reactiveUtils.js";import{s as l}from"../../../../chunks/vec3.js";import{c as p}from"../../../../chunks/vec3f64.js";import{projectVectorToVector as c,projectPointToVector as m}from"../../../../geometry/projection.js";import{create as u,empty as h,getMin as d}from"../../../../geometry/support/aaBoundingBox.js";import{containsXY as f}from"../../../../geometry/support/aaBoundingRect.js";import{getGraphicEffectiveElevationInfo as g}from"../../../../support/elevationInfoUtils.js";import{GrabbingState as v}from"./GrabbingState.js";import{ManipulatorState as y}from"./ManipulatorState.js";import{settings as E}from"./settings.js";import{ExtendedLineVisualElement as j}from"../visualElements/ExtendedLineVisualElement.js";import{LaserlineVisualElement as w}from"../visualElements/LaserlineVisualElement.js";import{PointVisualElement as b}from"../visualElements/PointVisualElement.js";import{evaluateElevationAlignmentAtPoint as S}from"../../layers/graphics/elevationAlignmentUtils.js";import{ElevationContext as x}from"../../layers/graphics/ElevationContext.js";import{GraphicState as A}from"../../layers/graphics/GraphicState.js";import{RenderOccludedFlag as L}from"../../webgl-engine/lib/Material.js";function M(t){const{view:n,graphic:i}=t,o=new A({graphic:i}),a=[],r=C(t,o,a);return P(t,o,a,r),a.push(n.trackGraphicState(o)),{visualElement:r,remove(){e(a).remove()}}}function P(e,n,s,p){const{view:m,graphic:u}=e,f=new j({view:m,extensionType:E.visualElements.zVerticalLine.extensionType,innerWidth:1,attached:!1,writeDepthEnabled:!1,renderOccluded:L.OccludeAndTransparent});E.visualElements.zVerticalLine.apply(f);const b=new w({view:m,intersectsLineInfinite:!0,attached:!1});E.visualElements.pointGraphics.shadowStyle.apply(b);const A=i(E.visualElements.heightPlaneAngleCutoff),M=new w({view:m,attached:!1,angleCutoff:A});E.visualElements.heightPlane.apply(M);const P=g(e.graphic),C=x.fromElevationInfo(P),R="on-the-ground"===P.mode||!P.offset&&"absolute-height"!==P.mode,U=new y;let D=1,I=1;const T=()=>{U.update(e);const t=G(u),i=R&&(n.isDraped||o(t)||!t.hasZ);let r=!0;if(!i&&a(t)){const e=S(t,m.elevationProvider,C,m.renderCoordsHelper);l(V,t.x,t.y,e),c(V,t.spatialReference,V,m.renderCoordsHelper.spatialReference),f.setStartEndFromWorldDownAtLocation(V),b.intersectsWorldUpAtLocation=V}else r=!1;const s=U.grabbingState&v.Z?E.visualElements.laserlineAlphaMultiplier:1;s!==D&&(D=s,E.visualElements.heightPlane.apply(M,s));const g=h(B);!i&&n.displaying&&p.calculateMapBounds(g)&&c(d(g,V),m.spatialReference,V,m.renderCoordsHelper.spatialReference)?(M.heightManifoldTarget=V,M.attached=!0):M.attached=!1;const y=U.grabbingState&v.XY?E.visualElements.laserlineAlphaMultiplier:1;y!==I&&(I=y,E.visualElements.pointGraphics.shadowStyle.apply(b,y));const j=r&&n.displaying&&!i;b.attached=j,f.attached=j};s.push(r((()=>[n.displaying,n.isDraped]),T),n.on("changed",T)),e.forEachManipulator((e=>{s.push(e.events.on("grab-changed",T))})),s.push(t(b)),s.push(t(f)),s.push(t(M)),T()}function C(e,n,i){const{view:o,graphic:a}=e,r=new b({view:o,geometry:G(a),elevationInfo:g(a),attached:!1});return R(e,r,n,i),i.push(t(r)),r}function G(e){const t=e.geometry;return o(t)?null:"point"===t.type?t:"mesh"===t.type?t.anchor.clone():null}function R(e,t,n,i){const o=()=>t.attached=n.displaying;U(e,t,n,i),E.visualElements.pointGraphics.outline.apply(t),i.push(r((()=>n.displaying),o,s))}function U(e,t,i,o){const{view:r,graphic:s}=e;let l=null;const p=e=>{a(l)&&(l.remove(),l=null),i.isDraped&&a(e)&&(l=D(r,e,(()=>{t.geometry=e})))},c=()=>{const e=G(s);p(e),t.geometry=e};o.push(i.on("changed",c),n((()=>l))),c()}function D(e,t,n){const i=e.elevationProvider.spatialReference;m(t,V,i);const o=V[0],a=V[1];return e.elevationProvider.on("elevation-change",(e=>{f(e.extent,o,a)&&n()}))}const V=p(),B=u();export{M as createVisualElements};
