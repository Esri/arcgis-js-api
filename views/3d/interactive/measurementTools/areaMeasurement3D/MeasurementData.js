/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["../../../../../geometry/SpatialReference","../../../../../geometry/support/intersects","../../../../../core/mathUtils","../../../../../chunks/vec3f64","../../../../../chunks/vec3","../../../support/mathUtils","../../../../../geometry/projectionEllipsoid","../../../../../geometry/projection","../../../../../core/Quantity","../../../../../chunks/vec2f64","../../../../../chunks/vec4f64","../../../../../core/libs/earcut/earcut","../../../../../chunks/vec2","../support/viewUtils","../support/measurementUtils"],(function(e,t,s,i,o,n,r,h,a,c,d,l,p,g,u){"use strict";function m(e,t){const s=new Float64Array(e.length*t);for(let i=0;i<e.length;++i){const o=e[i];for(let e=0;e<t;++e)s[i*t+e]=o[e]}return s}return function(){function _(){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=i.create(),this.areaCentroidRenderCoords=i.create(),this.geodesicAreaCentroidRenderCoords=i.create(),this._length=0,this._centroidRenderCoords=i.create(),this._planeWorldCoords=d.create(),this._worldUp=i.create(),this._worldTangent=i.create(),this._frame=[i.create(),i.create(),i.create()],this._pathVersion=-1,this._validMeasurement=!1,this._tempU=i.create(),this._tempV=i.create(),this._tempVec3=i.create(),this._tempSphere={center:i.create(),radius:0}}var f=_.prototype;return f.update=function(e,t,s,i,n,c,d){if(this._pathVersion===e.version&&this._validMeasurement===i)return;this._pathVersion=e.version,this._validMeasurement=i;const l=e.numVertices;this._resize(l);const p=r.getSphericalPCPF(t.spatialReference),g=h.canProjectWithoutEngine(t.spatialReference,p)&&h.canProjectToWGS84ComparableLonLat(t.spatialReference),u=this.positionsGeographic,m=this.positionsWorldCoords,_=this.positionsRenderCoords,f=this.positionsSpherical;e.forEachVertexPosition(((e,t)=>{h.projectPointToVector(e,m[t],c),h.projectPointToVector(e,_[t],n),g&&(h.projectPointToWGS84ComparableLonLat(e,u[t]),h.projectPointToVector(e,f[t],p),o.normalize(f[t],f[t]))}));const C=this._updatePathLengths(i);if(this.pathLength=this._length>0?new a(s.normalizeDistance(C),"meters"):null,g){const e=this._updateGeodesicPathLengths(i,c);this.geodesicPathLength=this._length>0?new a(e,"meters"):null}else this.geodesicPathLength=null;if(!i)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),void this.geodesicIntersectingSegments.clear();this._updateArea(t,s,n,c,d),g&&this._updateGeodesicArea(t)},f._resize=function(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(i.create()),this.positionsRenderCoords.push(i.create()),this.positionsProjectedWorldCoords.push(c.create()),this.positionsFittedRenderCoords.push(i.create()),this.positionsGeographic.push(i.create()),this.positionsSpherical.push(i.create()),this.positionsStereographic.push(c.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length},f._updatePathLengths=function(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let n=0;n<this._length;++n){const r=s[n]=o.distance(t[n],t[(n+1)%this._length]);(n<this._length-1||e)&&(i+=r)}return i},f._updateGeodesicPathLengths=function(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let n=0;n<this._length;++n){const r=i[n]=u.segmentLengthGeodesicVector(s[n],s[(n+1)%this._length],t);(n<this._length-1||e)&&(o+=r)}return o},f._updateArea=function(e,t,s,i,r){const c=e.renderCoordsHelper,d=this.positionsWorldCoords,l=this.positionsRenderCoords,m=this.positionsProjectedWorldCoords,_=this.positionsFittedRenderCoords,f=this._planeWorldCoords,C=this._centroidRenderCoords;g.midpoint(l,C),c.worldUpAtPosition(C,this._worldUp),c.worldBasisAtPosition(C,0,this._worldTangent),h.projectDirection(C,this._worldUp,s,this._worldUp,i),h.projectDirection(C,this._worldTangent,s,this._worldTangent,i),d.length>2&&u.bestFitPlane(d,f),this.fittingMode=this._selectFittingMode(f,d,this._worldUp,r);let S=0;if("horizontal"===this.fittingMode){let e=-1/0;l.forEach(((t,s)=>{const i=c.getAltitude(l[s]);i>e&&(e=i,S=s)}))}const P=d[S];let L=f,w=this._worldTangent;"horizontal"===this.fittingMode?L=this._worldUp:"vertical"===this.fittingMode&&(L=this._tempVec3,w=this._worldUp,n.makeOrthonormal(f,this._worldUp,L)),o.copy(this._frame[2],L),n.makeOrthonormal(w,L,this._frame[0]),o.cross(this._frame[1],this._frame[0],this._frame[2]),o.negate(this._frame[1],this._frame[1]);const R=this._tempVec3,A=this._tempU,W=this._tempV;for(let n=0;n<this._length;++n){const e=m[n],t=_[n];o.subtract(R,d[n],P),p.set(e,o.dot(this._frame[0],R),o.dot(this._frame[1],R)),o.scale(A,this._frame[0],e[0]),o.scale(W,this._frame[1],e[1]),o.add(R,A,W),o.add(R,R,P),h.projectVectorToVector(R,i,t,s)}this.perimeterLength=this._length>0?new a(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,g.midpoint(_,this.areaCentroidRenderCoords),h.projectVectorToVector(this.areaCentroidRenderCoords,s,this.areaCentroidWorldCoords,i),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new a(t.normalizeArea(this._computeArea()),"square-meters"):null},f._updateGeodesicArea=function(e){const t=e.renderCoordsHelper,s=this.positionsSpherical,i=this.positionsStereographic,h=this._tempVec3,c=u.fitHemisphere(s,h);if(!c)return void(this.geodesicArea=null);const d=this._tempU,l=this._tempV;n.tangentFrame(h,d,l);for(let n=0;n<this._length;++n){const e=o.dot(s[n],d),t=o.dot(s[n],l),r=o.dot(s[n],h);p.set(i[n],e/r,t/r)}o.scale(h,h,r.getReferenceEllipsoid(e.spatialReference).radius),t.toRenderCoords(h,r.getSphericalPCPF(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=c&&0===this.geodesicIntersectingSegments.size?new a(this._computeGeodesicArea(),"square-meters"):null},f._updatePerimeterLengths=function(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=t[i]=p.distance(e[i],e[(i+1)%this._length])}return s},f._updateIntersectingSegments=function(){const e=this.positionsProjectedWorldCoords,s=this.intersectingSegments;s.clear();for(let i=0;i<this._length;++i)for(let o=i+2;o<this._length;++o){if((o+1)%this._length===i)continue;const n=e[i],r=e[(i+1)%this._length],h=e[o],a=e[(o+1)%this._length];t.segmentIntersects(n,r,h,a)&&(s.add(i),s.add(o))}},f._computeArea=function(){const e=this.positionsProjectedWorldCoords,t=m(e,2),s=this.triangleIndices=new Uint32Array(l.earcut(t,[],2));let i=0;for(let o=0;o<s.length;o+=3)i+=u.triangleAreaEuclidean(e[s[o]],e[s[o+1]],e[s[o+2]]);return i},f._updateGeodesicIntersectingSegments=function(){const e=this.positionsStereographic,s=this.geodesicIntersectingSegments;s.clear();for(let i=0;i<this._length;++i)for(let o=i+2;o<this._length;++o){if((o+1)%this._length===i)continue;const n=e[i],r=e[(i+1)%this._length],h=e[o],a=e[(o+1)%this._length];t.segmentIntersects(n,r,h,a)&&(s.add(i),s.add(o))}},f._computeGeodesicArea=function(){const t=this.positionsGeographic,s=m(this.positionsStereographic,2),i=this.geodesicTriangleIndices=new Uint32Array(l.earcut(s,[],2));let o=0;for(let n=0;n<i.length;n+=3)o+=u.triangleAreaGeodesic(t[i[n]],t[i[n+1]],t[i[n+2]],e.WGS84);return o},f._selectFittingMode=function(e,t,i,n){const r=t.map((t=>Math.abs(u.planePointDistance(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);u.boundingSphere(t,this._tempSphere);const h=r/(2*this._tempSphere.radius),a=h<n.maxRelativeErrorCoplanar,c=h<n.maxRelativeErrorAlmostCoplanar;let d="horizontal";if(a)d="oblique";else if(c){d=Math.abs(o.dot(i,e))>Math.cos(s.deg2rad(n.verticalAngleThreshold))?"horizontal":"vertical"}return d},_}()}));
