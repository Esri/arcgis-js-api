/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{h as e,b as t,n as s,g as r,a as i,c as n}from"../../../../../chunks/vec3.js";import{c,a as o}from"../../../../../chunks/vec3f64.js";import{canProjectWithoutEngine as a,projectVectorToVector as p}from"../../../../../geometry/projection.js";import{getSphericalPCPF as h}from"../../../../../geometry/projectionEllipsoid.js";import{sv3d as d}from"../../../../../geometry/support/vectorStacks.js";import{slerpTangent as _,slerp as f}from"../../../support/mathUtils.js";class l{constructor(e=c(),t=c()){this.startRenderSpace=e,this.endRenderSpace=t,this.type="euclidean"}eval(r,i,n){return e(i,this.startRenderSpace,this.endRenderSpace,r),n&&(t(n,this.endRenderSpace,this.startRenderSpace),s(n,n)),i}createRenderGeometry(e,s){const r=[],i=[],n=(s,n)=>{const c=S;t(c,s,e),r.push([c[0],c[1],c[2]]),i.push([n[0],n[1],n[2]])},c=s.worldUpAtPosition(this.eval(.5,R),d.get());return n(this.startRenderSpace,c),n(this.endRenderSpace,c),{points:r,normals:i}}static fromPositionAndVector(e,t,s=1){return r(R,t,s),i(R,e,R),new l(o(e),o(R))}}class m{constructor(e,t,s){this.startRenderSpace=e,this.endRenderSpace=t,this.renderSpatialReference=s,this.type="geodesic",this._start=c(),this._end=c(),this._pcpf=h(s),this._project=a(s,this._pcpf),this._projectIn(e,this._start),this._projectIn(t,this._end)}_projectIn(e,t){this._project?p(e,this.renderSpatialReference,t,this._pcpf):n(t,e)}eval(r,n,c){if(this._project)if(c){const e=S;_(this._start,this._end,r,n,e),i(j,n,e),p(n,this._pcpf,n,this.renderSpatialReference),p(j,this._pcpf,j,this.renderSpatialReference),t(c,j,n),s(c,c)}else f(this._start,this._end,r,n),p(n,this._pcpf,n,this.renderSpatialReference);else e(n,this._start,this._end,r),c&&(t(c,this._end,this._start),s(c,c));return n}createRenderGeometry(e,s){const r=[],i=[],n=(s,n)=>{const c=j;t(c,s,e),r.push([c[0],c[1],c[2]]),i.push([n[0],n[1],n[2]])},c=128+1&-2;for(let t=0;t<c;++t){const e=t/(c-1),r=R,i=S;this.eval(e,r),s.worldUpAtPosition(r,i),n(r,i)}return{points:r,normals:i}}}function u(e,t,s,r){switch(e){case"euclidean":return new l(t,s);case"geodesic":return new m(t,s,r)}}const R=c(),S=c(),j=c();export{l as EuclideanSegment,m as GeodesicSegment,u as createSegment};
