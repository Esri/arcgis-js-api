/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import e from"../../../core/Accessor.js";import{lerp as i}from"../../../core/mathUtils.js";import{releaseMaybe as r,disposeMaybe as s,isNone as o,isSome as n}from"../../../core/maybe.js";import{secondsFromMilliseconds as a}from"../../../core/time.js";import{property as h}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as c}from"../../../core/accessorSupport/decorators/subclass.js";import{s as _,g as m,n as p,e as u,h as f}from"../../../chunks/vec3.js";import{c as d}from"../../../chunks/vec3f32.js";import{c as l}from"../../../chunks/vec3f64.js";import{WatchUpdatingTracking as w}from"../../../core/support/WatchUpdatingTracking.js";import{getReferenceEllipsoid as g}from"../../../geometry/projectionEllipsoid.js";import{PrecipitationPassParameters as T,PrecipitationTechnique as y}from"./PrecipitationTechnique.js";import{PrecipitationTechniqueConfiguration as b,PrecipitationType as j}from"./PrecipitationTechniqueConfiguration.js";import{glLayout as v}from"../support/buffer/glUtil.js";import{newLayout as q}from"../support/buffer/InterleavedLayout.js";import{AnimationTimer as P}from"../webgl-engine/lib/AnimationTimer.js";import{VertexAttribute as A}from"../webgl-engine/lib/VertexAttribute.js";import{BufferObject as I}from"../../webgl/BufferObject.js";import{PrimitiveType as x,Usage as C}from"../../webgl/enums.js";import{bindVertexBufferLayout as R,unbindVertexBufferLayout as U}from"../../webgl/Util.js";import{VertexArrayObject as S}from"../../webgl/VertexArrayObject.js";let O=class extends e{constructor(t){super(t),this._numParticles=25e4,this._rainSpeed=.1,this._snowSpeed=.01,this._opacity=1,this._width=500,this._offset=l(),this._tile=l(),this._particleColor=d(),this._particleColorAtNight=d(),this._nightMultiplier=.7,this._cameraDirection=d(),this._renderParameters=new T,this._animation=new P,this._updatingTracking=new w,this._renderParameters.time=0,this._renderParameters.radius=g(t.view.spatialReference).radius,this._shaderTechniqueRepository=t.context.shaderTechniqueRepository}destroy(){this._updatingTracking.destroy(),this._numParticles=0,this._snowTechnique=r(this._snowTechnique),this._rainTechnique=r(this._rainTechnique),this._vao=s(this._vao),this._instanceIdBuffer=s(this._instanceIdBuffer)}get updating(){return this._updatingTracking.updating}get rainTechnique(){if(o(this._rainTechnique)){const t=new b;t.type=j.Rain,this._rainTechnique=this._shaderTechniqueRepository.acquire(y,t)}return this._rainTechnique}get snowTechnique(){if(o(this._snowTechnique)){const t=new b;t.type=j.Snow,this._snowTechnique=this._shaderTechniqueRepository.acquire(y,t)}return this._snowTechnique}update(t){return this._animation.advance(t)}render(t,e,r){const s="rainy"===r,h=s?this.rainTechnique:this.snowTechnique;if(!h.compiled)return void this.context.requestRender();const c=t.rctx;if(this._ensureResources(c),o(h)||o(this._vao)||o(this._instanceIdBuffer))return;if(n(t.bindParameters.clouds.data)&&(this._opacity=1-t.bindParameters.clouds.fadeInOutHeight.factor),this._opacity<=0)return;const _=.35;e=e<.5?i(0,_,2*e):i(_,1,2*(e-.5));const m=c.bindTechnique(h);this._renderParameters.camera=t.bindParameters.camera,this._renderParameters.time=(s?this._rainSpeed:this._snowSpeed)*a(this._animation.time),this._renderParameters.time=this._renderParameters.time%1e5,this._update(m,r,t),c.bindVAO(this._vao);const p=y.attributeLocation;m.assertCompatibleVertexAttributeLocations(this._vao),R(c,p,this._instanceIdBuffer,B,0),c.capabilities.instancing.drawArraysInstanced(x.TRIANGLES,0,3,this._numParticles*e),U(c,p,this._instanceIdBuffer,B)}_update(t,e,i){const r=i.bindParameters.camera,s=r.eye;this._tile[0]=Math.floor((s[0]+.5*this._width)/this._width),this._tile[1]=Math.floor((s[1]+.5*this._width)/this._width),this._tile[2]=Math.floor((s[2]+.5*this._width)/this._width),this._offset[0]=s[0]-this._tile[0]*this._width,this._offset[1]=s[1]-this._tile[1]*this._width,this._offset[2]=s[2]-this._tile[2]*this._width,t.setUniform1f("width",this._width),t.setUniform3fv("offset",this._offset),t.setUniformMatrix4fv("view",r.viewMatrix),t.setUniform3fv("cameraPosition",s),t.bindPass(null,i.bindParameters),t.setUniform1f("time",this._renderParameters.time),"rainy"===e?_(this._particleColor,.85,.85,.85):_(this._particleColor,1,1,1),m(this._particleColorAtNight,this._particleColor,this._nightMultiplier),p(this._cameraDirection,s);const o=Math.max(0,u(this._cameraDirection,i.bindParameters.lighting.lightingMainDirection));f(this._particleColor,this._particleColorAtNight,this._particleColor,o),t.setUniform3fv("particleColor",this._particleColor),t.setUniform1f("opacity",this._opacity)}_ensureResources(t){o(this._vao)&&(this._vao=this._createVertexArrayObject(t)),o(this._instanceIdBuffer)&&(this._instanceIdBuffer=this._createInstanceIndices(t))}_createInstanceIndices(t){const e=[];for(let i=0;i<this._numParticles;i++)e.push(i);return I.createVertex(t,C.STATIC_DRAW,new Float32Array(e))}_createVertexArrayObject(t){const e=new Float32Array([-1,0,1,1,0,-1,1,0,1]);return new S(t,y.attributeLocation,{geometry:v(k)},{geometry:I.createVertex(t,C.STATIC_DRAW,e)})}};t([h({constructOnly:!0})],O.prototype,"context",void 0),t([h({constructOnly:!0})],O.prototype,"view",void 0),t([h({readOnly:!0})],O.prototype,"updating",null),t([h()],O.prototype,"_updatingTracking",void 0),O=t([c("esri.views.3d.environment.Precipitation")],O);const k=q().vec3f(A.POSITION),B=v(q().f32(A.INSTANCEFEATUREATTRIBUTE),1);export{O as Precipitation};
