/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import{isSome as r,releaseMaybe as i,disposeMaybe as s,isNone as h}from"../../../core/maybe.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import{f as n}from"../../../chunks/vec2f32.js";import{NoiseTextureRenderMode as a,NoiseTextureAtlasTechniqueConfiguration as u}from"./NoiseTextureAtlasConfiguration.js";import{ATLAS_SIZE as c}from"./NoiseTextureAtlasDimensions.js";import{NoiseTextureAtlasTechnique as l}from"./NoiseTextureAtlasTechnique.js";import{createQuadVAO as f}from"../webgl-engine/lib/glUtil3D.js";import{TargetType as p,TextureType as _,PixelFormat as T,PixelType as d,TextureWrapMode as m,TextureSamplingMode as w}from"../../webgl/enums.js";import{FramebufferObject as q}from"../../webgl/FramebufferObject.js";class x extends t{constructor(e){let t;super(e),this._weatherTile=n(0,0),this._needsRender=!0,this._frameBuffer=new q(e.context.renderContext.rctx,{colorTarget:p.TEXTURE,width:c,height:c},{target:_.TEXTURE_2D,pixelFormat:T.RGBA,dataType:d.UNSIGNED_BYTE,wrapMode:m.CLAMP_TO_EDGE,samplingMode:w.LINEAR,hasMipmap:!1,width:c,height:c}),this._vao=f(e.context.renderContext.rctx),this._shaderTechniqueRepository=e.context.shaderTechniqueRepository,this._ensureRendered=()=>(r(t)?r(this.weatherMapTechnique)&&this.weatherMapTechnique.compiled&&this._needsRender&&(t=this._render(e.context.renderContext.rctx,a.WeatherMap)):r(this.fullTechnique)&&this.fullTechnique.compiled&&(t=this._render(e.context.renderContext.rctx,a.Full)),t)}get textureAtlas(){return this._ensureRendered()}_setDirty(){this._needsRender=!0}updateWeatherMap(e){this._weatherTile[0]===e[0]&&this._weatherTile[1]===e[1]||(this._weatherTile=e,this._setDirty())}destroy(){this._fullTechnique=i(this._fullTechnique),this._weatherMapTechnique=i(this._weatherMapTechnique),this._frameBuffer=s(this._frameBuffer),this._vao=s(this._vao)}get fullTechnique(){if(h(this._fullTechnique)){const e=new u;e.mode=a.Full,this._fullTechnique=this._shaderTechniqueRepository.acquire(l,e)}return this._fullTechnique}get weatherMapTechnique(){if(h(this._weatherMapTechnique)){const e=new u;e.mode=a.WeatherMap,this._weatherMapTechnique=this._shaderTechniqueRepository.acquire(l,e)}return this._weatherMapTechnique}_render(e,t){if(h(this._vao)||h(this._frameBuffer))return null;const r=t===a.Full?this.fullTechnique:this.weatherMapTechnique;if(h(r))return null;const i=e.getViewport();e.setViewport(0,0,c,c),e.bindFramebuffer(this._frameBuffer);const s=e.bindTechnique(r);return s.setUniform2f("weatherTile",this._weatherTile[0],this._weatherTile[1]),e.bindVAO(this._vao),s.assertCompatibleVertexAttributeLocations(this._vao),e.gl.drawArrays(e.gl.TRIANGLE_STRIP,0,4),e.setViewport(i.x,i.y,i.width,i.height),this._needsRender=!1,this._frameBuffer.colorTexture}}e([o({constructOnly:!0})],x.prototype,"context",void 0);export{x as NoiseTextureAtlas};
