/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{disposeMaybe as r,abortMaybe as t}from"../../../core/maybe.js";import{createResolver as o,isAbortError as s}from"../../../core/promiseUtils.js";import{c as i}from"../../../chunks/mat4.js";import{c as a}from"../../../chunks/mat4f64.js";import{requestImage as n}from"../../../support/requestImageUtils.js";import{S as m}from"../../../chunks/SimpleAtmosphere.glsl.js";import{SimpleAtmosphereTechnique as l}from"./SimpleAtmosphereTechnique.js";import{SimpleAtmosphereTechniqueConfiguration as h,SimpleAtmosphereGeometry as p}from"./SimpleAtmosphereTechniqueConfiguration.js";import c from"./resources/SimpleAtmosphereTexture.js";import{glLayout as u}from"../support/buffer/glUtil.js";import{newLayout as f}from"../support/buffer/InterleavedLayout.js";import{Default3D as g}from"../webgl-engine/lib/DefaultVertexAttributeLocations.js";import _ from"../webgl-engine/lib/GeometryUtil.js";import{VertexAttribute as d}from"../webgl-engine/lib/VertexAttribute.js";import{BufferObject as b}from"../../webgl/BufferObject.js";import{PixelFormat as y,PixelType as j,TextureWrapMode as v,TextureSamplingMode as x,PrimitiveType as A,Usage as w}from"../../webgl/enums.js";import{Texture as C}from"../../webgl/Texture.js";import{vertexCount as T}from"../../webgl/Util.js";import{VertexArrayObject as P}from"../../webgl/VertexArrayObject.js";const q=e.getLogger("esri.views.3d.environment.PanoramicAtmosphere");class R{constructor(){this.type="panoramic",this._techniqueConfig=new h,this._passParameters=new m,this._readyResolver=o(),this._readyController=new AbortController}destroy(){this._readyResolver.reject(),this._passParameters.texture=r(this._passParameters.texture),this._vao=r(this._vao),this._readyController=t(this._readyController)}when(){return this._readyResolver.promise}initializeRenderContext(e){this._techniqueConfig.geometry=p.Cylinder,this._technique=e.shaderTechniqueRepository.acquire(l,this._techniqueConfig);const r=e.renderContext.rctx;this._vao=this._createVertexArrayObject(r),this._vaoCount=T(this._vao,"geometry"),n(c,{signal:this._readyController.signal}).then((t=>{this._passParameters.texture=new C(r,{pixelFormat:y.RGBA,dataType:j.UNSIGNED_BYTE,wrapMode:v.CLAMP_TO_EDGE,samplingMode:x.LINEAR,flipped:!0},t),e.requestRender(),this._readyController=null,this._readyResolver.resolve()})).catch((e=>{s(e)||q.error("Unable to initialize atmosphere: image request failed",e),this._readyResolver.reject()}))}get canRender(){return null!=this._passParameters.texture}render(e){const r=e.rctx,t=r.bindTechnique(this._technique,this._passParameters,e.bindParameters);I(O,e.bindParameters.camera.viewMatrix),t.setUniformMatrix4fv("view",O),r.bindVAO(this._vao),t.assertCompatibleVertexAttributeLocations(this._vao),r.drawArrays(A.TRIANGLES,0,this._vaoCount)}renderHaze(){return!1}_createVertexArrayObject(e){const r=_.createPolySphereGeometry(1,2,!1),t=r.indices.get(d.POSITION);for(let a=0;a<t.length;a+=3){const e=t[a];t[a]=t[a+2],t[a+2]=e}const o=r.vertexAttributes.get(d.POSITION).data,s=S.createBuffer(t.length),i=s.position;for(let a=0;a<t.length;++a){const e=3*t[a];i.set(a,0,o[e]),i.set(a,1,o[e+1]),i.set(a,2,o[e+2])}return new P(e,g,{geometry:u(S)},{geometry:b.createVertex(e,w.STATIC_DRAW,s.buffer)})}}function I(e,r){i(e,r),e[12]=0,e[13]=0,e[14]=0,e[15]=1}const O=a(),S=f().vec3f(d.POSITION);export{R as PanoramicAtmosphere};
