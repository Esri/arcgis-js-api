/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/tslib.es6","../../../../geometry","../../../../analysis/featureReferenceUtils","../../../../core/Accessor","../../../../core/asyncUtils","../../../../core/Evented","../../../../core/Handles","../../../../core/handleUtils","../../../../core/Logger","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/reactiveUtils","../../../../core/accessorSupport/decorators/property","../../../../core/arrayUtils","../../../../core/accessorSupport/ensureType","../../../../core/accessorSupport/decorators/subclass","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../core/support/WatchUpdatingTracking","../../../../geometry/projection","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/ray","../../../../support/elevationInfoUtils","../LineOfSightAnalysisResult","./LineOfSightComputation","./LineOfSightRayIntersector","../support/projectionUtils","../../webgl-engine/lib/IntersectorInterfaces","../../webgl-engine/lib/intersectorUtilsConversions","../../../support/Scheduler","../../../../geometry/Point"],(function(e,t,o,n,i,r,s,a,c,l,u,d,p,g,h,f,v,_,m,y,b,S,C,O,T,I,P,L,R,w,A,N,E){"use strict";const F="esri.views.3d.analysis.LineOfSight.LineOfSightController",H=u.getLogger(F);e.LineOfSightController=function(e){function o(t){var o;return(o=e.call(this,t)||this).updateOnCameraChange=!0,o._effectiveObserverElevationMode="absolute-height",o._observerFeatureId=null,o._updatingHandles=new b.WatchUpdatingTracking,o._frameTask=N.ImmediateTask,o._handles=new c,o._computationHandles=new c,o._externalObserverUpdate=!0,o}t._inheritsLoose(o,e);var n=o.prototype;return n.initialize=function(){const e=this.view.resourceController?.scheduler;this._frameTask=e?e.registerTask(N.TaskPriority.LINE_OF_SIGHT_TOOL):N.ImmediateTask,this._intersector=new L.LineOfSightRayIntersector({view:this.view}),this._handles.add([this._connectObserver(),this._connectComputations(),this._connectTargets()])},n.destroy=function(){this._handles.destroy(),this._computationHandles.destroy(),this._computations.removeAll(),this._updatingHandles.destroy()},n._computeResult=function(e){const t=e.computation,{inputPoints:o,computationResult:n}=t,{observerAdjusted:i,targetAdjusted:r}=o,{start:s,end:a}=n;m.copy(s,i),m.copy(a,r);this._canCompute(t)?this._computeIntersection(e):this._interpolateIntersection(e),t.notifyResultChanged(),this.emit("result-changed",{target:e.computation.target,result:t.result})},n._updateAdjustedPointsFromFeatures=function(e){const t=this.view,{sceneIntersectionHelper:o}=t,{inputPoints:n}=e,{observerAdjusted:r,observerFeatureId:s,targetFeatureId:a,targetAdjusted:c}=n;if(d.isNone(s)&&d.isNone(a))return;const l=m.distance(r,c),u=this._intersector.intersector,p=O.fromPoints(n.observer,n.target,V);u.options.store=w.StoreResults.ALL,o.intersectToolIntersectorRay(p,u);let g=null,h=null,f=null,v=null;for(const _ of u.results.all){const e=A.toGraphic(_,this.view);if(d.isNone(e)||d.isNone(_.distanceInRenderSpace))continue;const o=i.getFeatureId(e);d.isNone(o)||(d.isSome(s)&&o===s&&(d.isNone(g)&&(g=this._getFeatureDistanceThreshold(_,t,l)),_.distanceInRenderSpace<g&&(f=_)),d.isSome(a)&&o===a&&(d.isNone(h)&&(h=this._getFeatureDistanceThreshold(_,t,l)),d.isNone(v)&&_.distanceInRenderSpace<l&&l-_.distanceInRenderSpace<h&&(v=_)))}d.isSome(f)&&f.getIntersectionPoint(r)&&(n.observerSurfaceNormal=f.getTransformedNormal(y.create())),d.isSome(v)&&v.getIntersectionPoint(c)&&(n.targetSurfaceNormal=v.getTransformedNormal(y.create()))},n._getFeatureDistanceThreshold=function(e,t,o){if(A.hasLod(e)){const n=A.getIntersectedFeatureBSRadius(e,t);if(d.isSome(n))return Math.min(n*D,o)}return 1e-5*o},n._adjustStartEndPositions=function(e){const t=this._screenPixelSize,o=this.view,{inputPoints:n}=e,{observer:i,observerSurfaceNormal:r,target:s,targetSurfaceNormal:a,observerAdjusted:c,targetAdjusted:l}=n,u=j;m.copy(c,i),m.copy(l,s),this._updateAdjustedPointsFromFeatures(e),d.isSome(r)?m.copy(u,r):m.subtract(u,l,c);const p=t;m.normalize(u,u),m.scale(u,u,Math.min(p,1)),m.add(c,c,u),d.isSome(a)?m.copy(u,a):m.subtract(u,c,l);const g=o.state.camera.computeScreenPixelSizeAt(l);m.normalize(u,u),m.scale(u,u,Math.min(g,1)),m.add(l,l,u)},n._computeIntersection=function({computation:e,interpolationInfo:t}){const{view:o}=this,{sceneIntersectionHelper:n,renderCoordsHelper:i}=o;if(d.isNone(n))return;const r=this._intersector.intersector,{computationResult:s,inputPoints:a}=e,{observer:c,target:l}=a,{start:u,end:p}=s,g=O.fromPoints(u,p,V);r.options.store=w.StoreResults.MIN,n.intersectToolIntersectorRay(g,r);const h=r.results.min,f=s.intersection,v=j;let _=!0;if(d.isSome(h)&&h.getIntersectionPoint(f)){m.copy(t.originalIntersection,f),m.copy(t.originalObserver,u),m.copy(t.originalTarget,p),i.fromRenderCoords(f,v,o.spatialReference);const e=1-m.dist(p,l)/m.dist(u,l);_=m.dist(c,f)>=e*m.dist(c,l)}const y=new E(v,o.spatialReference);{const{result:t,target:n}=e;d.isSome(t)?(t.target=n,t.intersectedGraphic=_?null:A.toGraphic(h,o),t.intersectedLocation=_?null:y,t.visible=_):e.result=new I.LineOfSightAnalysisResult({target:n,elevationAlignedTargetLocation:e.elevationAlignedTargetLocation,intersectedGraphic:_?null:A.toGraphic(h,o),intersectedLocation:_?null:y,visible:_})}s.isValid=a.isValid=!0,s.isTargetVisible=_},n._interpolateIntersection=function({computation:e,interpolationInfo:t}){const{computationResult:o,inputPoints:n}=e,{start:i,end:r,intersection:s}=o,{originalIntersection:a,originalObserver:c,originalTarget:l}=t;if(m.copy(s,a),n.isValid){const e=j,t=m.dist(c,a)/m.dist(c,l);m.sub(e,i,c),m.scale(e,e,1-t),m.add(s,s,e),m.sub(e,r,l),m.scale(e,e,t),m.add(s,s,e),o.isValid=!0}else e.result=null,o.isValid=!1,o.isTargetVisible=!1},n._canCompute=function(e){const t=this.analysisViewData.elevationAlignedObserver,o=this.view.frustum;if(d.isNone(t)||d.isNone(e.elevationAlignedTargetLocation)||d.isNone(o))return!1;const{observerAdjusted:n,targetAdjusted:i}=e.inputPoints,r=o.intersectsPoint(n),s=o.intersectsPoint(i);return r&&s},n._onObserverPositionChange=function(e,t,o,n,r){if(this._externalObserverUpdate=r,d.isNone(e))return this.analysisViewData.elevationAlignedObserver=null,void(this._observerFeatureId=null);if(d.isNone(t))return R.logFailedGeometryProjectionError(this.analysis,e.spatialReference,H),void(this.analysisViewData.elevationAlignedObserver=null);const s=this._getEffectiveElevationInfo(t,o),{absoluteZ:a,elevation:c}=T.zValueInAbsoluteHeightMode(t.x,t.y,t.z,this.view.spatialReference,this.view,s),l=t.clone();l.z=a,this._effectiveObserverElevationMode=s.mode,this.analysisViewData.elevationAlignedObserver=l;const u=y.create();this.view.renderCoordsHelper.toRenderCoords(l,u),this._elevationAlignedObserverPositionRenderSpace=u,this._observerGroundOffsetRenderSpace=a-c,this._observerFeatureId=i.getFeatureId(n),this.priority=N.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},n._onObserverRenderSpacePositionChangeForComputation=function(e,t,o,n,i){const{inputPoints:r}=e;switch(m.copy(r.observer,t),r.observerFeatureId=i,r.observerSurfaceNormal=null,n){case"on-the-ground":case"relative-to-ground":{const e=this._intersector.updateFromGroundIntersection(r.observer,o,r.observer);d.isNone(r.observerFeatureId)&&(r.observerSurfaceNormal=e)}}this._adjustStartEndPositions(e),e.notifyInputPointsChanged(),this.priority=N.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},n._onTargetPositionChange=function(e,t,o,n,r,s=!0){const a=e.inputPoints;if(s&&(a.isValid=!1),d.isNone(o))return d.isSome(t)&&R.logFailedGeometryProjectionError(this.analysis,t.spatialReference,H),e.elevationAlignedTargetLocation=null,void e.notifyInputPointsChanged();const c=this._getEffectiveElevationInfo(o,n),{absoluteZ:l,elevation:u}=T.zValueInAbsoluteHeightMode(o.x,o.y,o.z,this.view.spatialReference,this.view,c),p=o.clone();switch(p.z=l,e.elevationAlignedTargetLocation=p,this.view.renderCoordsHelper.toRenderCoords(e.elevationAlignedTargetLocation,a.target),a.targetFeatureId=i.getFeatureId(r),a.targetSurfaceNormal=null,c.mode){case"on-the-ground":case"relative-to-ground":{const e=this._intersector.updateFromGroundIntersection(a.target,l-u,a.target);d.isNone(a.targetFeatureId)&&(a.targetSurfaceNormal=e)}}this._adjustStartEndPositions(e),e.notifyInputPointsChanged(),this.priority=N.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},n._connectComputationToTarget=function(e){return l.handlesGroup([this._updatingHandles.add((()=>({computation:e,targetPosition:e.target.position,targetElevationInfo:e.target.elevationInfo,targetFeatureInfo:e.target.feature,projectedTargetPosition:S.projectOrLoad(e.target.position,this.view.spatialReference)})),(({computation:e,targetPosition:t,targetElevationInfo:o,targetFeatureInfo:n,projectedTargetPosition:i})=>{d.isSome(i.pending)?this._updatingHandles.addPromise(i.pending):this._onTargetPositionChange(e,t,i.geometry,o,n)}),g.initial)])},n._connectComputationToObserver=function(e){return this._updatingHandles.add((()=>({computation:e,observer:this.analysisViewData.elevationAlignedObserver})),(({computation:e})=>{this._externalObserverUpdate&&(e.inputPoints.isValid=!1,e.notifyInputPointsChanged())}),g.initial)},n._connectComputationToRenderSpaceObserver=function(e){return this._updatingHandles.add((()=>({computation:e,observer:this._elevationAlignedObserverPositionRenderSpace,observerGroundOffset:this._observerGroundOffsetRenderSpace,observerElevationMode:this._effectiveObserverElevationMode,observerFeatureId:this._observerFeatureId})),(({computation:e,observer:t,observerGroundOffset:o,observerElevationMode:n,observerFeatureId:i})=>{this._onObserverRenderSpacePositionChangeForComputation(e,t,o,n,i)}),g.initial)},n._connectComputationToCamera=function(e){return this._updatingHandles.add((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:t})=>{!this.updateOnCameraChange||e.inputPoints.isValid&&!t||e.notifyInputPointsChanged()}))},n._connectComputationToSlicePlane=function(e){return this._updatingHandles.add((()=>this.view.slicePlane),(()=>{e.inputPoints.isValid=!1,e.notifyInputPointsChanged()}))},n._connectComputationToElevation=function(e){const t=(o,n)=>{const i=this.analysis.observer,r=e.target;let s=null,a=null,c=null,l=null,u=null,p=null;if(d.isSome(i)&&d.isSome(i.position)){const e=S.projectOrLoad(i.position,this.view.spatialReference);if(d.isSome(e.pending))return this._updatingHandles.addPromise(e.pending),void e.pending.finally((()=>t(o,n)));s=e.geometry,a=i.elevationInfo,c=i.feature}if(d.isSome(r.position)){const e=S.projectOrLoad(r.position,this.view.spatialReference);if(d.isSome(e.pending))return this._updatingHandles.addPromise(e.pending),void e.pending.finally((()=>t(o,n)));l=e.geometry,u=r.elevationInfo,p=r.feature}d.isNone(s)&&d.isNone(l)||(S.projectBoundingRect(o,n,G,this.view.spatialReference),d.isSome(s)&&C.containsPointObject(G,s)&&this._onObserverPositionChange(d.isSome(i)?i.position:null,s,a,c,!1),d.isSome(l)&&C.containsPointObject(G,l)&&this._onTargetPositionChange(e,r.position,l,u,p,!1),d.isSome(s)&&d.isSome(l)&&C.intersectsSegment(G,s,l)&&e.notifyInputPointsChanged())};return this.view.elevationProvider.on("elevation-change",(e=>t(e.extent,e.spatialReference)))},n._connectComputationToTask=function(e){var o=this;let n=d.none;const i={computation:e,interpolationInfo:{originalIntersection:y.create(),originalObserver:y.create(),originalTarget:y.create()}};return l.handlesGroup([this._updatingHandles.add((()=>e.inputPoints),(()=>{n=d.abortMaybe(n),n=s.createTask(function(){var e=t._asyncToGenerator((function*(e){yield p.ignoreAbortErrors(o._frameTask.schedule((()=>o._computeResult(i)),e))}));return function(t){return e.apply(this,arguments)}}())}),{initial:!0,equals:()=>!1}),l.makeHandle((()=>n=d.abortMaybe(n)))])},n._connectComputation=function(e){const t=this._computationHandles;t.has(e)||t.add([this._connectComputationToTarget(e),this._connectComputationToObserver(e),this._connectComputationToRenderSpaceObserver(e),this._connectComputationToCamera(e),this._connectComputationToSlicePlane(e),this._connectComputationToElevation(e),this._connectComputationToTask(e)],e)},n._disconnectComputation=function(e){this._computationHandles.remove(e)},n._onComputationCollectionChange=function({added:e,removed:t}){for(const o of t)this._disconnectComputation(o);for(const o of e)this._connectComputation(o)},n._onTargetCollectionChange=function({added:e,removed:t}){for(const o of t)this._removeTarget(o);for(const o of e)this._addTarget(o)},n._onCursorTargetChange=function(e,t){d.isSome(t)&&this._removeTarget(t),d.isSome(e)&&this._addTarget(e)},n._addTarget=function(e){this._computations.some((t=>t.target===e))||this._computations.add(new P.LineOfSightComputation({target:e}))},n._removeTarget=function(e){const t=this._computations.findIndex((t=>t.target===e));this._computations.removeAt(t)},n._connectObserver=function(){return l.handlesGroup([this._updatingHandles.add((()=>({observerPosition:d.isSome(this.analysis.observer)?this.analysis.observer.position:null,projectedObserverPosition:S.projectOrLoad(d.isSome(this.analysis.observer)?this.analysis.observer.position:null,this.view.spatialReference),observerElevationInfo:d.isSome(this.analysis.observer)?this.analysis.observer.elevationInfo:null,observerFeatureInfo:d.isSome(this.analysis.observer)?this.analysis.observer.feature:null})),(({observerPosition:e,projectedObserverPosition:t,observerElevationInfo:o,observerFeatureInfo:n})=>{d.isSome(t.pending)?this._updatingHandles.addPromise(t.pending):this._onObserverPositionChange(e,t.geometry,o,n,!0)}),g.initial)])},n._connectComputations=function(){return this._updatingHandles.addOnCollectionChange((()=>this._computations),(e=>this._onComputationCollectionChange(e)),{initial:!0,final:!0})},n._connectTargets=function(){return l.handlesGroup([this._updatingHandles.addOnCollectionChange((()=>this.analysis.targets),(e=>this._onTargetCollectionChange(e)),{initial:!0,final:!0}),this._updatingHandles.add((()=>this.analysisViewData.cursorTarget),((e,t)=>{this._onCursorTargetChange(e,t)}))])},n._getEffectiveElevationInfo=function(e,t){return e.hasZ?d.unwrapOr(t,{mode:"absolute-height",offset:0}):{mode:"on-the-ground",offset:0}},t._createClass(o,[{key:"updating",get:function(){return this._frameTask.updating||this._updatingHandles.updating}},{key:"priority",get:function(){return this._frameTask.priority},set:function(e){this._frameTask.priority=e}},{key:"_computations",get:function(){return this.analysisViewData.computations}},{key:"_elevationAlignedObserverPositionRenderSpace",get:function(){return this.analysisViewData.observerEngineLocation},set:function(e){this.analysisViewData.observerEngineLocation=e}},{key:"_screenPixelSize",get:function(){return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace)}},{key:"_isCameraDirty",get:function(){const e=this.analysisViewData.elevationAlignedObserver,{view:t}=this,{renderCoordsHelper:o}=t;if(d.isNone(e)||d.isNone(o))return!1;const n=j;o.toRenderCoords(e,n);const i=t.state.camera.computeScreenPixelSizeAt(n);return Math.abs((i-this._screenPixelSize)/this._screenPixelSize)>k}}]),o}(a.EventedMixin(r)),o.__decorate([h.property({constructOnly:!0})],e.LineOfSightController.prototype,"analysis",void 0),o.__decorate([h.property({constructOnly:!0})],e.LineOfSightController.prototype,"analysisViewData",void 0),o.__decorate([h.property({constructOnly:!0})],e.LineOfSightController.prototype,"view",void 0),o.__decorate([h.property()],e.LineOfSightController.prototype,"updating",null),o.__decorate([h.property()],e.LineOfSightController.prototype,"priority",null),o.__decorate([h.property()],e.LineOfSightController.prototype,"updateOnCameraChange",void 0),o.__decorate([h.property()],e.LineOfSightController.prototype,"_computations",null),o.__decorate([h.property()],e.LineOfSightController.prototype,"_elevationAlignedObserverPositionRenderSpace",null),o.__decorate([h.property()],e.LineOfSightController.prototype,"_observerGroundOffsetRenderSpace",void 0),o.__decorate([h.property()],e.LineOfSightController.prototype,"_effectiveObserverElevationMode",void 0),o.__decorate([h.property()],e.LineOfSightController.prototype,"_observerFeatureId",void 0),o.__decorate([h.property()],e.LineOfSightController.prototype,"_screenPixelSize",null),o.__decorate([h.property({readOnly:!0})],e.LineOfSightController.prototype,"_updatingHandles",void 0),o.__decorate([h.property()],e.LineOfSightController.prototype,"_frameTask",void 0),o.__decorate([h.property()],e.LineOfSightController.prototype,"_isCameraDirty",null),e.LineOfSightController=o.__decorate([_.subclass(F)],e.LineOfSightController);const k=.1,j=y.create(),V=O.create(),G=C.empty(),D=.05;Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
