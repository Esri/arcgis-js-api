/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/tslib.es6","../../../../geometry","../../../../core/Accessor","../../../../core/Evented","../../../../core/Handles","../../../../core/handleUtils","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/reactiveUtils","../../../../core/accessorSupport/decorators/property","../../../../core/arrayUtils","../../../../core/has","../../../../core/accessorSupport/ensureType","../../../../core/accessorSupport/decorators/subclass","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/projection","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/ray","./LineOfSightAnalysis","./LineOfSightRayIntersector","./LineOfSightResult","../../support/ElevationProvider","../../webgl-engine/lib/intersectorUtilsConversions","../../../support/Scheduler","../../../support/WatchUpdatingTracking","../../../../geometry/Point"],(function(e,t,n,i,s,r,o,a,l,c,u,d,h,y,p,g,_,v,f,m,b,A,C,T,O,S,L,I,P){"use strict";function E(e,t,n){return!l.isNone(n)&&(f.projectBoundingRect(e,t,V,n.spatialReference),m.containsPointObject(V,n))}function w(e,t){return l.isNone(t)||l.isSome(e)&&e.equals(t.point)}e.LineOfSightController=function(e){function n(t){var n;return(n=e.call(this,t)||this)._updatingHandles=new I.WatchUpdatingTracking,n._frameTask=L.ImmediateTask,n._handles=new o,n._analysisHandles=new o,n}t._inheritsLoose(n,e);var i=n.prototype;return i.initialize=function(){var e;const t=null==(e=this.view.resourceController)?void 0:e.scheduler;t&&(this._frameTask=t.registerTask(L.TaskPriority.LINE_OF_SIGHT_TOOL)),this._handles.add([this._connectObserver(),this._connectAnalyses(),this._connectTargets()]),this._intersector=new C.LineOfSightRayIntersector({view:this.view})},i.destroy=function(){this._handles.destroy(),this._analysisHandles.destroy(),this._analyses.removeAll(),this._updatingHandles.destroy()},i.getLineOfSightComputationDependencies=function(e){const{inputPoints:t}=e;return{inputPoints:t}},i.computeAnalysis=function(e){const t=e.analysis,{inputPoints:n,computationResult:i}=t,{observerAdjusted:s,targetAdjusted:r}=n,{start:o,end:a}=i;_.copy(o,s),_.copy(a,r);this._canComputeAnalysis(t)?this._computeAnalysisIntersection(e):this._interpolateAnalysisIntersection(e),t.updateComputationResults(),this.emit("result-changed",{target:e.analysis.target,result:t.result})},i._adjustStartEndPositions=function(e){const t=this._screenPixelSize,n=this.view,{inputPoints:i}=e,{observer:s,observerSurfaceNormal:r,target:o,targetSurfaceNormal:a,observerAdjusted:c,targetAdjusted:u}=i,d=R;l.isSome(r)?_.copy(d,r):_.subtract(d,o,s);const h=t;_.normalize(d,d),_.scale(d,d,Math.min(h,1)),_.add(c,s,d),l.isSome(a)?_.copy(d,a):_.subtract(d,s,o);const y=n.state.camera.computeScreenPixelSizeAt(o);_.normalize(d,d),_.scale(d,d,Math.min(y,1)),_.add(u,o,d)},i._computeAnalysisIntersection=function({analysis:e,interpolationInfo:t}){const{view:n}=this,{sceneIntersectionHelper:i,renderCoordsHelper:s}=n;if(l.isNone(i))return;const r=this._intersector.intersector,{computationResult:o,inputPoints:a}=e,{observer:c,target:u}=a,{start:d,end:h}=o,y=b.fromPoints(d,h,H);i.intersectToolIntersectorRay(y,r);const p=o.intersection,g=R,v=r.results.min.getIntersectionPoint(p);let f=!0;if(v){_.copy(t.originalIntersection,p),_.copy(t.originalObserver,d),_.copy(t.originalTarget,h),s.fromRenderCoords(p,g,n.spatialReference);const e=1-_.dist(h,u)/_.dist(d,u);f=_.dist(c,p)>=e*_.dist(c,u)}const m=new P(g,n.spatialReference);{const{result:t,target:i}=e;l.isSome(t)?(t.target=i,t.intersectedGraphic=f?null:S.toGraphic(r.results.min,n),t.intersectedLocation=f?null:m,t.visible=!!v&&f):e.result=new T.LineOfSightResult({target:i,elevationAlignedTargetLocation:e.elevationAlignedTargetLocation,intersectedGraphic:f?null:S.toGraphic(r.results.min,n),intersectedLocation:f?null:m,visible:!!v&&f})}o.isValid=a.isValid=!0,o.isTargetVisible=f},i._interpolateAnalysisIntersection=function({analysis:e,interpolationInfo:t}){const{computationResult:n,inputPoints:i}=e,{start:s,end:r,intersection:o}=n,{originalIntersection:a,originalObserver:l,originalTarget:c}=t;if(_.copy(o,a),i.isValid){const e=R,t=_.dist(l,a)/_.dist(l,c);_.sub(e,s,l),_.scale(e,e,1-t),_.add(o,o,e),_.sub(e,r,c),_.scale(e,e,t),_.add(o,o,e),n.isValid=!0}else e.result=null,n.isValid=!1,n.isTargetVisible=!1},i._canComputeAnalysis=function(e){const t=this.analysisViewData.elevationAlignedObserver,n=this.view.frustum;if(l.isNone(t)||l.isNone(e.target)||l.isNone(n))return!1;const{observerAdjusted:i,targetAdjusted:s}=e.inputPoints,r=n.intersectsPoint(i),o=n.intersectsPoint(s);return r&&o},i._onObserverChange=function(e,t){if(l.isNone(e))return this.analysis.targets.removeAll(),void(this.analysisViewData.elevationAlignedObserver=null);this.analysisViewData.elevationAlignedObserver=this._applyElevationAlignment(e,t);const n=v.create();this.view.renderCoordsHelper.toRenderCoords(this.analysisViewData.elevationAlignedObserver,n),this._observerEngineLocation=n,this.priority=L.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},i._applyElevationAlignment=function(e,t){if(e.hasZ&&(l.isNone(t)||0===t.type))return e;const n=e.clone();return n.z=l.unwrapOr(O.getElevationAtPoint(this.view.elevationProvider,n),0),n},i._onObserverChangeForAnalysis=function(e){e.inputPoints.isValid=!1},i._onObserverEngineForAnalysis=function(e,t,n){const{inputPoints:i}=e;if(_.copy(i.observer,t),l.isSome(n)){const e=this._intersector.updateFromIntersectionResult(n);l.isSome(e)&&this.view.renderCoordsHelper.toRenderCoords(e,i.observer),i.observerSurfaceNormal=v.clone(n.normal)}else i.observerSurfaceNormal=null;this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=L.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},i._onTargetLocationChange=function(e,t,n){const i=e.inputPoints;if(i.isValid=!1,l.isSome(t)){if(e.elevationAlignedTargetLocation=this._applyElevationAlignment(t,n),this.view.renderCoordsHelper.toRenderCoords(e.elevationAlignedTargetLocation,i.target),l.isSome(n)){const e=this._intersector.updateFromIntersectionResult(n);l.isSome(e)&&this.view.renderCoordsHelper.toRenderCoords(e,i.target),i.targetSurfaceNormal=v.clone(n.normal)}else i.targetSurfaceNormal=null;this._adjustStartEndPositions(e),e.updateInputPoints()}this.priority=L.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},i._connectAnalysisToTarget=function(e){return a.handlesGroup([u.react((()=>e.target.location),(t=>{w(t,e.target.intersection)||(e.target.intersection=null)}),u.initial),u.react((()=>({analysis:e,targetLocation:e.target.location,targetIntersection:e.target.intersection})),(({analysis:e,targetLocation:t,targetIntersection:n})=>{l.isSome(t)&&this._onTargetLocationChange(e,t,n)}),u.syncAndInitial)])},i._connectAnalysisToObserver=function(e){return u.react((()=>({analysis:e,observer:this.analysisViewData.elevationAlignedObserver})),(({analysis:e})=>{this._onObserverChangeForAnalysis(e)}),u.syncAndInitial)},i._connectAnalysisToObserverEngine=function(e){return u.react((()=>({analysis:e,observer:this._observerEngineLocation,observerIntersection:this.analysis.intersection})),(({analysis:e,observer:t,observerIntersection:n})=>{this._onObserverEngineForAnalysis(e,t,n)}),u.syncAndInitial)},i._connectAnalysisToCamera=function(e){return u.react((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:t})=>{e.inputPoints.isValid&&!t||e.updateInputPoints()}),u.sync)},i._connectAnalysisToElevation=function(e){return this.view.elevationProvider.on("elevation-change",(t=>{if(!this._canComputeAnalysis(e))return;const n=this.analysis.observer;E(t.extent,t.spatialReference,n)&&this._onObserverChange(n,this.analysis.intersection);const i=e.target;l.isSome(i)&&E(t.extent,t.spatialReference,i.location)&&e.onElevationChange()}))},i._connectAnalysisForCompute=function(e){var n=this;let i=l.none;const s={analysis:e,interpolationInfo:{originalIntersection:v.create(),originalObserver:v.create(),originalTarget:v.create()}};return a.handlesGroup([u.react((()=>this.getLineOfSightComputationDependencies(e)),(()=>{i=l.abortMaybe(i),i=c.createTask(function(){var e=t._asyncToGenerator((function*(e){yield c.ignoreAbortErrors(n._frameTask.schedule((()=>n.computeAnalysis(s)),e))}));return function(t){return e.apply(this,arguments)}}())}),u.syncAndInitial),a.makeHandle((()=>i=l.abortMaybe(i)))])},i._connectAnalysis=function(e){const t=this._analysisHandles;t.has(e)||t.add([this._connectAnalysisToTarget(e),this._connectAnalysisToObserver(e),this._connectAnalysisToObserverEngine(e),this._connectAnalysisToCamera(e),this._connectAnalysisToElevation(e),this._connectAnalysisForCompute(e)],e)},i._disconnectAnalysis=function(e){this._analysisHandles.remove(e)},i._onAnalysesCollectionChange=function(e){e.added.forEach((e=>this._connectAnalysis(e))),e.removed.forEach((e=>this._disconnectAnalysis(e)))},i._onTargetsChange=function(){return this._analyses.removeAll(),this.analysis.targets.forEach((e=>this._addTarget(e))),this._updatingHandles.addOnCollectionPropertyChange(this.analysis,"targets",(e=>this._onTargetCollectionChange(e)))},i._onTargetCollectionChange=function(e){e.added.forEach((e=>this._addTarget(e))),e.removed.forEach((e=>this._removeTarget(e)))},i._onCursorTargetChange=function(e,t){l.isSome(t)&&this._removeTarget(t),l.isSome(e)&&this._addTarget(e)},i._addTarget=function(e){this._analyses.some((t=>t.target===e))||this._analyses.add(new A.LineOfSightAnalysis({target:e}))},i._removeTarget=function(e){const t=this._analyses.find((t=>t.target===e));this._analyses.remove(t)},i._connectObserver=function(){return a.handlesGroup([u.react((()=>this.analysis.observer),(e=>{w(e,this.analysis.intersection)||(this.analysis.intersection=null)}),u.initial),u.react((()=>({observer:this.analysis.observer,intersection:this.analysis.intersection})),(({observer:e,intersection:t})=>this._onObserverChange(e,t)),u.syncAndInitial)])},i._connectAnalyses=function(){let e=null;return a.handlesGroup([u.react((()=>this._analyses),(()=>{l.removeMaybe(e),e=this._updatingHandles.addOnCollectionPropertyChange(this,"_analyses",(e=>this._onAnalysesCollectionChange(e))),this._analyses.forEach((e=>this._connectAnalysis(e)))}),u.syncAndInitial),a.makeHandle((()=>e=l.removeMaybe(e)))])},i._connectTargets=function(){let e=null;return a.handlesGroup([u.react((()=>this.analysis.targets),(()=>{e=l.removeMaybe(e),e=this._onTargetsChange()}),u.syncAndInitial),u.react((()=>this.analysisViewData.cursorTarget),((e,t)=>{this._onCursorTargetChange(e,t)})),a.makeHandle((()=>{e=l.removeMaybe(e)}))])},t._createClass(n,[{key:"updating",get:function(){return this._frameTask.updating||this._updatingHandles.updating}},{key:"priority",get:function(){return this._frameTask.priority},set:function(e){this._frameTask.priority=e}},{key:"_analyses",get:function(){return this.analysisViewData.analyses}},{key:"_observerEngineLocation",get:function(){return this.analysisViewData.observerEngineLocation},set:function(e){this.analysisViewData.observerEngineLocation=e}},{key:"_screenPixelSize",get:function(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}},{key:"_isCameraDirty",get:function(){const e=this.analysisViewData.elevationAlignedObserver,{view:t}=this,{renderCoordsHelper:n}=t;if(l.isNone(e)||l.isNone(n))return!1;const i=R;n.toRenderCoords(e,i);const s=t.state.camera.computeScreenPixelSizeAt(i);return Math.abs((s-this._screenPixelSize)/this._screenPixelSize)>k}}]),n}(r.EventedMixin(s)),n.__decorate([d.property({constructOnly:!0})],e.LineOfSightController.prototype,"analysis",void 0),n.__decorate([d.property({constructOnly:!0})],e.LineOfSightController.prototype,"analysisViewData",void 0),n.__decorate([d.property({constructOnly:!0})],e.LineOfSightController.prototype,"view",void 0),n.__decorate([d.property()],e.LineOfSightController.prototype,"updating",null),n.__decorate([d.property()],e.LineOfSightController.prototype,"priority",null),n.__decorate([d.property()],e.LineOfSightController.prototype,"_analyses",null),n.__decorate([d.property()],e.LineOfSightController.prototype,"_observerEngineLocation",null),n.__decorate([d.property()],e.LineOfSightController.prototype,"_screenPixelSize",null),n.__decorate([d.property({readOnly:!0})],e.LineOfSightController.prototype,"_updatingHandles",void 0),n.__decorate([d.property()],e.LineOfSightController.prototype,"_frameTask",void 0),n.__decorate([d.property()],e.LineOfSightController.prototype,"_isCameraDirty",null),e.LineOfSightController=n.__decorate([g.subclass("esri.views.3d.analysis.LineOfSight.LineOfSightController")],e.LineOfSightController);const k=.1,R=v.create(),H=b.create(),V=m.empty();Object.defineProperty(e,"__esModule",{value:!0})}));
