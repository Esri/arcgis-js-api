/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import"../../../../geometry.js";import{getFeatureId as t}from"../../../../analysis/featureReferenceUtils.js";import o from"../../../../core/Accessor.js";import i from"../../../../core/Evented.js";import n from"../../../../core/Handles.js";import{handlesGroup as r,makeHandle as s}from"../../../../core/handleUtils.js";import{equals as a}from"../../../../core/lang.js";import c from"../../../../core/Logger.js";import{isNone as l,isSome as u,abortMaybe as p,unwrapOr as d,none as h}from"../../../../core/maybe.js";import{createTask as g,ignoreAbortErrors as v}from"../../../../core/promiseUtils.js";import{watch as m,on as f,syncAndInitial as _,sync as b}from"../../../../core/reactiveUtils.js";import{property as y}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as C}from"../../../../core/accessorSupport/decorators/subclass.js";import{c as I,i as T,b as O,n as P,g as S,a as j,j as w,v as R}from"../../../../chunks/vec3.js";import{c as A}from"../../../../chunks/vec3f64.js";import{WatchUpdatingTracking as E}from"../../../../core/support/WatchUpdatingTracking.js";import{projectOrLoad as L,projectBoundingRect as F}from"../../../../geometry/projection.js";import{empty as V,containsPointObject as H,intersectsSegment as D}from"../../../../geometry/support/aaBoundingRect.js";import{fromPoints as x,create as N}from"../../../../geometry/support/ray.js";import{zValueInAbsoluteHeightMode as k}from"../../../../support/elevationInfoUtils.js";import{LineOfSightAnalysisResult as z}from"../LineOfSightAnalysisResult.js";import{LineOfSightComputation as G}from"./LineOfSightComputation.js";import{LineOfSightRayIntersector as M}from"./LineOfSightRayIntersector.js";import{logFailedGeometryProjectionError as U}from"../support/projectionUtils.js";import{StoreResults as Z}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{toGraphic as q,hasLod as B,getIntersectedFeatureBSRadius as W}from"../../webgl-engine/lib/intersectorUtilsConversions.js";import{ImmediateTask as J,TaskPriority as K}from"../../../support/Scheduler.js";import Q from"../../../../geometry/Point.js";const X=c.getLogger("esri.views.3d.analysis.LineOfSight.LineOfSightController");let Y=class extends(i.EventedMixin(o)){constructor(e){super(e),this.updateOnCameraChange=!0,this._effectiveObserverElevationMode="absolute-height",this._observerFeatureId=null,this._updatingHandles=new E,this._frameTask=J,this._handles=new n,this._computationHandles=new n,this._externalObserverUpdate=!0}initialize(){const e=this.view.resourceController?.scheduler;this._frameTask=e?e.registerTask(K.LINE_OF_SIGHT_TOOL):J,this._intersector=new M({view:this.view}),this._handles.add([this._connectObserver(),this._connectComputations(),this._connectTargets()])}destroy(){this._handles.destroy(),this._computationHandles.destroy(),this._computations.removeAll(),this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(e){this._frameTask.priority=e}get _computations(){return this.analysisViewData.computations}get _elevationAlignedObserverPositionRenderSpace(){return this.analysisViewData.observerEngineLocation}set _elevationAlignedObserverPositionRenderSpace(e){this.analysisViewData.observerEngineLocation=e}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace)}getLineOfSightComputationDependencies(e){const{inputPoints:t}=e;return{inputPoints:t}}_computeResult(e){const t=e.computation,{inputPoints:o,computationResult:i}=t,{observerAdjusted:n,targetAdjusted:r}=o,{start:s,end:a}=i;I(s,n),I(a,r);this._canCompute(t)?this._computeIntersection(e):this._interpolateIntersection(e),t.notifyResultChanged(),this.emit("result-changed",{target:e.computation.target,result:t.result})}_updateAdjustedPointsFromFeatures(e){const o=this.view,{sceneIntersectionHelper:i}=o,{inputPoints:n}=e,{observerAdjusted:r,observerFeatureId:s,targetFeatureId:a,targetAdjusted:c}=n;if(l(s)&&l(a))return;const p=T(r,c),d=this._intersector.intersector,h=x(n.observer,n.target,te);d.options.store=Z.ALL,i.intersectToolIntersectorRay(h,d);let g=null,v=null,m=null,f=null;for(const _ of d.results.all){const e=q(_,this.view);if(l(e)||l(_.distanceInRenderSpace))continue;const i=t(e);l(i)||(u(s)&&i===s&&(l(g)&&(g=this._getFeatureDistanceThreshold(_,o,p)),_.distanceInRenderSpace<g&&(m=_)),u(a)&&i===a&&(l(v)&&(v=this._getFeatureDistanceThreshold(_,o,p)),l(f)&&_.distanceInRenderSpace<p&&p-_.distanceInRenderSpace<v&&(f=_)))}u(m)&&m.getIntersectionPoint(r)&&(n.observerSurfaceNormal=m.getTransformedNormal(A())),u(f)&&f.getIntersectionPoint(c)&&(n.targetSurfaceNormal=f.getTransformedNormal(A()))}_getFeatureDistanceThreshold(e,t,o){if(B(e)){const i=W(e,t);if(u(i))return Math.min(i*ie,o)}return 1e-5*o}_adjustStartEndPositions(e){const t=this._screenPixelSize,o=this.view,{inputPoints:i}=e,{observer:n,observerSurfaceNormal:r,target:s,targetSurfaceNormal:a,observerAdjusted:c,targetAdjusted:l}=i,p=ee;I(c,n),I(l,s),this._updateAdjustedPointsFromFeatures(e),u(r)?I(p,r):O(p,l,c);const d=t;P(p,p),S(p,p,Math.min(d,1)),j(c,c,p),u(a)?I(p,a):O(p,c,l);const h=o.state.camera.computeScreenPixelSizeAt(l);P(p,p),S(p,p,Math.min(h,1)),j(l,l,p)}_computeIntersection({computation:e,interpolationInfo:t}){const{view:o}=this,{sceneIntersectionHelper:i,renderCoordsHelper:n}=o;if(l(i))return;const r=this._intersector.intersector,{computationResult:s,inputPoints:a}=e,{observer:c,target:p}=a,{start:d,end:h}=s,g=x(d,h,te);r.options.store=Z.MIN,i.intersectToolIntersectorRay(g,r);const v=r.results.min,m=s.intersection,f=ee;let _=!0;if(u(v)&&v.getIntersectionPoint(m)){I(t.originalIntersection,m),I(t.originalObserver,d),I(t.originalTarget,h),n.fromRenderCoords(m,f,o.spatialReference);const e=1-w(h,p)/w(d,p);_=w(c,m)>=e*w(c,p)}const b=new Q(f,o.spatialReference);{const{result:t,target:i}=e;u(t)?(t.target=i,t.intersectedGraphic=_?null:q(v,o),t.intersectedLocation=_?null:b,t.visible=_):e.result=new z({target:i,elevationAlignedTargetLocation:e.elevationAlignedTargetLocation,intersectedGraphic:_?null:q(v,o),intersectedLocation:_?null:b,visible:_})}s.isValid=a.isValid=!0,s.isTargetVisible=_}_interpolateIntersection({computation:e,interpolationInfo:t}){const{computationResult:o,inputPoints:i}=e,{start:n,end:r,intersection:s}=o,{originalIntersection:a,originalObserver:c,originalTarget:l}=t;if(I(s,a),i.isValid){const e=ee,t=w(c,a)/w(c,l);R(e,n,c),S(e,e,1-t),j(s,s,e),R(e,r,l),S(e,e,t),j(s,s,e),o.isValid=!0}else e.result=null,o.isValid=!1,o.isTargetVisible=!1}_canCompute(e){const t=this.analysisViewData.elevationAlignedObserver,o=this.view.frustum;if(l(t)||l(e.elevationAlignedTargetLocation)||l(o))return!1;const{observerAdjusted:i,targetAdjusted:n}=e.inputPoints,r=o.intersectsPoint(i),s=o.intersectsPoint(n);return r&&s}_onObserverPositionChange(e,o,i,n,r){if(this._externalObserverUpdate=r,l(e))return this.analysisViewData.elevationAlignedObserver=null,void(this._observerFeatureId=null);if(l(o))return U(this.analysis,e.spatialReference,X),void(this.analysisViewData.elevationAlignedObserver=null);const s=this._getEffectiveElevationInfo(o,i),{absoluteZ:a,elevation:c}=k(o.x,o.y,o.z,this.view.spatialReference,this.view,s),u=o.clone();u.z=a,this._effectiveObserverElevationMode=s.mode,this.analysisViewData.elevationAlignedObserver=u;const p=A();this.view.renderCoordsHelper.toRenderCoords(u,p),this._elevationAlignedObserverPositionRenderSpace=p,this._observerGroundOffsetRenderSpace=a-c,this._observerFeatureId=t(n),this.priority=K.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onObserverRenderSpacePositionChangeForComputation(e,t,o,i,n){const{inputPoints:r}=e;switch(I(r.observer,t),r.observerFeatureId=n,r.observerSurfaceNormal=null,i){case"on-the-ground":case"relative-to-ground":{const e=this._intersector.updateFromGroundIntersection(r.observer,o,r.observer);l(r.observerFeatureId)&&(r.observerSurfaceNormal=e)}}this._adjustStartEndPositions(e),e.notifyInputPointsChanged(),this.priority=K.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetPositionChange(e,o,i,n,r,s=!0){const a=e.inputPoints;if(s&&(a.isValid=!1),l(i))return u(o)&&U(this.analysis,o.spatialReference,X),e.elevationAlignedTargetLocation=null,void e.notifyInputPointsChanged();const c=this._getEffectiveElevationInfo(i,n),{absoluteZ:p,elevation:d}=k(i.x,i.y,i.z,this.view.spatialReference,this.view,c),h=i.clone();switch(h.z=p,e.elevationAlignedTargetLocation=h,this.view.renderCoordsHelper.toRenderCoords(e.elevationAlignedTargetLocation,a.target),a.targetFeatureId=t(r),a.targetSurfaceNormal=null,c.mode){case"on-the-ground":case"relative-to-ground":{const e=this._intersector.updateFromGroundIntersection(a.target,p-d,a.target);l(a.targetFeatureId)&&(a.targetSurfaceNormal=e)}}this._adjustStartEndPositions(e),e.notifyInputPointsChanged(),this.priority=K.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectComputationToTarget(e){return r([m((()=>({computation:e,targetPosition:e.target.position,targetElevationInfo:e.target.elevationInfo,targetFeatureInfo:e.target.feature,projectedTargetPosition:L(e.target.position,this.view.spatialReference)})),(({computation:e,targetPosition:t,targetElevationInfo:o,targetFeatureInfo:i,projectedTargetPosition:n})=>{u(n.pending)?this._updatingHandles.addPromise(n.pending):this._onTargetPositionChange(e,t,n.geometry,o,i)}),_)])}_connectComputationToObserver(e){return m((()=>({computation:e,observer:this.analysisViewData.elevationAlignedObserver})),(({computation:e})=>{this._externalObserverUpdate&&(e.inputPoints.isValid=!1,e.notifyInputPointsChanged())}),_)}_connectComputationToRenderSpaceObserver(e){return m((()=>({computation:e,observer:this._elevationAlignedObserverPositionRenderSpace,observerGroundOffset:this._observerGroundOffsetRenderSpace,observerElevationMode:this._effectiveObserverElevationMode,observerFeatureId:this._observerFeatureId})),(({computation:e,observer:t,observerGroundOffset:o,observerElevationMode:i,observerFeatureId:n})=>{this._onObserverRenderSpacePositionChangeForComputation(e,t,o,i,n)}),_)}_connectComputationToCamera(e){return m((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:t})=>{!this.updateOnCameraChange||e.inputPoints.isValid&&!t||e.notifyInputPointsChanged()}),b)}_connectComputationToSlicePlane(e){return m((()=>this.view.slicePlane),(()=>{e.inputPoints.isValid=!1,e.notifyInputPointsChanged()}))}_connectComputationToElevation(e){const t=(o,i)=>{const n=this.analysis.observer,r=e.target;let s=null,a=null,c=null,p=null,d=null,h=null;if(u(n)&&u(n.position)){const e=L(n.position,this.view.spatialReference);if(u(e.pending))return this._updatingHandles.addPromise(e.pending),void e.pending.finally((()=>t(o,i)));s=e.geometry,a=n.elevationInfo,c=n.feature}if(u(r.position)){const e=L(r.position,this.view.spatialReference);if(u(e.pending))return this._updatingHandles.addPromise(e.pending),void e.pending.finally((()=>t(o,i)));p=e.geometry,d=r.elevationInfo,h=r.feature}l(s)&&l(p)||(F(o,i,oe,this.view.spatialReference),u(s)&&H(oe,s)&&this._onObserverPositionChange(u(n)?n.position:null,s,a,c,!1),u(p)&&H(oe,p)&&this._onTargetPositionChange(e,r.position,p,d,h,!1),u(s)&&u(p)&&D(oe,s,p)&&e.notifyInputPointsChanged())};return this.view.elevationProvider.on("elevation-change",(e=>t(e.extent,e.spatialReference)))}_connectComputationToTask(e){let t=h;const o={computation:e,interpolationInfo:{originalIntersection:A(),originalObserver:A(),originalTarget:A()}};return r([m((()=>this.getLineOfSightComputationDependencies(e)),(()=>{t=p(t),t=g((async e=>{await v(this._frameTask.schedule((()=>this._computeResult(o)),e))}))}),{sync:!0,initial:!0,equals:a}),s((()=>t=p(t)))])}_connectComputation(e){const t=this._computationHandles;t.has(e)||t.add([this._connectComputationToTarget(e),this._connectComputationToObserver(e),this._connectComputationToRenderSpaceObserver(e),this._connectComputationToCamera(e),this._connectComputationToSlicePlane(e),this._connectComputationToElevation(e),this._connectComputationToTask(e)],e)}_disconnectComputation(e){this._computationHandles.remove(e)}_onComputationCollectionChange({added:e,removed:t}){for(const o of t)this._disconnectComputation(o);for(const o of e)this._connectComputation(o)}_onTargetCollectionChange({added:e,removed:t}){for(const o of t)this._removeTarget(o);for(const o of e)this._addTarget(o)}_onCursorTargetChange(e,t){u(t)&&this._removeTarget(t),u(e)&&this._addTarget(e)}_addTarget(e){this._computations.some((t=>t.target===e))||this._computations.add(new G({target:e}))}_removeTarget(e){const t=this._computations.findIndex((t=>t.target===e));this._computations.removeAt(t)}_connectObserver(){return r([m((()=>({observerPosition:u(this.analysis.observer)?this.analysis.observer.position:null,projectedObserverPosition:L(u(this.analysis.observer)?this.analysis.observer.position:null,this.view.spatialReference),observerElevationInfo:u(this.analysis.observer)?this.analysis.observer.elevationInfo:null,observerFeatureInfo:u(this.analysis.observer)?this.analysis.observer.feature:null})),(({observerPosition:e,projectedObserverPosition:t,observerElevationInfo:o,observerFeatureInfo:i})=>{u(t.pending)?this._updatingHandles.addPromise(t.pending):this._onObserverPositionChange(e,t.geometry,o,i,!0)}),_)])}_connectComputations(){return f((()=>this._computations),"change",(e=>this._onComputationCollectionChange(e)),{onListenerAdd:e=>{for(const t of e)this._connectComputation(t)},onListenerRemove:e=>{for(const t of e)this._disconnectComputation(t)},sync:!0})}_connectTargets(){return r([this._updatingHandles.addOnCollectionChange((()=>this.analysis.targets),(e=>this._onTargetCollectionChange(e)),{initial:!0,final:!0}),m((()=>this.analysisViewData.cursorTarget),((e,t)=>{this._onCursorTargetChange(e,t)}))])}get _isCameraDirty(){const e=this.analysisViewData.elevationAlignedObserver,{view:t}=this,{renderCoordsHelper:o}=t;if(l(e)||l(o))return!1;const i=ee;o.toRenderCoords(e,i);const n=t.state.camera.computeScreenPixelSizeAt(i);return Math.abs((n-this._screenPixelSize)/this._screenPixelSize)>$}_getEffectiveElevationInfo(e,t){return e.hasZ?d(t,{mode:"absolute-height",offset:0}):{mode:"on-the-ground",offset:0}}};e([y({constructOnly:!0})],Y.prototype,"analysis",void 0),e([y({constructOnly:!0})],Y.prototype,"analysisViewData",void 0),e([y({constructOnly:!0})],Y.prototype,"view",void 0),e([y()],Y.prototype,"updating",null),e([y()],Y.prototype,"priority",null),e([y()],Y.prototype,"updateOnCameraChange",void 0),e([y()],Y.prototype,"_computations",null),e([y()],Y.prototype,"_elevationAlignedObserverPositionRenderSpace",null),e([y()],Y.prototype,"_observerGroundOffsetRenderSpace",void 0),e([y()],Y.prototype,"_effectiveObserverElevationMode",void 0),e([y()],Y.prototype,"_observerFeatureId",void 0),e([y()],Y.prototype,"_screenPixelSize",null),e([y({readOnly:!0})],Y.prototype,"_updatingHandles",void 0),e([y()],Y.prototype,"_frameTask",void 0),e([y()],Y.prototype,"_isCameraDirty",null),Y=e([C("esri.views.3d.analysis.LineOfSight.LineOfSightController")],Y);const $=.1,ee=A(),te=N(),oe=V(),ie=.05;export{Y as LineOfSightController};
