/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/mathUtils","../../../../../core/maybe","../../../../../core/quantityUtils","../../../../../chunks/vec2","../../../../../chunks/vec2f64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../chunks/vec4f64","../../../../../geometry/projection","../../../../../geometry/projectionEllipsoid","../../../../../geometry/SpatialReference","../../../../../geometry/support/Axis","../../../../../geometry/support/intersectsBase","../../../../../geometry/support/triangle","../../interfaces","../../support/measurementUtils","../../support/viewUtils","../../../support/ElevationProvider","../../../support/mathUtils","../../../webgl-engine/lib/Indices","../../../../support/euclideanAreaMeasurementUtils"],(function(e,t,s,i,o,n,r,h,a,d,c,g,l,p,u,m,_,C,S,f,L,P){"use strict";let M=function(){function e(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=h.create(),this.areaCentroidRenderCoords=h.create(),this.geodesicAreaCentroidRenderCoords=h.create(),this._length=0,this._centroidRenderCoords=h.create(),this._planeWorldCoords=a.create(),this._worldUp=h.create(),this._worldTangent=h.create(),this._frame=[h.create(),h.create(),h.create()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=h.create(),this._tempV=h.create(),this._tempVec3=h.create(),this._tempSphere={center:h.create(),radius:0},this._sceneView=e,this.unitNormalizer=t}var S=e.prototype;return S.update=function(e,t,o,n,h,a,g){const l=this.unitNormalizer,p=this._sceneView.renderSpatialReference,u=this.unitNormalizer.spatialReference,m=s.isSome(t);if(this._pathVersion===e.version&&this._validMeasurement===n&&!g&&this._hasCursorPoint===m&&this._mode===a){return!e.isValidPolygon&&(this._updateCursorSegmentLength(e,t),!0)}this._pathVersion=e.version,this._validMeasurement=n,this._hasCursorPoint=m;const _=e.numVertices;this._resize(_);const C=c.getSphericalPCPF(o.spatialReference),S=d.canProjectWithoutEngine(o.spatialReference,C)&&d.canProjectToWGS84ComparableLonLat(o.spatialReference),{positionsGeographic:f,positionsWorldCoords:L,positionsRenderCoords:P,positionsSpherical:M}=this;e.forEachVertexPosition(((e,t)=>{R(o.elevationProvider,e),d.projectPointToVector(e,L[t],u),d.projectPointToVector(e,P[t],p),S&&(d.projectPointToWGS84ComparableLonLat(e,f[t]),d.projectPointToVector(e,M[t],C),r.normalize(M[t],M[t]))}));const A=this._updatePathLengths(n);if(this.pathLength=this._length>1?i.createLength(l.normalizeDistance(A),"meters"):null,S){const e=this._updateGeodesicPathLengths(n,u);this.geodesicPathLength=this._length>1?i.createLength(e,"meters"):null}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(e,t),this._updateMode(e,a),n?(this._updateArea(o,l,p,u,h),S&&this._updateGeodesicArea(o),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)},S.getData=function(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}},S._resize=function(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(h.create()),this.positionsRenderCoords.push(h.create()),this.positionsProjectedWorldCoords.push(n.create()),this.positionsFittedRenderCoords.push(h.create()),this.positionsGeographic.push(h.create()),this.positionsSpherical.push(h.create()),this.positionsStereographic.push(n.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length},S._updatePathLengths=function(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const n=s[o]=r.distance(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=n)}return i},S._updateGeodesicPathLengths=function(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let n=0;n<this._length;++n){const r=i[n]=_.segmentLengthGeodesicVector(s[n],s[(n+1)%this._length],t);(n<this._length-1||e)&&(o+=r)}return o},S._updateArea=function(e,t,s,n,h){const a=e.renderCoordsHelper,c=this.positionsWorldCoords,g=this.positionsRenderCoords,p=this.positionsProjectedWorldCoords,u=this.positionsFittedRenderCoords,m=this._planeWorldCoords,S=this._centroidRenderCoords;C.midpoint(g,S),a.worldUpAtPosition(S,this._worldUp),a.worldBasisAtPosition(S,l.Axis.X,this._worldTangent),d.projectDirection(S,this._worldUp,s,this._worldUp,n),d.projectDirection(S,this._worldTangent,s,this._worldTangent,n),c.length>2&&_.bestFitPlane(c,m),this.fittingMode=this._selectFittingMode(m,c,this._worldUp,h);let L=0;if("horizontal"===this.fittingMode){let e=-1/0;g.forEach(((t,s)=>{const i=a.getAltitude(g[s]);i>e&&(e=i,L=s)}))}const P=c[L];let M=m,R=this._worldTangent;"horizontal"===this.fittingMode?M=this._worldUp:"vertical"===this.fittingMode&&(M=this._tempVec3,R=this._worldUp,f.makeOrthonormal(m,this._worldUp,M)),r.copy(this._frame[2],M),f.makeOrthonormal(R,M,this._frame[0]),r.cross(this._frame[1],this._frame[0],this._frame[2]),r.negate(this._frame[1],this._frame[1]);const A=this._tempVec3,v=this._tempU,W=this._tempV;for(let i=0;i<this._length;++i){const e=p[i],t=u[i];r.subtract(A,c[i],P),o.set(e,r.dot(this._frame[0],A),r.dot(this._frame[1],A)),r.scale(v,this._frame[0],e[0]),r.scale(W,this._frame[1],e[1]),r.add(A,v,W),r.add(A,A,P),d.projectVectorToVector(A,n,t,s)}this.perimeterLength=this._length>0?i.createLength(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,C.midpoint(u,this.areaCentroidRenderCoords),d.projectVectorToVector(this.areaCentroidRenderCoords,s,this.areaCentroidWorldCoords,n),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?i.createArea(t.normalizeArea(this._computeArea()),"square-meters"):null},S._updateGeodesicArea=function(e){const{renderCoordsHelper:t,spatialReference:s}=e,{positionsSpherical:n,positionsStereographic:h}=this,a=this._tempVec3,d=_.fitHemisphere(n,a);if(!d)return void(this.geodesicArea=null);const g=this._tempU,l=this._tempV;f.tangentFrame(a,g,l);for(let i=0;i<this._length;++i){const e=r.dot(n[i],g),t=r.dot(n[i],l),s=r.dot(n[i],a);o.set(h[i],e/s,t/s)}r.scale(a,a,c.getReferenceEllipsoid(s).radius),t.toRenderCoords(a,c.getSphericalPCPF(s),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=d&&0===this.geodesicIntersectingSegments.size?i.createArea(this._computeGeodesicArea(),"square-meters"):null},S._updatePerimeterLengths=function(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=t[i]=o.distance(e[i],e[(i+1)%this._length])}return s},S._updateIntersectingSegments=function(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],n=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];p.segmentIntersects(o,n,r,h)&&(t.add(s),t.add(i))}},S._computeArea=function(){const e=this.positionsProjectedWorldCoords,t=this.triangleIndices=L.compactIndices(P.triangulate(e));let s=0;for(let i=0;i<t.length;i+=3)s+=u.areaPoints2d(e[t[i]],e[t[i+1]],e[t[i+2]]);return s},S._updateGeodesicIntersectingSegments=function(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],n=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];p.segmentIntersects(o,n,r,h)&&(t.add(s),t.add(i))}},S._computeGeodesicArea=function(){const e=this.positionsGeographic,t=this.positionsStereographic,s=this.geodesicTriangleIndices=L.compactIndices(P.triangulate(t));let i=0;for(let o=0;o<s.length;o+=3)i+=_.triangleAreaGeodesic(e[s[o]],e[s[o+1]],e[s[o+2]],g.WGS84);return i},S._selectFittingMode=function(e,s,i,o){const n=s.map((t=>Math.abs(_.planePointDistance(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);_.boundingSphere(s,this._tempSphere);const h=n/(2*this._tempSphere.radius),a=h<o.maxRelativeErrorCoplanar,d=h<o.maxRelativeErrorAlmostCoplanar;let c="horizontal";if(a)c="oblique";else if(d){c=Math.abs(r.dot(i,e))>Math.cos(t.deg2rad(o.verticalAngleThreshold))?"horizontal":"vertical"}return c},S._updateCursorSegmentLength=function(e,t){const o=e.lastPoint;!e.isValidPolygon&&s.isSome(o)&&s.isSome(t)?(this.geodesicCursorSegmentLength=i.createLength(_.segmentLengthGeodesic(o,t),"meters"),this.cursorSegmentLength=i.createLength(this.unitNormalizer.normalizeDistance(_.segmentLengthEuclidean(o,t,this.unitNormalizer.spatialReference)),"meters")):(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null)},S._updateMode=function(e,t){if(t===m.MeasurementMode.Auto){this.actualMeasurementMode="euclidean";let t=0;null!=this.geodesicPathLength&&(t+=this.geodesicPathLength.value),!e.isValidPolygon&&s.isSome(this.geodesicCursorSegmentLength)&&(t+=this.geodesicCursorSegmentLength.value),t>A&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=t===m.MeasurementMode.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=t},e}();function R(e,t){t.hasZ||(t.z=s.unwrapOr(S.getElevationAtPoint(e,t,"ground"),0))}const A=1e5;e.MeasurementDataManager=M,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
