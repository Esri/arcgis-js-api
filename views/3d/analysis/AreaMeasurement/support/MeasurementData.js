/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/mathUtils","../../../../../core/maybe","../../../../../core/Quantity","../../../../../chunks/earcut","../../../../../chunks/vec2","../../../../../chunks/vec2f64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../chunks/vec4f64","../../../../../geometry/projection","../../../../../geometry/projectionEllipsoid","../../../../../geometry/SpatialReference","../../../../../geometry/support/intersectsBase","../../support/measurementUtils","../../support/viewUtils","../../../support/ElevationProvider","../../../support/mathUtils"],(function(e,t,s,i,o,n,r,h,a,d,c,g,l,p,u,m,_,C){"use strict";let f=function(){function e(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=a.create(),this.areaCentroidRenderCoords=a.create(),this.geodesicAreaCentroidRenderCoords=a.create(),this._length=0,this._centroidRenderCoords=a.create(),this._planeWorldCoords=d.create(),this._worldUp=a.create(),this._worldTangent=a.create(),this._frame=[a.create(),a.create(),a.create()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=a.create(),this._tempV=a.create(),this._tempVec3=a.create(),this._tempSphere={center:a.create(),radius:0},this._sceneView=e,this.unitNormalizer=t}var _=e.prototype;return _.update=function(e,t,o,n,r,a,d){const l=this.unitNormalizer,p=this._sceneView.renderSpatialReference,u=this.unitNormalizer.spatialReference,m=s.isSome(t);if(this._pathVersion===e.version&&this._validMeasurement===n&&!d&&this._hasCursorPoint===m&&this._mode===a)return!1;this._pathVersion=e.version,this._validMeasurement=n,this._hasCursorPoint=m;const _=e.numVertices;this._resize(_);const C=g.getSphericalPCPF(o.spatialReference),f=c.canProjectWithoutEngine(o.spatialReference,C)&&c.canProjectToWGS84ComparableLonLat(o.spatialReference),S=this.positionsGeographic,P=this.positionsWorldCoords,R=this.positionsRenderCoords,M=this.positionsSpherical;e.forEachVertexPosition(((e,t)=>{L(o.elevationProvider,e),c.projectPointToVector(e,P[t],u),c.projectPointToVector(e,R[t],p),f&&(c.projectPointToWGS84ComparableLonLat(e,S[t]),c.projectPointToVector(e,M[t],C),h.normalize(M[t],M[t]))}));const w=this._updatePathLengths(n);if(this.pathLength=this._length>1?new i(l.normalizeDistance(w),"meters"):null,f){const e=this._updateGeodesicPathLengths(n,u);this.geodesicPathLength=this._length>1?new i(e,"meters"):null}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(e,t),this._updateMode(e,a),n?(this._updateArea(o,l,p,u,r),f&&this._updateGeodesicArea(o),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)},_.getData=function(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}},_._resize=function(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(a.create()),this.positionsRenderCoords.push(a.create()),this.positionsProjectedWorldCoords.push(r.create()),this.positionsFittedRenderCoords.push(a.create()),this.positionsGeographic.push(a.create()),this.positionsSpherical.push(a.create()),this.positionsStereographic.push(r.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length},_._updatePathLengths=function(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const n=s[o]=h.distance(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=n)}return i},_._updateGeodesicPathLengths=function(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let n=0;n<this._length;++n){const r=i[n]=u.segmentLengthGeodesicVector(s[n],s[(n+1)%this._length],t);(n<this._length-1||e)&&(o+=r)}return o},_._updateArea=function(e,t,s,o,r){const a=e.renderCoordsHelper,d=this.positionsWorldCoords,g=this.positionsRenderCoords,l=this.positionsProjectedWorldCoords,p=this.positionsFittedRenderCoords,_=this._planeWorldCoords,f=this._centroidRenderCoords;m.midpoint(g,f),a.worldUpAtPosition(f,this._worldUp),a.worldBasisAtPosition(f,0,this._worldTangent),c.projectDirection(f,this._worldUp,s,this._worldUp,o),c.projectDirection(f,this._worldTangent,s,this._worldTangent,o),d.length>2&&u.bestFitPlane(d,_),this.fittingMode=this._selectFittingMode(_,d,this._worldUp,r);let S=0;if("horizontal"===this.fittingMode){let e=-1/0;g.forEach(((t,s)=>{const i=a.getAltitude(g[s]);i>e&&(e=i,S=s)}))}const L=d[S];let P=_,R=this._worldTangent;"horizontal"===this.fittingMode?P=this._worldUp:"vertical"===this.fittingMode&&(P=this._tempVec3,R=this._worldUp,C.makeOrthonormal(_,this._worldUp,P)),h.copy(this._frame[2],P),C.makeOrthonormal(R,P,this._frame[0]),h.cross(this._frame[1],this._frame[0],this._frame[2]),h.negate(this._frame[1],this._frame[1]);const M=this._tempVec3,w=this._tempU,A=this._tempV;for(let i=0;i<this._length;++i){const e=l[i],t=p[i];h.subtract(M,d[i],L),n.set(e,h.dot(this._frame[0],M),h.dot(this._frame[1],M)),h.scale(w,this._frame[0],e[0]),h.scale(A,this._frame[1],e[1]),h.add(M,w,A),h.add(M,M,L),c.projectVectorToVector(M,o,t,s)}this.perimeterLength=this._length>0?new i(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,m.midpoint(p,this.areaCentroidRenderCoords),c.projectVectorToVector(this.areaCentroidRenderCoords,s,this.areaCentroidWorldCoords,o),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new i(t.normalizeArea(this._computeArea()),"square-meters"):null},_._updateGeodesicArea=function(e){const t=e.renderCoordsHelper,s=this.positionsSpherical,o=this.positionsStereographic,r=this._tempVec3,a=u.fitHemisphere(s,r);if(!a)return void(this.geodesicArea=null);const d=this._tempU,c=this._tempV;C.tangentFrame(r,d,c);for(let i=0;i<this._length;++i){const e=h.dot(s[i],d),t=h.dot(s[i],c),a=h.dot(s[i],r);n.set(o[i],e/a,t/a)}h.scale(r,r,g.getReferenceEllipsoid(e.spatialReference).radius),t.toRenderCoords(r,g.getSphericalPCPF(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=a&&0===this.geodesicIntersectingSegments.size?new i(this._computeGeodesicArea(),"square-meters"):null},_._updatePerimeterLengths=function(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=t[i]=n.distance(e[i],e[(i+1)%this._length])}return s},_._updateIntersectingSegments=function(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],n=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];p.segmentIntersects(o,n,r,h)&&(t.add(s),t.add(i))}},_._computeArea=function(){const e=this.positionsProjectedWorldCoords,t=S(e,2),s=this.triangleIndices=new Uint32Array(o.earcut(t,[],2));let i=0;for(let o=0;o<s.length;o+=3)i+=u.triangleAreaEuclidean(e[s[o]],e[s[o+1]],e[s[o+2]]);return i},_._updateGeodesicIntersectingSegments=function(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],n=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];p.segmentIntersects(o,n,r,h)&&(t.add(s),t.add(i))}},_._computeGeodesicArea=function(){const e=this.positionsGeographic,t=S(this.positionsStereographic,2),s=this.geodesicTriangleIndices=new Uint32Array(o.earcut(t,[],2));let i=0;for(let o=0;o<s.length;o+=3)i+=u.triangleAreaGeodesic(e[s[o]],e[s[o+1]],e[s[o+2]],l.WGS84);return i},_._selectFittingMode=function(e,s,i,o){const n=s.map((t=>Math.abs(u.planePointDistance(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);u.boundingSphere(s,this._tempSphere);const r=n/(2*this._tempSphere.radius),a=r<o.maxRelativeErrorCoplanar,d=r<o.maxRelativeErrorAlmostCoplanar;let c="horizontal";if(a)c="oblique";else if(d){c=Math.abs(h.dot(i,e))>Math.cos(t.deg2rad(o.verticalAngleThreshold))?"horizontal":"vertical"}return c},_._updateCursorSegmentLength=function(e,t){const o=e.lastPoint;!e.isValidPolygon&&s.isSome(o)&&s.isSome(t)?(this.geodesicCursorSegmentLength=new i(u.segmentLengthGeodesic(o,t),"meters"),this.cursorSegmentLength=new i(this.unitNormalizer.normalizeDistance(u.segmentLengthEuclidean(o,t,this.unitNormalizer.spatialReference)),"meters")):(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null)},_._updateMode=function(e,t){if(0===t){this.actualMeasurementMode="euclidean";let t=0;null!=this.geodesicPathLength&&(t+=this.geodesicPathLength.value),!e.isValidPolygon&&s.isSome(this.geodesicCursorSegmentLength)&&(t+=this.geodesicCursorSegmentLength.value),t>P&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=1===t?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=t},e}();function S(e,t){const s=new Float64Array(e.length*t);for(let i=0;i<e.length;++i){const o=e[i];for(let e=0;e<t;++e)s[i*t+e]=o[e]}return s}function L(e,t){t.hasZ||(t.z=s.unwrapOr(_.getElevationAtPoint(e,t,"ground"),0))}const P=1e5;e.MeasurementDataManager=f,Object.defineProperty(e,"__esModule",{value:!0})}));
