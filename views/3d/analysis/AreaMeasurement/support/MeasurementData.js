/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/mathUtils","../../../../../core/maybe","../../../../../core/quantityUtils","../../../../../chunks/earcut","../../../../../chunks/vec2","../../../../../chunks/vec2f64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../chunks/vec4f64","../../../../../geometry/projection","../../../../../geometry/projectionEllipsoid","../../../../../geometry/SpatialReference","../../../../../geometry/support/Axis","../../../../../geometry/support/intersectsBase","../../interfaces","../../support/measurementUtils","../../support/viewUtils","../../../support/ElevationProvider","../../../support/mathUtils"],(function(e,t,s,i,o,n,r,h,a,c,d,g,l,p,u,m,_,f,C,S){"use strict";let L=function(){function e(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=a.create(),this.areaCentroidRenderCoords=a.create(),this.geodesicAreaCentroidRenderCoords=a.create(),this._length=0,this._centroidRenderCoords=a.create(),this._planeWorldCoords=c.create(),this._worldUp=a.create(),this._worldTangent=a.create(),this._frame=[a.create(),a.create(),a.create()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=a.create(),this._tempV=a.create(),this._tempVec3=a.create(),this._tempSphere={center:a.create(),radius:0},this._sceneView=e,this.unitNormalizer=t}var C=e.prototype;return C.update=function(e,t,o,n,r,a,c){const l=this.unitNormalizer,p=this._sceneView.renderSpatialReference,u=this.unitNormalizer.spatialReference,m=s.isSome(t);if(this._pathVersion===e.version&&this._validMeasurement===n&&!c&&this._hasCursorPoint===m&&this._mode===a)return!1;this._pathVersion=e.version,this._validMeasurement=n,this._hasCursorPoint=m;const _=e.numVertices;this._resize(_);const f=g.getSphericalPCPF(o.spatialReference),C=d.canProjectWithoutEngine(o.spatialReference,f)&&d.canProjectToWGS84ComparableLonLat(o.spatialReference),S=this.positionsGeographic,L=this.positionsWorldCoords,P=this.positionsRenderCoords,R=this.positionsSpherical;e.forEachVertexPosition(((e,t)=>{M(o.elevationProvider,e),d.projectPointToVector(e,L[t],u),d.projectPointToVector(e,P[t],p),C&&(d.projectPointToWGS84ComparableLonLat(e,S[t]),d.projectPointToVector(e,R[t],f),h.normalize(R[t],R[t]))}));const A=this._updatePathLengths(n);if(this.pathLength=this._length>1?i.createLength(l.normalizeDistance(A),"meters"):null,C){const e=this._updateGeodesicPathLengths(n,u);this.geodesicPathLength=this._length>1?i.createLength(e,"meters"):null}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(e,t),this._updateMode(e,a),n?(this._updateArea(o,l,p,u,r),C&&this._updateGeodesicArea(o),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)},C.getData=function(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}},C._resize=function(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(a.create()),this.positionsRenderCoords.push(a.create()),this.positionsProjectedWorldCoords.push(r.create()),this.positionsFittedRenderCoords.push(a.create()),this.positionsGeographic.push(a.create()),this.positionsSpherical.push(a.create()),this.positionsStereographic.push(r.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length},C._updatePathLengths=function(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const n=s[o]=h.distance(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=n)}return i},C._updateGeodesicPathLengths=function(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let n=0;n<this._length;++n){const r=i[n]=_.segmentLengthGeodesicVector(s[n],s[(n+1)%this._length],t);(n<this._length-1||e)&&(o+=r)}return o},C._updateArea=function(e,t,s,o,r){const a=e.renderCoordsHelper,c=this.positionsWorldCoords,g=this.positionsRenderCoords,l=this.positionsProjectedWorldCoords,u=this.positionsFittedRenderCoords,m=this._planeWorldCoords,C=this._centroidRenderCoords;f.midpoint(g,C),a.worldUpAtPosition(C,this._worldUp),a.worldBasisAtPosition(C,p.Axis.X,this._worldTangent),d.projectDirection(C,this._worldUp,s,this._worldUp,o),d.projectDirection(C,this._worldTangent,s,this._worldTangent,o),c.length>2&&_.bestFitPlane(c,m),this.fittingMode=this._selectFittingMode(m,c,this._worldUp,r);let L=0;if("horizontal"===this.fittingMode){let e=-1/0;g.forEach(((t,s)=>{const i=a.getAltitude(g[s]);i>e&&(e=i,L=s)}))}const P=c[L];let M=m,R=this._worldTangent;"horizontal"===this.fittingMode?M=this._worldUp:"vertical"===this.fittingMode&&(M=this._tempVec3,R=this._worldUp,S.makeOrthonormal(m,this._worldUp,M)),h.copy(this._frame[2],M),S.makeOrthonormal(R,M,this._frame[0]),h.cross(this._frame[1],this._frame[0],this._frame[2]),h.negate(this._frame[1],this._frame[1]);const A=this._tempVec3,v=this._tempU,W=this._tempV;for(let i=0;i<this._length;++i){const e=l[i],t=u[i];h.subtract(A,c[i],P),n.set(e,h.dot(this._frame[0],A),h.dot(this._frame[1],A)),h.scale(v,this._frame[0],e[0]),h.scale(W,this._frame[1],e[1]),h.add(A,v,W),h.add(A,A,P),d.projectVectorToVector(A,o,t,s)}this.perimeterLength=this._length>0?i.createLength(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,f.midpoint(u,this.areaCentroidRenderCoords),d.projectVectorToVector(this.areaCentroidRenderCoords,s,this.areaCentroidWorldCoords,o),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?i.createArea(t.normalizeArea(this._computeArea()),"square-meters"):null},C._updateGeodesicArea=function(e){const t=e.renderCoordsHelper,s=this.positionsSpherical,o=this.positionsStereographic,r=this._tempVec3,a=_.fitHemisphere(s,r);if(!a)return void(this.geodesicArea=null);const c=this._tempU,d=this._tempV;S.tangentFrame(r,c,d);for(let i=0;i<this._length;++i){const e=h.dot(s[i],c),t=h.dot(s[i],d),a=h.dot(s[i],r);n.set(o[i],e/a,t/a)}h.scale(r,r,g.getReferenceEllipsoid(e.spatialReference).radius),t.toRenderCoords(r,g.getSphericalPCPF(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=a&&0===this.geodesicIntersectingSegments.size?i.createArea(this._computeGeodesicArea(),"square-meters"):null},C._updatePerimeterLengths=function(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=t[i]=n.distance(e[i],e[(i+1)%this._length])}return s},C._updateIntersectingSegments=function(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],n=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];u.segmentIntersects(o,n,r,h)&&(t.add(s),t.add(i))}},C._computeArea=function(){const e=this.positionsProjectedWorldCoords,t=P(e,2),s=this.triangleIndices=new Uint32Array(o.earcut(t,[],2));let i=0;for(let o=0;o<s.length;o+=3)i+=_.triangleAreaEuclidean(e[s[o]],e[s[o+1]],e[s[o+2]]);return i},C._updateGeodesicIntersectingSegments=function(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],n=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];u.segmentIntersects(o,n,r,h)&&(t.add(s),t.add(i))}},C._computeGeodesicArea=function(){const e=this.positionsGeographic,t=P(this.positionsStereographic,2),s=this.geodesicTriangleIndices=new Uint32Array(o.earcut(t,[],2));let i=0;for(let o=0;o<s.length;o+=3)i+=_.triangleAreaGeodesic(e[s[o]],e[s[o+1]],e[s[o+2]],l.WGS84);return i},C._selectFittingMode=function(e,s,i,o){const n=s.map((t=>Math.abs(_.planePointDistance(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);_.boundingSphere(s,this._tempSphere);const r=n/(2*this._tempSphere.radius),a=r<o.maxRelativeErrorCoplanar,c=r<o.maxRelativeErrorAlmostCoplanar;let d="horizontal";if(a)d="oblique";else if(c){d=Math.abs(h.dot(i,e))>Math.cos(t.deg2rad(o.verticalAngleThreshold))?"horizontal":"vertical"}return d},C._updateCursorSegmentLength=function(e,t){const o=e.lastPoint;!e.isValidPolygon&&s.isSome(o)&&s.isSome(t)?(this.geodesicCursorSegmentLength=i.createLength(_.segmentLengthGeodesic(o,t),"meters"),this.cursorSegmentLength=i.createLength(this.unitNormalizer.normalizeDistance(_.segmentLengthEuclidean(o,t,this.unitNormalizer.spatialReference)),"meters")):(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null)},C._updateMode=function(e,t){if(t===m.MeasurementMode.Auto){this.actualMeasurementMode="euclidean";let t=0;null!=this.geodesicPathLength&&(t+=this.geodesicPathLength.value),!e.isValidPolygon&&s.isSome(this.geodesicCursorSegmentLength)&&(t+=this.geodesicCursorSegmentLength.value),t>R&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=t===m.MeasurementMode.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=t},e}();function P(e,t){const s=new Float64Array(e.length*t);for(let i=0;i<e.length;++i){const o=e[i];for(let e=0;e<t;++e)s[i*t+e]=o[e]}return s}function M(e,t){t.hasZ||(t.z=s.unwrapOr(C.getElevationAtPoint(e,t,"ground"),0))}const R=1e5;e.MeasurementDataManager=L,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
