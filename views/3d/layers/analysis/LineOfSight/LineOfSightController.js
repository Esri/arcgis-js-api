/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/_rollupPluginBabelHelpers","../../../../../chunks/tslib.es6","../../../../../geometry","../../../../../core/Accessor","../../../../../core/Handles","../../../../../core/handleUtils","../../../../../core/maybe","../../../../../core/promiseUtils","../../../../../core/accessorSupport/decorators/property","../../../../../core/has","../../../../../core/accessorSupport/ensureType","../../../../../core/Logger","../../../../../core/accessorSupport/decorators/subclass","../../../../../core/accessorSupport/trackingUtils","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../geometry/support/ray","./LineOfSightAnalysis","./LineOfSightResult","../../../webgl-engine/lib/Intersector","../../../webgl-engine/lib/intersectorUtilsConversions","../../../../support/Scheduler","../../../../../geometry/Point"],(function(e,t,n,s,i,r,o,a,c,l,u,d,h,y,p,_,g,f,v,b,m,T,O,C){"use strict";e.LineOfSightController=function(e){function n(t){var n;return(n=e.call(this,t)||this)._tasks=O.ImmediateTask,n._handles=new r,n._analysisHandles=new r,n}t._inheritsLoose(n,e);var s=n.prototype;return s.initialize=function(){var e;const t=null==(e=this.view.resourceController)?void 0:e.scheduler;t&&(this._tasks=t.registerTask(O.TaskPriority.LINE_OF_SIGHT_TOOL));this._handles.add([p.reactionInit((()=>this.layer.observer),(e=>this._onObserverChange(e))),this._connectAnalyses(),this._connectTargets()]),this._intersector=new m.Intersector(this.view.state.viewingMode),this._intersector.options.hud=!1,this._intersector.options.store=0},s.destroy=function(){this._handles.destroy(),this._analysisHandles.destroy(),this._analyses.removeAll()},s.getLineOfSightComputationDependencies=function(e){const{inputPoints:t}=e;return{inputPoints:t}},s.computeAnalysis=function(e,t=!1){const{analysis:n}=e,{inputPoints:s,computationResult:i}=n,{observerAdjusted:r,targetAdjusted:o}=s,{start:a,end:c}=i;_.copy(a,r),_.copy(c,o);t||this._canComputeAnalysis(n)?this._computeAnalysisIntersection(e):this._interpolateAnalysisIntersection(e),n.updateComputationResults()},s._adjustStartEndPositions=function(e){const t=this._screenPixelSize,n=this.view,{inputPoints:s}=e,{observer:i,target:r,observerAdjusted:o,targetAdjusted:a}=s,c=A;_.subtract(c,r,i);const l=t;_.normalize(c,c),_.scale(c,c,Math.min(l,1)),_.add(o,i,c),_.subtract(c,i,r);const u=n.state.camera.computeScreenPixelSizeAt(r);_.normalize(c,c),_.scale(c,c,Math.min(u,1)),_.add(a,r,c)},s._computeAnalysisIntersection=function({analysis:e,interpolationInfo:t}){const{view:n}=this,{sceneIntersectionHelper:s,renderCoordsHelper:i}=n;if(a.isNone(s))return;const r=this._intersector,{computationResult:o,inputPoints:c}=e,{observer:l,target:u}=c,{start:d,end:h}=o,y=f.fromPoints(d,h,L);s.intersectToolIntersectorRay(y,r);const p=o.intersection,g=A,v=!!r.results.min&&r.results.min.getIntersectionPoint(p);let m=!0;if(v){_.copy(t.originalIntersection,p),_.copy(t.originalObserver,d),_.copy(t.originalTarget,h),i.fromRenderCoords(p,g,n.spatialReference);const e=1-_.dist(h,u)/_.dist(d,u);m=_.dist(l,p)>=e*_.dist(l,u)}const O=new C(g,n.spatialReference);e.result=new b.LineOfSightResult({target:e.target,intersectedGraphic:m?null:T.toGraphic(r.results.min,n),intersectedLocation:m?null:O,visible:!!v&&m}),o.isValid=c.isValid=!0,o.isTargetVisible=m},s._interpolateAnalysisIntersection=function({analysis:e,interpolationInfo:t}){const{computationResult:n,inputPoints:s}=e,{start:i,end:r,intersection:o}=n,{originalIntersection:a,originalObserver:c,originalTarget:l}=t;if(_.copy(o,a),s.isValid){const e=A,t=_.dist(c,a)/_.dist(c,l);_.sub(e,i,c),_.scale(e,e,1-t),_.add(o,o,e),_.sub(e,r,l),_.scale(e,e,t),_.add(o,o,e),n.isValid=!0}else e.result=null,n.isValid=!1,n.isTargetVisible=!1},s._canComputeAnalysis=function(e){const t=this.layer.observer,n=this.view.frustum;if(a.isNone(t)||a.isNone(e.target)||a.isNone(n))return!1;const{observerAdjusted:s,targetAdjusted:i}=e.inputPoints,r=n.intersectsPoint(s),o=n.intersectsPoint(i);return r&&o},s._onObserverChange=function(e){if(a.isNone(e))return void this.layer.targets.removeAll();const t=g.create();this.view.renderCoordsHelper.toRenderCoords(e,t),this._observerEngineLocation=t,this.priority=O.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},s._onObserverChangeForAnalysis=function(e){e.inputPoints.isValid=!1},s._onObserverEngineForAnalysis=function(e,t){const{inputPoints:n}=e;_.copy(n.observer,t),this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=O.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},s._onTargetLocationChange=function(e,t){const{inputPoints:n}=e;n.isValid=!1,this.view.renderCoordsHelper.toRenderCoords(t,n.target),this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=O.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},s._connectAnalysisToTarget=function(e){return p.reactionInit((()=>({analysis:e,target:e.target})),(({analysis:e,target:t})=>{a.isSome(t)&&this._onTargetLocationChange(e,t)}))},s._connectAnalysisToObserver=function(e){return p.reactionInit((()=>({analysis:e,observer:this.layer.observer})),(({analysis:e})=>{this._onObserverChangeForAnalysis(e)}))},s._connectAnalysisToObserverEngine=function(e){return p.reactionInit((()=>({analysis:e,observer:this._observerEngineLocation})),(({analysis:e,observer:t})=>{this._onObserverEngineForAnalysis(e,t)}))},s._connectAnalysisForCompute=function(e){var n=this;let s=a.none;const i={analysis:e,interpolationInfo:{originalIntersection:g.create(),originalObserver:g.create(),originalTarget:g.create()}};return o.handlesGroup([p.reactionInit((()=>this.getLineOfSightComputationDependencies(e)),(()=>{s=a.abortMaybe(s),s=c.createTask(function(){var e=t._asyncToGenerator((function*(e){yield c.ignoreAbortErrors(n._tasks.schedule((()=>n.computeAnalysis(i)),e))}));return function(t){return e.apply(this,arguments)}}())})),o.makeHandle((()=>s=a.abortMaybe(s)))])},s._connectAnalysis=function(e){const t=this._analysisHandles;t.has(e)||t.add([this._connectAnalysisToTarget(e),this._connectAnalysisToObserver(e),this._connectAnalysisToObserverEngine(e),this._connectAnalysisForCompute(e)])},s._disconnectAnalysis=function(e){this._analysisHandles.remove(e)},s._onAnalysesCollectionChange=function(e){e.added.forEach((e=>this._connectAnalysis(e))),e.removed.forEach((e=>this._disconnectAnalysis(e)))},s._onTargetsChange=function(e){return this._analyses.removeAll(),e.items.length>0&&e.forEach((e=>this._addTarget(e))),e.on("change",(e=>this._onTargetCollectionChange(e)))},s._onTargetCollectionChange=function(e){e.added.forEach((e=>this._addTarget(e))),e.removed.forEach((e=>this._removeTarget(e)))},s._addTarget=function(e){const t=this._analyses;t.some((t=>t.target===e))||t.add(new v.LineOfSightAnalysis({target:e}))},s._removeTarget=function(e){const t=this._analyses,n=t.find((t=>t.target===e));t.remove(n)},s._connectAnalyses=function(){let e=null;return o.handlesGroup([p.reactionInit((()=>this._analyses),(t=>{e=a.removeMaybe(e),e=t.on("change",(e=>this._onAnalysesCollectionChange(e))),t.forEach((e=>this._connectAnalysis(e)))})),o.makeHandle((()=>e=a.removeMaybe(e)))])},s._connectTargets=function(){let e=null;return o.handlesGroup([p.reactionInit((()=>this.layer.targets),(t=>{e=a.removeMaybe(e),e=this._onTargetsChange(t)})),o.makeHandle((()=>e=a.removeMaybe(e)))])},t._createClass(n,[{key:"updating",get:function(){return this._tasks.updating}},{key:"priority",get:function(){return this._tasks.priority},set:function(e){this._tasks.priority=e}},{key:"_analyses",get:function(){return this.layerViewData.analyses}},{key:"_observerEngineLocation",get:function(){return this.layerViewData.observerEngineLocation},set:function(e){this.layerViewData.observerEngineLocation=e}},{key:"_screenPixelSize",get:function(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}}]),n}(i),n.__decorate([l.property({constructOnly:!0})],e.LineOfSightController.prototype,"layer",void 0),n.__decorate([l.property({constructOnly:!0})],e.LineOfSightController.prototype,"layerViewData",void 0),n.__decorate([l.property({constructOnly:!0})],e.LineOfSightController.prototype,"view",void 0),n.__decorate([l.property()],e.LineOfSightController.prototype,"updating",null),n.__decorate([l.property()],e.LineOfSightController.prototype,"priority",null),n.__decorate([l.property()],e.LineOfSightController.prototype,"_analyses",null),n.__decorate([l.property()],e.LineOfSightController.prototype,"_observerEngineLocation",null),n.__decorate([l.property()],e.LineOfSightController.prototype,"_screenPixelSize",null),n.__decorate([l.property()],e.LineOfSightController.prototype,"_tasks",void 0),e.LineOfSightController=n.__decorate([y.subclass("esri.views.3d.layers.analysis.LineOfSight.LineOfSightController")],e.LineOfSightController);const A=g.create(),L=f.create();Object.defineProperty(e,"__esModule",{value:!0})}));
