/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/mathUtils","../../../../../core/Quantity","../../../../../chunks/earcut","../../../../../chunks/vec2","../../../../../chunks/vec2f64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../chunks/vec4f64","../../../../../geometry/projection","../../../../../geometry/projectionEllipsoid","../../../../../geometry/SpatialReference","../../../../../geometry/support/intersectsBase","../support/measurementUtils","../support/viewUtils","../../../support/mathUtils"],(function(e,t,i,s,o,n,r,h,a,c,d,g,l,p,m,u){"use strict";let _=function(){function e(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=h.create(),this.areaCentroidRenderCoords=h.create(),this.geodesicAreaCentroidRenderCoords=h.create(),this._length=0,this._centroidRenderCoords=h.create(),this._planeWorldCoords=a.create(),this._worldUp=h.create(),this._worldTangent=h.create(),this._frame=[h.create(),h.create(),h.create()],this._pathVersion=-1,this._validMeasurement=!1,this._tempU=h.create(),this._tempV=h.create(),this._tempVec3=h.create(),this._tempSphere={center:h.create(),radius:0},this._sceneView=e,this.unitNormalizer=t}var _=e.prototype;return _.update=function(e,t,s,o){const n=this.unitNormalizer,h=this._sceneView.renderSpatialReference,a=this.unitNormalizer.spatialReference;if(this._pathVersion===e.version&&this._validMeasurement===s)return;this._pathVersion=e.version,this._validMeasurement=s;const g=e.numVertices;this._resize(g);const l=d.getSphericalPCPF(t.spatialReference),p=c.canProjectWithoutEngine(t.spatialReference,l)&&c.canProjectToWGS84ComparableLonLat(t.spatialReference),m=this.positionsGeographic,u=this.positionsWorldCoords,_=this.positionsRenderCoords,f=this.positionsSpherical;e.forEachVertexPosition(((e,t)=>{c.projectPointToVector(e,u[t],a),c.projectPointToVector(e,_[t],h),p&&(c.projectPointToWGS84ComparableLonLat(e,m[t]),c.projectPointToVector(e,f[t],l),r.normalize(f[t],f[t]))}));const C=this._updatePathLengths(s);if(this.pathLength=this._length>1?new i(n.normalizeDistance(C),"meters"):null,p){const e=this._updateGeodesicPathLengths(s,a);this.geodesicPathLength=this._length>1?new i(e,"meters"):null}else this.geodesicPathLength=null;if(!s)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),void this.geodesicIntersectingSegments.clear();this._updateArea(t,n,h,a,o),p&&this._updateGeodesicArea(t)},_.getData=function(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,unitNormalizer:this.unitNormalizer}},_._resize=function(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(h.create()),this.positionsRenderCoords.push(h.create()),this.positionsProjectedWorldCoords.push(n.create()),this.positionsFittedRenderCoords.push(h.create()),this.positionsGeographic.push(h.create()),this.positionsSpherical.push(h.create()),this.positionsStereographic.push(n.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length},_._updatePathLengths=function(e){const t=this.positionsWorldCoords,i=this.pathSegmentLengths;let s=0;for(let o=0;o<this._length;++o){const n=i[o]=r.distance(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(s+=n)}return s},_._updateGeodesicPathLengths=function(e,t){const i=this.positionsGeographic,s=this.geodesicPathSegmentLengths;let o=0;for(let n=0;n<this._length;++n){const r=s[n]=p.segmentLengthGeodesicVector(i[n],i[(n+1)%this._length],t);(n<this._length-1||e)&&(o+=r)}return o},_._updateArea=function(e,t,s,n,h){const a=e.renderCoordsHelper,d=this.positionsWorldCoords,g=this.positionsRenderCoords,l=this.positionsProjectedWorldCoords,_=this.positionsFittedRenderCoords,f=this._planeWorldCoords,C=this._centroidRenderCoords;m.midpoint(g,C),a.worldUpAtPosition(C,this._worldUp),a.worldBasisAtPosition(C,0,this._worldTangent),c.projectDirection(C,this._worldUp,s,this._worldUp,n),c.projectDirection(C,this._worldTangent,s,this._worldTangent,n),d.length>2&&p.bestFitPlane(d,f),this.fittingMode=this._selectFittingMode(f,d,this._worldUp,h);let S=0;if("horizontal"===this.fittingMode){let e=-1/0;g.forEach(((t,i)=>{const s=a.getAltitude(g[i]);s>e&&(e=s,S=i)}))}const P=d[S];let L=f,R=this._worldTangent;"horizontal"===this.fittingMode?L=this._worldUp:"vertical"===this.fittingMode&&(L=this._tempVec3,R=this._worldUp,u.makeOrthonormal(f,this._worldUp,L)),r.copy(this._frame[2],L),u.makeOrthonormal(R,L,this._frame[0]),r.cross(this._frame[1],this._frame[0],this._frame[2]),r.negate(this._frame[1],this._frame[1]);const w=this._tempVec3,A=this._tempU,W=this._tempV;for(let i=0;i<this._length;++i){const e=l[i],t=_[i];r.subtract(w,d[i],P),o.set(e,r.dot(this._frame[0],w),r.dot(this._frame[1],w)),r.scale(A,this._frame[0],e[0]),r.scale(W,this._frame[1],e[1]),r.add(w,A,W),r.add(w,w,P),c.projectVectorToVector(w,n,t,s)}this.perimeterLength=this._length>0?new i(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,m.midpoint(_,this.areaCentroidRenderCoords),c.projectVectorToVector(this.areaCentroidRenderCoords,s,this.areaCentroidWorldCoords,n),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new i(t.normalizeArea(this._computeArea()),"square-meters"):null},_._updateGeodesicArea=function(e){const t=e.renderCoordsHelper,s=this.positionsSpherical,n=this.positionsStereographic,h=this._tempVec3,a=p.fitHemisphere(s,h);if(!a)return void(this.geodesicArea=null);const c=this._tempU,g=this._tempV;u.tangentFrame(h,c,g);for(let i=0;i<this._length;++i){const e=r.dot(s[i],c),t=r.dot(s[i],g),a=r.dot(s[i],h);o.set(n[i],e/a,t/a)}r.scale(h,h,d.getReferenceEllipsoid(e.spatialReference).radius),t.toRenderCoords(h,d.getSphericalPCPF(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=a&&0===this.geodesicIntersectingSegments.size?new i(this._computeGeodesicArea(),"square-meters"):null},_._updatePerimeterLengths=function(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let i=0;for(let s=0;s<this._length;++s){i+=t[s]=o.distance(e[s],e[(s+1)%this._length])}return i},_._updateIntersectingSegments=function(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let i=0;i<this._length;++i)for(let s=i+2;s<this._length;++s){if((s+1)%this._length===i)continue;const o=e[i],n=e[(i+1)%this._length],r=e[s],h=e[(s+1)%this._length];l.segmentIntersects(o,n,r,h)&&(t.add(i),t.add(s))}},_._computeArea=function(){const e=this.positionsProjectedWorldCoords,t=f(e,2),i=this.triangleIndices=new Uint32Array(s.earcut(t,[],2));let o=0;for(let s=0;s<i.length;s+=3)o+=p.triangleAreaEuclidean(e[i[s]],e[i[s+1]],e[i[s+2]]);return o},_._updateGeodesicIntersectingSegments=function(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let i=0;i<this._length;++i)for(let s=i+2;s<this._length;++s){if((s+1)%this._length===i)continue;const o=e[i],n=e[(i+1)%this._length],r=e[s],h=e[(s+1)%this._length];l.segmentIntersects(o,n,r,h)&&(t.add(i),t.add(s))}},_._computeGeodesicArea=function(){const e=this.positionsGeographic,t=f(this.positionsStereographic,2),i=this.geodesicTriangleIndices=new Uint32Array(s.earcut(t,[],2));let o=0;for(let s=0;s<i.length;s+=3)o+=p.triangleAreaGeodesic(e[i[s]],e[i[s+1]],e[i[s+2]],g.WGS84);return o},_._selectFittingMode=function(e,i,s,o){const n=i.map((t=>Math.abs(p.planePointDistance(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);p.boundingSphere(i,this._tempSphere);const h=n/(2*this._tempSphere.radius),a=h<o.maxRelativeErrorCoplanar,c=h<o.maxRelativeErrorAlmostCoplanar;let d="horizontal";if(a)d="oblique";else if(c){d=Math.abs(r.dot(s,e))>Math.cos(t.deg2rad(o.verticalAngleThreshold))?"horizontal":"vertical"}return d},e}();function f(e,t){const i=new Float64Array(e.length*t);for(let s=0;s<e.length;++s){const o=e[s];for(let e=0;e<t;++e)i[s*t+e]=o[e]}return i}e.MeasurementDataManager=_,Object.defineProperty(e,"__esModule",{value:!0})}));
