/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{estimateAttributesObjectSize as r,estimateFixedArraySize as t,estimateNumberByteSize as i}from"../../../../core/byteSizeEstimations.js";import a from"../../../../core/Error.js";import{HandleOwner as o}from"../../../../core/HandleOwner.js";import{makeHandle as s}from"../../../../core/handleUtils.js";import n from"../../../../core/Logger.js";import{isSome as l,disposeMaybe as d,unwrap as p,isNone as m,applySome as u,mapSome as h}from"../../../../core/maybe.js";import{initial as c,sync as y,watch as _}from"../../../../core/reactiveUtils.js";import{pt2px as f}from"../../../../core/screenUtils.js";import{property as g}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as R}from"../../../../core/accessorSupport/decorators/subclass.js";import{c as F}from"../../../../chunks/vec3.js";import{c as b}from"../../../../chunks/vec3f64.js";import{projectPointToVector as w}from"../../../../geometry/projection.js";import{getResolutionForScale as v}from"../../../../geometry/support/scaleUtils.js";import{getObjectId as S}from"../../../../layers/graphics/dehydratedFeatures.js";import{convertFromPoint as P}from"../../../../layers/graphics/featureConversionUtils.js";import{OptimizedFeature as j}from"../../../../layers/graphics/OptimizedFeature.js";import T from"../../../../layers/graphics/OptimizedGeometry.js";import x from"../../../../layers/graphics/data/FeatureStore.js";import{isNumericField as G}from"../../../../layers/support/fieldUtils.js";import{generateGradient as M}from"../../../../renderers/support/heatmapUtils.js";import{DrapeSourceType as N}from"../interfaces.js";import{DRAPED_Z as O}from"../../terrain/OverlayRenderer.js";import{UpdatePolicy as E,PrimitiveType as H}from"../../webgl-engine/lib/basicInterfaces.js";import{DrapedHeatmapRenderer as I}from"../../webgl-engine/lib/DrapedHeatmapRenderer.js";import{Geometry as C}from"../../webgl-engine/lib/Geometry.js";import{ModelDirty as U}from"../../webgl-engine/lib/ModelDirtyTypes.js";import{RenderGeometry as W}from"../../webgl-engine/lib/RenderGeometry.js";import{VertexAttribute as L}from"../../webgl-engine/lib/VertexAttribute.js";import{HeatmapDensityMaterial as V}from"../../webgl-engine/materials/HeatmapDensityMaterial.js";const D=n.getLogger("esri.views.3d.layers.support.HeatmapFeatureProcessor"),A=112;let B=class extends o{constructor(e){super(e),this.type="heatmap",this.filterVisibility={filterChanged(){},dirty:!1},this.preferredUpdatePolicy=E.ASYNC,this.dataExtent=null,this.drapeSourceType=N.Features,this._renderGeometries=new Map,this._material=new V({}),this._materialWithField=new V({isAttributeDriven:!0}),this._fieldTotal=0,this._drapeSourceRenderer=null}initialize(){this._featureStore=new x({geometryType:"esriGeometryPoint",hasZ:this.hasZ,hasM:this.hasM});const{colorBufferFloat:e,textureFloat:r}=this._renderView.capabilities,{floatBufferBlendWorking:t}=this._renderView.renderingContext.driverTest;if(!r?.textureFloat)throw new a("heatmap:missing-texture-float","HeatmapRenderer requires WebGL2 or the WebGL1 extension OES_texture_float.");if(!e?.textureFloat)throw new a("heatmap:missing-color-buffer-float","HeatmapRenderer requires the WebGL2 extension EXT_color_buffer_float or the WebGL1 extension WEBGL_color_buffer_float.");if(!e?.floatBlend)throw new a("heatmap:missing-float-blend","HeatmapRenderer requires the WebGL extension EXT_float_blend.");if(!t)throw new a("heatmap:missing-float-blend","HeatmapRenderer requires the WebGL extension EXT_float_blend. This device claims support for it, but does not actually support it.");this._drapeSourceRenderer=this.view.basemapTerrain.overlayManager.registerDrapeSource(this,I,this._rendererParameters),this.updatingHandles.addOnCollectionChange((()=>this._loadedPointGraphics),(e=>this._onLoadedFeaturesChange(e)),c),this.updatingHandles.addWhen((()=>this._materialParameters),(e=>this._forEachMaterial((r=>r.setParameters(e)))),c),this.updatingHandles.add((()=>this._rendererParameters),(e=>this._drapeSourceRenderer.set(e))),this.updatingHandles.add((()=>this._heatmapRendererField),(()=>{this._recreate()}),y),this.updatingHandles.add((()=>({fieldName:this._heatmapRendererFieldName,numeric:this._heatmapRendererFieldIsNumeric})),(({fieldName:e,numeric:r})=>{if(l(e)&&r){let r=0;this._featureStore.forEach((t=>r+=t.attributes[e]??0)),this._fieldTotal=r}else this._fieldTotal=this._featureStore.numFeatures}),c),this.handles.add([_((()=>({fieldName:this._heatmapRendererFieldName,field:this._heatmapRendererField})),(({fieldName:e,field:r})=>{e&&!r&&D.warn(`Heatmap renderer field '${e}' for layer '${this.layer.title??this.layer.id}' not found`)})),_((()=>({field:this._heatmapRendererField,numeric:this._heatmapRendererFieldIsNumeric})),(({field:e,numeric:r})=>{l(e)&&!r&&D.warn(`Heatmap renderer field '${e.name}' for layer '${this.layer.title??this.layer.id}' does not contain numeric values and cannot be used to drive the heatmap density`)})),s((()=>this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this)))])}destroy(){this._renderGeometries.clear(),this._material=d(this._material),this._materialWithField=d(this._materialWithField),this._featureStore.clear(),this._featureStore=null}get layer(){return this.owner.layer}get featureStore(){return this._featureStore}get updating(){return this.updatingHandles.updating}get updatingRemaining(){return 0}get suspendInfo(){return{}}get legendEnabled(){return!0}get displayFeatureLimit(){const e=this.owner?.view?.resourceController?.memoryController?.memoryFactor??1,r=this.owner?.view?.qualitySettings,t=r?Math.ceil(r.heatmap.maxTotalNumberOfFeatures*e):0;return{minimumTotalNumberOfFeatures:0,maximumTotalNumberOfFeatures:t,maximumTotalNumberOfPrimitives:t*2,maximumNumberOfFeatures:t}}get hasZ(){return"hasZ"in this.layer&&this.layer.hasZ}get hasM(){return"hasM"in this.layer&&this.layer.hasM}get view(){return this.owner.view}get fullOpacity(){return this.owner.fullOpacity}get updatePolicy(){return this.owner.updatePolicy}get scaleVisibilitySuspended(){return!1}get usedMemory(){const e=this.usedMemoryPerFeature*this._featureStore.numFeatures,{R32F:r}=this._renderView?.capabilities?.colorBufferFloat,t=null!=r?1:4,i=4,a=Math.ceil(this._overlayRenderer?.overlays[0]?.resolution*this._densityMapPixelRatio)??0;return a*a*t*i+e+(l(this._heatmapRenderer)?f(Math.min(this._heatmapRenderer.radius,A)):0)*t*i}get usedMemoryPerFeature(){if(0===this._featureStore.numFeatures)return 0;let e=0;this._featureStore.forEach((t=>e+=r(t.attributes))),e/=this._featureStore.numFeatures;const a=i(),o=6;return o*t([0,0,0],a)+o*t([0,0],a)+(this._heatmapRendererFieldIsNumeric?o*a:0)+e}get unprocessedMemoryEstimate(){return 0}get performanceInfo(){return{core:{visible:this._featureStore.numFeatures,missing:0,pending:0},elevationUpdating:!1,visibilityFrustum:!0,visibilityScale:!0}}get _overlayRenderer(){return this.view.basemapTerrain.overlayManager.renderer}get _overlaySpatialReference(){return p(this._overlayRenderer.spatialReference)}get _rendererParameters(){return{...this._radiusParameter,...this._densityParameters,...this._colorRampParameter,...this._pixelRatioParameter}}get _materialParameters(){return{...this._radiusParameter,...this._resolutionForScaleParameter}}get _densityParameters(){const e=this._heatmapRenderer;if(m(e))return null;const{minDensity:r,maxDensity:t}=e;return{minDensity:r,maxDensity:t,fieldTotal:this._fieldTotal}}get _radiusParameter(){return u(this._heatmapRenderer,(({radius:e})=>({searchRadius:f(this._clampSearchRadius(e))})))}get _resolutionForScaleParameter(){return u(this._heatmapRenderer,(({referenceScale:e})=>({resolutionForScale:0===e?0:v(e,this.view.spatialReference)})))}get _colorRampParameter(){return u(this._heatmapRenderer,(e=>({colorRampData:M(e.colorStops)})))}get _pixelRatioParameter(){return{pixelRatio:this._densityMapPixelRatio}}get _densityMapPixelRatio(){const e=this.owner?.view?.resourceController?.memoryController?.memoryFactor??1;return(this.owner?.view?.qualitySettings.heatmap.pixelRatio??1)*Math.sqrt(e)}get _renderView(){return this.view._stage.renderView}get _featuresArePoints(){return"point"===this.layer.geometryType}get _loadedPointGraphics(){return this.owner.loadedGraphics}get _heatmapRenderer(){const e=this.layer.renderer;return"heatmap"===e?.type?e:null}get _heatmapRendererFieldName(){return u(this._heatmapRenderer,(e=>e.field))}get _heatmapRendererField(){return u(this._heatmapRendererFieldName,(e=>this.layer.fieldsIndex.get(e)))}get _heatmapRendererFieldIsNumeric(){const e=this._heatmapRendererField;return!m(e)&&G(e)}async whenGraphicBounds(){return null}computeAttachmentOrigin(){return null}highlight(){return q}maskOccludee(){return q}setObjectIdVisibility(){}async setup(){}_onLoadedFeaturesChange(e){if(!this._featuresArePoints)return;const{objectIdField:r}=this.layer;this._featureStore.removeManyById(e.removed.map((e=>S(e,r)))),this._featureStore.addMany(e.added.map((e=>new j(P(new T,e.geometry),e.attributes,u(e.centroid,(e=>P(new T,e))),S(e,r)))));const t=e.added,i=e.removed;this._fieldTotal+=this._computeFieldTotalChange(t,i);const a=h(i,(({uid:e})=>{const r=this._renderGeometries.get(e);return this._renderGeometries.delete(e),r})),o=t.map((e=>{const r=this._pointGraphicToRenderGeometry(e);return this._renderGeometries.set(e.uid,r),r}));a.length>0&&this._drapeSourceRenderer.removeGeometries(a,U.Geometry.REMOVE),o.length>0&&this._drapeSourceRenderer.addGeometries(o,U.Geometry.ADD),(o.length>0||a.length>0)&&this._renderView.requestRender()}_recreate(){if(!this._loadedPointGraphics)return;const e=this._loadedPointGraphics.toArray();this._onLoadedFeaturesChange({added:e,removed:e})}_pointGraphicToRenderGeometry(e){const r=this._heatmapRendererFieldName,t=l(r)?this._materialWithField:this._material,i=b();w(e.geometry,i,this._overlaySpatialReference),i[2]=O;const a=[[L.POSITION,{data:i,size:i.length}]],o=this._heatmapRendererFieldIsNumeric;l(r)&&a.push([L.FEATUREATTRIBUTE,{data:[o?e.attributes[r]??0:0],size:1}]);const s=new W(new C(a,null,H.Point),t,{layerUid:this.layer.uid,graphicUid:e.uid});return F(s.boundingSphere,i),s}_forEachMaterial(e){e(this._material),e(this._materialWithField)}_computeFieldTotalChange(e,r){if(m(this._heatmapRendererFieldName)||!this._heatmapRendererFieldIsNumeric)return e.length-r.length;const t=this._heatmapRendererFieldName,i=(e,r)=>e+(r.attributes[t]??0);return e.reduce(i,0)-r.reduce(i,0)}_clampSearchRadius(e){return e>A&&D.warnOnce(`SceneView supports a maximum radius of ${A} pt for HeatmapRenderer.`),Math.min(e,A)}};e([g()],B.prototype,"type",void 0),e([g({constructOnly:!0})],B.prototype,"owner",void 0),e([g()],B.prototype,"layer",null),e([g()],B.prototype,"featureStore",null),e([g()],B.prototype,"updating",null),e([g()],B.prototype,"updatingRemaining",null),e([g()],B.prototype,"suspendInfo",null),e([g()],B.prototype,"legendEnabled",null),e([g()],B.prototype,"filterVisibility",void 0),e([g()],B.prototype,"displayFeatureLimit",null),e([g()],B.prototype,"preferredUpdatePolicy",void 0),e([g()],B.prototype,"hasZ",null),e([g()],B.prototype,"hasM",null),e([g()],B.prototype,"dataExtent",void 0),e([g()],B.prototype,"view",null),e([g()],B.prototype,"fullOpacity",null),e([g()],B.prototype,"updatePolicy",null),e([g()],B.prototype,"drapeSourceType",void 0),e([g()],B.prototype,"_featureStore",void 0),e([g()],B.prototype,"_overlayRenderer",null),e([g()],B.prototype,"_overlaySpatialReference",null),e([g()],B.prototype,"_rendererParameters",null),e([g()],B.prototype,"_materialParameters",null),e([g()],B.prototype,"_densityParameters",null),e([g()],B.prototype,"_radiusParameter",null),e([g()],B.prototype,"_resolutionForScaleParameter",null),e([g()],B.prototype,"_colorRampParameter",null),e([g()],B.prototype,"_pixelRatioParameter",null),e([g()],B.prototype,"_densityMapPixelRatio",null),e([g()],B.prototype,"_renderGeometries",void 0),e([g()],B.prototype,"_material",void 0),e([g()],B.prototype,"_materialWithField",void 0),e([g()],B.prototype,"_renderView",null),e([g()],B.prototype,"_featuresArePoints",null),e([g()],B.prototype,"_loadedPointGraphics",null),e([g()],B.prototype,"_heatmapRenderer",null),e([g()],B.prototype,"_heatmapRendererFieldName",null),e([g()],B.prototype,"_heatmapRendererField",null),e([g()],B.prototype,"_heatmapRendererFieldIsNumeric",null),e([g()],B.prototype,"_fieldTotal",void 0),e([g()],B.prototype,"_drapeSourceRenderer",void 0),B=e([R("esri.views.3d.layers.support.HeatmapFeatureProcessor")],B);const q=s();export{B as HeatmapFeatureProcessor,A as MAX_RADIUS_PT};
