/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../chunks/vec3f64","../../../../chunks/vec3","../../../../chunks/mat4","../../../../geometry/projection","../../../../chunks/mat4f64","../../support/ElevationProvider","../../support/debugFlags","./graphicUtils","./elevationAlignmentUtils"],(function(e,t,n,a,o,s,r,i,l,c,u){"use strict";function E(e,t,n,a){const o=e.stageObject,r=n.spatialReference,c=o.geometryRecords,E=c.length,f="absolute-height"!==t.mode;let A=0;for(let m=0;m<E;m++){const e=c[m].geometry,E=c[m].getShaderTransformation();T[0]=E[12],T[1]=E[13],T[2]=E[14],e.invalidateBoundingInfo();const v=e.getMutableAttribute("position"),b=v.data,h=e.vertexAttributes.get("mapPos").data,S=v.size,_=b.length/S,R=new i.SamplePosition(h,r);let D=0,L=!1,P=0;for(let o=0;o<_;o++){g[0]=b[D],g[1]=b[D+1],g[2]=b[D+2];const e=u.evaluateElevationAlignmentAtPoint(R,n,t,a,f?I:null);if(f&&(P+=I.sampledElevation),l.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(b[D]=R.array[R.offset],b[D+1]=R.array[R.offset+1],b[D+2]=e,s.projectBuffer(b,r,D,b,a.spatialReference,D,1),b[D]-=T[0],b[D+1]-=T[1],b[D+2]-=T[2]):(p[0]=b[D]+T[0],p[1]=b[D+1]+T[1],p[2]=b[D+2]+T[2],a.setAltitude(e,p),b[D]=p[0]-T[0],b[D+1]=p[1]-T[1],b[D+2]=p[2]-T[2]),l.TESTS_DISABLE_UPDATE_THRESHOLDS)L=!0;else{const e=d/a.unitInMeters;(Math.abs(g[0]-b[D])>=e||Math.abs(g[1]-b[D+1])>=e||Math.abs(g[2]-b[D+2])>=e)&&(L=!0)}D+=S,R.offset+=3}A+=P/_,L&&o.geometryVertexAttrsUpdated(m)}return A/E}function f(e,t,n,r){const i=e.stageObject,E=t.centerPointInElevationSR;let f=0,m=0;if(i.metadata.usesVerticalDistanceToGround)f=u.evaluateElevationAlignmentAtPoint(E,n,t,r,I),c.updateVertexAttributeAuxpos1w(i,I.verticalDistanceToGround),m=I.sampledElevation;else{const e="absolute-height"!==t.mode;f=u.evaluateElevationAlignmentAtPoint(E,n,t,r,e?I:null),e&&(m=I.sampledElevation)}const T=o.copy(A,i.transformation),g=a.set(b,T[12],T[13],T[14]);l.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(p[0]=E.x,p[1]=E.y,p[2]=f,s.computeLinearTransformation(E.spatialReference,p,T,r.spatialReference)&&(i.transformation=T)):r.setAltitudeOfTransformation(f,T);const v=d/r.unitInMeters;return(Math.abs(T[12]-g[0])>=v||Math.abs(T[13]-g[1])>=v||Math.abs(T[14]-g[2])>=v)&&(i.transformation=T),m}const A=r.create();function m(e,n,o,r){const i=e.graphics3DSymbolLayer.lodRenderer;if(t.isNone(i))return 0;const c=n.centerPointInElevationSR;let E=0,f=0;const A="absolute-height"!==n.mode;E=u.evaluateElevationAlignmentAtPoint(c,o,n,r,A?I:null),A&&(f=I.sampledElevation);const m=i.instanceData,T=e.instanceIndex,g=v;m.getGlobalTransform(T,g);const h=a.set(b,g[12],g[13],g[14]);l.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(p[0]=c.x,p[1]=c.y,p[2]=E,s.computeLinearTransformation(c.spatialReference,p,g,r.spatialReference)&&m.setGlobalTransform(T,g)):r.setAltitudeOfTransformation(E,g);const S=d/r.unitInMeters;return(l.TESTS_DISABLE_UPDATE_THRESHOLDS||Math.abs(g[12]-h[0])>=S||Math.abs(g[13]-h[1])>=S||Math.abs(g[14]-h[2])>=S)&&m.setGlobalTransform(T,g),f}const d=.01,p=n.create(),T=n.create(),g=n.create(),v=r.create(),b=n.create(),I={verticalDistanceToGround:0,sampledElevation:0};e.perLodInstanceElevationAligner=m,e.perObjectElevationAligner=f,e.perVertexElevationAligner=E,Object.defineProperty(e,"__esModule",{value:!0})}));
