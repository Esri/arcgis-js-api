/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/projection","./elevationAlignmentUtils","./graphicUtils","../../support/debugFlags","../../support/ElevationProvider","../../webgl-engine/lib/VertexAttribute"],(function(e,t,n,a,o,r,i,s,l,c,u,f){"use strict";function d(e,t,n,a){const o=e.stageObject,r=o.geometryRecords;let i=0;for(const s of r){const{update:e,averageGeometrySampledElevation:r}=O(s,t,n,a);i+=r,e&&o.geometryVertexAttrsUpdated(s)}return i/r.length}function m(e,t,a,r){const u=e.stageObject,f=t.centerPointInElevationSR;let d=0;if(u.metadata.usesVerticalDistanceToGround)s.evaluateElevationInfoAtPoint(f,a,t,r,h),l.updateVertexAttributeAuxpos1w(u,h.verticalDistanceToGround),d=h.sampledElevation;else{s.evaluateElevationInfoAtPoint(f,a,t,r,h);"absolute-height"!==t.mode&&(d=h.sampledElevation)}const m=n.copy(g,u.transformation),p=o.set(E,m[12],m[13],m[14]);c.TESTS_DISABLE_OPTIMIZATIONS?(A[0]=f.x,A[1]=f.y,A[2]=h.z,i.computeTranslationToOriginAndRotation(f.spatialReference,A,m,r.spatialReference)&&(u.transformation=m)):r.setAltitudeOfTransformation(h.z,m);const v=b/r.unitInMeters;return(Math.abs(m[12]-p[0])>=v||Math.abs(m[13]-p[1])>=v||Math.abs(m[14]-p[2])>=v)&&(u.transformation=m),d}const g=a.create();function p(e,n,a,r){const l=e.graphics3DSymbolLayer.lodRenderer;if(t.isNone(l))return 0;const u=n.centerPointInElevationSR;s.evaluateElevationInfoAtPoint(u,a,n,r,h);const f="absolute-height"!==n.mode?h.sampledElevation:0,d=l.instanceData,m=e.instanceIndex,g=T;d.getGlobalTransform(m,g);const p=o.set(E,g[12],g[13],g[14]);c.TESTS_DISABLE_OPTIMIZATIONS?(A[0]=u.x,A[1]=u.y,A[2]=h.z,i.computeTranslationToOriginAndRotation(u.spatialReference,A,g,r.spatialReference)&&d.setGlobalTransform(m,g)):r.setAltitudeOfTransformation(h.z,g);const v=b/r.unitInMeters;return(c.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(g[12]-p[0])>=v||Math.abs(g[13]-p[1])>=v||Math.abs(g[14]-p[2])>=v)&&d.setGlobalTransform(m,g),f}function v(e,t,n,a){const o=e.stageObject,r=o.geometryRecords;if(0===r.length)return 0;let i=0,s=null,l=0,c=!1;for(const u of r){const e=u.geometry.vertexAttributes.get(f.VertexAttribute.POSITION);if(e!==s){const{update:o,averageGeometrySampledElevation:r}=O(u,t,n,a);l=r,s=e,c=o}c&&o.geometryVertexAttrsUpdated(u),i+=l}return i/r.length}const b=.01,A=r.create(),I=r.create(),S=r.create(),T=a.create(),E=r.create(),h=new s.SampleElevationInfo;function O(e,t,n,a){let o=!1;const r=n.spatialReference,l=e.geometry,d=e.getShaderTransformation(),m=t.requiresSampledElevationInfo;I[0]=d[12],I[1]=d[13],I[2]=d[14],l.invalidateBoundingInfo();const g=l.getMutableAttribute(f.VertexAttribute.POSITION),p=g.data,v=l.vertexAttributes.get(f.VertexAttribute.MAPPOS).data,T=g.size,E=p.length/T,O=new u.SamplePosition(v,r);let y=0,M=0;for(let u=0;u<E;u++){if(S[0]=p[y],S[1]=p[y+1],S[2]=p[y+2],s.evaluateElevationInfoAtPoint(O,n,t,a,h),m&&(M+=h.sampledElevation),c.TESTS_DISABLE_OPTIMIZATIONS)p[y]=O.array[O.offset],p[y+1]=O.array[O.offset+1],p[y+2]=h.z,i.projectBuffer(p,r,y,p,a.spatialReference,y,1),p[y]-=I[0],p[y+1]-=I[1],p[y+2]-=I[2],o=!0;else{A[0]=p[y]+I[0],A[1]=p[y+1]+I[1],A[2]=p[y+2]+I[2],a.setAltitude(A,h.z),p[y]=A[0]-I[0],p[y+1]=A[1]-I[1],p[y+2]=A[2]-I[2];const e=b/a.unitInMeters;(Math.abs(S[0]-p[y])>=e||Math.abs(S[1]-p[y+1])>=e||Math.abs(S[2]-p[y+2])>=e)&&(o=!0)}y+=T,O.offset+=3}return M/=E,{update:o,averageGeometrySampledElevation:M}}e.perLodInstanceElevationAligner=p,e.perObjectElevationAligner=m,e.perVertexElevationAligner=d,e.sharedGeometryElevationAligner=v,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
