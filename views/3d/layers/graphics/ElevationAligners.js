/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isNone as t}from"../../../../core/maybe.js";import{c as e}from"../../../../chunks/mat4.js";import{c as o}from"../../../../chunks/mat4f64.js";import{s as a}from"../../../../chunks/vec3.js";import{c as r}from"../../../../chunks/vec3f64.js";import{computeTranslationToOriginAndRotation as n,projectBuffer as s}from"../../../../geometry/projection.js";import{evaluateElevationInfoAtPoint as i,SampleElevationInfo as l}from"./elevationAlignmentUtils.js";import{updateVertexAttributeAuxpos1w as c}from"./graphicUtils.js";import m from"../../support/debugFlags.js";import{SamplePosition as f}from"../../support/ElevationProvider.js";import{VertexAttribute as u}from"../../webgl-engine/lib/VertexAttribute.js";function p(t,e,o,a){const r=t.stageObject,n=r.geometryRecords;let s=0;for(const i of n){const{update:t,averageGeometrySampledElevation:n}=O(i,e,o,a);s+=n,t&&r.geometryVertexAttrsUpdated(i)}return s/n.length}function d(t,o,r,s){const l=t.stageObject,f=o.centerPointInElevationSR;let u=0;if(l.metadata.usesVerticalDistanceToGround)i(f,r,o,s,M),c(l,M.verticalDistanceToGround),u=M.sampledElevation;else{i(f,r,o,s,M);"absolute-height"!==o.mode&&(u=M.sampledElevation)}const p=e(g,l.transformation),d=a(E,p[12],p[13],p[14]);m.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=f.x,T[1]=f.y,T[2]=M.z,n(f.spatialReference,T,p,s.spatialReference)&&(l.transformation=p)):s.setAltitudeOfTransformation(M.z,p);const I=S/s.unitInMeters;return(Math.abs(p[12]-d[0])>=I||Math.abs(p[13]-d[1])>=I||Math.abs(p[14]-d[2])>=I)&&(l.transformation=p),u}const g=o();function I(e,o,r,s){const l=e.graphics3DSymbolLayer.lodRenderer;if(t(l))return 0;const c=o.centerPointInElevationSR;i(c,r,o,s,M);const f="absolute-height"!==o.mode?M.sampledElevation:0,u=l.instanceData,p=e.instanceIndex,d=A;u.getGlobalTransform(p,d);const g=a(E,d[12],d[13],d[14]);m.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=c.x,T[1]=c.y,T[2]=M.z,n(c.spatialReference,T,d,s.spatialReference)&&u.setGlobalTransform(p,d)):s.setAltitudeOfTransformation(M.z,d);const I=S/s.unitInMeters;return(m.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(d[12]-g[0])>=I||Math.abs(d[13]-g[1])>=I||Math.abs(d[14]-g[2])>=I)&&u.setGlobalTransform(p,d),f}function b(t,e,o,a){const r=t.stageObject,n=r.geometryRecords;if(0===n.length)return 0;let s=0,i=null,l=0,c=!1;for(const m of n){const t=m.geometry.vertexAttributes.get(u.POSITION);if(t!==i){const{update:r,averageGeometrySampledElevation:n}=O(m,e,o,a);l=n,i=t,c=r}c&&r.geometryVertexAttrsUpdated(m),s+=l}return s/n.length}const S=.01,T=r(),h=r(),v=r(),A=o(),E=r(),M=new l;function O(t,e,o,a){let r=!1;const n=o.spatialReference,l=t.geometry,c=t.getShaderTransformation(),p=e.requiresSampledElevationInfo;h[0]=c[12],h[1]=c[13],h[2]=c[14],l.invalidateBoundingInfo();const d=l.getMutableAttribute(u.POSITION),g=d.data,I=l.vertexAttributes.get(u.MAPPOS).data,b=d.size,A=g.length/b,E=new f(I,n);let O=0,y=0;for(let f=0;f<A;f++){if(v[0]=g[O],v[1]=g[O+1],v[2]=g[O+2],i(E,o,e,a,M),p&&(y+=M.sampledElevation),m.TESTS_DISABLE_OPTIMIZATIONS)g[O]=E.array[E.offset],g[O+1]=E.array[E.offset+1],g[O+2]=M.z,s(g,n,O,g,a.spatialReference,O,1),g[O]-=h[0],g[O+1]-=h[1],g[O+2]-=h[2],r=!0;else{T[0]=g[O]+h[0],T[1]=g[O+1]+h[1],T[2]=g[O+2]+h[2],a.setAltitude(T,M.z),g[O]=T[0]-h[0],g[O+1]=T[1]-h[1],g[O+2]=T[2]-h[2];const t=S/a.unitInMeters;(Math.abs(v[0]-g[O])>=t||Math.abs(v[1]-g[O+1])>=t||Math.abs(v[2]-g[O+2])>=t)&&(r=!0)}O+=b,E.offset+=3}return y/=A,{update:r,averageGeometrySampledElevation:y}}export{I as perLodInstanceElevationAligner,d as perObjectElevationAligner,p as perVertexElevationAligner,b as sharedGeometryElevationAligner};
