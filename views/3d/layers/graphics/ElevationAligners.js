/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/projection","./elevationAlignmentUtils","./graphicUtils","../../support/debugFlags","../../support/ElevationProvider","../../webgl-engine/lib/GeometryWithMapPositions","../../webgl-engine/lib/VertexAttribute"],(function(e,t,n,a,o,r,i,s,l,c,u,f,m){"use strict";function p(e,t,n,a,o){const r=e.stageObject,i=r.geometries;let s=0;for(const l of i){if(!f.isGeometryWithMapPositions(l))continue;const{update:e,averageGeometrySampledElevation:i}=O(l,t,n,a,o);s+=i,e&&r.geometryVertexAttrsUpdated(l)}return s/i.length}function d(e,t,a,r,s){const u=e.stageObject,f=t.centerPointInElevationSR;let m=0;if(u.metadata?.usesVerticalDistanceToGround)r(f,M),l.updateVertexAttributeAuxpos1w(u,M.verticalDistanceToGround),m=M.sampledElevation;else{r(f,M);"absolute-height"!==t.mode&&(m=M.sampledElevation)}const p=n.copy(g,u.transformation),d=o.set(E,p[12],p[13],p[14]);c.TESTS_DISABLE_OPTIMIZATIONS?(S[0]=f.x,S[1]=f.y,S[2]=M.z,i.computeTranslationToOriginAndRotation(f.spatialReference,S,p,s.spatialReference)&&(u.transformation=p)):s.setAltitudeOfTransformation(M.z,p);const b=I/s.unitInMeters;return(Math.abs(p[12]-d[0])>=b||Math.abs(p[13]-d[1])>=b||Math.abs(p[14]-d[2])>=b)&&(u.transformation=p),m}const g=a.create();function b(e,n,a,r,s){const l=e.graphics3DSymbolLayer.lodRenderer;if(t.isNone(l))return 0;const u=n.centerPointInElevationSR;r(u,M);const f="absolute-height"!==n.mode?M.sampledElevation:0,m=l.instanceData,p=e.instanceIndex,d=A;m.getGlobalTransform(p,d);const g=o.set(E,d[12],d[13],d[14]);c.TESTS_DISABLE_OPTIMIZATIONS?(S[0]=u.x,S[1]=u.y,S[2]=M.z,i.computeTranslationToOriginAndRotation(u.spatialReference,S,d,s.spatialReference)&&m.setGlobalTransform(p,d)):s.setAltitudeOfTransformation(M.z,d);const b=I/s.unitInMeters;return(c.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(d[12]-g[0])>=b||Math.abs(d[13]-g[1])>=b||Math.abs(d[14]-g[2])>=b)&&m.setGlobalTransform(p,d),f}function T(e,t,n,a,o){const r=e.stageObject,i=r.geometries;if(0===i.length)return 0;let s=0,l=null,c=0,u=!1;for(const p of i){if(!f.isGeometryWithMapPositions(p))continue;const e=p.vertexAttributes.get(m.VertexAttribute.POSITION);if(e!==l){const{update:r,averageGeometrySampledElevation:i}=O(p,t,n,a,o);c=i,l=e,u=r}u&&r.geometryVertexAttrsUpdated(p),s+=c}return s/i.length}const I=.01,S=r.create(),h=r.create(),v=r.create(),A=a.create(),E=r.create(),M=new s.SampleElevationInfo;function O(e,t,n,a,o){let r=!1;const s=e.shaderTransformation,l=t.requiresSampledElevationInfo;h[0]=s[12],h[1]=s[13],h[2]=s[14],e.invalidateBoundingInfo();const f=e.getMutableAttribute(m.VertexAttribute.POSITION),p=f.data,d=f.size,g=p.length/d,b=new u.SamplePosition(e.mapPositions,n);let T=0,A=0;for(let u=0;u<g;u++){if(v[0]=p[T],v[1]=p[T+1],v[2]=p[T+2],a(b,M),l&&(A+=M.sampledElevation),c.TESTS_DISABLE_OPTIMIZATIONS)p[T]=b.array[b.offset],p[T+1]=b.array[b.offset+1],p[T+2]=M.z,i.projectBuffer(p,n,T,p,o.spatialReference,T,1),p[T]-=h[0],p[T+1]-=h[1],p[T+2]-=h[2],r=!0;else{S[0]=p[T]+h[0],S[1]=p[T+1]+h[1],S[2]=p[T+2]+h[2],o.setAltitude(S,M.z),p[T]=S[0]-h[0],p[T+1]=S[1]-h[1],p[T+2]=S[2]-h[2];const e=I/o.unitInMeters;(Math.abs(v[0]-p[T])>=e||Math.abs(v[1]-p[T+1])>=e||Math.abs(v[2]-p[T+2])>=e)&&(r=!0)}T+=d,b.offset+=3}return A/=g,{update:r,averageGeometrySampledElevation:A}}e.perLodInstanceElevationAligner=b,e.perObjectElevationAligner=d,e.perVertexElevationAligner=p,e.sharedGeometryElevationAligner=T,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
