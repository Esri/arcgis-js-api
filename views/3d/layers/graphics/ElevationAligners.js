/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/projection","./elevationAlignmentUtils","./graphicUtils","../../support/debugFlags","../../support/ElevationProvider"],(function(e,t,n,a,o,s,r,i,l,c,u){"use strict";function E(e,t,n,a){const o=e.stageObject,s=n.spatialReference,l=o.geometryRecords,E=l.length,f="absolute-height"!==t.mode;let A=0;for(let m=0;m<E;m++){const e=l[m].geometry,E=l[m].getShaderTransformation();T[0]=E[12],T[1]=E[13],T[2]=E[14],e.invalidateBoundingInfo();const v=e.getMutableAttribute("position"),b=v.data,h=e.vertexAttributes.get("mapPos").data,S=v.size,_=b.length/S,R=new u.SamplePosition(h,s);let D=0,L=!1,P=0;for(let o=0;o<_;o++){g[0]=b[D],g[1]=b[D+1],g[2]=b[D+2];const e=i.evaluateElevationAlignmentAtPoint(R,n,t,a,f?I:null);if(f&&(P+=I.sampledElevation),c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(b[D]=R.array[R.offset],b[D+1]=R.array[R.offset+1],b[D+2]=e,r.projectBuffer(b,s,D,b,a.spatialReference,D,1),b[D]-=T[0],b[D+1]-=T[1],b[D+2]-=T[2]):(p[0]=b[D]+T[0],p[1]=b[D+1]+T[1],p[2]=b[D+2]+T[2],a.setAltitude(p,e),b[D]=p[0]-T[0],b[D+1]=p[1]-T[1],b[D+2]=p[2]-T[2]),c.TESTS_DISABLE_UPDATE_THRESHOLDS)L=!0;else{const e=d/a.unitInMeters;(Math.abs(g[0]-b[D])>=e||Math.abs(g[1]-b[D+1])>=e||Math.abs(g[2]-b[D+2])>=e)&&(L=!0)}D+=S,R.offset+=3}A+=P/_,L&&o.geometryVertexAttrsUpdated(m)}return A/E}function f(e,t,a,s){const u=e.stageObject,E=t.centerPointInElevationSR;let f=0,m=0;if(u.metadata.usesVerticalDistanceToGround)f=i.evaluateElevationAlignmentAtPoint(E,a,t,s,I),l.updateVertexAttributeAuxpos1w(u,I.verticalDistanceToGround),m=I.sampledElevation;else{const e="absolute-height"!==t.mode;f=i.evaluateElevationAlignmentAtPoint(E,a,t,s,e?I:null),e&&(m=I.sampledElevation)}const T=n.copy(A,u.transformation),g=o.set(b,T[12],T[13],T[14]);c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(p[0]=E.x,p[1]=E.y,p[2]=f,r.computeLinearTransformation(E.spatialReference,p,T,s.spatialReference)&&(u.transformation=T)):s.setAltitudeOfTransformation(f,T);const v=d/s.unitInMeters;return(Math.abs(T[12]-g[0])>=v||Math.abs(T[13]-g[1])>=v||Math.abs(T[14]-g[2])>=v)&&(u.transformation=T),m}const A=a.create();function m(e,n,a,s){const l=e.graphics3DSymbolLayer.lodRenderer;if(t.isNone(l))return 0;const u=n.centerPointInElevationSR;let E=0,f=0;const A="absolute-height"!==n.mode;E=i.evaluateElevationAlignmentAtPoint(u,a,n,s,A?I:null),A&&(f=I.sampledElevation);const m=l.instanceData,T=e.instanceIndex,g=v;m.getGlobalTransform(T,g);const h=o.set(b,g[12],g[13],g[14]);c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(p[0]=u.x,p[1]=u.y,p[2]=E,r.computeLinearTransformation(u.spatialReference,p,g,s.spatialReference)&&m.setGlobalTransform(T,g)):s.setAltitudeOfTransformation(E,g);const S=d/s.unitInMeters;return(c.TESTS_DISABLE_UPDATE_THRESHOLDS||Math.abs(g[12]-h[0])>=S||Math.abs(g[13]-h[1])>=S||Math.abs(g[14]-h[2])>=S)&&m.setGlobalTransform(T,g),f}const d=.01,p=s.create(),T=s.create(),g=s.create(),v=a.create(),b=s.create(),I={verticalDistanceToGround:0,sampledElevation:0};e.perLodInstanceElevationAligner=m,e.perObjectElevationAligner=f,e.perVertexElevationAligner=E,Object.defineProperty(e,"__esModule",{value:!0})}));
