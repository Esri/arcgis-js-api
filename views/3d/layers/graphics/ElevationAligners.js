/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/projection","./elevationAlignmentUtils","./graphicUtils","../../support/debugFlags","../../support/ElevationProvider"],(function(e,t,n,a,o,s,r,i,l,c,u){"use strict";function E(e,t,n,a){const o=e.stageObject,s=n.spatialReference,l=o.geometryRecords,E=l.length,A="absolute-height"!==t.mode;let f=0;for(let d=0;d<E;d++){const e=l[d].geometry,E=l[d].getShaderTransformation();T[0]=E[12],T[1]=E[13],T[2]=E[14],e.invalidateBoundingInfo();const v=e.getMutableAttribute("position"),b=v.data,h=e.vertexAttributes.get("mapPos").data,S=v.size,R=b.length/S,_=new u.SamplePosition(h,s);let D=0,L=!1,P=0;for(let o=0;o<R;o++){g[0]=b[D],g[1]=b[D+1],g[2]=b[D+2];const e=i.evaluateElevationAlignmentAtPoint(_,n,t,a,A?I:null);if(A&&(P+=I.sampledElevation),c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(b[D]=_.array[_.offset],b[D+1]=_.array[_.offset+1],b[D+2]=e,r.projectBuffer(b,s,D,b,a.spatialReference,D,1),b[D]-=T[0],b[D+1]-=T[1],b[D+2]-=T[2]):(p[0]=b[D]+T[0],p[1]=b[D+1]+T[1],p[2]=b[D+2]+T[2],a.setAltitude(p,e),b[D]=p[0]-T[0],b[D+1]=p[1]-T[1],b[D+2]=p[2]-T[2]),c.TESTS_DISABLE_UPDATE_THRESHOLDS)L=!0;else{const e=m/a.unitInMeters;(Math.abs(g[0]-b[D])>=e||Math.abs(g[1]-b[D+1])>=e||Math.abs(g[2]-b[D+2])>=e)&&(L=!0)}D+=S,_.offset+=3}f+=P/R,L&&o.geometryVertexAttrsUpdated(d)}return f/E}function A(e,t,a,s){const u=e.stageObject,E=t.centerPointInElevationSR;let A=0,d=0;if(u.metadata.usesVerticalDistanceToGround)A=i.evaluateElevationAlignmentAtPoint(E,a,t,s,I),l.updateVertexAttributeAuxpos1w(u,I.verticalDistanceToGround),d=I.sampledElevation;else{const e="absolute-height"!==t.mode;A=i.evaluateElevationAlignmentAtPoint(E,a,t,s,e?I:null),e&&(d=I.sampledElevation)}const T=n.copy(f,u.transformation),g=o.set(b,T[12],T[13],T[14]);c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(p[0]=E.x,p[1]=E.y,p[2]=A,r.computeTranslationToOriginAndRotation(E.spatialReference,p,T,s.spatialReference)&&(u.transformation=T)):s.setAltitudeOfTransformation(A,T);const v=m/s.unitInMeters;return(Math.abs(T[12]-g[0])>=v||Math.abs(T[13]-g[1])>=v||Math.abs(T[14]-g[2])>=v)&&(u.transformation=T),d}const f=a.create();function d(e,n,a,s){const l=e.graphics3DSymbolLayer.lodRenderer;if(t.isNone(l))return 0;const u=n.centerPointInElevationSR;let E=0,A=0;const f="absolute-height"!==n.mode;E=i.evaluateElevationAlignmentAtPoint(u,a,n,s,f?I:null),f&&(A=I.sampledElevation);const d=l.instanceData,T=e.instanceIndex,g=v;d.getGlobalTransform(T,g);const h=o.set(b,g[12],g[13],g[14]);c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(p[0]=u.x,p[1]=u.y,p[2]=E,r.computeTranslationToOriginAndRotation(u.spatialReference,p,g,s.spatialReference)&&d.setGlobalTransform(T,g)):s.setAltitudeOfTransformation(E,g);const S=m/s.unitInMeters;return(c.TESTS_DISABLE_UPDATE_THRESHOLDS||Math.abs(g[12]-h[0])>=S||Math.abs(g[13]-h[1])>=S||Math.abs(g[14]-h[2])>=S)&&d.setGlobalTransform(T,g),A}const m=.01,p=s.create(),T=s.create(),g=s.create(),v=a.create(),b=s.create(),I={verticalDistanceToGround:0,sampledElevation:0};e.perLodInstanceElevationAligner=d,e.perObjectElevationAligner=A,e.perVertexElevationAligner=E,Object.defineProperty(e,"__esModule",{value:!0})}));
