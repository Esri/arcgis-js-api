/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../request","../../../../core/asyncUtils","../../../../core/Error","../../../../core/Logger","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/Version","../../../../chunks/vec3f64","../../../../geometry/support/aaBoundingBox","../../../../support/requestImageUtils","../../webgl-engine/lib/Geometry","../../webgl-engine/lib/Texture","../../webgl-engine/materials/DefaultMaterial"],(function(e,t,r,n,a,s,o,i,u,l,c,p,f,d,m){"use strict";const y=s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");function x(e,t){return g.apply(this,arguments)}function g(){return(g=t._asyncToGenerator((function*(e,t){const r=yield h(e,t);return{resource:r,textures:yield I(r.textureDefinitions,t)}}))).apply(this,arguments)}function h(e,t){return b.apply(this,arguments)}function b(){return(b=t._asyncToGenerator((function*(e,t){const a=o.isSome(t)&&t.streamDataRequester;if(a)return v(e,a,t);const s=yield n.result(r(e,o.unwrap(t)));if(!0===s.ok)return s.value.data;i.throwIfAbortError(s.error),A(s.error)}))).apply(this,arguments)}function v(e,t,r){return w.apply(this,arguments)}function w(){return(w=t._asyncToGenerator((function*(e,t,r){const a=yield n.result(t.request(e,"json",r));if(!0===a.ok)return a.value;i.throwIfAbortError(a.error),A(a.error.details.url)}))).apply(this,arguments)}function A(e){throw new a("",`Request for object resource failed: ${e}`)}function T(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(y.warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t&&t.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(y.warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(y.warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(y.warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else y.warn("Indexed geometries must specify faces"),n=!1;break}default:y.warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(y.warn("Geometry requires material"),n=!1);const a=e.params.vertexAttributes;for(const s in a){a[s].values||(y.warn("Geometries with externally defined attributes are not yet supported"),n=!1)}return n}function M(e,t){const r=[],n=[],a=[],s=[],i=e.resource,c=u.Version.parse(i.version||"1.0","wosr");G.validate(c);const p=i.model.name,y=i.model.geometries,x=i.materialDefinitions,g=e.textures;let h=0;const b=new Map;for(let u=0;u<y.length;u++){const e=y[u];if(!T(e))continue;const i=E(e),c=e.params.vertexAttributes,p=[];for(const t in c){const e=c[t],r=e.values;p.push([t,{data:r,size:e.valuesPerElement,exclusive:!0}])}const v=[];if("PerAttributeArray"!==e.params.topology){const t=e.params.faces;for(const e in t)v.push([e,new Uint32Array(t[e].values)])}const w=g&&g[i.texture];if(w&&!b.has(i.texture)){const{image:e,params:t}=w,r=new d.Texture(e,t);s.push(r),b.set(i.texture,r)}const A=b.get(i.texture),M=A?A.id:void 0;let U=a[i.material]?a[i.material][i.texture]:null;if(!U){const e=x[i.material.substring(i.material.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=w&&w.alphaChannelUsage,n=e.transparency>0||"transparency"===r||"maskAndTransparency"===r,s=w?k(w.alphaChannelUsage):void 0,u={ambient:l.fromArray(e.diffuse),diffuse:l.fromArray(e.diffuse),opacity:1-(e.transparency||0),transparent:n,textureAlphaMode:s,textureAlphaCutoff:.33,textureId:M,initTextureTransparent:!0,doubleSided:!0,cullFace:0,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:!!w&&!!w.params.preMultiplyAlpha};o.isSome(t)&&t.materialParamsMixin&&Object.assign(u,t.materialParamsMixin),U=new m.DefaultMaterial(u),a[i.material]||(a[i.material]={}),a[i.material][i.texture]=U}n.push(U);const I=new f.Geometry(p,v);h+=v.position?v.position.length:0,r.push(I)}return{name:p,stageResources:{textures:s,materials:n,geometries:r},pivotOffset:i.model.pivotOffset,boundingBox:U(r),numberOfVertices:h,lodThreshold:null}}function U(e){const t=c.empty();return e.forEach((e=>{const r=e.boundingInfo;o.isSome(r)&&(c.expandWithVec3(t,r.getBBMin()),c.expandWithVec3(t,r.getBBMax()))})),t}function I(e,t){return P.apply(this,arguments)}function P(){return(P=t._asyncToGenerator((function*(e,t){const r=[];for(const s in e){const n=e[s],a=n.images[0].data;if(!a){y.warn("Externally referenced texture data is not yet supported");continue}const i=n.encoding+";base64,"+a,u="/textureDefinitions/"+s,l="rgba"===n.channels?n.alphaChannelUsage||"transparency":"none",c={noUnpackFlip:!0,wrap:{s:10497,t:10497},preMultiplyAlpha:1!==k(l)},f=o.isSome(t)&&t.disableTextures?Promise.resolve(null):p.requestImage(i,t);r.push(f.then((e=>({refId:u,image:e,params:c,alphaChannelUsage:l}))))}const n=yield Promise.all(r),a={};for(const s of n)a[s.refId]=s;return a}))).apply(this,arguments)}function k(e){switch(e){case"mask":return 2;case"maskAndTransparency":return 3;case"none":return 1;default:return 0}}function E(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const G=new u.Version(1,2,"wosr");e.createTextureResources=I,e.load=x,e.processLoadResult=M,Object.defineProperty(e,"__esModule",{value:!0})}));
