/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../request","../../../../core/asyncUtils","../../../../core/byteSizeEstimations","../../../../core/Error","../../../../core/Logger","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/Version","../../../../chunks/vec3f64","../../../../geometry/support/aaBoundingBox","../../../../support/requestImageUtils","../../webgl-engine/lib/basicInterfaces","../../webgl-engine/lib/Geometry","../../webgl-engine/lib/Texture","../../webgl-engine/materials/DefaultMaterial","../../../webgl/enums"],(function(e,t,r,n,a,s,o,i,u,l,c,p,d,f,m,y,g,h){"use strict";const x=o.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");function b(e,t){return v.apply(this,arguments)}function v(){return(v=t._asyncToGenerator((function*(e,t){const r=yield w(e,t),n=yield k(r.textureDefinitions,t);let s=0;for(const a in n)if(n.hasOwnProperty(a)){const e=n[a];s+=e?.image?e.image.width*e.image.height*4:0}return{resource:r,textures:n,size:s+a.estimateNestedObjectSize(r)}}))).apply(this,arguments)}function w(e,t){return A.apply(this,arguments)}function A(){return(A=t._asyncToGenerator((function*(e,t){const a=i.isSome(t)&&t.streamDataRequester;if(a)return M(e,a,t);const s=yield n.result(r(e,i.unwrap(t)));if(!0===s.ok)return s.value.data;u.throwIfAbortError(s.error),P(s.error)}))).apply(this,arguments)}function M(e,t,r){return T.apply(this,arguments)}function T(){return(T=t._asyncToGenerator((function*(e,t,r){const a=yield n.result(t.request(e,"json",r));if(!0===a.ok)return a.value;u.throwIfAbortError(a.error),P(a.error.details.url)}))).apply(this,arguments)}function P(e){throw new s("",`Request for object resource failed: ${e}`)}function I(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(x.warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t&&t.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(x.warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(x.warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(x.warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else x.warn("Indexed geometries must specify faces"),n=!1;break}default:x.warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(x.warn("Geometry requires material"),n=!1);const a=e.params.vertexAttributes;for(const s in a){a[s].values||(x.warn("Geometries with externally defined attributes are not yet supported"),n=!1)}return n}function E(e,t){const r=[],n=[],a=[],s=[],o=e.resource,u=l.Version.parse(o.version||"1.0","wosr");q.validate(u);const p=o.model.name,d=o.model.geometries,h=o.materialDefinitions,x=e.textures;let b=0;const v=new Map;for(let l=0;l<d.length;l++){const e=d[l];if(!I(e))continue;const o=O(e),u=e.params.vertexAttributes,p=[];for(const t in u){const e=u[t],r=e.values;p.push([t,{data:r,size:e.valuesPerElement,exclusive:!0}])}const w=[];if("PerAttributeArray"!==e.params.topology){const t=e.params.faces;for(const e in t)w.push([e,t[e].values])}const A=x&&x[o.texture];if(A&&!v.has(o.texture)){const{image:e,params:t}=A,r=new y.Texture(e,t);s.push(r),v.set(o.texture,r)}const M=v.get(o.texture),T=M?M.id:void 0;let P=a[o.material]?a[o.material][o.texture]:null;if(!P){const e=h[o.material.substring(o.material.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=A&&A.alphaChannelUsage,n=e.transparency>0||"transparency"===r||"maskAndTransparency"===r,s=A?D(A.alphaChannelUsage):void 0,u={ambient:c.fromArray(e.diffuse),diffuse:c.fromArray(e.diffuse),opacity:1-(e.transparency||0),transparent:n,textureAlphaMode:s,textureAlphaCutoff:.33,textureId:T,initTextureTransparent:!0,doubleSided:!0,cullFace:f.CullFaceOptions.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:!!A&&!!A.params.preMultiplyAlpha};i.isSome(t)&&t.materialParamsMixin&&Object.assign(u,t.materialParamsMixin),P=new g.DefaultMaterial(u),a[o.material]||(a[o.material]={}),a[o.material][o.texture]=P}n.push(P);const E=new m.Geometry(p,w);b+=w.position?w.position.length:0,r.push(E)}return{engineResources:[{name:p,stageResources:{textures:s,materials:n,geometries:r},pivotOffset:o.model.pivotOffset,numberOfVertices:b,lodThreshold:null}],referenceBoundingBox:U(r)}}function U(e){const t=p.empty();return e.forEach((e=>{const r=e.boundingInfo;i.isSome(r)&&(p.expandWithVec3(t,r.getBBMin()),p.expandWithVec3(t,r.getBBMax()))})),t}function k(e,t){return B.apply(this,arguments)}function B(){return(B=t._asyncToGenerator((function*(e,t){const r=[];for(const s in e){const n=e[s],a=n.images[0].data;if(!a){x.warn("Externally referenced texture data is not yet supported");continue}const o=n.encoding+";base64,"+a,u="/textureDefinitions/"+s,l="rgba"===n.channels?n.alphaChannelUsage||"transparency":"none",c={noUnpackFlip:!0,wrap:{s:h.TextureWrapMode.REPEAT,t:h.TextureWrapMode.REPEAT},preMultiplyAlpha:D(l)!==f.AlphaDiscardMode.Opaque},p=i.isSome(t)&&t.disableTextures?Promise.resolve(null):d.requestImage(o,t);r.push(p.then((e=>({refId:u,image:e,params:c,alphaChannelUsage:l}))))}const n=yield Promise.all(r),a={};for(const s of n)a[s.refId]=s;return a}))).apply(this,arguments)}function D(e){switch(e){case"mask":return f.AlphaDiscardMode.Mask;case"maskAndTransparency":return f.AlphaDiscardMode.MaskBlend;case"none":return f.AlphaDiscardMode.Opaque;default:return f.AlphaDiscardMode.Blend}}function O(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const q=new l.Version(1,2,"wosr");e.createTextureResources=k,e.load=b,e.processLoadResult=E,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
