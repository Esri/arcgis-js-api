/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../request","../../../../core/asyncUtils","../../../../core/byteSizeEstimations","../../../../core/Error","../../../../core/Logger","../../../../core/maybe","../../../../core/NestedMap","../../../../core/promiseUtils","../../../../core/Version","../../../../chunks/vec3f64","../../../../geometry/support/aaBoundingBox","../../../../support/requestImageUtils","../../webgl-engine/lib/Attribute","../../webgl-engine/lib/basicInterfaces","../../webgl-engine/lib/Geometry","../../webgl-engine/lib/Texture","../../webgl-engine/materials/DefaultMaterial","../../../webgl/enums"],(function(e,t,r,n,s,a,o,i,u,l,c,p,d,f,m,y,g,h,b,x){"use strict";const w=o.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");function A(e,t){return v.apply(this,arguments)}function v(){return(v=t._asyncToGenerator((function*(e,t){const r=yield M(e,t),n=yield O(r.textureDefinitions??{},t);let a=0;for(const s in n)if(n.hasOwnProperty(s)){const e=n[s];a+=e?.image?e.image.width*e.image.height*4:0}return{resource:r,textures:n,size:a+s.estimateNestedObjectSize(r)}}))).apply(this,arguments)}function M(e,t){return T.apply(this,arguments)}function T(){return(T=t._asyncToGenerator((function*(e,t){const s=i.isSome(t)&&t.streamDataRequester;if(s)return P(e,s,t);const a=yield n.result(r(e,i.unwrap(t)));if(!0===a.ok)return a.value.data;l.throwIfAbortError(a.error),E(a.error)}))).apply(this,arguments)}function P(e,t,r){return I.apply(this,arguments)}function I(){return(I=t._asyncToGenerator((function*(e,t,r){const s=yield n.result(t.request(e,"json",r));if(!0===s.ok)return s.value;l.throwIfAbortError(s.error),E(s.error.details.url)}))).apply(this,arguments)}function E(e){throw new a("",`Request for object resource failed: ${e}`)}function U(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(w.warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t&&t.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(w.warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(w.warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(w.warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else w.warn("Indexed geometries must specify faces"),n=!1;break}default:w.warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(w.warn("Geometry requires material"),n=!1);const s=e.params.vertexAttributes;for(const a in s){s[a].values||(w.warn("Geometries with externally defined attributes are not yet supported"),n=!1)}return n}function k(e,t){const r=new Array,n=new Array,s=new Array,a=new u.NestedMap,o=e.resource,l=c.Version.parse(o.version||"1.0","wosr");S.validate(l);const d=o.model.name,f=o.model.geometries,x=o.materialDefinitions??{},w=e.textures;let A=0;const v=new Map;for(let u=0;u<f.length;u++){const e=f[u];if(!U(e))continue;const o=R(e),l=e.params.vertexAttributes,c=[];for(const t in l){const e=l[t],r=e.values;c.push([t,new m.Attribute(r,e.valuesPerElement,!0)])}const d=[];if("PerAttributeArray"!==e.params.topology){const t=e.params.faces;for(const e in t)d.push([e,t[e].values])}const M=o.texture,T=w&&w[M];if(T&&!v.has(M)){const{image:e,params:t}=T,r=new h.Texture(e,t);n.push(r),v.set(M,r)}const P=v.get(M),I=P?P.id:void 0,E=o.material;let k=a.get(E,M);if(i.isNone(k)){const e=x[E.substring(E.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=T&&T.alphaChannelUsage,n=e.transparency>0||"transparency"===r||"maskAndTransparency"===r,s=T?G(T.alphaChannelUsage):void 0,o={ambient:p.fromArray(e.diffuse),diffuse:p.fromArray(e.diffuse),opacity:1-(e.transparency||0),transparent:n,textureAlphaMode:s,textureAlphaCutoff:.33,textureId:I,initTextureTransparent:!0,doubleSided:!0,cullFace:y.CullFaceOptions.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:!!T&&!!T.params.preMultiplyAlpha};i.isSome(t)&&t.materialParamsMixin&&Object.assign(o,t.materialParamsMixin),k=new b.DefaultMaterial(o),a.set(E,M,k)}s.push(k);const D=new g.Geometry(k,c,d);A+=d.position?d.position.length:0,r.push(D)}return{engineResources:[{name:d,stageResources:{textures:n,materials:s,geometries:r},pivotOffset:o.model.pivotOffset,numberOfVertices:A,lodThreshold:null}],referenceBoundingBox:D(r)}}function D(e){const t=d.empty();return e.forEach((e=>{const r=e.boundingInfo;i.isSome(r)&&(d.expandWithVec3(t,r.bbMin),d.expandWithVec3(t,r.bbMax))})),t}function O(e,t){return q.apply(this,arguments)}function q(){return(q=t._asyncToGenerator((function*(e,t){const r=[];for(const a in e){const n=e[a],s=n.images[0].data;if(!s){w.warn("Externally referenced texture data is not yet supported");continue}const o=n.encoding+";base64,"+s,u="/textureDefinitions/"+a,l="rgba"===n.channels?n.alphaChannelUsage||"transparency":"none",c={noUnpackFlip:!0,wrap:{s:x.TextureWrapMode.REPEAT,t:x.TextureWrapMode.REPEAT},preMultiplyAlpha:G(l)!==y.AlphaDiscardMode.Opaque},p=i.isSome(t)&&t.disableTextures?Promise.resolve(null):f.requestImage(o,t);r.push(p.then((e=>({refId:u,image:e,params:c,alphaChannelUsage:l}))))}const n=yield Promise.all(r),s={};for(const a of n)s[a.refId]=a;return s}))).apply(this,arguments)}function G(e){switch(e){case"mask":return y.AlphaDiscardMode.Mask;case"maskAndTransparency":return y.AlphaDiscardMode.MaskBlend;case"none":return y.AlphaDiscardMode.Opaque;default:return y.AlphaDiscardMode.Blend}}function R(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const S=new c.Version(1,2,"wosr");e.createTextureResources=O,e.load=A,e.processLoadResult=k,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
