/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{forEach as e}from"../../../../core/asyncUtils.js";import{isNone as t,isSome as s,get as r}from"../../../../core/maybe.js";import{onAbortOrThrow as o,throwIfAborted as a}from"../../../../core/promiseUtils.js";import i from"./Graphics3DGraphic.js";import{Graphics3DObject3DGraphicLayer as n}from"./Graphics3DObject3DGraphicLayer.js";import{make as y}from"./Graphics3DSymbolLayerFactory.js";import{ApplyRendererDiffResult as l}from"./interfaces.js";import{Loadable as h,LoadStatus as c}from"./Loadable.js";import{totalSymbolComplexities as m}from"./symbolComplexity.js";class d extends h{constructor(e,t,s){super(t.schedule),this._symbol=e,this._context=t,this._backgroundLayers=s,this._destroyed=!1,this.symbolLayers=new Array,this.referenced=0,this._extentPadding=0}set symbol(e){this._symbol=e;for(let s=0;s<e.symbolLayers.length;s++){const r=this.symbolLayers[s];t(r)||(r.symbol=e,r.symbolLayer=e.symbolLayers.items[s])}}get symbol(){return this._symbol}async doLoad(t){let r=this._symbol.symbolLayers;this._extentPadding=0,this._backgroundLayers&&(r=this._backgroundLayers.concat(r));const i=r.length;for(;this.symbolLayers.length<r.length;)this.symbolLayers.push(null);this.symbolLayers.length=r.length;const n=[];for(let e=0;e<i;e++){const s=r.getItemAt(e);if(!1===s.enabled)continue;p.renderPriority=1-(1+e)/i,p.renderPriorityStep=1/i,p.ignoreDrivers=s._ignoreDrivers;const a=y(this.symbol,s,this._context,p);n.push(o(t,(()=>{this.symbolLayers[e]=null,a.destroy()}))),this.symbolLayers[e]=a}await e(this.symbolLayers,(async(e,t)=>{if(s(e))try{await e.load(),this._extentPadding+=Math.max(this._extentPadding,e.extentPadding)}catch{this.symbolLayers[t]=null}}));for(const e of n)e?.remove();if(n.length=0,a(t),this.symbolLayers.length&&!this.symbolLayers.some((e=>!!e)))throw new Error}getSymbolLayerSize(e){const t=this.symbolLayers[e];return s(t)?t.getCachedSize():null}get extentPadding(){return this._extentPadding}createGraphics3DGraphic(e,t){const r=e.graphic,o=new Array(this.symbolLayers.length);for(let i=0;i<this.symbolLayers.length;i++){const t=this.symbolLayers[i];o[i]=s(t)?t.createGraphics3DGraphic(e):null}const a=this._context.arcade||this._context.featureExpressionInfoContext&&this._context.featureExpressionInfoContext.arcade&&this._context.featureExpressionInfoContext.arcade.modules||null;return new i(r,t||this,o,e.layer,a)}get complexity(){return m(this.symbolLayers.map((e=>r(e,"complexity"))))}globalPropertyChanged(e,t){const r=this.symbolLayers.length;for(let o=0;o<r;o++){const r=this.symbolLayers[o],a=e=>{const t=e.graphics[o];return t instanceof n?t:null};if(s(r)&&!r.globalPropertyChanged(e,t,a))return!1}return!0}applyRendererDiff(e,t){return this.loadStatus!==c.LOADED?l.Recreate_Symbol:this.symbolLayers.reduce(((r,o)=>r!==l.Recreate_Symbol&&s(o)?Math.min(r,o.applyRendererDiff(e,t)):r),l.Fast_Update)}prepareSymbolPatch(e){if(this.loadStatus===c.FAILED)return;if("partial"!==e.diff.type)return;const r=e.diff.diff;if(!r.symbolLayers||"partial"!==r.symbolLayers.type)return;const o=r.symbolLayers.diff;this.symbolLayers.forEach(((r,a)=>{if(t(r))return;const i=o[a];if(i){const t={diff:i,graphics3DGraphicPatches:[],symbolLayerStatePatches:[]};r.prepareSymbolLayerPatch(t),e.symbolStatePatches.push(...t.symbolLayerStatePatches),t.graphics3DGraphicPatches.length&&e.graphics3DGraphicPatches.push(((e,r)=>{const o=e.graphics[a];s(o)&&t.graphics3DGraphicPatches.forEach((e=>e(o,r)))}))}}))}updateGeometry(e,s){for(let r=0;r<this.symbolLayers.length;r++){const o=this.symbolLayers[r];if(t(o))continue;const a=e.graphics[r];if(t(a)||!o.updateGeometry(a,s))return!1}return!0}onRemoveGraphic(e){for(let r=0;r<this.symbolLayers.length;r++){const o=this.symbolLayers[r];if(t(o))continue;const a=e.graphics[r];s(a)&&o.onRemoveGraphic(a)}}getFastUpdateStatus(){let e=0,s=0,r=0;return this.symbolLayers.forEach((o=>{t(o)||(o.loadStatus===c.LOADING?e++:o.isFastUpdatesEnabled()?r++:s++)})),{loading:e,slow:s,fast:r}}destroy(){if(this.destroyed)console.error("Graphics3DSymbol.destroy called when already destroyed!");else{super.destroy();for(const e of this.symbolLayers)s(e)&&e.destroy();this.symbolLayers.length=0,this._destroyed=!0}}get destroyed(){return this._destroyed}}const p={renderPriority:0,renderPriorityStep:1,ignoreDrivers:!1};export{d as default};
