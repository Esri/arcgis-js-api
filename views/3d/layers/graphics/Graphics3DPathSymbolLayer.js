/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/Error","../../../../core/mathUtils","../../../../core/maybe","../../../../chunks/mat2","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f32","../../../../chunks/vec3f64","../../../../geometry/projection","../../../../geometry/support/aaBoundingBox","../../../../layers/graphics/dehydratedFeatures","./elevationAlignmentUtils","./ElevationContext","./Graphics3DObject3DGraphicLayer","./Graphics3DSymbolLayer","./graphicUtils","./interfaces","../support/FastSymbolUpdates","../../webgl-engine/lib/basicInterfaces","../../webgl-engine/lib/Object3D","../../webgl-engine/lib/PathGeometry","../../webgl-engine/lib/pathGeometryUtils","../../webgl-engine/materials/DefaultMaterial","../../webgl-engine/materials/PathMaterial"],(function(e,t,i,a,r,s,n,o,l,c,h,p,d,u,f,m,y,g,_,b,v,S,x,w,D,P,R){"use strict";const C=["polyline"];let A=function(e){function a(t,i,a,r){var s;return(s=e.call(this,t,i,a,r)||this)._intrinsicSize=o.fromValues(1,1),s.upVectorAlignment="path",s.stencilWidth=.1,s.ensureDrapedStatus(!1),s}t._inheritsLoose(a,e);var s=a.prototype;return s.doLoad=function(){var e=t._asyncToGenerator((function*(){const e=r.isSome(this.symbolLayer.width)?this.symbolLayer.width:this.symbolLayer.height,t=r.isSome(this.symbolLayer.height)?this.symbolLayer.height:e;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[e,1,t],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=v.initFastSymbolUpdatesState(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const a=this.symbolLayer.anchor||"center";this.upVectorAlignment="path","heading"===this.symbolLayer.profileRotation&&(this.upVectorAlignment="world");const s=this.symbolLayer.profile||"circle";switch(s){case"circle":default:this._profile=D.Profile.circle(N);break;case"quad":this._profile=D.Profile.rect()}let o=[0,0];"center"!==a&&(o={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[a],this._profile.translate(o[0],o[1]));switch(this.symbolLayer.join||"simple"){case"round":this._extruder=new D.MiterExtruder(0,k);break;case"bevel":this._extruder=new D.MiterExtruder(0,1);break;case"miter":this._extruder=new D.MiterExtruder(.8*Math.PI,1);break;default:this._extruder=new D.SimpleExtruder}const l=this.symbolLayer.cap||"butt";switch(l){case"none":this._startCap=new D.NoCapBuilder,this._endCap=new D.NoCapBuilder;break;case"butt":default:this._startCap=new D.TriangulationCapBuilder(this._profile,0),this._endCap=new D.TriangulationCapBuilder(this._profile,0,!0);break;case"square":this._startCap=new D.TriangulationCapBuilder(this._profile,-.5),this._endCap=new D.TriangulationCapBuilder(this._profile,.5,!0);break;case"round":{const e="quad"===s;this._startCap=new D.RoundCapBuilder({profile:this._profile,flip:!1,breakNormals:e,subdivisions:O}),this._endCap=new D.RoundCapBuilder({profile:this._profile,flip:!0,breakNormals:e,subdivisions:O});break}}const c=r.get(this.symbolLayer,"material","color"),p=this._getCombinedOpacityAndColor(c),d=h.fromArray(p),u=p[3],f=u<1||this.needsDrivenTransparentPass,m={diffuse:d,ambient:d,opacity:u,transparent:f,vertexColors:!1,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:f||"none"===l?S.CullFaceOptions.None:S.CullFaceOptions.Back,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(n.set(this._intrinsicSize,e,t),!_.isValidSize(this._intrinsicSize[0])||!_.isValidSize(this._intrinsicSize[1])))throw new i("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||n.scale(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled?(Object.assign(m,this._fastUpdates.materialParameters,{size:[this._intrinsicSize[0],this._intrinsicSize[1],0]}),this._material=new R.PathMaterial(m)):(m.vertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new P.DefaultMaterial(m)),this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._material)}));function a(){return e.apply(this,arguments)}return a}(),s.destroy=function(){e.prototype.destroy.call(this),this._context.stage.remove(this._material),this._material=null},s.createGraphics3DGraphic=function(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,C,this.symbolLayer.type))return null;const i=this.setGraphicElevationContext(t,new m.ElevationContext),a=e.renderingInfo;return this._createAs3DShape(t,a,i,t.uid)},s.layerOpacityChanged=function(){const e=r.get(this.symbolLayer,"material","color"),t=this._getCombinedOpacity(e),i=t<1||this.needsDrivenTransparentPass;return this._material.setParameters({opacity:t,transparent:i}),!0},s.layerElevationInfoChanged=function(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,f.needsElevationUpdates3D)},s.slicePlaneEnabledChanged=function(){return this._material.setParameters({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0},s.physicalBasedRenderingChanged=function(){return this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0},s.pixelRatioChanged=function(){return!0},s.applyRendererDiff=function(e,t){for(const i in e.diff){if("visualVariables"!==i)return b.ApplyRendererDiffResult.Recreate_Symbol;if(!v.updateFastSymbolUpdatesState(this._fastUpdates,t,this._vvConvertOptions))return b.ApplyRendererDiffResult.Recreate_Symbol;this._material.setParameters(this._fastUpdates.materialParameters)}return b.ApplyRendererDiffResult.Fast_Update},s.getVertexData=function(e){let t=0;const i=e.paths,a=[],r=e.spatialReference,s=this._context.elevationProvider.spatialReference,n=this._context.renderCoordsHelper.spatialReference;for(const p of i)t+=p.length;const o=new Float64Array(3*t),l=new Float64Array(3*t),c=new Float64Array(3*t);let h=0;for(const p of i){a.push({index:h,numVertices:p.length});for(const t of p)o[h++]=t[0],o[h++]=t[1],o[h++]=e.hasZ?t[2]:0}let d=!0;return r.equals(s)?this._copyVertices(o,0,l,0,t):d=p.projectBuffer(o,r,0,l,s,0,t),s.equals(n)?this._copyVertices(l,0,c,0,t):p.projectBuffer(l,s,0,c,n,0,t),{pathVertexDataInfos:a,vertexDataGS:o,vertexDataES:l,vertexDataRS:c,projectionSuccess:d,terrainElevation:0}},s._copyVertices=function(e,t,i,a,r){t*=3,a*=3;for(let s=0;s<r;++s)i[a++]=e[t++],i[a++]=e[t++],i[a++]=e[t++]},s._createAs3DShape=function(e,t,i,a){const s=e.geometry,n=new Array,o=new Array,c=new Array,h=s.spatialReference,p=d.create(),u=this._context.renderCoordsHelper;I.spatialReference=h;const m=this.getVertexData(s);if(!m.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(m.pathVertexDataInfos.length>0){for(let a=0;a<m.pathVertexDataInfos.length;++a){const s=m.pathVertexDataInfos[a],y=s.index,_=s.numVertices;if(_<2)continue;if(r.isSome(this._context.clippingExtent)&&(d.empty(p),d.expandWithBuffer(p,m.vertexDataES,3*y,_),!d.intersectsClippingArea(p,this._context.clippingExtent)))continue;const b=[];for(let e=y;e<y+3*_;){const t=e++,a=e++,r=e++,s=new D.PathVertex;l.set(s.posGS,m.vertexDataGS[t],m.vertexDataGS[a],m.vertexDataGS[r]),l.set(s.posES,m.vertexDataES[t],m.vertexDataES[a],m.vertexDataES[r]);const n=f.evaluateElevationAlignmentAtPoint(s.posES,this._context.elevationProvider,i,u);l.set(B,m.vertexDataRS[t],m.vertexDataRS[a],m.vertexDataRS[r]),u.setAltitude(B,n),l.set(s.pos,B[0],B[1],B[2]),b.push(s)}const v=new D.Path(b);E(v,this.upVectorAlignment,this._context.renderCoordsHelper);const S=new D.Builder(v,this._profile,this._extruder,this._startCap,this._endCap);let x=null;if(this._fastUpdates.enabled){const t=this._fastUpdates.visualVariables,i=t.size?g.getAttributeValue(t.size.field,e):0,a=t.color?g.getAttributeValue(t.color.field,e):0,r=t.opacity?g.getAttributeValue(t.opacity.field,e):0;x=new D.FastUpdatePathGeometry(S,i,a,r)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];this._drivenProperties.size&&(e[0]*=U(t.size[0],"symbol-value"===t.size[2]?this.symbolLayer.height||0:t.size[2],this.symbolLayer.width||0),e[1]*=U(t.size[2],"symbol-value"===t.size[0]?this.symbolLayer.width||0:t.size[0],this.symbolLayer.height||0));let i=null;this._drivenProperties.color&&(i=t.color),this._drivenProperties.opacity&&null!=t.opacity&&(i=i?[i[0],i[1],i[2],t.opacity]:[1,1,1,t.opacity]);const a=new D.StaticPathGeometry(S);a.bake(e),i&&a.bakeVertexColors(i),x=a}const{vertexAttributes:P,indices:R}=x.createGeometryData(),C=new w.PathGeometry(P,R,x,h,this.upVectorAlignment,this.stencilWidth);n.push(C),o.push(this._material),c.push(x.xform)}if(n.length>0){const e={layerUid:this._context.layer.uid,graphicUid:a},t=new x.Object3D({geometries:n,materials:o,transformations:c,metadata:e}),r=new y.Graphics3DObject3DGraphicLayer(this,t,n,null,null,L,i);return r.alignedSampledElevation=m.terrainElevation,r.needsElevationUpdates=f.needsElevationUpdates3D(i.mode),r}}else 0!==s.paths.length&&s.paths.some((e=>e.length>0))||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");return null},a}(g.Graphics3DSymbolLayer);function E(e,t,i){switch(t){case"world":for(const t of e.vertices)l.add(F,t.pos,e.offset),i.worldUpAtPosition(F,B),t.setFrameFromUpVector(B),t.computeRotationAxisAndAngleFromUpVector();break;case"path":l.add(F,e.vertices[0].pos,e.offset),i.worldUpAtPosition(F,B),D.computeMinimumRotationTangentFrame(e,B);for(const t of e.vertices){const e=Math.sign(l.dot(t.frame.right,t.vRight));l.cross(t.rotationFrame.up,t.vRight,t.vLeft),l.scale(t.rotationFrame.up,t.rotationFrame.up,e),l.normalize(t.rotationFrame.up,t.rotationFrame.up);const i=l.dot(t.rotationFrame.up,t.frame.up),r=l.dot(t.rotationFrame.up,t.frame.right);if(l.scale(F,t.frame.up,-r),l.scale(G,t.frame.right,i),l.add(F,F,G),l.normalize(t.rotationFrame.right,F),D.vertexSpaceToProfileSpace(t.rotationRight,t.frame,t.rotationFrame.right),l.negate(F,t.vLeft),t.rotationAngle=-e*(Math.PI-a.acosClamped(l.dot(F,t.vRight))),Math.abs(t.rotationAngle)>0){const e=a.reciprocalClamped(Math.cos(.5*t.rotationAngle));s.set(t.miterStretch,1+(e-1)*t.rotationRight[0]*t.rotationRight[0],(e-1)*t.rotationRight[0]*t.rotationRight[1],(e-1)*t.rotationRight[0]*t.rotationRight[1],1+(e-1)*t.rotationRight[1]*t.rotationRight[1])}const n=Math.PI-t.rotationAngle;t.maxStretchDistance=Math.abs(Math.min(t.vLeftLength,t.vRightLength)*a.reciprocalClamped(Math.cos(.5*n)))}}}function U(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function V(e,t,i,a){let r=0;for(const s of e.vertices)f.evaluateElevationInfoAtPoint(s.posES,i,t,a,M),r+=M.sampledElevation,l.add(B,s.pos,e.offset),a.setAltitude(B,M.z),l.subtract(s.pos,B,e.offset);return e.updatePathVertexInformation(),r/e.vertices.length}function L(e,t,i,a){const r=e.stageObject,s=r.geometryRecords;let n=0;z.spatialReference=a.spatialReference;for(const o of s){const e=o.geometry;if(!w.isPathGeometry(e))continue;const s=e.path,l=s.builder.path,c=e.geometrySR;I.spatialReference=c,n+=V(l,t,i,a),"world"!==e.upVectorAlignment&&E(l,e.upVectorAlignment,a),s.onPathChanged(),e.invalidateBoundingInfo(),r.geometryVertexAttrsUpdated(o)}return n/s.length}const z=u.makeDehydratedPoint(0,0,0,null),I=u.makeDehydratedPoint(0,0,0,null),B=h.create(),F=c.create(),G=c.create(),M=new f.SampleElevationInfo,k=3,O=3,N=10;e.Graphics3DPathSymbolLayer=A,e.NUM_CIRCLE_PROFILE_SUBDIVISIONS=N,e.NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS=O,e.NUM_ROUND_JOIN_SUBDIVISIONS=k,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
