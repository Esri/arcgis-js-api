/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{acosClamped as t,reciprocalClamped as r}from"../../../../core/mathUtils.js";import{isSome as i,get as s}from"../../../../core/maybe.js";import{s as a}from"../../../../chunks/mat2.js";import{a as o,f as n}from"../../../../chunks/vec2.js";import{f as l,b as h}from"../../../../chunks/vec2f64.js";import{s as c,a as p,e as m,f,g as d,n as u,o as g,b as y}from"../../../../chunks/vec3.js";import{c as _}from"../../../../chunks/vec3f32.js";import{d as b,c as v}from"../../../../chunks/vec3f64.js";import{projectBuffer as x}from"../../../../geometry/projection.js";import{create as w,empty as S,expandWithBuffer as R,intersectsClippingArea as D}from"../../../../geometry/support/aaBoundingBox.js";import{makeDehydratedPoint as P}from"../../../../layers/graphics/dehydratedFeatures.js";import{needsElevationUpdates3D as j,evaluateElevationAlignmentAtPoint as C,SampleElevationInfo as A,evaluateElevationInfoAtPoint as V}from"./elevationAlignmentUtils.js";import{ElevationContext as L}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as z}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as E,getAttributeValue as U}from"./Graphics3DSymbolLayer.js";import{isValidSize as k}from"./graphicUtils.js";import{ApplyRendererDiffResult as F}from"./interfaces.js";import{initFastSymbolUpdatesState as G,updateFastSymbolUpdatesState as I}from"../support/FastSymbolUpdates.js";import{CullFaceOptions as M}from"../../webgl-engine/lib/basicInterfaces.js";import{Object3D as B}from"../../webgl-engine/lib/Object3D.js";import{PathGeometry as O,isPathGeometry as q}from"../../webgl-engine/lib/PathGeometry.js";import{Profile as H,SimpleExtruder as T,MiterExtruder as N,RoundCapBuilder as W,TriangulationCapBuilder as Z,NoCapBuilder as J,PathVertex as K,Path as Q,Builder as X,FastUpdatePathGeometry as Y,StaticPathGeometry as $,computeMinimumRotationTangentFrame as ee,vertexSpaceToProfileSpace as te}from"../../webgl-engine/lib/pathGeometryUtils.js";import{DefaultMaterial as re}from"../../webgl-engine/materials/DefaultMaterial.js";import{PathMaterial as ie}from"../../webgl-engine/materials/PathMaterial.js";const se=["polyline"];class ae extends E{constructor(e,t,r,i){super(e,t,r,i),this._intrinsicSize=l(1,1),this.upVectorAlignment="path",this.stencilWidth=.1,this.ensureDrapedStatus(!1)}async doLoad(){const t=i(this.symbolLayer.width)?this.symbolLayer.width:this.symbolLayer.height,r=i(this.symbolLayer.height)?this.symbolLayer.height:t;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[t,1,r],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=G(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const a=this.symbolLayer.anchor||"center";this.upVectorAlignment="path","heading"===this.symbolLayer.profileRotation&&(this.upVectorAlignment="world");const l=this.symbolLayer.profile||"circle";switch(l){case"circle":default:this._profile=H.circle(_e);break;case"quad":this._profile=H.rect()}let c=[0,0];"center"!==a&&(c={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[a],this._profile.translate(c[0],c[1]));switch(this.symbolLayer.join||"simple"){case"round":this._extruder=new N(0,ge);break;case"bevel":this._extruder=new N(0,1);break;case"miter":this._extruder=new N(.8*Math.PI,1);break;default:this._extruder=new T}const p=this.symbolLayer.cap||"butt";switch(p){case"none":this._startCap=new J,this._endCap=new J;break;case"butt":default:this._startCap=new Z(this._profile,0),this._endCap=new Z(this._profile,0,!0);break;case"square":this._startCap=new Z(this._profile,-.5),this._endCap=new Z(this._profile,.5,!0);break;case"round":{const e="quad"===l;this._startCap=new W({profile:this._profile,flip:!1,breakNormals:e,subdivisions:ye}),this._endCap=new W({profile:this._profile,flip:!0,breakNormals:e,subdivisions:ye});break}}const m=s(this.symbolLayer,"material","color"),f=this._getCombinedOpacityAndColor(m),d=b(f),u=f[3],g=u<1||this.needsDrivenTransparentPass,y={diffuse:d,ambient:d,opacity:u,transparent:g,hasVertexColors:!1,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:g||"none"===p?M.None:M.Back,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(o(this._intrinsicSize,t,r),!k(this._intrinsicSize[0])||!k(this._intrinsicSize[1])))throw new e("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");if(this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||n(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled){const e={...y,...this._fastUpdates.materialParameters,size:h(this._intrinsicSize)};this._material=new ie(e)}else y.hasVertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new re(y);this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._material)}destroy(){super.destroy(),this._context.stage.remove(this._material),this._material=null}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,se,this.symbolLayer.type))return null;const r=this.setGraphicElevationContext(t,new L),i=e.renderingInfo;return this._createAs3DShape(t,i,r,t.uid)}layerOpacityChanged(){const e=s(this.symbolLayer,"material","color"),t=this._getCombinedOpacity(e),r=t<1||this.needsDrivenTransparentPass;return this._material.setParameters({opacity:t,transparent:r}),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,j)}slicePlaneEnabledChanged(){return this._material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}applyRendererDiff(e,t){for(const r in e.diff){if("visualVariables"!==r)return F.Recreate_Symbol;if(!I(this._fastUpdates,t,this._vvConvertOptions))return F.Recreate_Symbol;this._material.setParameters(this._fastUpdates.materialParameters)}return F.Fast_Update}getVertexData(e){let t=0;const r=e.paths,i=[],s=e.spatialReference,a=this._context.elevationProvider.spatialReference,o=this._context.renderCoordsHelper.spatialReference;for(const m of r)t+=m.length;const n=new Float64Array(3*t),l=new Float64Array(3*t),h=new Float64Array(3*t);let c=0;for(const m of r){i.push({index:c,numVertices:m.length});for(const t of m)n[c++]=t[0],n[c++]=t[1],n[c++]=e.hasZ?t[2]:0}let p=!0;return s.equals(a)?this._copyVertices(n,0,l,0,t):p=x(n,s,0,l,a,0,t),a.equals(o)?this._copyVertices(l,0,h,0,t):x(l,a,0,h,o,0,t),{pathVertexDataInfos:i,vertexDataGS:n,vertexDataES:l,vertexDataRS:h,projectionSuccess:p,terrainElevation:0}}_copyVertices(e,t,r,i,s){t*=3,i*=3;for(let a=0;a<s;++a)r[i++]=e[t++],r[i++]=e[t++],r[i++]=e[t++]}_createAs3DShape(e,t,r,s){const a=e.geometry,o=new Array,n=new Array,l=new Array,h=a.spatialReference,p=w(),m=this._context.renderCoordsHelper;pe.spatialReference=h;const f=this.getVertexData(a);if(!f.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(f.pathVertexDataInfos.length>0){for(let s=0;s<f.pathVertexDataInfos.length;++s){const a=f.pathVertexDataInfos[s],d=a.index,u=a.numVertices;if(u<2)continue;if(i(this._context.clippingExtent)&&(S(p),R(p,f.vertexDataES,3*d,u),!D(p,this._context.clippingExtent)))continue;const g=[];for(let e=d;e<d+3*u;){const t=e++,i=e++,s=e++,a=new K;c(a.posGS,f.vertexDataGS[t],f.vertexDataGS[i],f.vertexDataGS[s]),c(a.posES,f.vertexDataES[t],f.vertexDataES[i],f.vertexDataES[s]);const o=C(a.posES,this._context.elevationProvider,r,m);c(me,f.vertexDataRS[t],f.vertexDataRS[i],f.vertexDataRS[s]),m.setAltitude(me,o),c(a.pos,me[0],me[1],me[2]),g.push(a)}const y=new Q(g);oe(y,this.upVectorAlignment,this._context.renderCoordsHelper);const _=new X(y,this._profile,this._extruder,this._startCap,this._endCap);let b=null;if(this._fastUpdates.enabled){const t=this._fastUpdates.visualVariables,r=t.size?U(t.size.field,e):0,i=t.color?U(t.color.field,e):0,s=t.opacity?U(t.opacity.field,e):0;b=new Y(_,r,i,s)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];this._drivenProperties.size&&(e[0]*=ne(t.size[0],"symbol-value"===t.size[2]?this.symbolLayer.height||0:t.size[2],this.symbolLayer.width||0),e[1]*=ne(t.size[2],"symbol-value"===t.size[0]?this.symbolLayer.width||0:t.size[0],this.symbolLayer.height||0));let r=null;this._drivenProperties.color&&(r=t.color),this._drivenProperties.opacity&&null!=t.opacity&&(r=r?[r[0],r[1],r[2],t.opacity]:[1,1,1,t.opacity]);const i=new $(_);i.bake(e),r&&i.bakeVertexColors(r),b=i}const{vertexAttributes:v,indices:x}=b.createGeometryData(),w=new O(v,x,b,h,this.upVectorAlignment,this.stencilWidth);o.push(w),n.push(this._material),l.push(b.xform)}if(o.length>0){const e={layerUid:this._context.layer.uid,graphicUid:s},t=new B({geometries:o,materials:n,transformations:l,metadata:e}),i=new z(this,t,o,null,null,he,r);return i.alignedSampledElevation=f.terrainElevation,i.needsElevationUpdates=j(r.mode),i}}else 0!==a.paths.length&&a.paths.some((e=>e.length>0))||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");return null}}function oe(e,i,s){switch(i){case"world":for(const t of e.vertices)p(fe,t.pos,e.offset),s.worldUpAtPosition(fe,me),t.setFrameFromUpVector(me),t.computeRotationAxisAndAngleFromUpVector();break;case"path":p(fe,e.vertices[0].pos,e.offset),s.worldUpAtPosition(fe,me),ee(e,me);for(const i of e.vertices){const e=Math.sign(m(i.frame.right,i.vRight));f(i.rotationFrame.up,i.vRight,i.vLeft),d(i.rotationFrame.up,i.rotationFrame.up,e),u(i.rotationFrame.up,i.rotationFrame.up);const s=m(i.rotationFrame.up,i.frame.up),o=m(i.rotationFrame.up,i.frame.right);if(d(fe,i.frame.up,-o),d(de,i.frame.right,s),p(fe,fe,de),u(i.rotationFrame.right,fe),te(i.rotationRight,i.frame,i.rotationFrame.right),g(fe,i.vLeft),i.rotationAngle=-e*(Math.PI-t(m(fe,i.vRight))),Math.abs(i.rotationAngle)>0){const e=r(Math.cos(.5*i.rotationAngle));a(i.miterStretch,1+(e-1)*i.rotationRight[0]*i.rotationRight[0],(e-1)*i.rotationRight[0]*i.rotationRight[1],(e-1)*i.rotationRight[0]*i.rotationRight[1],1+(e-1)*i.rotationRight[1]*i.rotationRight[1])}const n=Math.PI-i.rotationAngle;i.maxStretchDistance=Math.abs(Math.min(i.vLeftLength,i.vRightLength)*r(Math.cos(.5*n)))}}}function ne(e,t,r){switch(e){case"symbol-value":return r;case"proportional":return t;default:return e}}function le(e,t,r,i){let s=0;for(const a of e.vertices)V(a.posES,r,t,i,ue),s+=ue.sampledElevation,p(me,a.pos,e.offset),i.setAltitude(me,ue.z),y(a.pos,me,e.offset);return e.updatePathVertexInformation(),s/e.vertices.length}function he(e,t,r,i){const s=e.stageObject,a=s.geometryRecords;let o=0;ce.spatialReference=i.spatialReference;for(const n of a){const e=n.geometry;if(!q(e))continue;const a=e.path,l=a.builder.path,h=e.geometrySR;pe.spatialReference=h,o+=le(l,t,r,i),"world"!==e.upVectorAlignment&&oe(l,e.upVectorAlignment,i),a.onPathChanged(),e.invalidateBoundingInfo(),s.geometryVertexAttrsUpdated(n)}return o/a.length}const ce=P(0,0,0,null),pe=P(0,0,0,null),me=v(),fe=_(),de=_(),ue=new A,ge=3,ye=3,_e=10;export{ae as Graphics3DPathSymbolLayer,_e as NUM_CIRCLE_PROFILE_SUBDIVISIONS,ye as NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS,ge as NUM_ROUND_JOIN_SUBDIVISIONS};
