/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/lang","../../../../core/maybe","../../../../core/Error","../../../../core/mathUtils","../../../../chunks/vec3f64","../../../../chunks/vec3","../../../../geometry/projection","../../../../chunks/vec2f64","../../../../chunks/vec2","../../../../geometry/support/aaBoundingBox","../../../../layers/graphics/dehydratedFeatures","../../../../chunks/vec3f32","../../webgl-engine/lib/Object3D","./graphicUtils","./elevationAlignmentUtils","./ElevationContext","./Graphics3DObject3DGraphicLayer","../../webgl-engine/lib/Geometry","./Graphics3DSymbolLayer","../../webgl-engine/materials/DefaultMaterial","../support/FastSymbolUpdates","../../../../chunks/mat2","../../webgl-engine/lib/pathGeometryUtils","../../webgl-engine/materials/PathMaterial"],(function(e,t,i,a,r,s,n,o,l,c,h,p,d,u,m,f,y,g,_,b,v,S,x,w,P,D){"use strict";let C=function(e){function s(t,i,a,r){var s;return(s=e.call(this,t,i,a,r)||this)._intrinsicSize=c.fromValues(1,1),s.upVectorAlignment="path",s.stencilWidth=.1,s.ensureDrapedStatus(!1),s}t._inheritsLoose(s,e);var d=s.prototype;return d.doLoad=async function(){const e=a.isSome(this.symbolLayer.width)?this.symbolLayer.width:a.isSome(this.symbolLayer.height)?this.symbolLayer.height:this.symbolLayer.size,t=a.isSome(this.symbolLayer.height)?this.symbolLayer.height:e;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[e,1,t],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=x.initFastSymbolUpdatesState(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const s=this.symbolLayer.anchor||"center";this.upVectorAlignment="path","heading"===this.symbolLayer.profileRotation&&(this.upVectorAlignment="world");const o=this.symbolLayer.profile||"circle";switch(o){case"circle":default:this._profile=P.Profile.circle(k);break;case"quad":this._profile=P.Profile.rect()}let l=[0,0];"center"!==s&&(l={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[s],this._profile.translate(l[0],l[1]));switch(this.symbolLayer.join||"simple"){case"round":this._extruder=new P.MiterExtruder(0,G);break;case"bevel":this._extruder=new P.MiterExtruder(0,1);break;case"miter":this._extruder=new P.MiterExtruder(.8*Math.PI,1);break;case"simple":default:this._extruder=new P.SimpleExtruder}const c=this.symbolLayer.cap||"butt";switch(c){case"none":this._startCap=new P.NoCapBuilder,this._endCap=new P.NoCapBuilder;break;case"butt":default:this._startCap=new P.TriangulationCapBuilder(this._profile,0),this._endCap=new P.TriangulationCapBuilder(this._profile,0,!0);break;case"square":this._startCap=new P.TriangulationCapBuilder(this._profile,-.5),this._endCap=new P.TriangulationCapBuilder(this._profile,.5,!0);break;case"round":{const e="quad"===o;this._startCap=new P.RoundCapBuilder({profile:this._profile,flip:!1,breakNormals:e,subdivisions:B}),this._endCap=new P.RoundCapBuilder({profile:this._profile,flip:!0,breakNormals:e,subdivisions:B});break}}const p=this._getIdHint(),d=a.get(this.symbolLayer,"material","color"),u=this._getCombinedOpacityAndColor(d),m=n.fromArray(u),y=u[3],g={diffuse:m,ambient:m,opacity:y,transparent:y<1||this.needsDrivenTransparentPass,vertexColors:!1,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:"none"===c?0:void 0,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(h.set(this._intrinsicSize,e,t),!f.isValidSize(this._intrinsicSize[0])||!f.isValidSize(this._intrinsicSize[1])))throw new r("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||h.scale(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled?(i.mixin(g,this._fastUpdates.materialParameters,{size:[this._intrinsicSize[0],this._intrinsicSize[1],0]}),this._material=new D.PathMaterial(g,`${p}_pathmat`)):(g.vertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new S.DefaultMaterial(g,`${p}_pathmat`)),this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(3,this._material)},d.destroy=function(){e.prototype.destroy.call(this),this._material&&(this._context.stage.remove(3,this._material.id),this._material=null)},d.createGraphics3DGraphic=function(e){const t=e.graphic;if(!this._validateGeometryType(t.geometry,s.validGeometryTypes,this.symbolLayer.type))return null;if(!this._validateGeometry(t.geometry))return null;const i="graphic"+t.uid,a=this.setGraphicElevationContext(t,new g.ElevationContext),r=e.renderingInfo;return this._createAs3DShape(t,r,a,i,t.uid)},d.layerOpacityChanged=function(){const e=a.get(this.symbolLayer,"material","color"),t=this._getCombinedOpacity(e),i=t<1||this.needsDrivenTransparentPass;return this._material.setParameterValues({opacity:t,transparent:i}),!0},d.layerElevationInfoChanged=function(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,y.needsElevationUpdates3D)},d.slicePlaneEnabledChanged=function(){return this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0},d.physicalBasedRenderingChanged=function(){return this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0},d.pixelRatioChanged=function(){return!0},d.applyRendererDiff=function(e,t){for(const i in e.diff)switch(i){case"visualVariables":if(!x.updateFastSymbolUpdatesState(this._fastUpdates,t,this._vvConvertOptions))return!1;this._material.setParameterValues(this._fastUpdates.materialParameters);break;default:return!1}return!0},d.getVertexData=function(e){let t=0;const i=e.paths,a=[],r=e.spatialReference,s=this._context.elevationProvider.spatialReference,n=this._context.renderCoordsHelper.spatialReference;for(const e of i)t+=e.length;const o=new Float64Array(3*t),c=new Float64Array(3*t),h=new Float64Array(3*t);let p=0;for(const t of i){a.push({index:p,numVertices:t.length});for(const i of t)o[p++]=i[0],o[p++]=i[1],o[p++]=e.hasZ?i[2]:0}let d=!0;return r.equals(s)?this._copyVertices(o,0,c,0,t):d=l.projectBuffer(o,r,0,c,s,0,t),s.equals(n)?this._copyVertices(c,0,h,0,t):l.projectBuffer(c,s,0,h,n,0,t),{pathVertexDataInfos:a,vertexDataGS:o,vertexDataES:c,vertexDataRS:h,projectionSuccess:d,terrainElevation:0}},d._copyVertices=function(e,t,i,a,r){t*=3,a*=3;for(let s=0;s<r;++s)i[a++]=e[t++],i[a++]=e[t++],i[a++]=e[t++]},d._createAs3DShape=function(e,t,i,r,s){const n=e.geometry,l=[],c=[],h=[],d=n.spatialReference,u=p.create(),f=this._context.renderCoordsHelper,g=this.getVertexData(n);if(!g.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(g.pathVertexDataInfos.length>0){for(let s=0;s<g.pathVertexDataInfos.length;++s){const n=g.pathVertexDataInfos[s],m=n.index,_=n.numVertices;if(_<2){this.logger.warn("PathSymbol3DLayer geometry failed to be created (paths should contain at least 2 vertices)");continue}if(a.isSome(this._context.clippingExtent)&&(p.empty(u),p.expandWithBuffer(u,g.vertexDataES,3*m,_),!p.intersectsClippingArea(u,this._context.clippingExtent)))continue;const S=[];for(let e=m;e<m+3*_;){const t=e++,a=e++,r=e++,s=new P.PathVertex;o.set(s.posGS,g.vertexDataGS[t],g.vertexDataGS[a],g.vertexDataGS[r]),o.set(s.posES,g.vertexDataES[t],g.vertexDataES[a],g.vertexDataES[r]);const n=y.evaluateElevationAlignmentAtPoint(s.posES,this._context.elevationProvider,i,f,null);o.set(L,g.vertexDataRS[t],g.vertexDataRS[a],g.vertexDataRS[r]),f.setAltitude(n,L),o.set(s.pos,L[0],L[1],L[2]),S.push(s)}const x=new P.Path(S);V(x,this.upVectorAlignment,this._context.renderCoordsHelper);const w=new P.Builder(x,this._profile,this._extruder,this._startCap,this._endCap);let D=null;if(this._fastUpdates.enabled){const t=this._fastUpdates.visualVariables,i=t.size?v.getAttributeValue(t.size.field,e):0,a=t.color?v.getAttributeValue(t.color.field,e):0,r=t.opacity?v.getAttributeValue(t.opacity.field,e):0;D=new P.FastUpdatePathGeometry(w,i,a,r)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];this._drivenProperties.size&&(e[0]*=R(t.size[0],"symbol-value"===t.size[2]?this.symbolLayer.height||0:t.size[2],this.symbolLayer.width||0),e[1]*=R(t.size[2],"symbol-value"===t.size[0]?this.symbolLayer.width||0:t.size[0],this.symbolLayer.height||0));let i=null;this._drivenProperties.color&&(i=t.color),this._drivenProperties.opacity&&null!=t.opacity&&(i=i?[i[0],i[1],i[2],t.opacity]:[1,1,1,t.opacity]);const a=new P.StaticPathGeometry(w);a.bake(e),i&&a.bakeVertexColors(i),D=a}const C=D.createGeometryData(),E=new b(C,r+"path"+s),U={pathGeometry:D,geometrySR:d,upVectorAlignment:this.upVectorAlignment,stencilWidth:this.stencilWidth};E.metadata=U,l.push(E),c.push(this._material),h.push(D.xform)}const n={layerUid:this._context.layer.uid,graphicUid:s};if(l.length>0){const e=new m({geometries:l,materials:c,transformations:h,castShadow:!0,metadata:n,idHint:r}),t=new _(this,e,l,null,null,U,i);return t.alignedSampledElevation=g.terrainElevation,t.needsElevationUpdates=y.needsElevationUpdates3D(i.mode),t}}else this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");return null},s}(v.Graphics3DSymbolLayer);function V(e,t,i){switch(t){case"world":for(const t of e.vertices)o.add(z,t.pos,e.offset),i.worldUpAtPosition(z,L),t.setFrameFromUpVector(L),t.computeRotationAxisAndAngleFromUpVector();break;case"path":o.add(z,e.vertices[0].pos,e.offset),i.worldUpAtPosition(z,L),P.computeMinimumRotationTangentFrame(e,L);for(const t of e.vertices){const e=s.sign(o.dot(t.frame.right,t.vRight));o.cross(t.rotationFrame.up,t.vRight,t.vLeft),o.scale(t.rotationFrame.up,t.rotationFrame.up,e),o.normalize(t.rotationFrame.up,t.rotationFrame.up);const i=o.dot(t.rotationFrame.up,t.frame.up),a=o.dot(t.rotationFrame.up,t.frame.right);if(o.scale(z,t.frame.up,-a),o.scale(I,t.frame.right,i),o.add(z,z,I),o.normalize(t.rotationFrame.right,z),P.vertexSpaceToProfileSpace(t.rotationRight,t.frame,t.rotationFrame.right),o.negate(z,t.vLeft),t.rotationAngle=-e*(Math.PI-s.acosClamped(o.dot(z,t.vRight))),Math.abs(t.rotationAngle)>0){const e=s.reciprocalClamped(Math.cos(.5*t.rotationAngle));w.set(t.miterStretch,1+(e-1)*t.rotationRight[0]*t.rotationRight[0],(e-1)*t.rotationRight[0]*t.rotationRight[1],(e-1)*t.rotationRight[0]*t.rotationRight[1],1+(e-1)*t.rotationRight[1]*t.rotationRight[1])}const r=Math.PI-t.rotationAngle;t.maxStretchDistance=Math.abs(Math.min(t.vLeftLength,t.vRightLength)*s.reciprocalClamped(Math.cos(.5*r)))}}}function R(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function E(e,t,i,a){let r=0;for(const s of e.vertices){const n=y.evaluateElevationAlignmentAtPoint(s.posES,i,t,a,F);r+=F.sampledElevation,o.add(L,s.pos,e.offset),a.setAltitude(n,L),o.subtract(s.pos,L,e.offset)}return e.updatePathVertexInformation(),r/e.vertices.length}function U(e,t,i,a){const r=e.stageObject,s=r.geometryRecords,n=s.length;let o=0;A.spatialReference=a.spatialReference;for(let e=0;e<n;e++){const n=s[e].geometry,l=n.metadata,c=l.pathGeometry,h=c.builder.path;l.geometrySR;o+=E(h,t,i,a),"world"!==h.upVector&&V(h,l.upVectorAlignment,a),c.onPathChanged(),n.invalidateBoundingInfo(),r.geometryVertexAttrsUpdated(e)}return o/n}C.validGeometryTypes=["polyline"];const A=d.makeDehydratedPoint(0,0,0,null),L=n.create(),z=u.create(),I=u.create(),G=3,B=3,k=10,F={verticalDistanceToGround:0,sampledElevation:0};e.Graphics3DPathSymbolLayer=C,e.NUM_CIRCLE_PROFILE_SUBDIVISIONS=k,e.NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS=B,e.NUM_ROUND_JOIN_SUBDIVISIONS=G,e.default=C,Object.defineProperty(e,"__esModule",{value:!0})}));
