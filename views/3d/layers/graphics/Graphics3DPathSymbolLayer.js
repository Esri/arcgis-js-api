/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/has","../../../../core/Error","../../../../core/mathUtils","../../../../core/maybe","../../../../chunks/mat2","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/projection","../../../../geometry/support/aaBoundingBox","../../../../layers/graphics/dehydratedFeatures","./elevationAlignmentUtils","./ElevationContext","./Graphics3DObject3DGraphicLayer","./Graphics3DPathSymbolLayerConstants","./Graphics3DSymbolLayer","./graphicUtils","./interfaces","../support/FastSymbolUpdates","../../webgl-engine/lib/basicInterfaces","../../webgl-engine/lib/DoubleArray","../../webgl-engine/lib/Object3D","../../webgl-engine/lib/PathGeometry","../../webgl-engine/lib/pathGeometryUtils","../../webgl-engine/materials/DefaultMaterial","../../webgl-engine/materials/PathMaterial"],(function(e,t,i,a,r,n,s,o,l,c,h,p,d,u,f,m,g,y,_,b,v,S,x,P,U,C,D,R,w){"use strict";const A=["polyline"];let V=function(e){function i(t,i,a,r){var n;return(n=e.call(this,t,i,a,r)||this)._intrinsicSize=l.fromValues(1,1),n._upVectorAlignment=C.UpVectorAlignment.Path,n._stencilWidth=.1,n.ensureDrapedStatus(!1),n}t._inheritsLoose(i,e);var r=i.prototype;return r.doLoad=function(){var e=t._asyncToGenerator((function*(){const e=n.isSome(this.symbolLayer.width)?this.symbolLayer.width:this.symbolLayer.height,t=n.isSome(this.symbolLayer.height)?this.symbolLayer.height:e;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[e,1,t],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=S.initFastSymbolUpdatesState(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const i=this.symbolLayer.anchor||"center";this._upVectorAlignment="heading"===this.symbolLayer.profileRotation?C.UpVectorAlignment.World:C.UpVectorAlignment.Path;const r=this.symbolLayer.profile||"circle";switch(r){default:case"circle":this._profile=D.createCircleProfile(y.PATH_NUM_CIRCLE_PROFILE_SUBDIVISIONS);break;case"quad":this._profile=D.creatQuadProfile()}let s=[0,0];switch("center"!==i&&(s={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[i],this._profile.translate(s[0],s[1])),this.symbolLayer.join){case"round":this._extruder=new D.MiterExtruder(0,y.PATH_NUM_ROUND_JOIN_SUBDIVISIONS);break;case"bevel":this._extruder=new D.MiterExtruder(0,1);break;case"miter":this._extruder=new D.MiterExtruder(.8*Math.PI,1);break;default:this._extruder=new D.SimpleExtruder}const c=this.symbolLayer.cap||"butt";switch(c){case"none":this._startCap=new D.NoCapBuilder,this._endCap=new D.NoCapBuilder;break;case"butt":default:this._startCap=new D.TriangulationCapBuilder(this._profile,0),this._endCap=new D.TriangulationCapBuilder(this._profile,0,!0);break;case"square":this._startCap=new D.TriangulationCapBuilder(this._profile,-.5),this._endCap=new D.TriangulationCapBuilder(this._profile,.5,!0);break;case"round":{const e="quad"===r;this._startCap=new D.RoundCapBuilder({profile:this._profile,flip:!1,breakNormals:e,subdivisions:y.PATH_NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS}),this._endCap=new D.RoundCapBuilder({profile:this._profile,flip:!0,breakNormals:e,subdivisions:y.PATH_NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS});break}}const p=n.get(this.symbolLayer,"material","color"),d=this._getCombinedOpacityAndColor(p),u=h.fromArray(d),f=d[3],m=f<1||this.needsDrivenTransparentPass,g={diffuse:u,ambient:u,opacity:f,transparent:m,hasVertexColors:!1,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:m||"none"===c?x.CullFaceOptions.None:x.CullFaceOptions.Back,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(o.set(this._intrinsicSize,e,t),!b.isValidSize(this._intrinsicSize[0])||!b.isValidSize(this._intrinsicSize[1])))throw new a("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");if(this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||o.scale(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled){const e={...g,...this._fastUpdates.materialParameters,size:l.fromArray(this._intrinsicSize)};this._material=new w.PathMaterial(e)}else g.hasVertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new R.DefaultMaterial(g);this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._material)}));function i(){return e.apply(this,arguments)}return i}(),r.destroy=function(){e.prototype.destroy.call(this),this._context.stage.remove(this._material),this._material=null},r.createGraphics3DGraphic=function(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,A,this.symbolLayer.type))return null;const i=this.setGraphicElevationContext(t,new m.ElevationContext),a=e.renderingInfo;return this._createAs3DShape(t,a,i,t.uid)},r.layerOpacityChanged=function(){const e=n.get(this.symbolLayer,"material","color"),t=this._getCombinedOpacity(e),i=t<1||this.needsDrivenTransparentPass;this._material.setParameters({opacity:t,transparent:i})},r.layerElevationInfoChanged=function(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,f.needsElevationUpdates3D)},r.slicePlaneEnabledChanged=function(){return this._material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),!0},r.physicalBasedRenderingChanged=function(){return this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0},r.pixelRatioChanged=function(){return!0},r.skipHighSymbolLodsChanged=function(){return!0},r.applyRendererDiff=function(e,t){for(const i in e.diff){if("visualVariables"!==i)return v.ApplyRendererDiffResult.Recreate_Symbol;if(!S.updateFastSymbolUpdatesState(this._fastUpdates,t,this._vvConvertOptions))return v.ApplyRendererDiffResult.Recreate_Symbol;this._material.setParameters(this._fastUpdates.materialParameters)}return v.ApplyRendererDiffResult.Fast_Update},r._getVertexData=function(e){let t=0;const i=e.paths,a=[],r=e.spatialReference,s=this._context.elevationProvider.spatialReference,o=this._context.renderCoordsHelper.spatialReference;for(const n of i)t+=n.length;const l=P.newDoubleArray(3*t),c=P.newDoubleArray(3*t);let h=0;for(const n of i){a.push({index:h,numVertices:n.length});for(const t of n)l[h++]=t[0],l[h++]=t[1],l[h++]=e.hasZ?t[2]:0}let d=!0;return n.isSome(s)&&!r.equals(s)&&(d=p.projectBuffer(l,r,0,l,s,0,t)),n.isSome(s)&&!s.equals(o)?p.projectBuffer(l,s,0,c,o,0,t):this._copyVertices(l,0,c,0,t),{pathVertexDataInfos:a,vertexDataES:l,vertexDataRS:c,projectionSuccess:d,terrainElevation:0}},r._copyVertices=function(e,t,i,a,r){t*=3,a*=3;for(let n=0;n<r;++n)i[a++]=e[t++],i[a++]=e[t++],i[a++]=e[t++]},r._createAs3DShape=function(e,t,i,a){const r=e.geometry,s=new Array,o=r.spatialReference,l=d.create(),h=this._context.renderCoordsHelper;B.spatialReference=o;const p=this._getVertexData(r);if(!p.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(0===p.pathVertexDataInfos.length)return 0!==r.paths.length&&r.paths.some((e=>e.length>0))||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)"),null;for(const g of p.pathVertexDataInfos){const r=g.index,u=g.numVertices;if(u<2)continue;if(n.isSome(this._context.clippingExtent)&&(d.empty(l),d.expandWithBuffer(l,p.vertexDataES,3*r,u),!d.intersectsClippingArea(l,this._context.clippingExtent)))continue;const m=[];for(let e=r;e<r+3*u;){const t=e++,a=e++,r=e++,n=new D.PathVertex;c.set(n.posES,p.vertexDataES[t],p.vertexDataES[a],p.vertexDataES[r]);const s=f.evaluateElevationAlignmentAtPoint(n.posES,this._context.elevationProvider,i,h);c.set(O,p.vertexDataRS[t],p.vertexDataRS[a],p.vertexDataRS[r]),h.setAltitude(O,s),c.copy(n.pos,O),m.push(n)}const y=new D.Path(m);L(y,this._upVectorAlignment,this._context.renderCoordsHelper);const b=new D.Builder(y,this._profile,this._extruder,this._startCap,this._endCap);let v=null;if(this._fastUpdates.enabled){const t=this._fastUpdates.visualVariables,i=t.size?_.getAttributeValue(t.size.field,e):0,a=t.color?_.getAttributeValue(t.color.field,e):0,r=t.opacity?_.getAttributeValue(t.opacity.field,e):0;v=new D.FastUpdatePathGeometry(b,i,a,r)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];if(this._drivenProperties.size){const i=t.size;e[0]*=E(i[0],"symbol-value"===i[2]?this.symbolLayer.height||0:i[2],this.symbolLayer.width||0),e[1]*=E(i[2],"symbol-value"===i[0]?this.symbolLayer.width||0:i[0],this.symbolLayer.height||0)}let i;this._drivenProperties.color&&(i=t.color),this._drivenProperties.opacity&&null!=t.opacity&&(i=i?[i[0],i[1],i[2],t.opacity]:[1,1,1,t.opacity]);const a=new D.StaticPathGeometry(b);a.bake(e),i&&a.bakeVertexColors(i),v=a}const{vertexAttributes:S,indices:x}=v.createGeometryData(),P=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:a,layerUid:this._context.layer.uid}),U=new C.PathGeometry(this._material,S,x,v,o,this._upVectorAlignment,this._stencilWidth,P);U.transformation=v.xform,s.push(U)}if(0===s.length)return null;const u={layerUid:this._context.layer.uid,graphicUid:a},m=new U.Object3D({geometries:s,metadata:u}),y=new g.Graphics3DObject3DGraphicLayer(this,m,s,null,null,M,i);return y.alignedSampledElevation=p.terrainElevation,y.needsElevationUpdates=f.needsElevationUpdates3D(i.mode),y},i}(_.Graphics3DSymbolLayer);function L(e,t,i){switch(t){default:case C.UpVectorAlignment.World:for(const t of e.vertices){c.add(O,t.pos,e.offset),i.worldUpAtPosition(O,O),t.setFrameFromUpVector(O),t.rotationFrameUp=t.frame.up,o.set(t.rotationRight,1,0),c.scale(O,t.frame.up,c.dot(t.frame.up,t.vLeft)),c.subtract(O,t.vLeft,O),c.negate(O,O),c.normalize(O,O),c.scale(k,t.frame.up,c.dot(t.frame.up,t.vRight)),c.subtract(k,t.vRight,k),c.normalize(k,k),c.cross(F,t.rotationFrameUp,t.vLeft);const a=Math.sign(c.dot(F,t.vRight));if(t.rotationAngle=a*(Math.PI-r.acosClamped(c.dot(O,k))),Math.abs(t.rotationAngle)>0){const e=r.reciprocalClamped(Math.cos(.5*t.rotationAngle));s.set(t.miterStretch,e-1+1,0,0,1)}const n=Math.PI-t.rotationAngle;t.maxStretchDistance=Math.abs(t.vMinSiblingLength/Math.cos(.5*n))}break;case C.UpVectorAlignment.Path:c.add(O,e.vertices[0].pos,e.offset),i.worldUpAtPosition(O,O),D.computeMinimumRotationTangentFrame(e,O);for(const t of e.vertices){const e=Math.sign(c.dot(t.frame.right,t.vRight));c.cross(t.rotationFrameUp,t.vRight,t.vLeft),c.scale(t.rotationFrameUp,t.rotationFrameUp,e),c.normalize(t.rotationFrameUp,t.rotationFrameUp);const i=c.dot(t.rotationFrameUp,t.frame.up),a=c.dot(t.rotationFrameUp,t.frame.right);if(c.scale(O,t.frame.up,-a),c.scale(k,t.frame.right,i),c.add(O,O,k),c.normalize(O,O),D.vertexSpaceToProfileSpace(t.rotationRight,t.frame,O),c.negate(O,t.vLeft),t.rotationAngle=-e*(Math.PI-r.acosClamped(c.dot(O,t.vRight))),Math.abs(t.rotationAngle)>0){const e=r.reciprocalClamped(Math.cos(.5*t.rotationAngle));s.set(t.miterStretch,1+(e-1)*t.rotationRight[0]*t.rotationRight[0],(e-1)*t.rotationRight[0]*t.rotationRight[1],(e-1)*t.rotationRight[0]*t.rotationRight[1],1+(e-1)*t.rotationRight[1]*t.rotationRight[1])}const n=Math.PI-t.rotationAngle;t.maxStretchDistance=Math.abs(t.vMinSiblingLength*r.reciprocalClamped(Math.cos(.5*n)))}}}function E(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function I(e,t,i,a){let r=0;for(const n of e.vertices)i(n.posES,G),r+=G.sampledElevation,c.add(O,n.pos,e.offset),a.setAltitude(O,G.z),c.subtract(n.pos,O,e.offset);return e.updatePathVertexInformation(),r/e.vertices.length}function M(e,t,i,a,r){const n=e.stageObject,s=n.geometries;let o=0;z.spatialReference=r.spatialReference;for(const l of s){if(!C.isPathGeometry(l))continue;const e=l.path,i=e.builder.path,s=l.geometrySR;B.spatialReference=s,o+=I(i,t,a,r),l.upVectorAlignment!==C.UpVectorAlignment.World&&L(i,l.upVectorAlignment,r),e.onPathChanged(),l.invalidateBoundingInfo(),n.geometryVertexAttrsUpdated(l)}return o/s.length}const z=u.makeDehydratedPoint(0,0,0,null),B=u.makeDehydratedPoint(0,0,0,null),O=h.create(),k=h.create(),F=h.create(),G=new f.SampleElevationInfo;e.Graphics3DPathSymbolLayer=V,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
