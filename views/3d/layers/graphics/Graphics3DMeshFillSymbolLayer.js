/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../Color","../../../../core/has","../../../../core/maybe","../../../../chunks/mat3","../../../../chunks/mat3f64","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../chunks/vec4f64","../../../../geometry/projection","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/MeshComponent","../../../../geometry/support/MeshMaterialMetallicRoughness","../../../../geometry/support/buffer/BufferView","../../../../chunks/vec32","../../../../geometry/support/meshUtils/projection","../../../../layers/graphics/dehydratedFeatures","../../../ViewingMode","../../glTF/internal/resourceUtils","../../glTF/internal/TextureTransformUtils","./ElevationAligners","./elevationAlignmentUtils","./ElevationContext","./Graphics3DObject3DGraphicLayer","./Graphics3DSymbolLayer","../support/edgeUtils","../support/symbolColorUtils","../../support/debugFlags","../../webgl-engine/lib/Attribute","../../webgl-engine/lib/basicInterfaces","../../webgl-engine/lib/ContentObjectType","../../webgl-engine/lib/FloatArray","../../webgl-engine/lib/Geometry","../../webgl-engine/lib/Indices","../../webgl-engine/lib/Object3D","../../webgl-engine/lib/Texture","../../webgl-engine/lib/VertexAttribute","../../webgl-engine/materials/DefaultMaterial","../../webgl-engine/materials/NativeLineMaterial","../../../webgl/enums"],(function(e,t,r,n,o,a,i,s,l,u,c,m,f,h,p,d,g,x,T,b,_,y,A,v,C,M,O,S,w,E,N,P,R,I,B,V,F,j,L,D,G,U,$){"use strict";const k=["mesh"];let H=function(e){function n(t,r,n,o){var a;return(a=e.call(this,t,r,n,o)||this)._materials=new Map,a._textures=new Map,a.ensureDrapedStatus(!1),a}t._inheritsLoose(n,e);var i=n.prototype;return i.doLoad=function(){var e=t._asyncToGenerator((function*(){N.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new U.NativeLineMaterial({color:[1,0,1,1]}),this._debugFaceNormalMaterial=new U.NativeLineMaterial({color:[0,1,1,1]}))}));function r(){return e.apply(this,arguments)}return r}(),i.destroy=function(){e.prototype.destroy.call(this),this._context.stage.removeMany(Array.from(this._materials.values(),(e=>e.material))),this._context.stage.removeMany(Array.from(this._textures.values())),this._materials.clear(),this._textures.clear()},i.createGraphics3DGraphic=function(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,k,"fill on mesh-3d"))return null;const r=this.setGraphicElevationContext(t,new M.ElevationContext),n=e.renderingInfo;return this._createAs3DShape(t,n,r,t.uid)},i.layerOpacityChanged=function(e,t){const r=this._getLayerOpacity();this._materials.forEach((e=>{e.material.setParameters({layerOpacity:r});const t=e.material.parameters;this._setMaterialTransparentParameter(t,e),e.material.setParameters({transparent:t.transparent})})),e.forEach((e=>{const n=t(e);o.isSome(n)&&n.layerOpacityChanged(r,this._context.isAsync)}))},i.layerElevationInfoChanged=function(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,C.needsElevationUpdates3D)},i.slicePlaneEnabledChanged=function(e,t){return this._materials.forEach((e=>{e.material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),e.forEach((e=>{const r=t(e);o.isSome(r)&&r.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0},i.physicalBasedRenderingChanged=function(){const e=this._usePBR();return this._materials.forEach((t=>t.material.setParameters({usePBR:e}))),!0},i.pixelRatioChanged=function(){return!0},i.skipHighSymbolLodsChanged=function(){return!0},i._requiresSymbolVertexColors=function(){return this._drivenProperties.color||this._drivenProperties.opacity},i._colorOrTextureUid=function(e){return o.isNone(e)?"-":e instanceof r?e.toHex():e.contentHash},i._materialPropertiesDefault=function(e,t){const r=this._requiresSymbolVertexColors(),n=!!e.vertexAttributes.color,o=!!e.vertexAttributes.tangent;return{hasSymbolVertexColors:r,hasVertexColors:n,hasVertexTangents:o,uid:`vc:${n},vt:${o},vct${t},svc:${r}`}},i._materialProperties=function(e,t,r){const n=this._materialPropertiesDefault(e,r);if(!t.material)return n;const{color:o,colorTexture:a,normalTexture:i,doubleSided:s,alphaCutoff:l,alphaMode:u}=t.material,c=this._colorOrTextureUid(o),m=this._colorOrTextureUid(a),f=this._colorOrTextureUid(i);if(n.color=o,n.colorTexture=a,n.normalTexture=i,n.uid=`${n.uid},cmuid:${c},ctmuid:${m},ntmuid:${f},ds:${s},ac:${l},am:${u}`,t.material instanceof d){const{metallic:e,roughness:r,metallicRoughnessTexture:o,emissiveColor:a,emissiveTexture:i,occlusionTexture:s}=t.material,l=this._colorOrTextureUid(o),u=this._colorOrTextureUid(a),c=this._colorOrTextureUid(i),m=this._colorOrTextureUid(s);n.metallic=e,n.roughness=r,n.metallicRoughnessTexture=o,n.emissiveColor=a,n.emissiveTexture=i,n.occlusionTexture=s,n.colorTextureTransform=t.material.colorTextureTransform,n.normalTextureTransform=t.material.normalTextureTransform,n.emissiveTextureTransform=t.material.emissiveTextureTransform,n.occlusionTextureTransform=t.material.occlusionTextureTransform,n.metallicRoughnessTextureTransform=t.material.metallicRoughnessTextureTransform,n.uid=`${n.uid},mrm:${e},mrr:${r},mrt:${l},emuid:${u},etmuid:${c},otmuid:${m}`}return n},i._setInternalColorValueParameters=function(e,t){t.diffuse=r.toUnitRGB(e),t.opacity=e.a},i._getLoadableTextureResource=function(e){return e.data?e.data:e.url},i._getInternalTextureId=function(e){const t=this._getInternalTexture(e,R.AlphaDiscardMode.Opaque);return o.isSome(t)?t.id:null},i._getInternalTexture=function(e,t){const r=this._getLoadableTextureResource(e);if(!r)return null;const n=`${e.contentHash}/${t}`;let a=this._textures.get(n);return a||(a=new L.Texture(y.isEncodedMeshTexture(r)?r.data:r,{mipmap:!0,wrap:this._castTextureWrap(e.wrap),noUnpackFlip:!0,preMultiplyAlpha:!y.isEncodedMeshTexture(r)&&t!==R.AlphaDiscardMode.Opaque,encoding:y.isEncodedMeshTexture(r)&&o.isSome(r.encoding)?r.encoding:void 0}),this._textures.set(n,a),this._context.stage.add(a),this._context.stage.loadImmediate(a)),a},i._castTextureWrap=function(e="repeat"){if("string"==typeof e){const t=this._castTextureWrapIndividual(e);return{s:t,t}}return{s:this._castTextureWrapIndividual(e.horizontal),t:this._castTextureWrapIndividual(e.vertical)}},i._castTextureWrapIndividual=function(e){switch(e){case"clamp":return $.TextureWrapMode.CLAMP_TO_EDGE;case"mirror":return $.TextureWrapMode.MIRRORED_REPEAT;default:return $.TextureWrapMode.REPEAT}},i._setInternalMaterialParameters=function(e,t){if(o.isSome(e.color)&&this._setInternalColorValueParameters(e.color,t),o.isSome(e.colorTexture)){const r=this._getInternalTexture(e.colorTexture,t.textureAlphaMode);o.isSome(r)?(t.textureId=r.id,t.textureAlphaPremultiplied=!!r.params.preMultiplyAlpha):t.textureId=void 0}o.isSome(e.normalTexture)&&(t.normalTextureId=this._getInternalTextureId(e.normalTexture)),o.isSome(e.emissiveColor)&&(t.emissiveFactor=r.toUnitRGB(e.emissiveColor)),o.isSome(e.emissiveTexture)&&(t.emissiveTextureId=this._getInternalTextureId(e.emissiveTexture)),o.isSome(e.occlusionTexture)&&(t.occlusionTextureId=this._getInternalTextureId(e.occlusionTexture)),o.isSome(e.metallicRoughnessTexture)&&(t.metallicRoughnessTextureId=this._getInternalTextureId(e.metallicRoughnessTexture)),t.colorTextureTransformMatrix=A.getTransformMatrix(e.colorTextureTransform),t.normalTextureTransformMatrix=A.getTransformMatrix(e.normalTextureTransform),t.occlusionTextureTransformMatrix=A.getTransformMatrix(e.occlusionTextureTransform),t.emissiveTextureTransformMatrix=A.getTransformMatrix(e.emissiveTextureTransform),t.metallicRoughnessTextureTransformMatrix=A.getTransformMatrix(e.metallicRoughnessTextureTransform)},i._setExternalMaterialParameters=function(e){const t=this._drivenProperties.color;let n=o.isSome(this.symbolLayer.material)?this.symbolLayer.material.colorMixMode:null;if(t)e.externalColor=m.ONES;else{const t=o.isSome(this.symbolLayer.material)?this.symbolLayer.material.color:null;o.isSome(t)?e.externalColor=r.toUnitRGBA(t):(n=null,e.externalColor=m.ONES)}n&&(e.colorMixMode=n),e.castShadows=!!this.symbolLayer.castShadows},i._hasTransparentVertexColors=function(e){const t=e.vertexAttributes.color;if(o.isNone(t))return!1;for(let r=3;r<t.length;r+=4)if(255!==t[r])return!0;return!1},i._getOrCreateMaterial=function(e,t){const r=t.material?.color,n=t.material?.colorTexture,a=t.material?.alphaMode,i="blend"===a,s=!("opaque"===a)&&(this._hasTransparentVertexColors(e)||o.isSome(r)&&r.a<1||o.isSome(n)&&n.transparent||i),l=this._materialProperties(e,t,s),u=this._materials.get(l.uid);if(u)return u.material;const m={material:null,isComponentTransparent:s,alphaMode:t.material?t.material.alphaMode:"opaque"},f=null==l.metallicRoughnessTexture&&null==l.metallic&&null==l.roughness,h={usePBR:this._usePBR(),isSchematic:f,hasVertexColors:l.hasVertexColors,hasSymbolColors:l.hasSymbolVertexColors,hasVertexTangents:l.hasVertexTangents,ambient:c.ZEROS,diffuse:c.ONES,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:R.CullFaceOptions.None,layerOpacity:this._getLayerOpacity(),hasSlicePlane:this._context.slicePlaneEnabled,initTextureTransparent:!0};f||(h.mrrFactors=[null!=l.metallic?l.metallic:1,null!=l.roughness?l.roughness:1,.5]),t.material&&(h.doubleSided=t.material.doubleSided,h.cullFace=t.material.doubleSided?R.CullFaceOptions.None:R.CullFaceOptions.Back,h.textureAlphaCutoff=t.material.alphaCutoff),this._setExternalMaterialParameters(h),this._setMaterialTransparentParameter(h,m),this._setInternalMaterialParameters(l,h);const p=new G.DefaultMaterial(h);return m.material=p,this._materials.set(l.uid,m),this._context.stage.add(p),p},i._usePBR=function(){return this._context.physicalBasedRenderingEnabled},i._setMaterialTransparentParameter=function(e,t){e.transparent=this.needsDrivenTransparentPass||t.isComponentTransparent||e.layerOpacity<1||e.opacity<1||e.externalColor&&e.externalColor[3]<1,"auto"===t.alphaMode?e.textureAlphaMode=e.transparent?R.AlphaDiscardMode.MaskBlend:R.AlphaDiscardMode.Opaque:e.textureAlphaMode="opaque"===t.alphaMode?R.AlphaDiscardMode.Opaque:"mask"===t.alphaMode?R.AlphaDiscardMode.Mask:R.AlphaDiscardMode.Blend},i._addDebugNormals=function(e,t){const r=t.length,n=e.spatialReference.isGeographic?20015077/180:1,o=.1*Math.max(e.extent.width*n,e.extent.height*n,e.extent.zmax-e.extent.zmin),a=[],i=[],s=[],l=[];for(let h=0;h<r;h++){const e=t[h],r=e.vertexAttributes.get(D.VertexAttribute.POSITION),n=e.vertexAttributes.get(D.VertexAttribute.NORMAL),c=e.indices.get(D.VertexAttribute.POSITION),m=e.indices.get(D.VertexAttribute.NORMAL),f=r.data,p=n.data;for(let t=0;t<c.length;t++){const e=3*c[t],r=3*m[t];for(let t=0;t<3;t++)a.push(f[e+t]);for(let t=0;t<3;t++)a.push(f[e+t]+p[r+t]*o);if(i.push(i.length),i.push(i.length),t%3==0){this._calculateFaceNormal(f,c,t,J),this._getFaceVertices(f,c,t,z,Y,Z),u.add(z,z,Y),u.add(z,z,Z),u.scale(z,z,1/3);for(let e=0;e<3;e++)s.push(z[e]);for(let e=0;e<3;e++)s.push(z[e]+J[e]*o);l.push(l.length),l.push(l.length)}}}const c=t[0].transformation,m=new V.Geometry(this._debugVertexNormalMaterial,[[D.VertexAttribute.POSITION,new P.Attribute(a,3,!0)]],[[D.VertexAttribute.POSITION,i]],null,I.ContentObjectType.Line);t.push(m),m.transformation=c;const f=new V.Geometry(this._debugFaceNormalMaterial,[[D.VertexAttribute.POSITION,new P.Attribute(s,3,!0)]],[[D.VertexAttribute.POSITION,l]],null,I.ContentObjectType.Line);f.transformation=c,t.push(f)},i._createAs3DShape=function(e,t,r,n){const a=e.geometry;if("mesh"!==a.type)return null;const i=this._createGeometryInfo(a,t,n);if(o.isNone(i))return null;const{geometries:s,objectTransformation:l}=i;N.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(a,s);const u=new j.Object3D({geometries:s,metadata:{layerUid:this._context.layer.uid,graphicUid:n}});u.transformation=l;const c=w.createMaterial(this.symbolLayer,{opacity:this._getLayerOpacity()}),m=o.isSome(c)?new O.Object3DEdgeState(s[0].material,[c],{mergeGeometries:!0,hasSlicePlane:this._context.slicePlaneEnabled}):null,f=new O.Graphics3DObject3DGraphicLayer(this,u,s,null,null,v.perObjectElevationAligner,r,m);f.needsElevationUpdates=C.needsElevationUpdates3D(r.mode),f.useObjectOriginAsAttachmentOrigin=!0,r.centerPointInElevationSR=this._getCenterPointInElevationSR(u);const{elevationProvider:h,renderCoordsHelper:p}=this._context,d=(e,t)=>C.evaluateElevationInfoAtPoint(e,h,r,p,t);return f.alignedSampledElevation=v.perObjectElevationAligner(f,r,h.spatialReference,d,p),f},i._getCenterPointInElevationSR=function(e){const t=b.makeDehydratedPoint(0,0,0,o.isSome(this._context.elevationProvider.spatialReference)?this._context.elevationProvider.spatialReference:null);return f.projectVectorToDehydratedPoint([e.transformation[12],e.transformation[13],e.transformation[14]],this._context.renderCoordsHelper.spatialReference,t),t},i._createComponentNormals=function(e,t,r,n){switch(r.shading||"flat"){default:case"source":return this._createComponentNormalsSource(e,t,r,n);case"flat":return this._createComponentNormalsFlat(e,n);case"smooth":return this._createComponentNormalsSmooth(e,n)}},i._createComponentNormalsSource=function(e,t,r,n){if(o.isNone(t))return this._createComponentNormalsFlat(e,n);let a=!1;if(!r.trustSourceNormals)for(let o=0;o<n.length;o+=3){this._calculateFaceNormal(e,n,o,J);for(let e=0;e<3;e++){const r=3*n[o+e];z[0]=t[r+0],z[1]=t[r+1],z[2]=t[r+2],u.dot(J,z)<0&&(t[r+0]=-t[r+0],t[r+1]=-t[r+1],t[r+2]=-t[r+2],a=!0)}}return new W(t,n,a)},i._createComponentNormalsFlat=function(e,t){const r=B.newFloatArray(t.length),n=new Array(3*t.length);for(let o=0;o<t.length;o+=3){const a=this._calculateFaceNormal(e,t,o,J);for(let e=0;e<3;e++)r[o+e]=a[e],n[o+e]=o/3}return new W(r,n,!1)},i._createComponentNormalsSmooth=function(e,t){const r={};for(let a=0;a<t.length;a+=3){const n=this._calculateFaceNormal(e,t,a,J);for(let e=0;e<3;e++){const o=t[a+e];let i=r[o];i||(i={normal:c.create(),count:0},r[o]=i),u.add(i.normal,i.normal,n),i.count++}}const n=B.newFloatArray(3*t.length),o=new Array(3*t.length);for(let a=0;a<t.length;a++){const e=r[t[a]];1!==e.count&&(u.normalize(e.normal,e.normal),e.count=1);for(let t=0;t<3;t++)n[3*a+t]=e.normal[t];o[a]=a}return new W(n,o,!1)},i._getFaceVertices=function(e,t,r,n,o,a){const i=3*t[r+0],s=3*t[r+1],l=3*t[r+2];n[0]=e[i+0],n[1]=e[i+1],n[2]=e[i+2],o[0]=e[s+0],o[1]=e[s+1],o[2]=e[s+2],a[0]=e[l+0],a[1]=e[l+1],a[2]=e[l+2]},i._calculateFaceNormal=function(e,t,r,n){return this._getFaceVertices(e,t,r,z,Y,Z),u.subtract(Y,Y,z),u.subtract(Z,Z,z),u.cross(z,Y,Z),u.normalize(n,z),n},i._getOrCreateComponents=function(e){return o.unwrapOr(e.components,ee)},i._createPositionBuffer=function(e,t){let r=e.vertexAttributes.position;const n=t.reprojection===te.ECEF?t.transformBeforeProject:null;if(o.isSome(n)&&(r=T.transformPosition(r,new Float64Array(r.length),n)),t.reprojection===te.NONE)return t.needsBufferCopy?new Float64Array(r):r;const a=o.isSome(n)?r:new Float64Array(r.length);return f.projectBuffer(r,e.spatialReference,0,a,this._context.renderCoordsHelper.spatialReference,0,r.length/3),a},i._createNormalBuffer=function(e,t,r){let n=e.vertexAttributes.normal;if(o.isNone(n))return null;const a=r.reprojection===te.ECEF?r.transformBeforeProject:null;o.isSome(a)&&(n=T.transformNormal(n,new Float32Array(n.length),a));if("local"===this._context.graphicsCoreOwner.view.viewingMode||r.reprojection===te.NONE)return r.needsBufferCopy&&e.vertexAttributes.normal===n?new Float32Array(n):n;const i=e.vertexAttributes.position,s=o.isSome(a)?n:new Float32Array(n.length);return T.projectNormalToPCPF(n,i,t,e.spatialReference,s)},i._createTangentBuffer=function(e,t,r){let n=e.vertexAttributes.tangent;if(o.isNone(n))return null;const a=r.reprojection===te.ECEF?r.transformBeforeProject:null;o.isSome(a)&&(n=T.transformTangent(n,new Float32Array(n.length),a));if("local"===this._context.graphicsCoreOwner.view.viewingMode||r.reprojection===te.NONE)return r.needsBufferCopy&&e.vertexAttributes.normal===n?new Float32Array(n):n;const i=e.vertexAttributes.position,s=o.isSome(a)?n:new Float32Array(n.length);return T.projectTangentToPCPF(n,i,t,e.spatialReference,s)},i._createColorBuffer=function(e){return e.vertexAttributes.color},i._createSymbolColorBuffer=function(e){if(this._requiresSymbolVertexColors()){const t=this._getVertexOpacityAndColor(e),r=E.parseColorMixMode(o.get(this.symbolLayer,"material","colorMixMode")),n=new Uint8Array(4);return E.encodeSymbolColor(t,r,n),n}return null},i._createBuffers=function(e,t){const r=e.vertexAttributes&&e.vertexAttributes.position;if(!r)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;const n=e.vertexAttributes.normal,a=e.vertexAttributes.uv,i=e.vertexAttributes.tangent;if(o.isSome(n)&&n.length!==r.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(o.isSome(i)&&i.length/4!=r.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(o.isSome(a)&&a.length/2!=r.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;const s=this._computeReprojectionInfo(e),u=this._createPositionBuffer(e,s),c=this._createColorBuffer(e),m=this._createSymbolColorBuffer(t),f=this._createNormalBuffer(e,u,s),h=this._createTangentBuffer(e,u,s);return{positionBuffer:u,normalBuffer:f,tangentBuffer:h,uvBuffer:a,colorBuffer:c,symbolColorBuffer:m,objectTransformation:s.reprojection===te.NONE&&o.isSome(s.objectTransformation)?s.objectTransformation:this._transformOriginLocal(e,u,f,h),geometryTransformation:s.reprojection===te.NONE&&o.isSome(s.geometryTransformation)?s.geometryTransformation:l.create()}},i._computeReprojectionInfo=function(e){const t=o.isSome(e.transform),r=t&&e.transform.geographic||this._context.renderCoordsHelper.viewingMode===_.ViewingMode.Local?te.NONE:te.ECEF;if(t){if(r===te.NONE){const t=l.create();f.computeTranslationToOriginAndRotation(e.spatialReference,e.transform.origin,t,this._context.renderCoordsHelper.spatialReference);return{reprojection:r,objectTransformation:t,geometryTransformation:l.clone(e.transform.localMatrix),needsBufferCopy:!1}}const t=s.fromTranslation(l.create(),e.transform.origin);return s.multiply(t,t,e.transform.localMatrix),{reprojection:r,transformBeforeProject:t,needsBufferCopy:!0}}return{reprojection:r,needsBufferCopy:!0}},i._transformOriginLocal=function(e,t,r,n){const i=this._context.renderCoordsHelper.spatialReference,u=e.anchor;q[0]=u.x,q[1]=u.y,q[2]=u.z;const c=l.create();f.computeTranslationToOriginAndRotation(e.spatialReference,q,c,i);const m=g.BufferViewVec3f64.fromTypedArray(t);if(s.invert(K,c),x.transformMat4(m,m,K),o.isSome(r)||o.isSome(n)){if(a.fromMat4(Q,c),a.transpose(Q,Q),o.isSome(r)){const e=g.BufferViewVec3f.fromTypedArray(r);x.transformMat3(e,e,Q)}if(o.isSome(n)){const e=g.BufferViewVec3f.fromTypedArray(n,4*n.BYTES_PER_ELEMENT);x.transformMat3(e,e,Q)}}return c},i._validateFaces=function(e,t){const r=e.vertexAttributes.position.length/3,n=t.faces;if(n){let e=-1;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}if(r<=e)return this.logger.warn(`Vertex index ${e} is out of bounds of the mesh position buffer`),!1}else if(r%3!=0)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),!1;return!0},i._getOrCreateFaces=function(e,t){return t.faces?t.faces:F.generateDefaultIndexArray(e.vertexAttributes.position.length/3)},i._isOutsideClippingArea=function(e){if(!this._context.clippingExtent)return!1;const t=e.vertexAttributes&&e.vertexAttributes.position;if(!t)return!1;const r=this._context.elevationProvider.spatialReference;let n;const a=t.length/3;return o.isSome(r)&&!e.spatialReference.equals(r)?(n=new Float64Array(t.length),f.projectBuffer(e.vertexAttributes.position,e.spatialReference,0,n,r,0,a)):n=t,h.empty(X),h.expandWithBuffer(X,n,0,a),!h.intersectsClippingArea(X,this._context.clippingExtent)},i._createGeometryInfo=function(e,t,r){if(!f.canProjectWithoutEngine(e.spatialReference,this._context.graphicsCoreOwner.view.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(this._isOutsideClippingArea(e))return null;const n=this._createBuffers(e,t);if(o.isNone(n))return null;const{positionBuffer:a,uvBuffer:i,colorBuffer:s,symbolColorBuffer:l,normalBuffer:u,tangentBuffer:c,objectTransformation:m,geometryTransformation:h}=n,p=this._getOrCreateComponents(e),d=new Array;let g=!1;for(const f of p){if(!this._validateFaces(e,f))return null;const t=this._getOrCreateFaces(e,f);if(0===t.length)continue;const n=this._createComponentNormals(a,u,f,t);n.didFlipNormals&&(g=!0);const m=[[D.VertexAttribute.POSITION,new P.Attribute(a,3,!0)],[D.VertexAttribute.NORMAL,new P.Attribute(n.normals,3,!0)]],p=[[D.VertexAttribute.POSITION,t],[D.VertexAttribute.NORMAL,n.indices]];o.isSome(s)&&(m.push([D.VertexAttribute.COLOR,new P.Attribute(s,4,!0)]),p.push([D.VertexAttribute.COLOR,t])),o.isSome(l)&&(m.push([D.VertexAttribute.SYMBOLCOLOR,new P.Attribute(l,4,!0)]),p.push([D.VertexAttribute.SYMBOLCOLOR,new Array(t.length).fill(0)])),o.isSome(i)&&(m.push([D.VertexAttribute.UV0,new P.Attribute(i,2,!0)]),p.push([D.VertexAttribute.UV0,t])),o.isSome(c)&&(m.push([D.VertexAttribute.TANGENT,new P.Attribute(c,4,!0)]),p.push([D.VertexAttribute.TANGENT,t]));const x=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:r,layerUid:this._context.layer.uid}),T=this._getOrCreateMaterial(e,f),b=new V.Geometry(T,m,p,null,I.ContentObjectType.Mesh,x);b.transformation=h,d.push(b)}return g&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."),{geometries:d,objectTransformation:m}},n}(S.Graphics3DSymbolLayer),W=function(e,t,r){this.normals=e,this.indices=t,this.didFlipNormals=r};const q=c.create(),z=c.create(),Y=c.create(),Z=c.create(),J=c.create(),K=l.create(),Q=i.create(),X=h.create(),ee=[new p];var te;!function(e){e[e.NONE=0]="NONE",e[e.ECEF=1]="ECEF"}(te||(te={})),e.Graphics3DMeshFillSymbolLayer=H,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
