/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/has","../../../../core/maybe","../../../../Color","../../../../chunks/vec3f64","../../../../chunks/vec3","../../../../chunks/mat4","../../../../geometry/projection","../../../../chunks/mat3f64","../../../../chunks/mat4f64","../../../../chunks/vec4f64","../../../../geometry/support/MeshMaterialMetallicRoughness","../../../../geometry/support/MeshComponent","../../../../chunks/mat3","../../../../geometry/support/meshUtils/projection","../../../../geometry/support/aaBoundingBox","../../webgl-engine/lib/Util","../../webgl-engine/lib/GeometryData","../../webgl-engine/lib/Object3D","../../support/debugFlags","./elevationAlignmentUtils","./ElevationAligners","./ElevationContext","./Graphics3DObject3DGraphicLayer","../../webgl-engine/lib/Geometry","../support/edgeUtils","./Graphics3DSymbolLayer","../../webgl-engine/materials/DefaultMaterial","../../webgl-engine/lib/Texture","../support/symbolColorUtils","../../webgl-engine/materials/NativeLineMaterial"],(function(e,t,r,a,n,o,i,s,l,c,u,h,m,f,d,p,g,x,_,b,y,v,T,C,M,w,A,O,N,S,I,E){"use strict";const P=x.VertexAttrConstants;let R=function(e){function r(t,r,a,n){var o;return(o=e.call(this,t,r,a,n)||this)._materials=new Map,o._textures=new Map,o.ensureDrapedStatus(!1),o}t._inheritsLoose(r,e);var c=r.prototype;return c.doLoad=async function(){y.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new E.NativeLineMaterial({color:[1,0,1,1]},"debugVertexNormal"),this._debugFaceNormalMaterial=new E.NativeLineMaterial({color:[0,1,1,1]},"debugFAceNormal"))},c.destroy=function(){e.prototype.destroy.call(this),this._materials.forEach((e=>{this._context.stage.remove(3,e.material.id)})),this._textures.forEach((e=>{this._context.stage.remove(4,e.id)})),this._materials.clear(),this._textures.clear()},c.createGraphics3DGraphic=function(e){const t=e.graphic;if(!this._validateGeometryType(t.geometry,r.validGeometryTypes,"fill on mesh-3d"))return null;if(!this._validateGeometry(t.geometry))return null;const a="graphic"+t.uid,n=this.setGraphicElevationContext(t,new C.ElevationContext),o=e.renderingInfo;return this._createAs3DShape(t,o,n,a,t.uid)},c.layerOpacityChanged=function(e,t){const r=this._getLayerOpacity();return this._materials.forEach((e=>{e.material.setParameterValues({layerOpacity:r});const t=e.material.params;this._setMaterialTransparentParameter(t,e),e.material.setParameterValues({transparent:t.transparent})})),e.forEach((e=>{const n=t(e);a.isSome(n)&&n.layerOpacityChanged(r,this._context.isAsync)})),!0},c.layerElevationInfoChanged=function(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,v.needsElevationUpdates3D)},c.slicePlaneEnabledChanged=function(e,t){return this._materials.forEach((e=>{e.material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled})})),e.forEach((e=>{const r=t(e);a.isSome(r)&&r.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0},c.physicalBasedRenderingChanged=function(){return this._materials.forEach((e=>{const{isSchematic:t}=e.material.params;e.material.setParameterValues({usePBR:this._usePBR(t)})})),!0},c.pixelRatioChanged=function(){return!0},c._requiresSymbolVertexColors=function(){return this._drivenProperties.color||this._drivenProperties.opacity},c._colorOrTextureUid=function(e){return e?e instanceof n?e.toHex():e.contentHash:"-"},c._materialPropertiesDefault=function(e,t){const r=this._requiresSymbolVertexColors(),a=!!e.vertexAttributes.color,n=!!e.vertexAttributes.tangent;return{hasSymbolVertexColors:r,hasVertexColors:a,hasVertexTangents:n,uid:`vc:${a},vt:${n},vct${t},svc:${r}`}},c._materialProperties=function(e,t,r){const a=this._materialPropertiesDefault(e,r);if(!t.material)return a;const{color:n,colorTexture:o,normalTexture:i,doubleSided:s,alphaCutoff:l,alphaMode:c}=t.material,u=this._colorOrTextureUid(n),h=this._colorOrTextureUid(o),f=this._colorOrTextureUid(i);if(a.color=n,a.colorTexture=o,a.normalTexture=i,a.uid=`${a.uid},cmuid:${u},ctmuid:${h},ntmuid:${f},ds:${s},ac:${l},am:${c}`,t.material instanceof m){const{metallic:e,roughness:r,metallicRoughnessTexture:n,emissiveColor:o,emissiveTexture:i,occlusionTexture:s}=t.material,l=this._colorOrTextureUid(n),c=this._colorOrTextureUid(o),u=this._colorOrTextureUid(i),h=this._colorOrTextureUid(s);a.metallic=e,a.roughness=r,a.metallicRoughnessTexture=n,a.emissiveColor=o,a.emissiveTexture=i,a.occlusionTexture=s,a.uid=`${a.uid},mrm:${e},mrr:${r},mrt:${l},emuid:${c},etmuid:${u},otmuid:${h}`}return a},c._setInternalColorValueParameters=function(e,t){t.diffuse=n.toUnitRGB(e),t.opacity=e.a},c._getLoadableTextureResource=function(e){return e.data?e.data:e.url},c._getInternalTextureId=function(e,t){const r=this._getLoadableTextureResource(e);if(!r)return;const a=e.contentHash;let n=this._textures.get(a);return n||(n=new S(r,`${t}_${a}_tex`,{mipmap:!0,wrap:this._castTextureWrap(e.wrap),noUnpackFlip:!0,preMultiplyAlpha:!0}),this._textures.set(a,n),this._context.stage.add(4,n)),n.id},c._castTextureWrap=function(e="repeat"){if("string"==typeof e){const t=this._castTextureWrapIndividual(e);return{s:t,t:t}}return{s:this._castTextureWrapIndividual(e.horizontal),t:this._castTextureWrapIndividual(e.vertical)}},c._castTextureWrapIndividual=function(e){switch(e){case"clamp":return 33071;case"mirror":return 33648;case"repeat":default:return 10497}},c._setInternalMaterialParameters=function(e,t,r){e.color&&this._setInternalColorValueParameters(e.color,r),e.colorTexture&&(r.textureId=this._getInternalTextureId(e.colorTexture,t)),e.normalTexture&&(r.normalTextureId=this._getInternalTextureId(e.normalTexture,t)),e.emissiveColor&&(r.emissiveFactor=n.toUnitRGB(e.emissiveColor)),e.emissiveTexture&&(r.emissiveTextureId=this._getInternalTextureId(e.emissiveTexture,t)),e.occlusionTexture&&(r.occlusionTextureId=this._getInternalTextureId(e.occlusionTexture,t)),e.metallicRoughnessTexture&&(r.metallicRoughnessTextureId=this._getInternalTextureId(e.metallicRoughnessTexture,t))},c._setExternalMaterialParameters=function(e){const t=this._drivenProperties.color;let r=a.isSome(this.symbolLayer.material)?this.symbolLayer.material.colorMixMode:null;if(t)e.externalColor=h.ONES;else{const t=a.isSome(this.symbolLayer.material)?this.symbolLayer.material.color:null;a.isSome(t)?e.externalColor=n.toUnitRGBA(t):(r=null,e.externalColor=h.ONES)}r&&(e.colorMixMode=r),e.castShadows=!!this.symbolLayer.castShadows},c._hasTransparentVertexColors=function(e){const t=e.vertexAttributes.color;if(!t)return!1;for(let e=3;e<t.length;e+=4)if(255!==t[e])return!0;return!1},c._getOrCreateMaterial=function(e,t){const r=t.material&&t.material.color,a=t.material&&t.material.colorTexture,n=t.material&&"blend"===t.material.alphaMode,i=!(t.material&&"opaque"===t.material.alphaMode)&&(this._hasTransparentVertexColors(e)||r&&r.a<1||a&&a.transparent||n),s=this._materialProperties(e,t,i),l=this._materials.get(s.uid);if(l)return l.material;const c={material:null,isComponentTransparent:i,alphaMode:t.material?t.material.alphaMode:"opaque"},u=this._getIdHint(),h=null==s.metallicRoughnessTexture&&null==s.metallic&&null==s.roughness,m={usePBR:this._usePBR(h),isSchematic:h,vertexColors:s.hasVertexColors,symbolColors:s.hasSymbolVertexColors,vertexTangents:s.hasVertexTangents,ambient:o.ZEROS,diffuse:o.ONES,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:0,textureAlphaPremultiplied:!0,layerOpacity:this._getLayerOpacity(),slicePlaneEnabled:this._context.slicePlaneEnabled,initTextureTransparent:!0};h||(m.mrrFactors=[null!=s.metallic?s.metallic:1,null!=s.roughness?s.roughness:1,.5]),t.material&&(m.doubleSided=t.material.doubleSided,m.cullFace=t.material.doubleSided?0:2,m.textureAlphaCutoff=t.material.alphaCutoff),this._setInternalMaterialParameters(s,u,m),this._setExternalMaterialParameters(m),this._setMaterialTransparentParameter(m,c);const f=new N.DefaultMaterial(m,`${u}_${s.uid}_mat`);return c.material=f,this._materials.set(s.uid,c),this._context.stage.add(3,f),f},c._usePBR=function(e){return!e||this._context.physicalBasedRenderingEnabled},c._setMaterialTransparentParameter=function(e,t){e.transparent=this.needsDrivenTransparentPass||t.isComponentTransparent||e.layerOpacity<1||e.opacity<1||e.externalColor&&e.externalColor[3]<1,"auto"===t.alphaMode?e.textureAlphaMode=e.transparent?3:1:e.textureAlphaMode="opaque"===t.alphaMode?1:"mask"===t.alphaMode?2:0},c._addDebugNormals=function(e,t,r,a){const n=t.length,o=e.spatialReference.isGeographic?20015077/180:1,s=.1*Math.max(e.extent.width*o,e.extent.height*o,e.extent.zmax-e.extent.zmin),l=[],c=[],h=[],m=[];for(let e=0;e<n;e++){const r=t[e],a=r.data.getAttribute(P.POSITION),n=r.data.getAttribute(P.NORMAL),o=r.data.getIndices(P.POSITION),u=r.data.getIndices(P.NORMAL),f=a.data,d=n.data;for(let e=0;e<o.length;e++){const t=3*o[e],r=3*u[e];for(let e=0;e<3;e++)l.push(f[t+e]);for(let e=0;e<3;e++)l.push(f[t+e]+d[r+e]*s);if(c.push(c.length),c.push(c.length),e%3==0){this._calculateFaceNormal(f,o,e,G),this._getFaceVertices(f,o,e,F,L,V),i.add(F,F,L),i.add(F,F,V),i.scale(F,F,1/3);for(let e=0;e<3;e++)h.push(F[e]);for(let e=0;e<3;e++)h.push(F[e]+G[e]*s);m.push(m.length),m.push(m.length)}}}{const e={[P.POSITION]:{data:new Float64Array(l),size:3}},n={[P.POSITION]:new Uint32Array(c)},o=new _.GeometryData(e,n,"line"),i=new w(o,"debugVertexNormal");t.push(i),r.push(this._debugVertexNormalMaterial),a.push(u.clone(a[0]))}{const e={[P.POSITION]:{data:new Float64Array(h),size:3}},n={[P.POSITION]:new Uint32Array(m)},o=new _.GeometryData(e,n,"line"),i=new w(o,"debugFaceNormal");t.push(i),r.push(this._debugFaceNormalMaterial),a.push(u.clone(a[0]))}},c._createAs3DShape=function(e,t,r,n,o){const i=e.geometry;if("mesh"!==i.type)return null;const s=this._createGeometryInfo(i,t,n);if(!s)return null;const{geometries:l,materials:c,transformations:u,objectTransformation:h}=s;y.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(i,l,c,u);const m=new b({geometries:l,materials:c,transformations:u,castShadow:!0,metadata:{layerUid:this._context.layer.uid,graphicUid:o},idHint:n});m.objectTransformation=h;const f=T.perObjectElevationAligner,d=this._createEdgeMaterial(),p=a.isSome(d)?{baseMaterial:c[0],edgeMaterials:[d],properties:{mergeGeometries:!0,slicePlaneEnabled:this._context.slicePlaneEnabled}}:null,g=new M(this,m,l,null,null,f,r,p);g.needsElevationUpdates=v.needsElevationUpdates3D(r.mode);const x=i.extent.center.clone();return x.z=0,g.elevationContext.centerPointInElevationSR=x,g.alignedSampledElevation=f(g,g.elevationContext,this._context.elevationProvider,this._context.renderCoordsHelper),g},c._createComponentNormals=function(e,t,r,a){switch(r.shading||"flat"){case"source":return this._createComponentNormalsSource(e,t,r,a);case"flat":return this._createComponentNormalsFlat(e,a);case"smooth":return this._createComponentNormalsSmooth(e,a);default:return}},c._createComponentNormalsSource=function(e,t,r,a){if(!t)return this._createComponentNormalsFlat(e,a);let n=!1;if(!r.trustSourceNormals)for(let r=0;r<a.length;r+=3){this._calculateFaceNormal(e,a,r,G);for(let e=0;e<3;e++){const o=3*a[r+e];F[0]=t[o+0],F[1]=t[o+1],F[2]=t[o+2],i.dot(G,F)<0&&(t[o+0]=-t[o+0],t[o+1]=-t[o+1],t[o+2]=-t[o+2],n=!0)}}return{normals:t,indices:a,didFlipNormals:n}},c._createComponentNormalsFlat=function(e,t){const r=new Float32Array(t.length),a=new Uint32Array(3*t.length);for(let n=0;n<t.length;n+=3){const o=this._calculateFaceNormal(e,t,n,G);for(let e=0;e<3;e++)r[n+e]=o[e],a[n+e]=n/3}return{normals:r,indices:a,didFlipNormals:!1}},c._createComponentNormalsSmooth=function(e,t){const r={};for(let a=0;a<t.length;a+=3){const n=this._calculateFaceNormal(e,t,a,G);for(let e=0;e<3;e++){const s=t[a+e];let l=r[s];l||(l={normal:o.create(),count:0},r[s]=l),i.add(l.normal,l.normal,n),l.count++}}const a=new Float32Array(3*t.length),n=new Uint32Array(3*t.length);for(let e=0;e<t.length;e++){const o=r[t[e]];1!==o.count&&(i.normalize(o.normal,o.normal),o.count=1);for(let t=0;t<3;t++)a[3*e+t]=o.normal[t];n[e]=e}return{normals:a,indices:n,didFlipNormals:!1}},c._getFaceVertices=function(e,t,r,a,n,o){const i=3*t[r+0],s=3*t[r+1],l=3*t[r+2];a[0]=e[i+0],a[1]=e[i+1],a[2]=e[i+2],n[0]=e[s+0],n[1]=e[s+1],n[2]=e[s+2],o[0]=e[l+0],o[1]=e[l+1],o[2]=e[l+2]},c._calculateFaceNormal=function(e,t,r,a){return this._getFaceVertices(e,t,r,F,L,V),i.subtract(L,L,F),i.subtract(V,V,F),i.cross(F,L,V),i.normalize(a,F),a},c._getOrCreateComponents=function(e){return e.components?e.components:j},c._createPositionBuffer=function(e){const t=e.vertexAttributes.position,r=new Float64Array(t.length),a=this._context.renderCoordsHelper.spatialReference;return l.projectBuffer(e.vertexAttributes.position,e.spatialReference,0,r,a,0,t.length/3),r},c._createNormalBuffer=function(e,t){const r=e.vertexAttributes.normal;if(!r)return null;if("local"===this._context.layerView.view.viewingMode)return r;const a=e.vertexAttributes.position,n=new Float32Array(r.length);return p.projectNormalToECEF(r,a,t,e.spatialReference,n)},c._createTangentBuffer=function(e,t){const r=e.vertexAttributes.tangent;if(!r)return null;if("local"===this._context.layerView.view.viewingMode)return r;const a=e.vertexAttributes.position,n=new Float32Array(r.length);return p.projectTangentToECEF(r,a,t,e.spatialReference,n)},c._createColorBuffer=function(e){return e.vertexAttributes.color},c._createSymbolColorBuffer=function(e){if(this._requiresSymbolVertexColors()){const t=this._getVertexOpacityAndColor(e),r=I.parseColorMixMode(a.get(this.symbolLayer,"material","colorMixMode")),n=new Uint8Array(4);return I.encodeSymbolColor(t,r,n),n}return null},c._createColorIndices=function(e){const t=new Uint32Array(e.length);for(let e=0;e<t.length;e++)t[e]=0;return t},c._createBuffers=function(e,t){const r=e.vertexAttributes&&e.vertexAttributes.position;if(!r)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;const a=e.vertexAttributes.normal,n=e.vertexAttributes.uv,o=e.vertexAttributes.tangent;if(a&&a.length!==r.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(o&&o.length/4!=r.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(n&&n.length/2!=r.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;const i=this._createPositionBuffer(e),s=this._createColorBuffer(e),l=this._createSymbolColorBuffer(t),c=this._createNormalBuffer(e,i);return{positionBuffer:i,normalBuffer:c,tangentBuffer:this._createTangentBuffer(e,i),uvBuffer:n,colorBuffer:s,symbolColorBuffer:l,objectTransformation:this._transformCenterLocal(e,i,c)}},c._transformCenterLocal=function(e,t,r){const a=e.extent.center,n=this._context.renderCoordsHelper.spatialReference;B[0]=a.x,B[1]=a.y,B[2]=0;const o=u.create();l.computeLinearTransformation(e.spatialReference,B,o,n),s.invert(U,o);for(let e=0;e<t.length;e+=3)F[0]=t[e+0],F[1]=t[e+1],F[2]=t[e+2],i.transformMat4(F,F,U),t[e+0]=F[0],t[e+1]=F[1],t[e+2]=F[2];if(r){d.fromMat4(D,o),d.transpose(D,D);for(let e=0;e<r.length;e+=3)F[0]=r[e+0],F[1]=r[e+1],F[2]=r[e+2],i.transformMat3(F,F,D),r[e+0]=F[0],r[e+1]=F[1],r[e+2]=F[2]}return o},c._validateFaces=function(e,t){const r=e.vertexAttributes.position.length/3,a=t.faces;if(a){let e=-1;for(let t=0;t<a.length;t++){const r=a[t];r>e&&(e=r)}if(r<=e)return this.logger.warn(`Vertex index ${e} is out of bounds of the mesh position buffer`),!1}else if(r%3!=0)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),!1;return!0},c._getOrCreateFaces=function(e,t){if(t.faces)return t.faces;{const t=new Uint32Array(e.vertexAttributes.position.length/3);for(let e=0;e<t.length;e++)t[e]=e;return t}},c._isOutsideClippingArea=function(e){if(!this._context.clippingExtent)return!1;const t=e.vertexAttributes&&e.vertexAttributes.position;if(!t)return!1;const r=this._context.elevationProvider.spatialReference;let a;const n=t.length/3;return e.spatialReference.equals(r)?a=t:(a=new Float64Array(t.length),l.projectBuffer(e.vertexAttributes.position,e.spatialReference,0,a,r,0,n)),g.empty($),g.expandWithBuffer($,a,0,n),!g.intersectsClippingArea($,this._context.clippingExtent)},c._createGeometryInfo=function(e,t,r){if(!l.canProjectWithoutEngine(e.spatialReference,this._context.layerView.view.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(this._isOutsideClippingArea(e))return null;const a=this._createBuffers(e,t);if(!a)return null;const{positionBuffer:n,uvBuffer:o,colorBuffer:i,symbolColorBuffer:s,normalBuffer:c,tangentBuffer:h,objectTransformation:m}=a,f=this._getOrCreateComponents(e),d=[],p=[],g=[];let x=!1;for(const t of f){if(!this._validateFaces(e,t))return null;const a=this._getOrCreateFaces(e,t);if(0===a.length)continue;const l=this._createComponentNormals(n,c,t,a);l.didFlipNormals&&(x=!0);const m={[P.POSITION]:{size:3,data:n},[P.NORMAL]:{size:3,data:l.normals}},f={[P.POSITION]:a,[P.NORMAL]:l.indices};i&&(m[P.COLOR]={size:4,data:i},f[P.COLOR]=a),s&&(m[P.SYMBOLCOLOR]={size:4,data:s},f[P.SYMBOLCOLOR]=this._createColorIndices(a)),e.vertexAttributes.uv&&(m[P.UV0]={size:2,data:o},f[P.UV0]=a),e.vertexAttributes.tangent&&(m[P.TANGENT]={size:4,data:h},f[P.TANGENT]=a);const b=new _.GeometryData(m,f),y=new w(b,`${r}_mesh`);d.push(y),p.push(u.create()),g.push(this._getOrCreateMaterial(e,t))}return x&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."),{geometries:d,transformations:p,materials:g,objectTransformation:m}},c._createEdgeMaterial=function(){const e={opacity:this._getLayerOpacity()};return A.createMaterial(this.symbolLayer,e)},r}(O.Graphics3DSymbolLayer);R.validGeometryTypes=["mesh"];const B=o.create(),F=o.create(),L=o.create(),V=o.create(),G=o.create(),U=u.create(),D=c.create(),$=g.create(),j=[new f];e.Graphics3DMeshFillSymbolLayer=R,e.default=R,Object.defineProperty(e,"__esModule",{value:!0})}));
