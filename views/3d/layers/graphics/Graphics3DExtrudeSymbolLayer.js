/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{get as t,isSome as r,isNone as s}from"../../../../core/maybe.js";import{e as n}from"../../../../chunks/earcut.js";import{a}from"../../../../chunks/mat3.js";import{c as i}from"../../../../chunks/mat3f64.js";import{a as o}from"../../../../chunks/mat4.js";import{I as l,c}from"../../../../chunks/mat4f64.js";import{c as h,n as m,s as p,b as d,f as u,m as f}from"../../../../chunks/vec3.js";import{d as g,c as y}from"../../../../chunks/vec3f64.js";import{computeTranslationToOriginAndRotation as _}from"../../../../geometry/projection.js";import{create as b,empty as E,expandWithBuffer as x,intersectsClippingArea as P}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec3f64 as S}from"../../../../geometry/support/buffer/BufferView.js";import{t as v,a as w}from"../../../../chunks/vec32.js";import{getDriverAxisSizeValue as j}from"../../../../renderers/support/renderingInfoUtils.js";import{ViewingMode as A}from"../../../ViewingMode.js";import{needsElevationUpdates3D as L,evaluateElevationInfoAtPoint as M,SampleElevationInfo as O}from"./elevationAlignmentUtils.js";import{ElevationContext as B}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as C}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as I}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as R,computeCentroid as T}from"./graphicUtils.js";import{ApplyRendererDiffResult as z}from"./interfaces.js";import{geometryAsPolygon as D,geometryToRenderInfo as G}from"./polygonUtils.js";import{createMaterial as U}from"../support/edgeUtils.js";import k from"../../support/debugFlags.js";import{SamplePosition as N}from"../../support/ElevationProvider.js";import{CullFaceOptions as F,PrimitiveType as V}from"../../webgl-engine/lib/basicInterfaces.js";import{Geometry as H}from"../../webgl-engine/lib/Geometry.js";import{Object3D as Y}from"../../webgl-engine/lib/Object3D.js";import{VertexAttribute as Z}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as W}from"../../webgl-engine/materials/DefaultMaterial.js";const q=["polygon","extent"];class J extends I{constructor(e,t,r,s){super(e,t,r,s),this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=R(this._getSymbolSize());if(t)throw new e("graphics3dextrudesymbollayer:invalid-size",t)}const r=t(this.symbolLayer,"material","color"),s=this._getCombinedOpacityAndColor(r),n=g(s),a=s[3],i=a<1||this.needsDrivenTransparentPass,o={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0,diffuse:n,ambient:n,opacity:a,transparent:i,cullFace:i?F.None:F.Back,hasVertexColors:!0,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,offsetTransparentBackfaces:!0};this._material=new W(o),this._bottomMaterial=new W({...o,cullFace:F.Back}),this._context.stage.add(this._material),this._context.stage.add(this._bottomMaterial)}destroy(){super.destroy(),this._material&&(this._context.stage.remove(this._material),this._context.stage.remove(this._bottomMaterial))}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,q,this.symbolLayer.type))return null;const r=this._getVertexOpacityAndColor(e.renderingInfo,255),s=this.setGraphicElevationContext(t,new B);return this._createAs3DShape(t,e.renderingInfo,r,s,t.uid)}layerOpacityChanged(e,s){const n=t(this.symbolLayer,"material","color"),a=this._getCombinedOpacity(n),i=a<1||this.needsDrivenTransparentPass;this._material.setParameters({opacity:a,transparent:i}),this._bottomMaterial.setParameters({opacity:a,transparent:i});const o=this._getLayerOpacity();return e.forEach((e=>{const t=s(e);r(t)&&t.layerOpacityChanged(o,this._context.isAsync)})),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,L)}slicePlaneEnabledChanged(e,t){return this._material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),this._bottomMaterial.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),e.forEach((e=>{const s=t(e);r(s)&&s.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){return this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._bottomMaterial.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}_getExtrusionSize(e){let t;return t=e.size&&this._drivenProperties.size?j(e.size,2)??0:this._getSymbolSize(),t/=this._context.renderCoordsHelper.unitInMeters,t}applyRendererDiff(e,t){return this._drivenPropertiesChanged(t)?z.Recreate_Symbol:z.Recreate_Graphics}_getSymbolSize(){return this.symbolLayer.size??1}_createAs3DShape(e,t,h,m,p){const d=D(e.geometry);if(s(d))return null;const u=G(d,this._context.elevationProvider,this._context.renderCoordsHelper,m);if(this._logGeometryCreationWarnings(u,d.rings,"rings","ExtrudeSymbol3DLayer"),0===d.rings.length||!d.rings.some((e=>e.length>0)))return null;const f=T(d);if(s(f))return null;const g=new Array,j=new Array,M=new Array,O=b(),B=c(),I=y(),R=this._context.renderCoordsHelper.viewingMode===A.Global;R||this._context.renderCoordsHelper.worldUpAtPosition(null,I),_(d.spatialReference,[f.x,f.y,0],B,this._context.renderCoordsHelper.spatialReference);const z=c();o(z,B);const k=i();a(k,z);const{polygons:N,mapPosition:F,position:V}=u,H=V.length/3,Z=new Float64Array(3*H*6),W=new Float64Array(3*H*6),q=new Float64Array(3*H*6),J=new Float64Array(1*H*6);let X=0;for(let r=0;r<N.length;++r){const e=N[r],s=e.count;if(this._context.clippingExtent&&(E(O),x(O,e.mapPosition),!P(O,this._context.clippingExtent)))continue;const a=n(e.mapPosition,e.holeIndices,3);if(0===a.length)continue;const i=3*s*2+a.length,o=new Uint32Array(i),c=new Uint32Array(a.length),m=6*s,p=3*Z.BYTES_PER_ELEMENT,d=new S(Z.buffer,X*p,p,(X+m)*p),u=3*W.BYTES_PER_ELEMENT,f=new S(W.buffer,X*u,u,(X+m)*u),y=new Float64Array(q.buffer,3*X*q.BYTES_PER_ELEMENT,3*m),_=new Float64Array(J.buffer,1*X*J.BYTES_PER_ELEMENT,1*m),b=this._getExtrusionSize(t);Q(V,F,a,e,d.typedBuffer,y,f.typedBuffer,_,0,o,c,b,I,R),v(d,d,z),w(f,f,k),X+=6*s;const A=K(o,o.length-c.length,{positions:d.typedBuffer,elevation:y,normals:f.typedBuffer,heights:_},h);g.push(A),j.push(this._material),M.push(l);const L=K(c,0,{positions:d.typedBuffer,elevation:y,normals:f.typedBuffer,heights:_},h);g.push(L),j.push(this._bottomMaterial),M.push(l)}if(0===g.length)return null;const $=new Y({geometries:g,materials:j,transformations:M,metadata:{layerUid:this._context.layer.uid,graphicUid:p,isElevationSource:!0}});$.transformation=B;const ee=U(this.symbolLayer,{opacity:this._getLayerOpacity()}),te=r(ee)?{baseMaterial:this._material,edgeMaterials:[ee],properties:{mergeGeometries:!0,hasSlicePlane:this._context.slicePlaneEnabled}}:null,re=new C(this,$,g,null,null,ce,m,te);return re.alignedSampledElevation=u.sampledElevation,re.needsElevationUpdates=L(m.mode),re}}function K(e,t,r,s){const n=new Uint32Array(e.length),a=[[Z.POSITION,{size:3,data:r.positions,exclusive:!0}],[Z.NORMAL,{size:3,data:r.normals,exclusive:!0}],[Z.COLOR,{size:4,data:s,exclusive:!0}],[Z.SIZE,{size:1,data:r.heights,exclusive:!0}]],i=[[Z.POSITION,e],[Z.NORMAL,e],[Z.COLOR,n]];return r.elevation&&(a.push([Z.MAPPOS,{size:3,data:r.elevation}]),i.push([Z.MAPPOS,e])),new H(a,i,V.Triangle,t)}function Q(e,t,r,s,n,a,i,o,l,c,h,m,p,d){const u=r.length/3;let f=0,g=2*s.count;X(e,t,s.index,s.count,r,0,u,n,a,i,o,l,c,h,g,m,p,d),l+=2*s.count,g=0,te(n,a,o,i,f,s.pathLengths[0],s.count,l,c,g,m),l+=4*s.pathLengths[0],g+=2*s.pathLengths[0],f+=s.pathLengths[0];for(let y=1;y<s.pathLengths.length;++y)te(n,a,o,i,f,s.pathLengths[y],s.count,l,c,g,m),l+=4*s.pathLengths[y],g+=2*s.pathLengths[y],f+=s.pathLengths[y]}function X(e,t,r,s,n,a,i,o,l,c,p,d,u,f,g,y,_,b){h(me,_);const E=y>0?1:-1;let x=3*r,P=d,S=3*P,v=d+s,w=3*v;for(let h=0;h<s;++h)b&&(me[0]=e[x+0],me[1]=e[x+1],me[2]=e[x+2],m(me,me)),o[S+0]=e[x+0],o[S+1]=e[x+1],o[S+2]=e[x+2],l[S+0]=t[x+0],l[S+1]=t[x+1],l[S+2]=t[x+2],c[S+0]=-E*me[0],c[S+1]=-E*me[1],c[S+2]=-E*me[2],p[P]=0,o[w+0]=e[x+0]+y*me[0],o[w+1]=e[x+1]+y*me[1],o[w+2]=e[x+2]+y*me[2],l[w+0]=t[x+0],l[w+1]=t[x+1],l[w+2]=t[x+2],c[w+0]=E*me[0],c[w+1]=E*me[1],c[w+2]=E*me[2],p[v]=y,S+=3,w+=3,x+=3,P+=1,v+=1;x=3*a,S=0,w=3*g;const j=y<0?ue:de,A=y<0?de:ue;for(let h=0;h<i;++h)f[S+0]=n[x+j[0]],f[S+1]=n[x+j[1]],f[S+2]=n[x+j[2]],u[w+0]=n[x+A[0]]+s,u[w+1]=n[x+A[1]]+s,u[w+2]=n[x+A[2]]+s,S+=3,w+=3,x+=3}function $(e,t,r,s,n,a,i){s[a]=s[i],i*=3,e[(a*=3)+0]=e[i+0],e[a+1]=e[i+1],e[a+2]=e[i+2],t[a+0]=t[i+0],t[a+1]=t[i+1],t[a+2]=t[i+2],r[a+0]=n[0],r[a+1]=n[1],r[a+2]=n[2]}const ee=y();function te(e,t,r,s,n,a,i,o,l,c,h){let m=n,p=n+1,d=n+i,u=n+i+1,f=o,g=o+1,y=o+2*a,_=o+2*a+1;h<0&&(m=n+i+1,u=n),c*=3;for(let b=0;b<a;++b)b===a-1&&(h>0?(p=n,u=n+i):(p=n,m=n+i)),oe(e,m,p,d,ee),$(e,t,s,r,ee,f,m),$(e,t,s,r,ee,g,p),$(e,t,s,r,ee,y,d),$(e,t,s,r,ee,_,u),l[c++]=f,l[c++]=y,l[c++]=_,l[c++]=f,l[c++]=_,l[c++]=g,m++,p++,d++,u++,f+=2,g+=2,y+=2,_+=2}const re=y(),se=y(),ne=y(),ae=y(),ie=y();function oe(e,t,r,s,n){t*=3,r*=3,s*=3,p(re,e[t++],e[t++],e[t++]),p(se,e[r++],e[r++],e[r++]),p(ne,e[s++],e[s++],e[s++]),d(ae,se,re),d(ie,ne,re),u(n,ie,ae),m(n,n)}const le=y();function ce(e,t,r,s){const n=e.stageObject,a=n.geometryRecords,i=a.length,l="absolute-height"!==t.mode;let h=0;const m=n.transformation,d=o(c(),m);for(let o=0;o<i;o+=2){const e=a[o].geometry,i=e.getMutableAttribute(Z.POSITION).data,c=e.vertexAttributes.get(Z.SIZE).data,u=e.vertexAttributes.get(Z.MAPPOS).data,g=new N(u),y=i.length/3;let _=0,b=!1,E=0;const x=r.spatialReference;for(let n=0;n<y;n++){le[0]=i[_],le[1]=i[_+1],le[2]=i[_+2],M(g,r,t,s,pe),l&&(E+=pe.sampledElevation),k.TESTS_DISABLE_OPTIMIZATIONS?(p(he,g.array[g.offset+0],g.array[g.offset+1],pe.z+c[_/3]),s.toRenderCoords(he,x,he),f(he,he,d)):(p(he,i[_+0],i[_+1],i[_+2]),f(he,he,m),s.setAltitude(he,pe.z+c[_/3]),f(he,he,d)),i[_]=he[0],i[_+1]=he[1],i[_+2]=he[2];const e=fe/s.unitInMeters;(Math.abs(le[0]-i[_])>=e||Math.abs(le[1]-i[_+1])>=e||Math.abs(le[2]-i[_+2])>=e)&&(b=!0),g.offset+=3,_+=3}b&&(e.invalidateBoundingInfo(),n.geometryVertexAttrsUpdated(a[o]),a[o+1].geometry.invalidateBoundingInfo(),n.geometryVertexAttrsUpdated(a[o+1])),h+=E/y}return h/i}const he=y(),me=y(),pe=new O,de=[0,2,1],ue=[0,1,2],fe=.01;export{J as Graphics3DExtrudeSymbolLayer};
