/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../core/typedArrayUtil","../../../../core/maybe","../../../../core/mathUtils","../../../../chunks/vec3f64","../../../../chunks/vec3","../../../../geometry/projection","../../../../geometry/support/triangulationUtils","../../webgl-engine/lib/GeometryData","./elevationAlignmentUtils","../../webgl-engine/shaders/RibbonLineTechnique","../../terrain/OverlayRenderer","./constants"],(function(t,e,n,o,r,i,a,s,u,b,c,l,f){"use strict";function I(t,e,n){const o=new Array;for(const{index:r,count:i}of t){if(i<=1)continue;const t=3*r,a=t+3*i;o.push({position:e.subarray(t,a),mapPosition:n?n.subarray(t,a):void 0})}return o}function d(t){return 1.863798+-2.0062872/Math.pow(1+t/18.2313,.8856294)}const p=r.create(),A=r.create(),R=4/Math.PI;t.createGeometryData=function(t){const r={},a={};!function(t,n,o){const{attributeData:{position:r},removeDuplicateStartEnd:i}=t,a=function(t){const e=t.length;return t[0]===t[e-3]&&t[1]===t[e-2]&&t[2]===t[e-1]}(r)&&1===i,s=r.length/3-(a?1:0),u=new Uint32Array(2*(s-1)),b=a?e.slice(r,0,r.length-3):r;let l=0;for(let t=0;t<s-1;t++)u[l++]=t,u[l++]=t+1;n[c.RibbonVertexAttributeConstants.POSITION]={size:3,data:b,offsetIdx:0,strideIdx:3},o[c.RibbonVertexAttributeConstants.POSITION]=u}(t,a,r);const s=new Uint32Array(r[c.RibbonVertexAttributeConstants.POSITION].length);return function(t,e,o){const r=t.attributeData.mapPosition;if(n.isNone(r))return;o.mapPos=o[c.RibbonVertexAttributeConstants.POSITION],e.mapPos={size:3,data:r,offsetIdx:0,strideIdx:3}}(t,a,r),function(t,e,o,r){if(n.isSome(t.attributeData.colorFeature))return;const i=t.attributeData.color;e[c.RibbonVertexAttributeConstants.COLOR]={size:4,data:n.unwrapOr(i,f.WHITE_UNIT),offsetIdx:0,strideIdx:4},o[c.RibbonVertexAttributeConstants.COLOR]=r}(t,a,r,s),function(t,e,o,r){if(n.isSome(t.attributeData.sizeFeature))return;const i=t.attributeData.size;e[c.RibbonVertexAttributeConstants.SIZE]={size:1,data:new Float32Array([n.unwrapOr(i,1)]),offsetIdx:0,strideIdx:1},o[c.RibbonVertexAttributeConstants.SIZE]=r}(t,a,r,s),function(t,e,o,r){const i=t.attributeData.colorFeature;if(n.isNone(i))return;e[c.RibbonVertexAttributeConstants.COLORFEATUREATTRIBUTE]={size:1,data:new Float32Array([i]),offsetIdx:0,strideIdx:1},o[c.RibbonVertexAttributeConstants.COLOR]=r}(t,a,r,s),function(t,e,o,r){const i=t.attributeData.sizeFeature;if(n.isNone(i))return;e[c.RibbonVertexAttributeConstants.SIZEFEATUREATTRIBUTE]={size:1,data:new Float32Array([i]),offsetIdx:0,strideIdx:1},o[c.RibbonVertexAttributeConstants.SIZEFEATUREATTRIBUTE]=r}(t,a,r,s),function(t,e,o,r){const i=t.attributeData.opacityFeature;if(n.isNone(i))return;e[c.RibbonVertexAttributeConstants.OPACITYFEATUREATTRIBUTE]={size:1,data:new Float32Array([i]),offsetIdx:0,strideIdx:1},o[c.RibbonVertexAttributeConstants.OPACITYFEATUREATTRIBUTE]=r}(t,a,r,s),function(t,e,r){if("round"!==t.join)return;const a=e[c.RibbonVertexAttributeConstants.POSITION].data,s=a.length/3,u=new Float32Array(s),b=p,l=A;i.set(b,0,0,0);const f=n.unwrapOr(t.uniformSize,1);for(let t=-1;t<s;++t){const e=t<0?s+t:t,n=(t+1)%s;if(i.set(l,a[3*n+0]-a[3*e+0],a[3*n+1]-a[3*e+1],a[3*n+2]-a[3*e+2]),i.normalize(l,l),t>=0){const e=1*((Math.PI-o.acosClamped(i.dot(b,l)))*R)*d(f);u[t]=Math.max(Math.floor(e),0)}i.scale(b,l,-1)}e[c.RibbonVertexAttributeConstants.SUBDIVISIONS]={size:1,data:u,offsetIdx:0,strideIdx:1},r[c.RibbonVertexAttributeConstants.SUBDIVISIONS]=r[c.RibbonVertexAttributeConstants.POSITION]}(t,a,r),new u.GeometryData(a,r,"line")},t.geometryToRenderInfo=function(t,e,n,o){const r="polygon"===t.type?1:0,i="polygon"===t.type?t.rings:t.paths,{position:a,outlines:u}=s.pathsToTriangulationInfo(i,t.hasZ,r),c=new Float64Array(a.length),l=b.applyPerVertexElevationAlignment(a,t.spatialReference,0,c,0,a,0,a.length/3,e,n,o),f=null!=l;return{lines:f?I(u,a,c):[],projectionSuccess:f,sampledElevation:l}},t.geometryToRenderInfoDraped=function(t,e){const n="polygon"===t.type?1:0,o="polygon"===t.type?t.rings:t.paths,{position:r,outlines:i}=s.pathsToTriangulationInfo(o,!1,n),u=a.projectBuffer(r,t.spatialReference,0,r,e,0,r.length/3);for(let t=2;t<r.length;t+=3)r[t]=l.DRAPED_Z;return{lines:u?I(i,r):[],projectionSuccess:u}},Object.defineProperty(t,"__esModule",{value:!0})}));
