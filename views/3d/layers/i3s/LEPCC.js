/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../core/Error"],(function(e,t){"use strict";const o=!0,n=0,r=10,i=10,c=12,s=16;function d(e,t,s){return{identifier:String.fromCharCode.apply(null,new Uint8Array(e,s+n,r)),version:t.getUint16(s+i,o),checksum:t.getUint32(s+c,o)}}const l=0,a=4,u=8,w=16,f=24,h=32,g=40,p=48,U=56,y=64,M=72,m=80,z=84,L=88;function B(e,t,o){const n=[];t=b(e,t,n);const r=[];for(let i=0;i<n.length;i++){r.length=0,t=b(e,t,r);for(let e=0;e<r.length;e++)o.push(r[e]+n[i])}return t}function b(e,n,r){const i=new DataView(e,n),c=i.getUint8(0),s=31&c,d=!!(32&c),l=(192&c)>>6;let a=0;if(0===l)a=i.getUint32(1,o),n+=5;else if(1===l)a=i.getUint16(1,o),n+=3;else{if(2!==l)throw new t("lepcc-decode-error","Bad count type");a=i.getUint8(1),n+=2}if(d)throw new t("lepcc-decode-error","LUT not implemented");const u=Math.ceil(a*s/8),w=new Uint8Array(e,n,u);let f=0,h=0,g=0;const p=-1>>>32-s;for(let e=0;e<a;e++){for(;h<s;)f|=w[g]<<h,h+=8,g+=1;r[e]=f&p,f>>>=s,h-=s,h+s>32&&(f|=w[g-1]>>8-h)}return n+g}const F=0,C=4,A=8,k=12,v=14,X=15,Y=16;const Z=0,P=4,x=8,H=12,D=14,V=15,E=16;e.decodeIntensity=function(e){const n=new DataView(e,0);let r=0;const{identifier:i,version:c}=d(e,n,r);if(r+=s,"Intensity "!==i)throw new t("lepcc-decode-error","Bad identifier");if(c>1)throw new t("lepcc-decode-error","Unknown version");const l=function(e,t){return{sizeLo:e.getUint32(t+Z,o),sizeHi:e.getUint32(t+P,o),count:e.getUint32(t+x,o),scaleFactor:e.getUint16(t+H,o),bitsPerPoint:e.getUint8(t+D),reserved:e.getUint8(t+V)}}(n,r);if(r+=E,l.sizeHi*Math.pow(2,32)+l.sizeLo!==e.byteLength)throw new t("lepcc-decode-error","Bad size");const a=new Uint16Array(l.count);if(8===l.bitsPerPoint){if(l.count+r!==e.byteLength)throw new t("lepcc-decode-error","Bad size");const o=new Uint8Array(e,r,l.count);for(let e=0;e<l.count;e++)a[e]=o[e]*l.scaleFactor}else if(16===l.bitsPerPoint){if(2*l.count+r!==e.byteLength)throw new t("lepcc-decode-error","Bad size");const o=new Uint16Array(e,r,l.count);for(let e=0;e<l.count;e++)a[e]=o[e]*l.scaleFactor}else{const o=[];if(b(e,r,o)!==e.byteLength)throw new t("lepcc-decode-error","Bad size");for(let e=0;e<l.count;e++)a[e]=o[e]*l.scaleFactor}return a},e.decodeRGB=function(e){const n=new DataView(e,0);let r=0;const{identifier:i,version:c}=d(e,n,r);if(r+=s,"ClusterRGB"!==i)throw new t("lepcc-decode-error","Bad identifier");if(c>1)throw new t("lepcc-decode-error","Unknown version");const l=function(e,t){return{sizeLo:e.getUint32(t+F,o),sizeHi:e.getUint32(t+C,o),count:e.getUint32(t+A,o),colorMapCount:e.getUint16(t+k,o),lookupMethod:e.getUint8(t+v),compressionMethod:e.getUint8(t+X)}}(n,r);if(r+=Y,l.sizeHi*Math.pow(2,32)+l.sizeLo!==e.byteLength)throw new t("lepcc-decode-error","Bad size");if((2===l.lookupMethod||1===l.lookupMethod)&&0===l.compressionMethod){if(3*l.colorMapCount+l.count+r!==e.byteLength||l.colorMapCount>256)throw new t("lepcc-decode-error","Bad count");const o=new Uint8Array(e,r,3*l.colorMapCount),n=new Uint8Array(e,r+3*l.colorMapCount,l.count),i=new Uint8Array(3*l.count);for(let e=0;e<l.count;e++){const t=n[e];i[3*e]=o[3*t],i[3*e+1]=o[3*t+1],i[3*e+2]=o[3*t+2]}return i}if(0===l.lookupMethod&&0===l.compressionMethod){if(3*l.count+r!==e.byteLength||0!==l.colorMapCount)throw new t("lepcc-decode-error","Bad count");return new Uint8Array(e,r).slice()}if(l.lookupMethod<=2&&1===l.compressionMethod){if(r+3!==e.byteLength||1!==l.colorMapCount)throw new t("lepcc-decode-error","Bad count");const o=n.getUint8(r),i=n.getUint8(r+1),c=n.getUint8(r+2),s=new Uint8Array(3*l.count);for(let e=0;e<l.count;e++)s[3*e]=o,s[3*e+1]=i,s[3*e+2]=c;return s}throw new t("lepcc-decode-error","Bad method "+l.lookupMethod+","+l.compressionMethod)},e.decodeXYZ=function(e){const n=new DataView(e,0);let r=0;const{identifier:i,version:c}=d(e,n,r);if(r+=s,"LEPCC     "!==i)throw new t("lepcc-decode-error","Bad identifier");if(c>1)throw new t("lepcc-decode-error","Unknown version");const b=function(e,t){return{sizeLo:e.getUint32(t+l,o),sizeHi:e.getUint32(t+a,o),minX:e.getFloat64(t+u,o),minY:e.getFloat64(t+w,o),minZ:e.getFloat64(t+f,o),maxX:e.getFloat64(t+h,o),maxY:e.getFloat64(t+g,o),maxZ:e.getFloat64(t+p,o),errorX:e.getFloat64(t+U,o),errorY:e.getFloat64(t+y,o),errorZ:e.getFloat64(t+M,o),count:e.getUint32(t+m,o),reserved:e.getUint32(t+z,o)}}(n,r);if(r+=L,b.sizeHi*Math.pow(2,32)+b.sizeLo!==e.byteLength)throw new t("lepcc-decode-error","Bad size");const F=new Float64Array(3*b.count),C=[],A=[],k=[],v=[];if(r=B(e,r,C),r=B(e,r,A),r=B(e,r,k),r=B(e,r,v),r!==e.byteLength)throw new t("lepcc-decode-error","Bad length");let X=0,Y=0;for(let e=0;e<C.length;e++){Y+=C[e];let t=0;for(let o=0;o<A[e];o++){t+=k[X];const e=v[X];F[3*X]=Math.min(b.maxX,b.minX+2*b.errorX*t),F[3*X+1]=Math.min(b.maxY,b.minY+2*b.errorY*Y),F[3*X+2]=Math.min(b.maxZ,b.minZ+2*b.errorZ*e),X++}}return{errorX:b.errorX,errorY:b.errorY,errorZ:b.errorZ,result:F}},Object.defineProperty(e,"__esModule",{value:!0})}));
