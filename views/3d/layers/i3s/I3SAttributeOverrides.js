/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../../request.js";import{remove as t,splitIntoChunks as s}from"../../../../core/arrayUtils.js";import{resultOrAbort as i,result as r}from"../../../../core/asyncUtils.js";import{estimateStringByteSize as a,estimateNumberByteSize as n}from"../../../../core/byteSizeEstimations.js";import o from"../../../../core/Logger.js";import{isNone as c,unwrap as d,get as h,isSome as l}from"../../../../core/maybe.js";import{whenOrAbort as m}from"../../../../core/promiseUtils.js";import{formatNumber as u}from"../../../../intl/number.js";import{getMaximumQuerySize as g,queryAllJSON as b}from"../../../../layers/support/featureQueryAll.js";const p=o.getLogger("esri.views.3d.layers.i3s.I3SAttributeOverrides");class f{constructor(e,t){this.layer=e,this.warnMaximumChangedObjectsExceeded=!1,this.changedObjectIds=new Set,this.pendingFetchAbortController=new AbortController,this.interactiveEditingSessions=null,this._maximumNumberOfEditOVerrides=j,this.memCache=t.newCache(`${e.uid}-attribute-overrides`),this.pendingFetchChangedObjectIds=this._fetchChangedObjectIds(this.pendingFetchAbortController.signal),this.pendingFetchChangedObjectIds.then((()=>this.pendingFetchAbortController=null))}destroy(){this.layer=null,this.memCache.destroy(),this.memCache=null,this.pendingFetchAbortController&&(this.pendingFetchAbortController.abort(),this.pendingFetchAbortController=null),this.pendingFetchChangedObjectIds=null}createInteractiveEditSession(e){this.changedObjectIds.add(e),c(this.interactiveEditingSessions)&&(this.interactiveEditingSessions=[]);const s=this.interactiveEditingSessions,i=new y(e,{rollback:()=>{t(s,i),0===s.length&&(this.interactiveEditingSessions=null)},commit:t=>{for(const[s,i]of t)this.updateValue(e,s,i)}});return s.unshift(i),i}async apply(e,t,s){if(c(t))return;const{loadedAttributes:i,attributeData:r}=t;if(c(i)||0===i.length||c(r))return;if(await m(this.pendingFetchChangedObjectIds,s),0===this.changedObjectIds.size)return;const a={loadedAttributes:i,attributeData:r},n=this._getOverridesFromCache(e,a,this.changedObjectIds),{objectIds:o,fieldNames:d}=n,h=await this._queryOverridesFromAssociatedLayer(o,d,s);c(h)||this._processOverridesFromAssociatedLayer(e,h,d,a)}updateValue(e,t,s){this.changedObjectIds.add(e),this._cacheValue(e,t,s)}_cacheValue(e,t,s){this.memCache.put(this._getCacheKey(e,t),s,this._memCacheValueSize(s))}_getOverridesFromCache(e,{loadedAttributes:t,attributeData:s},i){const r=new Set,a=new Array;for(const o of t)a[o.index]=s[o.name];const n=new Set;for(let o=0;o<e.length;o++){const s=e[o];if(i.has(s))for(const e of t){const t=this._fromCache(s,e.index);void 0===t?(r.add(s),n.add(e.name)):a[e.index][o]=t}}return{objectIds:Array.from(r),fieldNames:Array.from(n)}}_fromCache(e,t){const s=this._fromInteractiveEditingSession(e,t);if(void 0!==s)return s;const i=this._getCacheKey(e,t);return this.memCache.get(i)}_fromInteractiveEditingSession(e,t){if(!c(this.interactiveEditingSessions))for(const s of this.interactiveEditingSessions){if(s.objectId!==e)continue;const i=s.get(t);if(void 0!==i)return i}}_getCacheKey(e,t){return`${e}-${t}`}async _queryOverridesFromAssociatedLayer(e,t,r){if(0===e.length||0===t.length)return null;e=e.sort(((e,t)=>e-t)),this.warnMaximumChangedObjectsExceeded&&(this.warnMaximumChangedObjectsExceeded=!1,this._logMaximumObjectsExceededWarning());const a=d(this.layer.associatedLayer),n=a.createQuery();n.where="1=1",n.returnGeometry=!1,n.outFields=[a.objectIdField,...t],n.cacheHint=!0,n.objectIds=e;const o=g(a),c=e.length>o?s(e,o).map((e=>{const t=n.clone();return t.objectIds=e,i(b(a,t,{signal:r}))})):[i(b(a,n,{signal:r}))];return(await Promise.all(c)).reduce(((e,t)=>e.concat(t.ok?t.value.features:[])),[])}_logMaximumObjectsExceededWarning(){let e=`The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${u(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;const t=this.layer.portalItem;t&&t.loaded?e+=` (${t.portal.url}/home/item.html?id=${t.id}#settings)`:e+=` (${this.layer.parsedUrl.path})`,p.warn("#queryOverrides()",this.layer.title,`${e}.`)}_processOverridesFromAssociatedLayer(e,t,s,{loadedAttributes:i,attributeData:r}){const a=d(this.layer.associatedLayer).objectIdField,n=s.map((e=>r[e])),o=new Map(i.map((e=>[e.name,e.index]))),c=s.map((e=>o.get(e))),h=new Map(Array.from(e,((e,t)=>[e,t])));for(const d of t){const e=d.attributes[a];for(let t=0;t<s.length;t++){const i=c[t],r=h.get(e),a=d.attributes[s[t]];n[t][r]=a,this._cacheValue(e,i,a)}}}_memCacheValueSize(e){return"string"==typeof e?a(e):n()}async _fetchChangedObjectIds(t){const s=this.layer;if(await s.load({signal:t}),this.changedObjectIds.clear(),c(s.associatedLayer)||!s.associatedLayer.capabilities?.operations?.supportsChangeTracking)return;const i=this._getFetchChangedObjectIdsServerGen();if(c(i))return null;const a=s.associatedLayer.layerId,n=await r(e(`${s.associatedLayer.url}/extractChanges`,{method:"post",query:{f:"json",returnIdsOnly:!0,layers:`${a}`,returnUpdates:!0,returnDeletes:!1,returnInserts:!1,layerServerGens:JSON.stringify([{id:a,serverGen:i}])},timeout:C,signal:t})),o=n.ok&&n.value.data?.edits?h(n.value.data.edits[0],"objectIds","updates"):null;if(l(o)){const e=Math.min(this._maximumNumberOfEditOVerrides,o.length);e<o.length&&(this.warnMaximumChangedObjectsExceeded=!0);const t=o.sort(((e,t)=>e-t));for(let s=0;s<e;s++)this.changedObjectIds.add(t[s])}}_getFetchChangedObjectIdsServerGen(){const e=this.layer;if(l(e.serviceUpdateTimeStamp)&&l(e.serviceUpdateTimeStamp.lastUpdate))return e.serviceUpdateTimeStamp.lastUpdate;const t=e.associatedLayer;return l(t)&&l(t.serverGens)&&l(t.serverGens.minServerGen)?t.serverGens.minServerGen:null}get test(){const e=Array.from(this.changedObjectIds),t=this.pendingFetchChangedObjectIds,s=this;return{changedObjectIds:e,pendingFetchChangedObjectIds:t,get maximumNumberOfEditOVerrides(){return s._maximumNumberOfEditOVerrides},set maximumNumberOfEditOVerrides(e){s._maximumNumberOfEditOVerrides=e}}}}class y{constructor(e,t){this.objectId=e,this.options=t,this.updates=new Map,this.state=O.ACTIVE}get(e){return this.updates.get(e)}set(e,t){this.isActive&&this.updates.set(e,t)}rollback(){this.isActive&&(this.state=O.ROLLED_BACK,this.options.rollback())}commit(){this.isActive&&(this.state=O.COMMITTED,this.options.commit(this.updates),this.updates.clear())}get isActive(){return this.state===O.ACTIVE}}var O;!function(e){e[e.ACTIVE=0]="ACTIVE",e[e.COMMITTED=1]="COMMITTED",e[e.ROLLED_BACK=2]="ROLLED_BACK"}(O||(O={}));const C=1e4,j=5e4;export{f as I3SAttributeOverrides};
