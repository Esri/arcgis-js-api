/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{n as e,s as i,d as s}from"../../../chunks/vec3.js";import{c as r,d as o}from"../../../chunks/vec3f64.js";import{lonLatToSphericalPCPF as a}from"../../../geometry/projection.js";import{getReferenceEllipsoid as n}from"../../../geometry/projectionEllipsoid.js";import{intersectsSphere as h,NumPlanes as l,PlaneIndex as d}from"../../../geometry/support/frustum.js";import{create as c}from"../../../geometry/support/plane.js";import{PatchType as u}from"./interfaces.js";import{createSphericalGlobePatch as p,updateCornerElevationsSpherical as m,updateEdgesElevationsSpherical as _}from"./PatchGeometryFactory.js";import{Tile as f}from"./Tile.js";class D extends f{constructor(t,e,i){super(),this.obb=new Array(8);for(let s=0;s<8;s++)this.obb[s]=r();void 0!==t&&this.init(t,e,i)}init(i,s,r){super.init(i,s,r);const n=this.ellipsoid.radius,h=this.extentInRadians[0],l=this.extentInRadians[1],d=this.extentInRadians[2],c=this.extentInRadians[3],u=i[0],p=t(l,c,.5),m=t(h,d,.5),_=0===u?0:Math.min(Math.abs(l),Math.abs(c));this._edgeLen=(d-h)*Math.cos(_)*n,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=n-Math.sqrt(n*n-this._edgeLen2/4),a(this.centerAtSeaLevel,m,p,this.ellipsoid.radius);const f=o(this.centerAtSeaLevel);e(f,f),this.up=f,this._updateOBB(),this.updateRadiusAndCenter()}updateRadiusAndCenter(){if(0===this.lij[0])i(this._center[E.MIDDLE],0,0,0),i(this._center[E.TOP],0,0,0),i(this._center[E.BOTTOM],0,0,0),this.ellipsoid||(this.ellipsoid=n(this.surface.spatialReference)),this._center[E.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const t=Math.max(s(this._center[E.MIDDLE],this.obb[0]),s(this._center[E.MIDDLE],this.obb[1]));this._center[E.MIDDLE][3]=Math.sqrt(t)}}_isVisible(t){if(!h(t,this._center[E.MIDDLE]))return!1;if(this.lij[0]<10)return!0;const e=this.obb;for(let i=0;i<l.NUM;i++){const s=i===d.NEAR,r=t[i];s&&(O[0]=r[0],O[1]=r[1],O[2]=r[2],O[3]=r[3]-this.surface.view.state.camera.near);const o=s?O:r;let a;for(a=0;a<8;a++){const t=e[a];if(o[0]*t[0]+o[1]*t[1]+o[2]*t[2]+o[3]<0)break}if(8===a)return!1}return!0}computeElevationBounds(){super.computeElevationBounds(),this._updateOBB()}createGeometry(){const t=this._getPatchType(this.lij[1],this.lij[0]);p(this.renderData,t),this.setMemoryDirty()}_updateOBB(){const t=this.extentInRadians,e=this.obb;for(let i=0;i<2;i++){const s=this.elevationBounds[i];let r=4*i;a(e[r++],t[0],t[1],this.ellipsoid.radius+s),a(e[r++],t[0],t[3],this.ellipsoid.radius+s),a(e[r++],t[2],t[3],this.ellipsoid.radius+s),a(e[r++],t[2],t[1],this.ellipsoid.radius+s)}if(this.surface.isWebMercator)switch(this._getPatchType(this.lij[1],this.lij[0])){case u.HAS_NORTH_POLE:i(e[1],0,0,this.ellipsoid.radius),i(e[2],0,0,this.ellipsoid.radius),i(e[5],0,0,this.ellipsoid.radius),i(e[6],0,0,this.ellipsoid.radius);break;case u.HAS_SOUTH_POLE:i(e[0],0,0,-this.ellipsoid.radius),i(e[3],0,0,-this.ellipsoid.radius),i(e[4],0,0,-this.ellipsoid.radius),i(e[7],0,0,-this.ellipsoid.radius)}}_getPatchType(t,e){return t===(1<<e)-1?0===t?u.HAS_BOTH_POLES:u.HAS_SOUTH_POLE:0===t?u.HAS_NORTH_POLE:u.REGULAR}intersectsRay(t,e,i,s){const r=this._center[E.MIDDLE],o=r[3]+i,a=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=r[0]-t[0],h=r[1]-t[1],l=r[2]-t[2],d=(n*e[0]+h*e[1]+l*e[2])/a,c=e[0]*d-n,u=e[1]*d-h,p=e[2]*d-l;return c*c+u*u+p*p<o*o}getDefaultVerticesPerRowOnLevel(){return this.level<L.length?L[this.level]+1:2}updateCornerElevations(){m(this.renderData)}updateEdgeElevations(){_(this.renderData)}}const L=[128,64,32,16,16,8,8,4],O=c();var E;!function(t){t[t.TOP=0]="TOP",t[t.MIDDLE=1]="MIDDLE",t[t.BOTTOM=2]="BOTTOM"}(E||(E={}));export{E as CenterPosition,D as SphericalPatch};
