/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/mathUtils","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/projection","../../../geometry/support/frustum","../../../chunks/sphere","./interfaces","./PatchGeometryFactory","./terrainUtils","./Tile","./tileUtils","../webgl-engine/lib/DoubleArray"],(function(e,t,i,n,s,o,r,l,a,c,u,h,d,p){"use strict";let f=function(e){function f(t,i,n){var s;return(s=e.call(this)||this)._convexHull=new Array(24),s._boundingSphere=l.create(),void 0!==t&&s.init(t,i,n),s}t._inheritsLoose(f,e);var x=f.prototype;return x.init=function(t,r,l){e.prototype.init.call(this,t,r,l);const a=this.ellipsoid.radius,c=this.extentInRadians[0],u=this.extentInRadians[1],h=this.extentInRadians[2],d=this.extentInRadians[3],p=t[0],f=i.lerp(u,d,.5),m=i.lerp(c,h,.5),_=0===p?0:Math.min(Math.abs(u),Math.abs(d));this._edgeLen=(h-c)*Math.cos(_)*a,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=a-Math.sqrt(a*a-this._edgeLen2/4),o.lonLatToSphericalPCPF(this.centerAtSeaLevel,m,f,this.ellipsoid.radius);const g=s.fromArray(this.centerAtSeaLevel);n.normalize(g,g),this.up=g,this.updateRadiusAndCenter()},x.updateRadiusAndCenter=function(){this._updateBoundingVolumes();const e=this._center;if(0===this.lij[0])n.set(e[h.CenterPosition.MIDDLE],0,0,0),n.set(e[h.CenterPosition.TOP],0,0,0),n.set(e[h.CenterPosition.BOTTOM],0,0,0),e[h.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const t=e[h.CenterPosition.MIDDLE],i=this.convexHull;let n=0;for(let e=0;e<8;++e)n=Math.max(n,_(t,i,3*e));e[h.CenterPosition.MIDDLE][3]=Math.sqrt(n)}},x._calculateFrustumVisibilityStatus=function(e){if(!r.intersectsSphere(e,this._boundingSphere))return a.TileFrustumVisibility.OUTSIDE;if(this.lij[0]<10)return a.TileFrustumVisibility.INTERSECTS;const t=this.convexHull,i=this.surface.view.state.camera.near;let n=!0;for(let s=0;s<r.NumPlanes.NUM;s++){const o=s===r.PlaneIndex.NEAR,l=e[s],c=l[0],u=l[1],h=l[2],d=l[3]-(o?i:0);let p=!1;for(let e=0;e<8;++e){const i=3*e;if(c*t[i+0]+u*t[i+1]+h*t[i+2]+d<0){if(p=!0,!n)break}else n=!1}if(!p)return a.TileFrustumVisibility.OUTSIDE}return n?a.TileFrustumVisibility.INSIDE:a.TileFrustumVisibility.INTERSECTS},x.computeElevationBounds=function(){e.prototype.computeElevationBounds.call(this),this._updateBoundingVolumes()},x.createGeometry=function(){c.createSphericalGlobePatch(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()},x._updateBoundingVolumes=function(){this._updateConvexHull(),this._updateBoundingSphere(),u.ENABLE_TERRAIN_INTERNAL_CHECKS&&this._checkBVs()},x._updateBoundingSphere=function(){const e=this._boundingSphere,t=e,i=this.elevationBounds,s=this.ellipsoid.radius,o=i[1];if(0===this.level)n.set(t,0,0,0),e[3]=s+o;else{const o=this.extentInRadians,r=.5*(o[0]+o[2]),l=o[1],a=o[3];b(T,r,l,s),b(v,r,a,s),n.add(t,T,v);const c=s+.5*(i[0]+i[1]);n.scale(t,t,c/n.len(t));const u=this.convexHull;let h=0;const d=(e,t)=>{const i=e[0]-u[3*t+0],n=e[1]-u[3*t+1],s=e[2]-u[3*t+2];return Math.sqrt(i*i+n*n+s*s)};for(let e=0;e<8;++e){const i=d(t,e);h=Math.max(h,i)}const p=h;e[3]=p+2}},x._updateConvexHull=function(){const e=this.extentInRadians,t=this.ellipsoid.radius;if(0===this.level)return;const i=this.elevationBounds,o=this._getPatchType(),r=this.surface.isWebMercator,l=r&&o===a.PatchType.HAS_NORTH_POLE,c=r&&o===a.PatchType.HAS_SOUTH_POLE,h=c||l,d=Math.PI/2,p=e[0],f=e[2],m=c?-d:e[1],_=l?d:e[3],g=.5*(p+f),T=i[0],v=t+(h?Math.min(0,T-1):T),x=(e,t,i)=>b(e,t,i,v),y=s.create(),S=s.create(),E=s.create(),M=s.create();x(y,p,m),x(S,p,_),x(E,f,_),x(M,f,m);const P=(e,t)=>{for(let i=0;i<3;++i)this._convexHull[3*t+i]=e[i]};P(y,0),P(S,1),P(E,2),P(M,3);const A=i[1],L=t+(h?Math.max(0,A+1):A),C=s.create(),I=s.create(),R=s.create();b(I,g,_,v),b(R,g,m,v),n.add(C,I,R),n.normalize(C,C);const H=s.create(),B=s.create(),D=(e,t)=>{n.sub(B,e,t),n.normalize(B,B);const i=-n.dot(e,H)/n.dot(B,H);u.internalAssert(i>=0),n.scale(B,B,i),n.add(e,e,B)};if(2**this.lij[0]>2*this.lij[1]){const e=R,t=s.create();n.cross(t,$,e),n.normalize(t,t),n.cross(H,e,t),n.normalize(H,H),u.internalAssert(u.almostEquals(n.dot(H,e)/n.len(e),0)),D(y,S),D(M,E),P(y,0),P(M,3)}else if(2**this.lij[0]!==2*this.lij[1]){const e=I,t=s.create();n.cross(t,$,e),n.normalize(t,t),n.cross(H,t,e),n.normalize(H,H),D(S,y),D(E,M),P(S,1),P(E,2)}const j=(e,t)=>{const i=L/n.dot(t,C);for(let n=0;n<3;++n)this._convexHull[3*e+n]=t[n]*i};j(4,y),j(5,S),j(6,E),j(7,M)},x._getPatchType=function(){const e=this.lij[1],t=0===e,i=e===(1<<this.level)-1;return t?i?a.PatchType.HAS_BOTH_POLES:a.PatchType.HAS_NORTH_POLE:i?a.PatchType.HAS_SOUTH_POLE:a.PatchType.REGULAR},x.intersectsRay=function(e,t,i,n){const s=this._boundingSphere,o=s[3]+i,r=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],l=s[0]-e[0],a=s[1]-e[1],c=s[2]-e[2],u=(l*t[0]+a*t[1]+c*t[2])/r,h=t[0]*u-l,d=t[1]*u-a,p=t[2]*u-c;return h*h+d*d+p*p<o*o},x.getDefaultVerticesPerSide=function(){return this.level<m.length?m[this.level]+1:2},x.updateCornerElevations=function(){c.updateCornerSpherical(this.renderData),this._updateBoundingVolumes()},x.updateEdgeElevations=function(){c.updateEdgesAndCornersSpherical(this.renderData),this._updateBoundingVolumes()},x._checkBVs=function(){if(!u.ENABLE_TERRAIN_INTERNAL_CHECKS)return;if(this.level<=2)return;const e=this._boundingSphere,t=e[3],i=e,o=s.create(),r=this.ellipsoid.radius,l=this.elevationBounds;l[1],l[0];const a=r+l[0],c=1,f=0,m=this._center[h.CenterPosition.MIDDLE][3],_=this.convexHull,$=(e,t)=>{for(let i=0;i<3;++i)e[i]=_[3*t+i]};{const e=s.create(),t=s.create(),i=s.create(),o=s.create(),r=s.create(),l=(s,l,a,c)=>{$(t,s),$(i,l),$(o,a),n.sub(t,t,i),n.sub(o,o,i),n.cross(e,t,o),n.normalize(e,e);const h=n.dot(e,i);$(r,c);const d=n.dot(e,r),p=Math.abs(d-h);u.internalAssert(u.almostEquals(p,0),`Non coplanar ${s},${l},${a},${c} diff = ${p}`)};l(0,1,2,3),l(4,5,6,7),l(0,1,4,5),l(1,2,5,6),l(2,3,6,7),l(3,0,7,4)}const T=p.newDoubleArray(24),v=(e,t,i)=>{const n=4*e;for(let s=0;s<3;++s)T[n+s]=t[s];T[n+3]=i},x=s.create(),y=s.create(),S=s.create(),E=s.create(),M=(e,t,i,s)=>{$(x,t),$(y,i),$(S,s),n.sub(x,x,y),n.normalize(x,x),n.sub(S,S,y),n.normalize(S,S),n.cross(E,x,S),n.normalize(E,E);const o=n.dot(E,y);v(e,E,o)};M(0,0,1,2),M(1,1,0,4),M(2,1,5,2),M(3,3,2,6),M(4,4,0,3),M(5,4,6,5);const P=1,A=(e,t,i,n)=>{const s=4*e;return T[s+0]*t+T[s+1]*i+T[s+2]*n-T[s+3]},L=(e,t,i,n)=>A(e,t,i,n)>=-P,C=(e,t)=>L(e,t[0],t[1],t[2]),I=2**this.lij[0]>2*this.lij[1],R=(e,n,s)=>Math.sqrt(g(e,n,s,i[0],i[1],i[2]))<t,H=e=>R(e[0],e[1],e[2]),B=(e,t)=>R(e[t+0],e[t+1],e[t+2]),D=this.extentInRadians,j=.5*(D[0]+D[2]),N=D[1],O=D[3],V=s.create(),F=s.create();b(V,j,O,a),b(F,j,N,a);const z=I?"Upper":"Lower";let k=!0;for(let n=0;n<6;++n){for(let e=0;e<8;++e){const t=3*e,i=L(n,_[t+0],_[t+1],_[t+2]);k&&(k=i),u.internalAssert(i,`Tile[${this.lij}] Convex hull point ${e} outside of plane ${n}`)}u.internalAssert(C(n,F),`Tile[${this.lij}] (${z}) bottom mid outside of plane ${n}`),u.internalAssert(C(n,V),`Tile[${this.lij}] (${z}) top mid outside of plane ${n}`)}u.internalAssert(k,"Not all convex hull points are inside  convex hull polyhedron"),u.internalAssert(H(F),`Tile[${this.lij}] (${z}) bottom mid outside of bounding sphere`),u.internalAssert(H(V),`Tile[${this.lij}] (${z}) top mid outside of bounding sphere`);for(let n=0;n<8;++n){const e=B(_,3*n);u.internalAssert(e,`Tile[${this.lij}] Convex hull point ${n} outside of bounding sphere`)}for(let n=0;n<6;++n)for(let e=0;e<8;++e){const t=3*e;L(n,_[t+0],_[t+1],_[t+2])||console.error(`Tile[${this.lij}] Convex hull point ${e} outside of plane ${n}`)}const U=this.extentInRadians,q=Math.max(U[2]-U[0],U[3]-U[1]),w=Math.round(q*r),G=this.renderData;if(G){const e=G.geometryInfo,a=G.localOrigin,u=e.vertexAttributes?.position;if(!u)return;const h=u.count,p=s.create(),_=e.numVerticesPerSide-2,g=_*_,b=G.geometryState.neighborData,$=b.edgeResolutions.reduce(((e,t)=>e+t+1),0);for(let s=0;s<h;++s){const e=s<g,h=!e&&s<g+$;let T=!1,v=-1;if(h){let e=g;for(let t=0;t<4;++t){const i=b.edgeResolutions[t];if(s===e||s===e+i-1){T=!0;break}if(e+=i,s<e){v=t;break}}}const x=v,y=T,S=h&&!y,E=h?b.edgePeerNeighbors[x]:null,M=h&&E&&d.compareTilesByLij(this,E)>0,P=e?"internal":S?"edge":y?"corner":"pole";u.getVec(s,o),n.add(p,o,a);const C=n.len(p)-r;let I=0,R=!1;const H=l[0]-C,B=C-l[1],D=H>c,j=B>c,N=D||j,O=`Tile[${this.lij}].vertex[${s}]:${P}`+(D?"(below)":j?"(above)":"")+(M?"(Neighbor)":"");{const e=n.dist(p,i);if(e>=t+f){const i=e-t;N||(console.error(`${O} is out of the bounding sphere by ${i.toFixed(0)} / ${t.toFixed(0)}[tol=${f}] h=${C.toFixed(0)} / [${l[0].toFixed(0)}..${l[1].toFixed(0)}] (${(i/t).toFixed(0)})`),R=!0)}}for(let i=0;i<6;++i)if(!L(i,p[0],p[1],p[2])){const e=A(i,p[0],p[1],p[2]),n=s%_,o=(s-n)/_;0===i&&H||5===i&&B||(console.error(`${O} (${n},${o})|${_}] is out of the bounding trapezoid plane ${i} h=${Math.round(C)} / [${Math.round(l[0])}..${Math.round(l[1])}] dist=${Math.round(e)} radii = ${Math.round(t)}/${Math.round(m)}} : maxL = ${w}`),++I)}if(R||I>0)break}}},t._createClass(f,[{key:"convexHull",get:function(){return this._convexHull}}]),f}(h.Tile);const m=[128,64,64,32,16,8,8,4];function _(e,t,i){return g(e[0],e[1],e[2],t[i+0],t[i+1],t[i+2])}function g(e,t,i,n,s,o){const r=n-e,l=s-t,a=o-i;return r*r+l*l+a*a}const b=(e,t,i,n)=>{const s=Math.cos(t),o=Math.sin(t),r=Math.cos(i),l=Math.sin(i);e[0]=n*r*s,e[1]=n*r*o,e[2]=n*l},$=[0,0,1],T=s.create(),v=s.create();e.SphericalPatch=f,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
