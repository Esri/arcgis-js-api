/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../core/mathUtils.js";import{isSome as t,abortMaybe as i,isNone as s}from"../../../core/maybe.js";import n from"../../../core/ObjectPool.js";import{c as r,a}from"../../../chunks/vec2.js";import{a as o}from"../../../chunks/vec2f64.js";import{b as h,p as l,e as d,g as u,a as c,l as g}from"../../../chunks/vec3.js";import{c as f,u as p}from"../../../chunks/vec3f64.js";import{E as m}from"../../../chunks/common.js";import{getReferenceEllipsoid as _}from"../../../geometry/projectionEllipsoid.js";import{create as y,equals as A}from"../../../geometry/support/aaBoundingRect.js";import{c as E}from"../../../chunks/sphere.js";import{VectorTile as T}from"../../2d/engine/vectorTiles/VectorTile.js";import{ImageWithType as v}from"../support/StreamDataLoader.js";import{ElevationBounds as L}from"./ElevationBounds.js";import{ElevationTileAgent as M}from"./ElevationTileAgent.js";import{LODSnapping as D,TextureUpdate as I,NeighborIndex as N}from"./interfaces.js";import{LayerClasses as b,LayerClass as S}from"./LayerClass.js";import{MapTileAgent as x}from"./MapTileAgent.js";import{RasterTile as j}from"./RasterTile.js";import{MAX_PATCH_TESSELATION as O,getElevationDesiredResolutionLevel as C}from"./TerrainConst.js";import{weakAssert as U,getLayerWithExtentRange as R,isBlendableLayerView as P,oppositeCorner as B,neighborCornerIndices as G,neighborEdgeIndices as V,oppositeEdge as W,internalAssert as w,isNorth as q,isSouth as H,isWest as F,isEast as k,ENABLE_WATERPROOFNESS_TESTS as X,isWestCorner as z,isNorthCorner as J}from"./terrainUtils.js";import{TILE_AGENT_DONE as Y}from"./TileAgent.js";import{TilePerLayerInfo as $}from"./TilePerLayerInfo.js";import Q from"./TileTexture.js";import{TileUpdate as K}from"./TileUpdate.js";import{fallsWithinLayer as Z}from"./tileUtils.js";import{getGpuMemoryUsage as ee}from"../../webgl/Util.js";const te=f(),ie=f(),se=f(),ne=.1;class re{constructor(){this.fovX=0,this.fovY=0,this.relativeWidthLimit=0,this.relativeHeightLimit=0,this.maxLod=0,this.angledSplitBias=0,this.aboveGround=!0}}class ae{constructor(){this.lij=[0,0,0],this._children=[null,null,null,null],this._pendingUpdates=0,this._dirty=!0,this._previouslyRendered=!1,this.extent=y(),this._elevationBounds=o(),this.layerInfo=[[],[]],this.extentInRadians=y(),this.centerAtSeaLevel=f(),this._center=[f(),E(),f()],this.up=p(),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._maxTesselation=0,this._usedMemory=null,this._mapTileMemory=0,this._mapDataRefCount=0,this._screenDepth=0,this.renderOrder=0,this._edgeLen=0,this._edgeLen2=0,this._curvatureHeight=0}static prune(){le.prune(0),de.prune(0),$.prune()}get isCached(){return!this.shouldLoad&&this._mapDataRefCount<=0}get maxTesselation(){return this._maxTesselation}get isWithinClippingArea(){return this._isWithinClippingArea}get intersectsClippingArea(){return this._intersectsClippingArea}get clippingArea(){return this._clippingArea}get parent(){return this._parent}get children(){return this._children}get surface(){return this._surface}get elevationBounds(){return this._elevationBounds}get level(){return this.lij[0]}get key(){return`${this.lij[0]}/${this.lij[1]}/${this.lij[2]}`}get edgeLen(){return this._edgeLen}get radius(){return this._center[ce.MIDDLE][3]}get screenDepth(){return this._screenDepth}get visible(){return this._dirty&&this.computeVisibility(),this._visible}computeVisibility(){this._dirty=!1;const e=this._intersectsClippingArea&&this._isVisible(this.surface.frustum);return e!==this._visible&&(this._visible=e,this._surface.emit("tiles-visibility-changed"),this._surface.renderer.setNeedsRender(),this.updateAgentSuspension()),this._visible}get loadable(){return this.visible||this._surface.view.state.fixedContentCamera}get rendered(){const e=!!this.renderData;return e!==this._previouslyRendered&&(this._surface.emit("tiles-visibility-changed"),this._previouslyRendered=e,this._surface.renderer.setNeedsRender()),e}get shouldLoad(){if(!this.loadable)return!1;if(this._surface.lodSnapping===D.ON){const e=this.level-this._surface.snapLevel;if(0===e)return!0;if(1===e)return!1}return this.isLeaf}init(e,t,i){this.lij[0]=e[0],this.lij[1]=e[1],this.lij[2]=e[2],this.ellipsoid=_(i.tilingScheme.spatialReference),i.tilingScheme.getExtent(e[0],e[1],e[2],this.extent),i.tilingScheme.convertExtentToRadians(this.extent,this.extentInRadians),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._clippingArea=null,this._mapDataRefCount=0,i.upsampleMapCache.pop(this.key),this._edgeLen=0,this._edgeLen2=0,this._center[ce.MIDDLE][3]=0,this.vlevel=e?e[0]:0,t&&t.elevationBounds?r(this._elevationBounds,t.elevationBounds):a(this._elevationBounds,0,0),this._pendingUpdates=0,this.renderData=null,this._screenDepth=0,this._visible=!1,this._previouslyRendered=!1,this._parent=t,this.unsetChildren(),this._surface=i,this.updateVisibility();for(const s of b){const e=i.numLayers(s),t=this.layerInfo[s];for(const i of t)i.release();t.length=e;for(let i=0;i<e;i++)t[i]=$.acquire(this._surface.upsampleInfoPool),s===S.ELEVATION&&this.findElevationBoundsForLayer(i,-1)}this.computeElevationBounds(),this._maxTesselation=Math.min(i.tilingScheme.pixelSize,O)}release(){U(!this.renderData,"tile.renderData was not unloaded"),this._surface.upsampleMapCache.pop(this.key);for(const e of b){for(const t of this.layerInfo[e])t.release();this.layerInfo[e].length=0}this._parent=null,this._surface=null,this.setMemoryDirty()}refMapData(){++this._mapDataRefCount,this.isCached||this._surface.upsampleMapCache.pop(this.key)}unrefMapData(){if(--this._mapDataRefCount,this.isCached){this.setMemoryDirty();const e=this.cachedMemory;e>0&&this._surface.upsampleMapCache.put(this.key,this,e)}}setMemoryDirty(){this._usedMemory=null}get usedMemory(){return this._ensureUsedMemory()+(this.isCached?0:this._mapTileMemory)}get cachedMemory(){return this.isCached?this.mapTileMemory:0}get mapTileMemory(){return this._ensureUsedMemory(),this.layerInfo[S.MAP].reduce(((e,t)=>e+(t instanceof T?t.memoryUsage:0)),this._mapTileMemory)}get cpuImageMemorySize(){const e=4,t=this._surface.tilingScheme.pixelSize;return t*t*e}_ensureUsedMemory(){if(t(this._usedMemory))return this._usedMemory;this._usedMemory=0,this._mapTileMemory=0;let e=0;for(const{data:t}of this.layerInfo[S.MAP])t instanceof T?e+=this._getTerrainDataMemory(t):this._mapTileMemory+=this._getTerrainDataMemory(t);const i=this.cpuImageMemorySize;for(const t of this.layerInfo[S.ELEVATION])this._usedMemory+=t.data?i:0;return this.renderData&&(this._usedMemory+=this.renderData.estimatedGeometryMemoryUsage,this._mapTileMemory+=ee(this.renderData.textureDescriptor)),this.isCached&&this._surface.upsampleMapCache.updateSize(this.key,this,this._mapTileMemory+e),this._usedMemory}getUsedMemoryForLayer(e,t){const i=this.layerInfo[e][t];return i?.data?e===S.MAP?this.isCached?0:this._getTerrainDataMemory(i.data):e===S.ELEVATION?this.cpuImageMemorySize:0:0}_getTerrainDataMemory(e){return e instanceof Q?ee(e.texture):e instanceof HTMLImageElement||e instanceof v?this.cpuImageMemorySize:e instanceof T||e instanceof j?e.memoryUsage:0}updateScreenDepth(e){const t=this._center[ce.MIDDLE],i=e,s=t[0],n=t[1],r=t[2],a=i[2]*s+i[6]*n+i[10]*r+i[14];this._screenDepth=a<0?0:a/(i[3]*s+i[7]*n+i[11]*r+i[15])}shouldSplit(e,i,s){if(t(e.frustum)&&(!this._intersectsClippingArea||!this._isVisible(e.frustum)))return K.NONE;const n=this.level;h(te,this._center[ce.MIDDLE],i);let r=l(te),a=ce.MIDDLE;h(ie,this._center[ce.TOP],i);const o=l(ie);o<r&&(r=o,a=ce.TOP),h(ie,this._center[ce.BOTTOM],i);const f=l(ie);if(f<r&&(r=f,a=ce.BOTTOM),this._edgeLen2>r&&n<e.maxLod)return K.SPLIT;const p=Math.sqrt(r),m=e.fovX*p*2,_=this._edgeLen/m,y=()=>{const t=n+Math.ceil(-Math.log2(e.relativeWidthLimit/_));return t!==this.vlevel?(this.vlevel=t,K.VSPLITMERGE):K.NONE_HIT_MAXLOD};if(s===D.ON){if(1===this._surface.snapLevel-n)return n>=e.maxLod?y():K.SPLIT}const A=d(this.up,te),E=this._elevationBounds[1]-this._elevationBounds[0],T=E/this.edgeLen;if(e.aboveGround&&A>0&&T<.001){if(A/p-Math.sin(this._curvatureHeight/(this.edgeLen*Math.SQRT1_2)*Math.PI)-T>0)return K.NONE}if(_<e.relativeWidthLimit)return this.vlevel!==this.level?(this.vlevel=this.level,K.VSPLITMERGE):K.NONE;if(n>=e.maxLod)return y();if(n>6){h(ie,this._center[a],i),u(se,this.up,A),h(se,se,ie);const t=l(se);if(t>this.radius*this.radius){u(se,se,this.radius/Math.sqrt(t)),c(se,se,this._center[a]),h(se,i,se);const s=Math.min(1,(Math.abs(d(se,this.up))+.5*E+this._curvatureHeight)/g(se)),n=ne/e.angledSplitBias,r=e.fovY*p*2;if(s*(this._edgeLen/r)<n*e.relativeHeightLimit)return K.NONE}}return K.SPLIT}setChildren(e,t,i,s){U(!!(e&&t&&i&&s),"Null child passed"),this._children[0]=e,this._children[1]=t,this._children[2]=i,this._children[3]=s}unsetChildren(){this._children[0]=null,this._children[1]=null,this._children[2]=null,this._children[3]=null}get isLoaded(){return this.renderData?.hasGeometry??!1}prepareToLoad(e){this.refMapData();for(const t of b)this._createOrUpdateAgents(0,t);e.updateTileGeometryState(this)}load(e){this.prepareToLoad(e),this.loadPrepared(e)}loadPrepared(e){e.loadTile(this)}unload(e){e.unloadTile(this);for(const t of b){const e=this.layerInfo[t];for(const t of e)t.loadingAgent&&t.loadingAgent!==Y&&(he(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0}this.resetPendingUpdate(K.GEOMETRY),this.resetPendingUpdate(K.TEXTURE_NOFADING),this.resetPendingUpdate(K.TEXTURE_FADING),this.unrefMapData()}unloadMapData(){const e=this.layerInfo[S.MAP];for(const t of e)t.loadingAgent&&t.loadingAgent!==Y&&(he(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0;this.renderData&&this.renderData.releaseTexture(),this.setMemoryDirty()}updateClippingStatus(e){if(A(e,this._clippingArea))return!1;const i=this._intersectsClippingArea,s=this._isWithinClippingArea;t(e)?(this._intersectsClippingArea=this.intersectsExtent(e),this._isWithinClippingArea=this._isWithinExtent(e)):(this._intersectsClippingArea=!0,this._isWithinClippingArea=!0),this._clippingArea=e,this.updateVisibility();const n=s&&this._isWithinClippingArea,r=!(s||i||this._isWithinClippingArea||this._intersectsClippingArea);return!this.renderData||n||r||this.setPendingUpdate(K.GEOMETRY),!0}updateVisibility(){this._dirty=!0,this._surface.setTileTreeDirty()}getLayerInfo(e,t){return this.layerInfo[t][e]}hasLayerData(e,t){const i=this.layerInfo[t][e];return!(!i||!i.data||i.dataInvalidated)}get updating(){if(this.hasPendingUpdates)return!0;for(const e of b){const t=this.layerInfo[e];for(const e of t)if(e.loadingAgent&&e.loadingAgent!==Y&&e.loadingAgent.updating)return!0}return!1}_isSuspended(e){return!!this.hasPendingUpdate(K.SPLIT)||e!==S.ELEVATION&&!this.loadable}get hasPendingUpdates(){return 0!==this._pendingUpdates}hasPendingUpdate(e){return(this._pendingUpdates&e)===e}setPendingUpdate(e){this._pendingUpdates|=e,e===K.SPLIT||e===K.MERGE?this._surface.setTileTreeDirty():this._surface.requestUpdate()}resetPendingUpdate(e){return!!this.hasPendingUpdate(e)&&(this._pendingUpdates&=~e,!0)}requestLayerData(e,t,s){const n=this.layerInfo[t][e];if(n.waitingAgents.has(s))return console.warn("agent already requested this piece of map data (tile %s, agent tile %s, layer: %d/%d)",this.lij.toString(),s.tile.lij.toString(),t,e),!0;if(n.waitingAgents.push(s),n.data&&!n.dataInvalidated)return console.warn("agent requested existing data (tile %s, agent tile %s, layer: %d/%d)",this.lij.toString(),s.tile.lij.toString(),t,e),s.dataArrived(this),!0;if(n.requestPromise)return!0;i(n.requestAbort),n.requestAbort=new AbortController;const r=this._surface.requestTileData(this,e,t,n.requestAbort);if(!r)return n.requestAbort=null,!1;const a=()=>{n.requestPromise===r&&(n.requestPromise=null,n.requestAbort=null)};return n.requestPromise=r,r.then(a,a),!0}get isLeaf(){return null==this._children[0]}hasLij(e){return this.lij[0]===e[0]&&this.lij[1]===e[1]&&this.lij[2]===e[2]}findByLij(e){if(this.hasLij(e))return this;if(this.isLeaf)return null;const t=this._children[0].findByLij(e)||this._children[1].findByLij(e)||this._children[2].findByLij(e)||this._children[3].findByLij(e);return t||null}distanceToSquared(e){return l(h(se,this._center[ce.MIDDLE],e))}containsPoint(e){const t=this.extent;return e[0]>=t[0]&&e[1]>=t[1]&&e[0]<=t[2]&&e[1]<=t[3]}unrequestLayerData(e,t,i){const s=this.layerInfo[t][e],n=s.waitingAgents,r=null!=n.removeUnordered(i);U(r,"agent has not requested this piece of map data"),n.length<1&&(s.abortRequest(),this.setMemoryDirty())}dataArrived(e,t,i){const s=this.layerInfo[t][e];s.data=i,s.dataInvalidated=!1,s.waitingAgents.forAll((e=>e.dataArrived(this))),s.waitingAgents.clear(),this.setMemoryDirty()}dataMissing(e,t,i){i.notInTilemap||console.error(`Tile ${this.lij.toString()} layer ${t}/${e} error ${i}`);const s=this.layerInfo[t][e];s.dataMissing=!0,s.waitingAgents.forAll((e=>e.dataMissing())),s.waitingAgents.clear(),this.setMemoryDirty()}updateRenderData(e,t){switch(e){case S.MAP:return this._updateTexture(t);case S.ELEVATION:return this._updateGeometry()}}_updateTexture(e){this.renderData&&(this.resetPendingUpdate(e===I.FADING?K.TEXTURE_NOFADING:K.TEXTURE_FADING),this.setPendingUpdate(e===I.FADING?K.TEXTURE_FADING:K.TEXTURE_NOFADING))}_updateGeometry(){this.setPendingUpdate(K.GEOMETRY);for(const e of this.layerInfo[S.ELEVATION])e.pendingUpdates|=K.GEOMETRY}invalidateLayerData(e,t){this.layerInfo[t][e].invalidateSourceData(),this.restartAgents(t)}computeElevationBounds(){const e=this._elevationBounds;a(e,Number.MAX_VALUE,-Number.MAX_VALUE);const i=this.layerInfo[S.ELEVATION];let s=!0;for(const n of i)t(n.elevationBounds)&&(e[0]=Math.min(e[0],n.elevationBounds.min),e[1]=Math.max(e[1],n.elevationBounds.max),n.elevationBounds.hasNoDataValues||(s=!1));s&&(e[0]=Math.min(e[0],0),e[1]=Math.max(e[1],0)),this.updateRadiusAndCenter(),this._surface.setTileTreeDirty()}_updateCenter(){const e=this._elevationBounds,t=.5*(e[0]+e[1]);u(se,this.up,t),c(this._center[ce.MIDDLE],this.centerAtSeaLevel,se),u(se,this.up,e[0]),c(this._center[ce.TOP],this.centerAtSeaLevel,se),u(se,this.up,e[1]),c(this._center[ce.BOTTOM],this.centerAtSeaLevel,se)}findElevationBoundsForLayer(e,i){const n=this.layerInfo[S.ELEVATION][e];if(t(n.elevationBounds)&&n.elevationBounds.level>=i)return;const r=this._surface.layerViewByIndex(e,S.ELEVATION),a=R(r);if(!Z(this,a,!1))return;const o=ue;let h=!1;if(n.data){const e=n.data;o.min=e.bounds[0],o.max=e.bounds[1],o.hasNoDataValues=e.hasNoDataValues,o.level=this.level,h=!0}else{let t,i,s=0;for(let n=this._parent;n&&(!i||s<C(this.level))&&(s=this.vlevel-n.level,t=i||t,i=n.layerInfo[S.ELEVATION][e].data,!(!i&&t&&s>=C(this.level)));n=n.parent);i=i||t,i&&(i.computeMinMaxValue(this.lij[0],this.lij[1],this.lij[2],o),o.min!==1/0&&(o.level=i.level,h=!0))}h&&(s(n.elevationBounds)&&(n.elevationBounds=new L),n.elevationBounds.copyFrom(o))}modifyLayers(e,t,i){const s=this.layerInfo[i];for(const a of s)a.loadingAgent&&a.loadingAgent!==Y&&(he(a.loadingAgent),a.loadingAgent=null),a.waitingAgents.clear();for(let a=0;a<s.length;++a)void 0===e[a]&&s[a].release();const n=new Array(...s),r=t.length;s.length=r;for(let a=0;a<r;a++){const e=t[a];s[a]=e>-1?n[e]:$.acquire(this._surface.upsampleInfoPool)}this.setMemoryDirty()}restartAgents(e){this.renderData&&(this._createOrUpdateAgents(0,e),this.updateRenderData(e,I.FADING))}updateAgents(e){if(this.renderData){const t=this.layerInfo[e];for(const e of t)e.loadingAgent===Y&&(e.loadingAgent=null);this._createOrUpdateAgents(0,e)}}updateAgentSuspension(){for(const e of b){const t=this._isSuspended(e);for(const i of this.layerInfo[e])i.loadingAgent&&i.loadingAgent!==Y&&(i.loadingAgent.setSuspension(t),i.loadingAgent===Y&&this.updateRenderData(e,I.FADING))}}removeLayerAgent(e,t){const i=this.layerInfo[t][e];i.loadingAgent&&i.loadingAgent!==Y&&i.loadingAgent.dispose(),i.loadingAgent=null}agentDone(e,t){const i=this.layerInfo[t][e];i.loadingAgent=Y,!i.data&&s(i.upsampleInfo)&&this._createOrUpdateAgents(e+1,t)}_createOrUpdateAgents(e,t){const i=this.layerInfo[t];if(0===i.length)return;const s=(()=>{for(let s=e;s<i.length;++s){const e=this._surface.layerViewByIndex(s,t);if(P(e)&&"normal"!==e.layer.blendMode)return!0}return!1})(),n=this._isSuspended(t);for(let r=e;r<i.length;++r){const e=i[r];let a=!1;const o=this._surface.layerViewByIndex(r,t),h=R(o);if(e.loadingAgent?Z(this,h,!1)?(e.loadingAgent!==Y&&e.loadingAgent.setSuspension(n),e.loadingAgent!==Y&&(a=e.loadingAgent.update())):e.dispose():Z(this,h,!1)&&(e.loadingAgent=oe(this,r,t,n),a=e.loadingAgent.startLoading(),a?e.loadingAgent===Y&&this.setPendingUpdate(K.GEOMETRY):(he(e.loadingAgent),e.loadingAgent=Y)),e.loadingAgent===Y&&this.updateRenderData(t,I.FADING),!s&&a&&o.isOpaque)return}}_isWithinExtent(e){const t=this.extent;return t[0]>=e[0]&&e[2]>=t[2]&&t[1]>=e[1]&&e[3]>=t[3]}intersectsExtent(e){const t=this.extent;return t[2]>=e[0]&&e[2]>=t[0]&&t[3]>=e[1]&&e[3]>=t[1]}getElevationBasedVerticesPerSide(t){const i=this.vlevel-this.level,s=Math.max(this.level-t,C(this.level)-i);return e(1+(this.maxTesselation>>s),2,this.maxTesselation+1)}get test(){return{cachedMemory:this.cachedMemory}}_findLIJ(e,i){if(!e)return null;const s=this.surface.rootTiles;if(t(s))for(const t of s)if(ge(t,e)){let s=t,n=e[0]-s.level-1;for(;n>=0&&!s.isLeaf&&!i(s);){const t=e[1]>>n&1,i=e[2]>>n&1;s=s.children[2*t+i],n--}return i(s)?s:null}return null}findNeighborTile(e,t){const i=this.lij,s=this.getNeighborLIJ(i,e);return s?fe(i,s)?t(this)?this:null:this._findLIJ(s,t):null}findCorner(e,t){const i=e===N.NORTH_EAST?1:e===N.NORTH_WEST?0:e===N.SOUTH_WEST?2:3;let s=this;for(;!(s.isLeaf||t&&t(s));)s=s.children[i];return s}findNeighborCornerTileExact(e,t){return this.findNeighborTile(e,(e=>t(e)||e.level===this.level))?.findCorner(B(e),t)}forAllSubtreeOnSide(e,t){const i=e===N.NORTH?[0,1]:e===N.NORTH_EAST?[1]:e===N.EAST?[1,3]:e===N.SOUTH_EAST?[3]:e===N.SOUTH?[2,3]:e===N.SOUTH_WEST?[2]:e===N.WEST?[0,2]:[0],s=e=>{t(e)||e.isLeaf||i.forEach((t=>s(e.children[t])))};s(this)}forallNeighbors(e){G.forEach((t=>this.findNeighborCornerTileExact(t,e))),V.forEach((t=>this.findNeighborTile(t,(t=>t.level===this.level||e(t)))?.forAllSubtreeOnSide(W(t),e)))}getNeighborEdgeStartVertexIndex(e,t){const i=t??this.findNeighborTile(V[e],(e=>e.isLoaded));if(!i||!this.isLoaded||!i.isLoaded)return 0;const s=this.level-i.level;if(0===s)return 0;const n=2**s,r=1==(1&e),a=r?0:1,o=i.lij[a+1]*n,h=this.lij[a+1]-o;return r?n-1-h:h}_updateNeighborsWithChangedEdgeResolution(){for(let e=0;e<4;++e)if(this.renderData.geometryState.neighborData.modifiedEdgeResolutions[e]){const t=V[e],i=this.findNeighborTile(t,(e=>e.isLoaded||e.level===this.level));if(!i)continue;if(!i.isLoaded){w(!i.isLeaf);const s=(e+2)%4,n=W(t);i.forAllSubtreeOnSide(n,(e=>e.isLoaded?(e.updateEdgeAfterResolutionChange(s),!0):(w(!e.isLeaf),!1)))}this.renderData.geometryState.neighborData.modifiedEdgeResolutions[e]=!1}}updateNeighborDataAndGeometryIfNeeded(){this.isLoaded&&this.renderData.updateNeighborDataAndGeometryIfNeeded()}updateNeighborsAfterGeometryChange(e=this.level){this.forEachLoadedNeighbor((e=>this._updateNeighbor(e))),V.forEach((t=>{this.findNeighborTile(t,(t=>t.isLoaded&&t.level<e))?.updateNeighborsWithChangedEdgeResolution()}))}updateNeighborsWithChangedEdgeResolution(){this.isLoaded&&this._updateNeighborsWithChangedEdgeResolution()}updateEdgeAfterResolutionChange(e){this.renderData.updateEdgeAfterResolutionChange(e)}forEachLoadedNeighbor(e){const t=this.level,i=e=>e.level===t||e.isLoaded;V.forEach(((t,s)=>{const n=this.findNeighborTile(t,i);null!=n&&n!==this&&n.forAllSubtreeOnSide(W(t),(t=>!!t.isLoaded&&(e(t),!0)));const r=this.renderData?.geometryState?.neighborData;r&&(r.modifiedEdgeResolutions[s]=!1)})),G.forEach((t=>{const s=this.findNeighborTile(t,i)?.findCorner(B(t),(e=>e.isLoaded));w(!s||_e(this,s,t)),s?.isLoaded&&e(s)}))}_updateNeighbor(e){e?.isLoaded&&e.updateNeighborDataAndGeometryIfNeeded()}getNeighborLIJ(e,t){const i=q(t)?-1:H(t)?1:0,s=F(t)?-1:k(t)?1:0,n=[e[0],e[1]+i,e[2]+s];return n[1]<0?null:this.surface.isGlobal?this.wrapLIJ(n):n[2]<0?null:n}wrapLIJ(e){return!e||e[1]<0||e[1]>=2**e[0]?null:this.surface.wrapEastWest(e)}get westNeighborWestExtent(){return this.extent[0]*(this.isWestEnd?-1:1)}get eastNeighborEastExtent(){return this.extent[2]*(this.isEastEnd?-1:1)}get isEastEnd(){return this.lij[2]===this.surface.lijEastEnd(this.level)-1}get isWestEnd(){return 0===this.lij[2]}get isNorthEnd(){return 0===this.lij[1]}get isSouthEnd(){return this.extent[1]+m>=this.surface.extent[1]}compareLIJs(e){const t=this.lij,i=t[0],s=e[0];if(i===s)return[t,e];const n=i-s;if(n<0){const i=2**-n;return[[s,t[1]*i,t[2]*i],e]}{const s=2**n;return[t,[i,e[1]*s,e[2]*s]]}}checkGeometryWaterproofness(){X&&(w(this.isLoaded),this.renderData.checkGeometryWaterproofness())}shouldHaveNeighbor(e){const t=this.extent,i=this.surface.rootTilesExtent,s=.25*(t[2]-t[0]);if(q(e)&&t[3]+s>=i[3])return!1;if(H(e)&&t[1]-s<=i[1])return!1;const n=this.surface.isGlobal;return!(!n&&F(e)&&t[0]-s<=i[0])&&!(!n&&k(e)&&t[2]+s>=i[2])}}function oe(e,t,i,s){const n=i===S.ELEVATION?de.acquire():le.acquire();return n.init(e,t,i,s),n}function he(e){e.dispose(),e instanceof M?de.release(e):e instanceof x&&le.release(e)}const le=new n(x),de=new n(M),ue=new L;var ce;function ge(e,t){const i=e.level,s=t[0];if(i>s)return!1;const n=s-i,r=Math.floor(t[1]/2**n),a=Math.floor(t[2]/2**n);return r===e.lij[1]&&a===e.lij[2]}function fe(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function pe(e,t,i){return Math.abs(e-t)<=i}function me(e,t,i){if(s(e)||s(t))return!1;if(0===e.level&&0===t.level){if(e.isEastEnd&&t.isWestEnd&&i===N.EAST)return!0;if(e.isWestEnd&&t.isEastEnd&&i===N.WEST)return!0}const n=1e-6*(e.extent[2]-e.extent[0]);switch(i){case N.NORTH:return pe(e.extent[3],t.extent[1],n);case N.SOUTH:return pe(e.extent[1],t.extent[3],n);case N.EAST:return pe(e.extent[2],t.extent[0],n)||pe(e.extent[2],-t.extent[0],n);case N.WEST:return pe(e.extent[0],t.extent[2],n)||pe(e.extent[0],-t.extent[2],n)}}function _e(e,t,i){return!s(e)&&!s(t)&&t!==e&&(e.level>=t.level?ye(e,t,i):ye(t,e,B(i)))}function ye(e,t,i){w(e.level>=t.level);const s=z(i),n=J(i),r=e.extent,a=t.extent,o=[s?r[0]:r[2],n?r[3]:r[1]],h=[s?a[2]:a[0],n?a[1]:a[3]],l=1e-5*(r[2]-r[0]),d=pe(o[0],h[0],l)||e.surface.isGlobal&&pe(o[0],-h[0],l),u=pe(o[1],h[1],l);if(d&&u)return!0;if(e.level===t.level)return!1;if(!d&&!u)return!1;return d?Ae(a[1],a[3],r[1],r[3],l):Ae(a[0],a[2],r[0],r[2],l)}function Ae(e,t,i,s,n=m){return e-n<=i&&i<=s&&s<=t+n}!function(e){e[e.TOP=0]="TOP",e[e.MIDDLE=1]="MIDDLE",e[e.BOTTOM=2]="BOTTOM"}(ce||(ce={}));export{ce as CenterPosition,re as SplitLimits,ae as Tile,pe as almostEquals,_e as isCornerNeighbor,me as isEdgeNeighbor};
