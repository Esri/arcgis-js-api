/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../core/mathUtils","../../../core/maybe","../../../chunks/vec4","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","./ElevationData","./interfaces","./PatchGeometry","./PatchGeometryLUT","./PatchRenderData","./terrainUtils","./Tile","./tileUtils"],(function(e,t,n,o,s,i,r,a,l,c,u,d,f,m){"use strict";const p=65536;function g(e,t){const n=e.tile,{extent:o,extentInRadians:i,surface:r}=n,c=e.localOrigin,u=e.geometryState,f=r.isWebMercator,m=r.shading||Y,p=u.numVerticesPerSide,g=p-1,x=(p-2)**2,M=f&&(t===a.PatchType.HAS_SOUTH_POLE||t===a.PatchType.HAS_BOTH_POLES),B=f&&(t===a.PatchType.HAS_NORTH_POLE||t===a.PatchType.HAS_BOTH_POLES),E=6,S=((M?1:0)+(B?1:0))*E*(g+1),v=u.neighborData,L=v.edgeResolutions.reduce(((e,t)=>e+t+1),0),T=x+S+L,I=l.acquireTerrainAttributes(T),R=e.geometryInfo;R.numVerticesPerSide=u.numVerticesPerSide,R.vertexAttributes=I;const N=R.boundingBox;s.empty(N);const V=b(e);k.update(g,i,V),h(e),q(e,x),A(e);const P=[];if((()=>{let e=x+L;const t=c[0],s=c[1],i=c[2],r=n.ellipsoid.radius,a=o[1],u=o[3],d=(n,o)=>{const c=o*p,d=-t,f=-s,h=n*r-i;l.minMaxBoundingBox(d,f,h,N),P.push({connectedRowOffset:c,connectedOuterEdgeOffset:1===n?0:2,rowOffset:e,latitudeResolution:E});const x=y(-1===n?a:u,r),M=n*Math.PI/2-x,B=.99*(1===n?1:-1),A=r+0,S=I.position,v=I.uv0,L=I.normalCompressed;for(let r=1;r<=E;++r){const n=x+M*(r/E),o=Math.cos(n),a=Math.sin(n);for(let r=0;r<=g;r++){const n=r/g,c=k.sinLonLUT[r],u=k.cosLonLUT[r]*o,d=c*o,f=a,p=u*A-t,h=d*A-s,x=f*A-i;l.minMaxBoundingBox(p,h,x,N),S.setValues(e,p,h,x),l.encodeUVInBuffer(v,e,n,B),m&&l.encodeNormalToBufferFromValues(L,e,u,d,f),++e}}};M&&d(-1,0),B&&d(1,g)})(),j(R,u.numVerticesPerSide,P,[0,p-1],[0,p-1],u.wireframe),e.intersectionData=null,d.ENABLE_TERRAIN_INTERNAL_CHECKS)for(let s=0;s<4;++s)d.internalAssert(R.outerEdges[s].count===v.edgeResolutions[s]+1)}function h(e){const t=e.tile;t.intersectsClippingArea&&(t.surface.shading||Y?M(e):x(e))}function x(e){const t=e.geometryState,n=t.numVerticesPerSide,o=n-2,s=n-1,i=e.geometryInfo,a=i.vertexAttributes,c=a.position,u=a.uv0,d=e.tile,f=d.extent,m=f[0],p=f[2],g=f[1],h=f[3],x=d.ellipsoid.radius,M=t.samplerData,B=e.localOrigin,E=B[0],A=B[1],S=B[2],v=i.boundingBox,y=c.typedBuffer,L=c.typedBufferStride;let T=0;for(let b=1;b<=o;b++){const e=b/s,t=g*(1-e)+h*e,n=k.sinLatLUT[b],i=k.cosLatLUT[b];for(let a=1;a<=o;a++){const o=a/s,c=m*(1-o)+p*o,d=k.sinLonLUT[a],f=k.cosLonLUT[a],g=x+r.sampleElevation(c,t,M),h=f*i*g-E,B=d*i*g-A,b=n*g-S;l.minMaxBoundingBox(h,B,b,v);const I=T*L;y[I+0]=h,y[I+1]=B,y[I+2]=b,l.encodeUVInBuffer(u,T,o,e),++T}}}function M(e){const t=e.geometryState,n=t.numVerticesPerSide,o=n-2,s=n-1,i=e.geometryInfo,a=i.vertexAttributes,c=a.position,u=a.uv0,d=a.normalCompressed,f=e.tile,m=f.extent,p=m[0],g=m[2],h=m[1],x=m[3],M=f.ellipsoid.radius,B=t.samplerData,E=e.localOrigin,A=E[0],S=E[1],v=E[2],y=c.typedBuffer,L=c.typedBufferStride,T=1/s,b=i.boundingBox;let I=0;if(1<=o){const e=T,t=h*(1-e)+x*e,n=k.sinLatLUT[1],s=k.cosLatLUT[1];for(let i=1;i<=o;i++){const o=i*T,a=p*(1-o)+g*o,c=k.sinLonLUT[i],d=k.cosLonLUT[i],f=M+r.sampleElevation(a,t,B),m=f*d*s-A,h=f*c*s-S,x=f*n-v;l.minMaxBoundingBox(m,h,x,b);const E=(i-1)*L;y[E+0]=m,y[E+1]=h,y[E+2]=x,l.encodeUVInBuffer(u,i-1,o,e)}}for(let R=1;R<=o;R++){const e=R*T,t=h*(1-e)+x*e,n=k.sinLatLUT[R],i=k.cosLatLUT[R],a=R+1,c=a*T,f=h*(1-c)+x*c,m=k.sinLatLUT[a],E=k.cosLatLUT[a],N=k.sinLonLUT[0],V=k.cosLonLUT[0],P=M+r.sampleElevation(p,t,B);let C=V*i*P-A,O=N*i*P-S,U=n*P-v;const D=I*L;let _=y[D+0],w=y[D+1],H=y[D+2];for(let x=1;x<=o;x++){const e=x*T,a=p*(1-e)+g*e,N=k.sinLonLUT[x],V=k.cosLonLUT[x],P=V*i,D=N*i,j=n;let q=0,F=0,W=0;{let e=0,a=0,l=0;if(x<o){const t=(I+1)*L;e=y[t+0],a=y[t+1],l=y[t+2]}else{const o=k.sinLonLUT[s],c=k.cosLonLUT[s],u=M+r.sampleElevation(g,t,B);e=c*i*u-A,a=o*i*u-S,l=n*u-v}const c=C,u=O,d=U;C=_,O=w,U=H,_=e,w=a,H=l;const f=e-c,m=a-u,p=l-d,h=m*j-p*D,E=p*P-f*j,T=f*D-m*P;q=E*p-T*m,F=T*f-h*p,W=h*m-E*f}{let t=0,n=0,s=0;if(R>1){const e=(I-o)*L;t=y[e+0],n=y[e+1],s=y[e+2]}else{const e=k.sinLatLUT[0],o=k.cosLatLUT[0],i=M+r.sampleElevation(a,h,B);t=V*o*i-A,n=N*o*i-S,s=e*i-v}{const i=M+r.sampleElevation(a,f,B),d=V*E*i-A,p=N*E*i-S,g=m*i-v;if(R<o){const t=I+o,n=t*L;y[n+0]=d,y[n+1]=p,y[n+2]=g,l.minMaxBoundingBox(d,p,g,b),l.encodeUVInBuffer(u,t,e,c)}const h=t-d,x=n-p,T=s-g,C=x*j-T*D,O=T*P-h*j,U=h*D-x*P;q+=O*T-U*x,F+=U*h-C*T,W+=C*x-O*h}}const K=1/Math.sqrt(q*q+F*F+W*W);l.encodeNormalToBufferFromValues(d,I,q*K,F*K,W*K),++I}}}function B(e){e.tile.intersectsClippingArea&&(A(e),G(e))}function E(e){e.tile.intersectsClippingArea&&(v(e),S(e,!0),G(e))}function A(e){e.tile.intersectsClippingArea&&(v(e),S(e))}function S(e,o=!1){const s=e.geometryState,i=e.geometryInfo,a=s.neighborData,c=e.tile,f=c.level,p=c.extent,g=c.ellipsoid.radius,h=c.extentInRadians,x=h[0],M=h[2],B=h[1],E=h[3],A=s.samplerData,S=p[0],v=p[2],y=p[1],L=p[3],T=b(e),I=i.boundingBox,R=e.localOrigin,N=R[0],V=R[1],P=R[2],C=c.surface.shading||Y,O=i.vertexAttributes,U=O.position,D=U.typedBuffer,_=U.typedBufferStride,w=O.uv0;for(let b=0;b<4;++b){const s=1===b||3===b,h=a.edgeResolutions[b];d.internalAssert(t.isPowerOfTwo(h));const R=h+1,O=u.neighborTileIfLoadedOrSelf(c,a.edgePeerNeighbors[b]);if(X(c,O,b)){F(e,b);continue}const U=n.isSome(O);d.internalAssert(!U||O.level===c.level),d.internalAssert(!U||m.compareTilesByLij(c,O)<=0);const H=O?.renderData,j=H?.geometryState;if(d.ENABLE_TERRAIN_INTERNAL_CHECKS){const e=c.surface;if(!O&&e&&!e.updatingRootTiles){const t=d.neighborEdgeIndices[b],o=c.findNeighborTile(t,(e=>e.isLoaded||e.isLeaf||e.level===c.level));o?o.intersectsClippingArea&&(d.internalAssert(!o.isLoaded),d.internalAssert(!o.isLeaf),d.internalAssert(o.level===f)):d.internalAssert(n.isNone(e?.rootTiles)||!c.shouldHaveNeighbor(t))}}const q=1===b?p[2]:p[0],W=O?.extent,K=U&&s?1===b?W[0]:W[2]:q,G=0===b?p[3]:p[1],z=1===b?1:0,k=0===b?1:0,J=1===b?M:x,Q=0===b?E:B,Y=Math.sin(J),Z=Math.cos(J),$=Math.sin(Q),ee=Math.cos(Q),te=j?.samplerData,ne=(e,t,n)=>r.sampleElevation(e,t,A),oe=(e,t,n)=>.5*(r.sampleElevation(e,t,A)+r.sampleElevation(n,t,te)),se=U?oe:ne,ie=i.outerEdges[b],re=o&&R>3?R-3:1,ae=n.isSome(A)&&A.some((e=>null!=e)),le=n.isSome(te)&&te.some((e=>null!=e)),ce=ae||le,ue=1/h,de=ie.index0;if(C){d.internalAssert(!U||d.almostEquals(W[2]-W[0],p[2]-p[0]));(()=>{const e=1===b?-1:3===b?1:0,t=0===b?-1:2===b?1:0,n=(p[2]-p[0])*ue,o=e*n,i=t*n,a=s?e*((M-x)*ue):0,c=s?0:t*ue,u=k,d=s?J+a:J,f=s?Math.sin(d):Y,m=s?Math.cos(d):Z,h=s?J-a:J,B=s?Math.sin(h):Y,E=s?Math.cos(h):Z,C=s?Q:T(u+c),O=s?$:Math.sin(C),H=s?ee:Math.cos(C),j=s?Q:T(u-c),F=s?$:Math.sin(j),W=s?ee:Math.cos(j),X=(de+0)*_;let ne=D[X+0]+N,oe=D[X+1]+V,ae=D[X+2]+P,le=0,fe=0,me=0;{const e=1*ue,t=s?q:S*(1-e)+v*e,n=s?K:t,o=s?y*(1-e)+L*e:G,i=s?J:x*(1-e)+M*e,r=s?Y:Math.sin(i),a=s?Z:Math.cos(i),l=s?T(e):Q,c=s?Math.sin(l):$,u=s?Math.cos(l):ee,d=g+se(t,o,n);le=a*u*d,fe=r*u*d,me=c*d}for(let p=1;p<R-1;p+=re){let e=0,t=0,n=0;{const o=(de+p+1)*_;if(p<R-2){const o=(p+1)*ue,i=s?q:S*(1-o)+v*o,r=s?K:i,a=s?y*(1-o)+L*o:G,l=s?J:x*(1-o)+M*o,c=s?Y:Math.sin(l),u=s?Z:Math.cos(l),d=s?T(o):Q,f=s?Math.sin(d):$,m=s?Math.cos(d):ee,h=g+se(i,a,r);e=u*m*h,t=c*m*h,n=f*h}else e=D[o+0]+N,t=D[o+1]+V,n=D[o+2]+P}const a=e,c=t,u=n,d=le,h=fe,b=me;le=a,fe=c,me=u;{const e=de+p,t=e*_,n=d-N,o=h-V,i=b-P;D[t+0]=n,D[t+1]=o,D[t+2]=i,l.minMaxBoundingBox(n,o,i,I);const r=p*ue,a=s?z:r,c=s?r:k;l.encodeUVInBuffer(w,e,a,c)}const C=ne,j=oe,X=ae;ne=d,oe=h,ae=b;const re=d,pe=h,ge=b;let he=0,xe=0,Me=0;if(ce){const e=1/Math.sqrt(re*re+pe*pe+ge*ge),t=re*e,n=pe*e,l=ge*e;{const e=a-C,o=c-j,s=u-X,i=o*l-s*n,r=s*t-e*l,d=e*n-o*t;he+=r*s-d*o,xe+=d*e-i*s,Me+=i*o-r*e}{const e=p*ue,a=s?q:S*(1-e)+v*e,c=s?K:a,u=s?y*(1-e)+L*e:G,d=s?J:x*(1-e)+M*e,h=s?Y:Math.sin(d),b=s?Z:Math.cos(d),I=s?T(e):Q,R=s?Math.sin(I):$,N=s?Math.cos(I):ee;let V=re,P=pe,C=ge;if(U){const e=c-o,t=u-i,n=g+r.sampleElevation(e,t,te),a=s?N:W;V=(s?E:b)*a*n,P=(s?B:h)*a*n,C=(s?R:F)*n}{const e=a+o,c=u+i,d=g+r.sampleElevation(e,c,A),p=s?N:H,x=(s?m:b)*p*d,M=(s?f:h)*p*d,B=(s?R:O)*d;U||(V=2*re-x,P=2*pe-M,C=2*ge-B);const E=V-x,S=P-M,v=C-B,y=S*l-v*n,L=v*t-E*l,T=E*n-S*t;he+=L*v-T*S,xe+=T*E-y*v,Me+=y*S-L*E}}}else he=re,xe=pe,Me=ge;const Be=1/Math.sqrt(he*he+xe*xe+Me*Me);ie.setNormalFromValues(p,he*Be,xe*Be,Me*Be)}})()}else{(()=>{for(let e=1;e<R-1;e+=re){const t=e*ue,n=s?z:t,o=s?t:k,i=s?q:S*(1-t)+v*t,r=s?y*(1-t)+L*t:G,a=s?K:i,c=s?J:x*(1-t)+M*t,u=s?Y:Math.sin(c),d=s?Z:Math.cos(c),f=s?T(t):Q,m=s?Math.sin(f):$,p=s?Math.cos(f):ee,h=se(i,r,a),B=g+h,E=d*p*B-N,A=u*p*B-V,b=m*B-P;l.minMaxBoundingBox(E,A,b,I);const R=de+e,C=R*_;D[C+0]=E,D[C+1]=A,D[C+2]=b,l.encodeUVInBuffer(w,R,n,o)}})()}}}function v(e){W(e)}function y(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function L(e,t,n,o){return y(e*(1-o)+t*o,n)}function T(e,t,n){return e*(1-n)+t*n}function b(e){const t=e.tile;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius;return t=>L(e[1],e[3],n,t)}const n=t.extentInRadians;return e=>T(n[1],n[3],e)}function I(e,t){const i=e.tile.extent,r=e.geometryState,a=i[0],c=i[1],u=i[2]-a,d=i[3]-c,f=r.clippingArea,m=n.isSome(f)?Math.max(0,(f[0]-a)/u):0,p=n.isSome(f)?Math.max(0,(f[1]-c)/d):0,g=n.isSome(f)?Math.min(1,(f[2]-a)/u):1,h=n.isSome(f)?Math.min(1,(f[3]-c)/d):1,x=r.numVerticesPerSide,M=(x-2)**2,B=M+r.neighborData.edgeResolutions.reduce(((e,t)=>e+t+1),0),E=l.acquireTerrainAttributes(B),A=e.geometryInfo,S=A.boundingBox;s.empty(S),A.numVerticesPerSide=r.numVerticesPerSide,A.vertexAttributes=E,o.set(A.uvRange,m,p,g,h),R(e),q(e,M),O(e),j(A,r.numVerticesPerSide,[],[0,x-1],[0,x-1],r.wireframe),e.intersectionData=null}function R(e){const t=e.tile;t.intersectsClippingArea&&(t.surface.shading?V(e):N(e))}function N(e){const o=e.geometryState,s=o.samplerData,i=e.tile,a=i.surface,c=e.localOrigin,u=a.isWebMercatorOnPlateeCarree,d=o.clippingArea,f=n.isSome(d)?d:J,m=i.extent,p=m[0],g=m[1],h=m[2],x=m[3],M=Math.max(p,f[0]),B=Math.min(h,f[2]),E=Math.max(g,f[1]),A=Math.min(x,f[3]),S=c[0],v=c[1],y=c[2],L=i.ellipsoid.radius,T=i.horizontalScale,b=H(u,L,T),I=o.numVerticesPerSide,R=I-1,N=I-2,V=e.geometryInfo,P=V.uvRange,C=P[0],O=P[1],U=P[2],D=P[3],_=V.boundingBox,w=V.vertexAttributes,j=w.position,q=w.uv0;let F=0;for(let n=1;n<=N;n++){const e=n/R,o=t.clamp(g*(1-e)+x*e,E,A),i=t.clamp(e,O,D),a=b(o)-v;for(let n=1;n<=N;n++){const e=n/R,c=t.clamp(p*(1-e)+h*e,M,B),u=t.clamp(e,C,U),d=c*T-S,f=r.sampleElevation(c,o,s)-y;l.minMaxBoundingBox(d,a,f,_),j.setValues(F,d,a,f),l.encodeUVInBuffer(q,F,u,i),++F}}}function V(e){const o=e.tile,s=o.surface;if(!(s.shading||Y))return;const i=e.geometryState,a=i.samplerData,c=e.localOrigin,u=s.isWebMercatorOnPlateeCarree,d=i.clippingArea,f=n.isSome(d)?d:J,m=o.extent,p=m[0],g=m[1],h=m[2],x=m[3],M=Math.max(p,f[0]),B=Math.min(h,f[2]),E=Math.max(g,f[1]),A=Math.min(x,f[3]),S=o.ellipsoid.radius,v=o.horizontalScale,y=i.numVerticesPerSide,L=y-1,T=y-2,b=e.geometryInfo,I=b.vertexAttributes,R=I.position,N=I.uv0,V=I.normalCompressed,P=b.uvRange,C=P[0],O=P[1],U=P[2],D=P[3],_=b.boundingBox,w=c[0],H=c[1],j=c[2],q=R.typedBuffer,F=R.typedBufferStride;let W=0;const K=t.clamp(g,E,A),G=u?(Math.PI/2-2*Math.atan(Math.exp(-K/S)))*S:K*v,z=1/L,k=t.clamp(g*(1-z)+x*z,E,A);let Q=G,X=u?(Math.PI/2-2*Math.atan(Math.exp(-k/S)))*S:k*v;for(let n=1;n<=T;n++){const e=n/L,o=t.clamp(g*(1-e)+x*e,E,A),s=t.clamp(e,O,D),i=X,c=(n-1)/L,d=t.clamp(g*(1-c)+x*c,E,A),f=Q,m=(n+1)/L,y=t.clamp(g*(1-m)+x*m,E,A),b=u?(Math.PI/2-2*Math.atan(Math.exp(-y/S)))*S:y*v,I=t.clamp(m,O,D);Q=X,X=b;const R=t.clamp(p,M,B);let P=R*v,K=r.sampleElevation(R,o,a);const G=1/L,z=t.clamp(G,C,U),k=t.clamp(p*(1-z)+h*z,M,B);let J=z,Y=k,Z=k*v,$=r.sampleElevation(k,o,a);if(1===n){const e=Z-w,n=Q-H,o=$-j,i=0*F;q[i+0]=e,q[i+1]=n,q[i+2]=o,l.minMaxBoundingBox(e,n,o,_);const r=t.clamp(G,C,U);l.encodeUVInBuffer(N,W,r,s)}for(let u=1;u<=T;u++){const e=Z,c=$,m=(u+1)/L,g=t.clamp(m,C,U),x=t.clamp(p*(1-m)+h*m,M,B),E=Y;Y=x;{const e=W+1,t=e*F;if(1===n||u===T){const c=x*v,d=i,f=r.sampleElevation(x,o,a);if(1===n&&u<T){const n=c-w,o=d-H,i=f-j;q[t+0]=n,q[t+1]=o,q[t+2]=i,l.minMaxBoundingBox(n,o,i,_),l.encodeUVInBuffer(N,e,g,s)}Z=c,$=f}else Z=q[t+0]+w,$=q[t+2]+j}const A=Z,S=$,R=P,O=K;P=e,K=c;const D=(W-T)*F,G=1===n?r.sampleElevation(E,d,a):q[D+2]+j,z=r.sampleElevation(E,y,a);if(n<T){const t=W+T,n=t*F,o=e-w,s=b-H,i=z-j;q[n+0]=o,q[n+1]=s,q[n+2]=i,l.minMaxBoundingBox(o,s,i,_);const r=J;J=g,l.encodeUVInBuffer(N,t,r,I)}{const e=A-R,t=-e*(S-O),n=f-b,o=-n*(G-z),s=e*e+n*n,i=t*t+o*o+s*s;if(0===i)l.encodeNormalToBufferFromValues(V,W,0,0,1);else{const e=1/Math.sqrt(i);l.encodeNormalToBufferFromValues(V,W,t*e,o*e,s*e)}}++W}}}function P(e,t){e.tile.intersectsClippingArea&&(D(e),U(e,!0),G(e))}function C(e,t){e.tile.intersectsClippingArea&&(O(e),G(e))}function O(e,t){e.tile.intersectsClippingArea&&(D(e),U(e,!1))}function U(e,o){const s=e.geometryState,i=s.neighborData,a=e.tile,c=a.surface,f=c.shading||Y,p=a.extent,g=s.clippingArea,h=n.isSome(g)?g:J,x=p[0],M=p[2],B=p[1],E=p[3],A=[E>h[3],M>h[2],B<h[1],x<h[0]],S=e.geometryInfo,v=a.horizontalScale,y=H(c.isWebMercatorOnPlateeCarree,a.ellipsoid.radius,v),L=S.boundingBox,T=S.uvRange[0],b=S.uvRange[1],I=S.uvRange[2],R=S.uvRange[3],N=Math.max(x,h[0]),V=Math.min(M,h[2]),P=Math.max(B,h[1]),C=Math.min(E,h[3]),O=e.localOrigin,U=O[0],D=O[1],_=O[2],w=s.samplerData;for(let H=0;H<4;++H){const s=1===H||3===H,p=i.edgeResolutions[H];d.internalAssert(t.isPowerOfTwo(p));const g=p+1,h=A[H],O=u.neighborTileIfLoadedOrSelf(a,i.edgePeerNeighbors[H]);if(!h&&X(a,O,H)){F(e,H);continue}const j=n.isSome(O)&&!h,q=O?.renderData,W=q?.geometryState;if(d.ENABLE_TERRAIN_INTERNAL_CHECKS&&(d.internalAssert(!j||O.level===a.level),d.internalAssert(!j||m.compareTilesByLij(a,O)<=0),a&&!O&&!c.updatingRootTiles)){const e=d.neighborEdgeIndices[H],t=a.findNeighborTile(e,(e=>e.isLoaded||e.isLeaf||e.level===a.level));c.updatingRootTiles||(t?t.intersectsClippingArea&&(d.internalAssert(!t.isLoaded),d.internalAssert(!t.isLeaf),d.internalAssert(t.level===a.level)):d.internalAssert(n.isNone(c?.rootTiles)||!a.shouldHaveNeighbor(e)))}const K=t.clamp(1===H?M:x,N,V),G=t.clamp(0===H?E:B,P,C),z=W?.samplerData,k=S.outerEdges[H],J=o&&g>3?g-3:1,Q=t.clamp(1===H?1:0,T,I),Y=t.clamp(0===H?1:0,b,R),Z=(e,t)=>r.sampleElevation(e,t,w),$=(e,t)=>.5*(r.sampleElevation(e,t,z)+r.sampleElevation(e,t,w)),ee=j?$:Z;if(f){const e=(M-x)/p,n=s?1===H?e:-e:0,o=s?0:0===H?e:-e,i=-n,a=-o,c=k.attributes.position.typedBuffer,u=k.attributes.position.typedBufferStride,d=k.index0,f=k.stride,m=d*u;let h=c[m+0]+U,A=c[m+1]+D,S=c[m+2]+_,O=0,q=0,F=0;{const e=1/p,n=s?K:t.clamp(x*(1-e)+M*e,N,V),o=s?t.clamp(B*(1-e)+E*e,P,C):G,i=ee(n,o),r=n*v,a=y(o);O=r,q=a,F=i}for(let H=1;H<g-1;H+=J){const e=H/p,m=O,W=q,J=F;{const n=s?Q:t.clamp(e,T,I),o=s?t.clamp(e,b,R):Y,i=m-U,r=W-D,a=J-_;l.minMaxBoundingBox(m,r,a,L),k.setVertexFromValuesRawPositionUV(H,i,r,a,n,o)}const X=H+1;if(H===g-1){const e=(d+X*f)*u;O=c[e+0]+U,q=c[e+1]+D,F=c[e+2]+_}else{const e=X/p,n=s?K:t.clamp(x*(1-e)+M*e,N,V),o=s?t.clamp(B*(1-e)+E*e,P,C):G,i=ee(n,o);O=n*v,q=y(o),F=i}const Z=O,$=q,te=F,ne=h,oe=A,se=S;h=m,A=W,S=J;let ie=0,re=0,ae=0;if(s){{const e=$-W,t=oe-W;re-=t*(se-J)+e*(te-J),ae+=t*t+e*e}{const o=t.clamp(B*(1-e)+E*e,P,C),s=K+i,a=o,l=s*v-m;if(ie-=l*(r.sampleElevation(s,a,w)-J),ae+=l*l,j){const e=K+n,t=o,s=e*v-m;ie-=s*(r.sampleElevation(e,t,z)-J),ae+=s*s}}}else{{const e=Z-m,t=ne-m;ie-=e*(te-J)+t*(se-J),ae+=e*e+t*t}{const n=t.clamp(x*(1-e)+M*e,N,V),s=n,i=G+a,l=r.sampleElevation(s,i,w)-J,c=y(i)-W;if(re-=c*l,ae+=c*c,j){const e=n,t=G+o,s=y(t)-W;re-=s*(r.sampleElevation(e,t,z)-J),ae+=s*s}}}const le=1/Math.sqrt(ie*ie+re*re+ae*ae);k.setNormalFromValues(H,ie*le,re*le,ae*le)}}else for(let e=1;e<g-1;e+=J){const n=e/p,o=s?K:t.clamp(x*(1-n)+M*n,N,V),i=s?t.clamp(B*(1-n)+E*n,P,C):G,r=s?Q:t.clamp(n,T,I),a=s?t.clamp(n,b,R):Y,c=ee(o,i),u=o*v-U,d=y(i)-D,f=c-_;l.minMaxBoundingBox(u,d,f,L),k.setVertexFromValuesRawPositionUV(e,u,d,f,r,a)}}}function D(e,t){W(e)}function _(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}function w(e,t){return e*t}function H(e,t,n){return e?e=>_(e,t):e=>w(e,n)}function j(e,t,n,o,s,i){const r=t-1,a=e.vertexAttributes.count,l=2*(Math.min(t-2,o[1])-Math.max(1,o[0]))*(Math.min(t-2,s[1])-Math.max(1,s[0])),c=d.neighborEdgeIndices.map(((e,n)=>0===n&&s[1]<t-2||1===n&&o[1]<t-2||2===n&&s[0]>1||3===n&&o[0]>1)),u=e.outerEdges.reduce(((e,t,n)=>e+(c[n]?0:r-2+t.count-1)),0),f=n.reduce(((e,t)=>e+r*(2*(t.latitudeResolution-1)+1)),0),m=i?2:1,g=3*(l+u+f)*m,h=a>=p?new Uint32Array(g):new Uint16Array(g);let x=0;const M=t-2,B=r-2;if(d.internalAssert(B>=0),i){const i=(e,t,n)=>{h[x++]=e,h[x++]=t,h[x++]=t,h[x++]=n,h[x++]=n,h[x++]=e,d.ENABLE_TERRAIN_INTERNAL_CHECKS&&(d.internalAssert(e<a),d.internalAssert(t<a),d.internalAssert(n<a),d.internalAssert(x<=g))};(()=>{for(let e=Math.max(s[0],1)-1;e<Math.min(s[1],t-2)-1;++e)for(let n=Math.max(o[0],1)-1;n<Math.min(o[1],t-2)-1;++n){const t=e*M+n,o=t+1,s=o+M,r=s-1;i(t,o,s),i(s,r,t)}})(),d.internalAssert(x===3*l*m);(()=>{for(let t=0;t<4;++t){const n=x;if(c[t])continue;const o=e.outerEdges[t],s=e.innerEdges[t];let a=0,l=0;const u=o.count,f=s.count;d.internalAssert(f===r-1);let p=0;const g=1===t||2===t?(e,t,n)=>i(e,t,n):(e,t,n)=>i(e,n,t);for(;a<u-1||l<f-1;){const e=s.getVertexIndex(l),t=o.getVertexIndex(a),n=a<u-1,i=l<f-1,c=n?0+r*(a+.5)/(u-1):0,m=i?1+B*(l+.5)/(f-1):0;if(n&&(!i||c<=m)){++a,d.ENABLE_TERRAIN_INTERNAL_CHECKS&&d.internalAssert(a<u);g(e,t,o.getVertexIndex(a)),p++}else{++l,d.ENABLE_TERRAIN_INTERNAL_CHECKS&&d.internalAssert(l<f);g(e,t,s.getVertexIndex(l)),p++}}d.ENABLE_TERRAIN_INTERNAL_CHECKS&&(d.internalAssert(a===u-1),d.internalAssert(l===f-1),d.internalAssert(p===u+f-2),d.internalAssert(p===r-2+o.count-1),d.internalAssert(x===n+3*p*m))}})(),d.internalAssert(x===3*(l+u)*m);const f=n=>{const o=e.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),a=o.stride;for(let e=0;e<n.latitudeResolution;++e){const o=0===e?n.rowOffset:s+t;for(let t=0;t<r;t++)i(s,s+1,o+t),e<n.latitudeResolution-1&&i(s+1,o+t+1,o+t),s+=a;s=o,a=1}};(()=>n.forEach(f))()}else{(()=>{const e=Math.max(s[0],1)-1,n=Math.min(s[1],t-2)-1,i=Math.max(o[0],1)-1,r=Math.min(o[1],t-2)-1;for(let t=e;t<n;++t){const e=t*M;for(let t=i;t<r;++t){const n=e+t,o=n+1,s=o+M,i=s-1;h[x+0]=n,h[x+1]=o,h[x+2]=s,h[x+3]=s,h[x+4]=i,h[x+5]=n,x+=6}}})(),d.internalAssert(x===3*l*m);(()=>{for(let t=0;t<4;++t){if(c[t])continue;const n=e.outerEdges[t],o=e.innerEdges[t];let s=0,i=0;const a=n.count,l=o.count;d.internalAssert(l===r-1);const u=1===t||2===t,f=u?1:2,m=u?2:1,p=n.index0,g=n.stride,M=o.index0,E=o.stride;for(;s<a-1||i<l-1;){const e=M+i*E,t=p+s*g,n=s<a-1,o=i<l-1,c=n?0+r*(s+.5)/(a-1):0,u=o?1+B*(i+.5)/(l-1):0,d=n&&(!o||c<=u);d?++s:++i;const A=d?t+g:e+E;h[x+0]=e,h[x+f]=t,h[x+m]=A,x+=3}}})(),d.internalAssert(x===3*(l+u)*m);const i=n=>{const o=e.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),i=o.stride;for(let e=0;e<n.latitudeResolution;++e){const o=0===e?n.rowOffset:s+t;for(let t=0;t<r;t++){const r=o+t;h[x+0]=s,h[x+1]=s+1,h[x+2]=r,e<n.latitudeResolution-1?(h[x+3]=s+1,h[x+4]=r+1,h[x+5]=r,x+=6):x+=3,s+=i}s=o,i=1}};(()=>n.forEach(i))()}d.internalAssert(x===g),e.indices=h,e.indexCount=g}function q(e,t){const n=e.localOrigin,o=e.geometryInfo,s=e.geometryState.neighborData.edgeResolutions,i=o.numVerticesPerSide-2,r=o.vertexAttributes;let a=t;for(let c=0;c<4;++c){{const e=0===c||2===c,t=(0===c?i-1:0)*i+(1===c?i-1:0),s=(e?0:1)*i+(e?1:0);o.innerEdges[c]=new l.EdgeDescriptor(r,n,t,s,i)}{const e=a,t=s[c]+1;o.outerEdges[c]=new l.EdgeDescriptor(r,n,e,1,t),a+=t}}}function F(e,n){const o=(n+2)%4,s=e.geometryState,i=e.tile,r=s.neighborData,a=u.neighborTileIfLoadedOrSelf(i,r.edgePeerNeighbors[n]),c=i.level-a.level,f=1===n||3===n,m=r.edgeResolutions[n];d.internalAssert(t.isPowerOfTwo(m));const p=m+1,g=e.geometryInfo,h=g.boundingBox,x=g.outerEdges[n],M=g.uvRange[0],B=g.uvRange[1],E=g.uvRange[2],A=g.uvRange[3],S=t.clamp(1===n?1:0,M,E),v=t.clamp(0===n?1:0,B,A),y=a.renderData,L=y.geometryState,T=y.geometryInfo.outerEdges[o],b=i.getNeighborEdgeStartVertexIndex(n,a)*m,I=m*2**c;d.internalAssert(L.neighborData.edgeResolutions[o]===I),d.internalAssert(T.count-1===I);const R=y.localOrigin[0]-e.localOrigin[0],N=y.localOrigin[1]-e.localOrigin[1],V=y.localOrigin[2]-e.localOrigin[2],P=x.attributes,C=x.index0,O=x.stride,U=P.position.typedBuffer,D=P.position.typedBufferStride,_=P.normalCompressed.typedBuffer,w=P.normalCompressed.typedBufferStride,H=P.uv0,j=T.attributes,q=T.index0,F=T.stride,W=j.position.typedBuffer,K=j.position.typedBufferStride,G=j.normalCompressed.typedBuffer,z=j.normalCompressed.typedBufferStride;for(let u=1;u<p-1;++u){const e=C+O*u,n=q+F*(b+u),o=e*D,s=n*K,i=W[s+0]+R,r=W[s+1]+N,a=W[s+2]+V;U[o+0]=i,U[o+1]=r,U[o+2]=a,l.minMaxBoundingBox(i,r,a,h);const c=e*w,d=n*z;_[c+0]=G[d+0],_[c+1]=G[d+1];const p=u/m,g=f?S:t.clamp(p,M,E),x=f?t.clamp(p,B,A):v;l.encodeUVInBuffer(H,e,g,x)}}function W(e){const o=e.geometryState,s=o.neighborData,i=e.localOrigin,a=s.cornerNeighborData,c=e.geometryInfo,u=c.outerEdges,f=c.boundingBox,p=e.tile,g="local"===e.tile.surface.view?.viewingMode,h=p.ellipsoid.radius,x=p.extentInRadians,M=p.horizontalScale;let B=0,E=0,A=0,S=0,v=0,y=0;const L=(e,t,n)=>{const o=x[0===t?1:3],s=x[0===e?0:2],i=Math.cos(o),r=Math.sin(o),a=Math.sin(s),l=Math.cos(s),c=h+n;B=l*i*c,E=a*i*c,A=r*c},T=g?(()=>{const o=e.geometryState.clippingArea,s=p.extent,i=n.isSome(o)&&(s[3]>o[3]||s[2]>o[2]||s[1]<o[1]||s[0]<o[0]),r=H(p.surface.isWebMercatorOnPlateeCarree,p.ellipsoid.radius,M);return(e,n,s)=>{const a=0===e?C[0]:C[2],l=0===n?C[1]:C[3],c=i?t.clamp(a,o[0],o[2]):a,u=i?t.clamp(l,o[1],o[3]):l,d=s;B=c*M,E=r(u),A=d}})():L;let I=0,R=0,N=0;const V=g&&e.tile.surface.isWebMercatorOnPlateeCarree,P=(e,t,n,o)=>{if(g){const e=t*M,s=V?(Math.PI/2-2*Math.atan(Math.exp(-n/h)))*h:n*M,i=e-B,r=s-E,a=o-A;I+=-i*a,R+=-r*a,N+=i*i+r*r}else{const s=b(e),i=e.tile,r=i.extent,a=i.extentInRadians,l=(t-r[0])/(r[2]-r[0]),c=(n-r[1])/(r[3]-r[1]),u=a[0]*(1-l)+a[2]*l,d=s(c),f=Math.cos(d),m=Math.sin(d),p=Math.sin(u),g=Math.cos(u),x=h+o,M=g*f*x-B,L=p*f*x-E,T=m*x-A,V=L*y-T*v,P=T*S-M*y,C=M*v-L*S;I+=P*T-C*L,R+=C*M-V*T,N+=V*L-P*M}},C=p.extent,O=o.clippingArea,U=n.isSome(O)?O:J,D=C[0],_=C[2],w=C[1],j=C[3],q=[j>U[3],_>U[2],w<U[1],D<U[0]],F=Math.max(D,U[0]),W=Math.min(_,U[2]),G=Math.max(w,U[1]),k=Math.min(j,U[3]),X=c.uvRange[0],Z=c.uvRange[1],$=c.uvRange[2],ee=c.uvRange[3],te=p.surface.shading||Y,ne=e=>{if(!g){const e=1/Math.sqrt(B*B+E*E+A*A);S=B*e,v=E*e,y=A*e}const t=a[e].cornerTiles;I=0,R=0,N=0;let n=1/0;for(let r=0;r<4;++r)n=Math.min(n,t[r]?.level??1/0);for(let r=0;r<4;++r){const e=t[r];Q[r]=e?.level===n?e:null}let o=1,s=0;for(let r=0;r<4;++r){const e=Q[r];e&&(o=Math.max(o,e?.renderData.geometryState.numVerticesPerSide),s=e.extent[2]-e.extent[0])}const i=s,l=o;d.internalAssert(l>1);const c=i/l;for(let a=0;a<4;++a){const e=Q[(a+3)%4],t=Q[(a+0)%4];if(!e&&!t)continue;const n=0===a?1:1===a?2:2===a?3:0,o=0===a?2:1===a?3:2===a?0:1;if(e&&t){const s=z[a][0]*c,i=z[a][1]*c,l=e.extent,u=l[0===n||1===n?2:0]+s,d=l[0===n||3===n?3:1]+i,f=t.extent,m=f[0===o||1===o?2:0]+s,p=f[0===o||3===o?3:1]+i,g=e.renderData,h=t.renderData,x=r.sampleElevation(u,d,g.geometryState.samplerData),M=r.sampleElevation(m,p,h.geometryState.samplerData);P(g,u,d,.5*(x+M))}else{const s=e??t,i=e?n:o,l=s.extent,u=z[a],d=l[0===i||1===i?2:0]+u[0]*c,f=l[0===i||3===i?3:1]+u[1]*c,m=s.renderData,p=r.sampleElevation(d,f,m.geometryState.samplerData);P(m,d,f,p)}}const u=1/Math.sqrt(I*I+R*R+N*N);I*=u,R*=u,N*=u};for(let n=0;n<4;++n){const s=n,c=(n+1)%4,g=0===n||1===n?1:0,h=0===n||3===n?1:0,x=t.clamp(g,X,$),M=t.clamp(h,Z,ee),S=u[s],v=0===n||3===n?S.count-1:0,y=u[c],L=0===n||1===n?y.count-1:0,b=a[n].cornerTiles;let V=-1;for(let e=0;e<4;++e){const t=b[e];t&&(-1===V||m.compareTilesByLij(b[V],t)>0)&&(V=e)}const P=V,C=b[P];if(I=0,R=0,N=1,C!==p){const t=p.level-C.level,o=2**t,s=[C.lij[0]+t,C.lij[1]*o,C.lij[2]*o],i=[s[1]+o===p.lij[1],0===n&&(1===P||0===P&&C!==b[3])||1===n&&(0===P||1===P&&C!==b[2]),s[1]===p.lij[1]+1,2===n&&(3===P||2===P&&C!==b[1])||3===n&&(2===P||3===P&&C!==b[0])],r=i.reduce(((e,t)=>e+(t?1:0)),0);d.internalAssert(1===r||2===r);let a=-1,c=-1;const u=C.renderData;if(1===r){const t=i.findIndex((e=>e));d.internalAssert(0<=t&&t<=3),a=(t+2)%4;const o=e.geometryState.neighborData.edgeResolutions[t];c=p.getNeighborEdgeStartVertexIndex(t,C)*o+o*(0===t&&0===n||1===t&&0===n||2===t&&1===n||3===t&&3===n?1:0)}else{d.internalAssert(i[1]||i[3]),a=i[1]?3:1;const e=u.geometryState.neighborData.edgeResolutions[a];c=0===n||3===n?0:e}const m=u.geometryInfo.outerEdges[a];{const t=S.index0+v*S.stride,n=y.index0+L*y.stride,o=m.index0+c*m.stride;{const s=m.attributes.position,i=s.typedBuffer,r=o*s.typedBufferStride,a=e.localOrigin,c=m.localOrigin,u=i[r+0]+c[0]-a[0],d=i[r+1]+c[1]-a[1],p=i[r+2]+c[2]-a[2];l.minMaxBoundingBox(u,d,p,f);{const e=S.attributes.position,n=e.typedBuffer,o=t*e.typedBufferStride;n[o+0]=u,n[o+1]=d,n[o+2]=p}{const e=y.attributes.position,t=e.typedBuffer,o=n*e.typedBufferStride;t[o+0]=u,t[o+1]=d,t[o+2]=p}}l.encodeUVInBuffer(S.attributes.uv0,t,x,M),l.encodeUVInBuffer(y.attributes.uv0,n,x,M);{const e=m.attributes.normalCompressed.typedBuffer,s=o*m.attributes.normalCompressed.typedBufferStride;{const n=S.attributes.normalCompressed,o=n.typedBuffer,i=t*n.typedBufferStride;o[i+0]=e[s+0],o[i+1]=e[s+1]}{const t=y.attributes.normalCompressed,o=t.typedBuffer,i=n*t.typedBufferStride;o[i+0]=e[s+0],o[i+1]=e[s+1]}}}}else{const e=q[s],a=q[c];let u;if(e||a){const e=t.clamp(D*(1-g)+_*g,F,W),n=t.clamp(w*(1-h)+j*h,G,k),s=o.samplerData;u=r.sampleElevation(e,n,s)}else u=K(b);T(g,h,u),(te||Y)&&ne(n);const d=B-i[0],m=E-i[1],p=A-i[2];l.minMaxBoundingBox(d,m,p,f),S.setVertexFromValuesRawPositionUVNormal(v,d,m,p,x,M,I,R,N),y.setVertexFromValuesRawPositionUVNormal(L,d,m,p,x,M,I,R,N)}}for(let t=0;t<4;++t)Q[t]=null}function K(e){const t=e.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);d.ENABLE_TERRAIN_INTERNAL_CHECKS&&(d.internalAssert(!e[0]||!e[2]||f.isCornerNeighbor(e[0],e[2],a.NeighborIndex.SOUTH_WEST)),d.internalAssert(!e[1]||!e[3]||f.isCornerNeighbor(e[1],e[3],a.NeighborIndex.NORTH_WEST)));let n=0,o=0;for(let i=0;i<4;++i){const s=e[i];if(s&&s.level===t){const e=0===i||1===i,t=0===i||3===i,a=s.extent,l=a[e?0:2],c=a[t?1:3],u=s.renderData?.geometryState?.samplerData;o+=r.sampleElevation(l,c,u),n++}}const s=n?o/n:0;return d.internalAssert(null!=s),s}function G(e){const t=e.vao,n=e.geometryInfo.vertexAttributes.position.typedBuffer;t.vertexBuffers.geometry.setSubData(n,0,0,n.length)}const z=[[0,1],[1,0],[0,-1],[-1,0]],k=new c.PatchGeometryLUT,J=i.fromValues(-1/0,-1/0,1/0,1/0),Q=[null,null,null,null];function X(e,t,n){if(!t)return!1;const o=m.compareTilesByLij(e,t);return o>0||0===o&&n<2}const Y=!0;e.createInternalVerticesPositionsSpherical=x,e.createPlanarGlobePatch=I,e.createSphericalGlobePatch=g,e.updateCornerSpherical=E,e.updateCornersPlanar=P,e.updateEdgesAndCornersPlanar=C,e.updateEdgesAndCornersSpherical=B,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
