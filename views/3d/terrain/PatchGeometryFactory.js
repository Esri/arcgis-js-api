/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../core/mathUtils.js";import{isSome as t,unwrapOr as n}from"../../../core/maybe.js";import{s as o,n as r,a,v as s,f as i,b as c}from"../../../chunks/vec3.js";import{c as l,f as u}from"../../../chunks/vec3f64.js";import{s as f}from"../../../chunks/vec4.js";import{empty as g}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as d,containsXYWithMargin as m}from"../../../geometry/support/aaBoundingRect.js";import{sampleElevationOrZero as h}from"./ElevationData.js";import{PatchType as x}from"./interfaces.js";import{acquireTerrainAttributes as p,EdgeDescriptor as b}from"./PatchGeometry.js";import{PatchGeometryLUT as M}from"./PatchGeometryLUT.js";import"./PatchRenderData.js";import{GEOMETRY_VERTEX_STRIDE as S}from"./TerrainConst.js";import{internalAssert as y,neighborEdgeIndices as v}from"./terrainUtils.js";const D=65536;function O(e,t){const n=e.tile,{extent:s,extentInRadians:l,surface:u}=n,d=e.localOrigin,m=e.geometryState,b=u.isWebMercator,M=u.shadingEnabled,v=m.numVerticesPerSide,D=v-1,O=(v-2)**2,V=b&&(t===x.HAS_SOUTH_POLE||t===x.HAS_BOTH_POLES),A=b&&(t===x.HAS_NORTH_POLE||t===x.HAS_BOTH_POLES),P=6,B=((V?1:0)+(A?1:0))*P*(D+1),w=m.neighborData,I=w.edgeResolutions.reduce(((e,t)=>e+t+1),0),L=p(O+B+I),T=e.geometryInfo;T.numVerticesPerSide=m.numVerticesPerSide,T.vertexAttributes=L,f(T.uvOffsetAndScale,0,0,1,1);const U=L.position.typedBuffer,N=L.uv0.typedBuffer,j=L.normal.typedBuffer,Z=T.boundingBox;g(Z);const C=d[0],H=d[1],W=d[2];ge.update(D,l);let _=0;const X=m.samplerData,q=n.ellipsoid.radius,k=ee(e),G=v-2,z=s[0],F=s[2],J=s[1],Q=s[3];if((()=>{for(let e=1;e<=G;e++){const t=e/D,n=J*(1-t)+Q*t,o=k(t),r=Math.cos(o),a=Math.sin(o);for(let e=1;e<=G;e++){const o=e/D,s=z*(1-o)+F*o,i=ge.sinLonLUT[e],c=ge.cosLonLUT[e],l=q+h(s,n,X),u=c*r*l-C,f=i*r*l-H,g=a*l-W;ue(u,f,g,Z);const d=S*_;U[d+0]=u,U[d+1]=f,U[d+2]=g,N[d+0]=o,N[d+1]=t,++_}}})(),M){(()=>{const t=e=>(c(xe,e,Se),i(pe,xe,ye),i(be,pe,xe),be),n=L.position,s=L.normal;_=0;const l=e=>{n.getVec(e,he),a(ve,ve,t(he))},u=(e,n)=>{{const t=e/D,r=z*(1-t)+F*t,a=ge.sinLonLUT[e],s=ge.cosLonLUT[e],i=n/D,c=J*(1-i)+Q*i,l=k(i),u=Math.cos(l),f=Math.sin(l),g=q+h(r,c,X);o(he,s*u*g-C,a*u*g-H,f*g-W)}a(ve,ve,t(he))},f=(e,t,n)=>{e>1&&t>1&&e<G&&t<G?l(_+n):u(e,t)};for(let i=1;i<=G;i++)for(let t=1;t<=G;t++)n.getVec(_,Se),a(Me,Se,e.localOrigin),r(ye,Me),o(ve,0,0,0),f(t-1,i,-1),f(t+1,i,1),f(t,i-1,-G),f(t,i+1,+G),r(ve,ve),s.setVec(_,ve),++_})()}_=O,E(e,O),Y(e),_=O+I;const $=[];(()=>{const e=(e,t)=>{const n=t*v;ue(-C,-H,e*q-W,Z),$.push({connectedRowOffset:n,connectedOuterEdgeOffset:1===e?0:2,rowOffset:_,latitudeResolution:P});const o=K(-1===e?J:Q,q),r=e*Math.PI/2-o,a=.99*(1===e?1:-1),s=q+0;for(let i=1;i<=P;++i){const e=o+r*(i/P),t=Math.cos(e),n=Math.sin(e);for(let o=0;o<=D;o++){const e=o/D,r=ge.sinLonLUT[o],i=ge.cosLonLUT[o]*t*s-C,c=r*t*s-H,l=n*s-W;ue(i,c,l,Z);const u=S*_;if(U[u+0]=i,U[u+1]=c,U[u+2]=l,N[u+0]=e,N[u+1]=a,M){const e=1/Math.sqrt(i*i+c*c+l*l);j[u+0]=e*i,j[u+1]=e*c,j[u+2]=e*l}++_}}};V&&e(-1,0),A&&e(1,D)})(),R(T,m.numVerticesPerSide,$,[0,v-1],[0,v-1],m.wireframe),e.intersectionData=null;for(let o=0;o<4;++o)y(T.outerEdges[o].count===w.edgeResolutions[o]+1)}function V(n,o){const r=n.tile,a=r.extent,s=n.localOrigin,i=n.geometryState,c=r.surface,l=c.isWebMercatorOnPlateeCarree,u=c.shadingEnabled,m=a[0],x=a[1],b=a[2]-m,M=a[3]-x,y=i.clippingArea,v=t(y)?Math.max(0,(y[0]-a[0])/b):0,D=t(y)?Math.max(0,(y[1]-a[1])/M):0,O=t(y)?Math.min(1,(y[2]-a[0])/b):1,V=t(y)?Math.min(1,(y[3]-a[1])/M):1,A=O-v,P=V-D,B=A>0?1/A:1,w=P>0?1/P:1,L=-v*B,T=-D*w,U=i.numVerticesPerSide,N=U-1,Z=(U-2)**2+i.neighborData.edgeResolutions.reduce(((e,t)=>e+t+1),0),C=p(Z),H=C.position.typedBuffer,W=C.uv0.typedBuffer,_=C.normal.typedBuffer,X=n.geometryInfo,Y=X.boundingBox;g(Y);let q=0;const k=r.ellipsoid.radius,G=i.samplerData,z=t(y)?y:de,F=d(Math.max(a[0],z[0]),Math.max(a[1],z[1]),Math.min(a[2],z[2]),Math.min(a[3],z[3])),J=s[0],K=s[1],Q=s[2],$=j(l,k,o);(()=>{for(let t=1;t<=N-1;t++){const n=t/N,r=T+n*w,a=e(x+n*M,F[1],F[3]),s=e(r,0,1),i=$(a)-K,c=b/N;for(let t=1;t<=N-1;t++){const n=t/N,r=L+n*B,l=e(m+n*b,F[0],F[2]),f=e(r,0,1),g=h(l,a,G),d=l*o-J,x=g-Q;ue(d,i,x,Y);const p=S*q;if(H[p+0]=d,H[p+1]=i,H[p+2]=x,W[p+0]=f,W[p+1]=s,u){const e=h(l+c,a,G),t=h(l-c,a,G),n=h(l,a+c,G),o=.25*(t-e),r=.25*(h(l,a-c,G)-n),s=c,i=Math.sqrt(o*o+r*r+s*s);_[p+0]=o/i,_[p+1]=r/i,_[p+2]=s/i}++q}}})(),X.numVerticesPerSide=i.numVerticesPerSide,X.vertexAttributes=C,f(n.geometryInfo.uvOffsetAndScale,v,D,O-v,V-D),E(n,q),I(n,o),q=Z,R(X,i.numVerticesPerSide,[],[0,U-1],[0,U-1],i.wireframe),n.intersectionData=null}function R(e,t,n,o,r,a){const s=t-1,i=e.vertexAttributes.count,c=2*(Math.min(t-2,o[1])-Math.max(1,o[0]))*(Math.min(t-2,r[1])-Math.max(1,r[0])),l=v.map(((e,n)=>0===n&&r[1]<t-2||1===n&&o[1]<t-2||2===n&&r[0]>1||3===n&&o[0]>1)),u=3*(c+e.outerEdges.reduce(((e,t,n)=>e+(l[n]?0:s-2+t.count-1)),0)+n.reduce(((e,t)=>e+s*(2*(t.latitudeResolution-1)+1)),0))*(a?2:1),f=new(i>D?Uint32Array:Uint16Array)(u);let g=0;const d=a?(e,t,n)=>{f[g++]=e,f[g++]=t,f[g++]=t,f[g++]=n,f[g++]=n,f[g++]=e}:(e,t,n)=>{f[g++]=e,f[g++]=t,f[g++]=n},m=t-2,h=s-2;(()=>{for(let e=Math.max(r[0],1)-1;e<Math.min(r[1],t-2)-1;++e)for(let n=Math.max(o[0],1)-1;n<Math.min(o[1],t-2)-1;++n){const t=e*m+n,o=t+1,r=o+m,a=r-1;d(t,o,r),d(r,a,t)}})();(()=>{for(let t=0;t<4;++t){if(l[t])continue;const n=e.outerEdges[t],o=e.innerEdges[t];let r=0,a=0;const i=n.count,c=o.count;n.count;const u=1===t||2===t?(e,t,n)=>d(e,t,n):(e,t,n)=>d(e,n,t);for(;r<i-1||a<c-1;){const e=o.getVertexOffset(a),t=n.getVertexOffset(r),l=r<i-1,f=a<c-1,g=l?0+s*(r+.5)/(i-1):0,d=f?1+h*(a+.5)/(c-1):0;if(l&&(!f||g<=d)){++r;u(e,t,n.getVertexOffset(r))}else{++a;u(e,t,o.getVertexOffset(a))}}}})();const x=n=>{let o=e.outerEdges[n.connectedOuterEdgeOffset].offset0;for(let e=0;e<n.latitudeResolution;++e){const r=0===e?n.rowOffset:o+t;for(let t=0;t<s;t++)d(o,o+1,r+t),e<n.latitudeResolution-1&&d(o+1,r+t+1,r+t),++o;o=r}};(()=>{n.forEach(x)})(),e.indices=f,e.indexCount=u}function E(e,t){const n=e.localOrigin,o=e.geometryInfo,r=e.geometryState.neighborData.edgeResolutions,a=o.numVerticesPerSide-2,s=o.vertexAttributes.position.typedBuffer;let i=t;for(let c=0;c<4;++c){{const e=0===c||2===c,t=(0===c?a-1:0)*a+(1===c?a-1:0),r=(e?0:1)*a+(e?1:0);o.innerEdges[c]=new b(s,n,t,r,a)}{const e=i,t=r[c]+1;o.outerEdges[c]=new b(s,n,e,1,t),i+=t}}}function A(e){H(e),te(e);const t=e.vao,n=e.geometryInfo.vertexAttributes;t?.vertexBuffers?.geometry?.setSubData(n.position.typedBuffer)}function P(e){Y(e),X(e)}function B(e,t){W(e,t),ne(e,t),X(e)}function w(e,t){I(e,t),X(e)}function I(e,t){W(e,t),k(e,t),ne(e,t)}function L(e,t,n,o,r){const a=Math.cos(n),s=Math.sin(n),i=Math.sin(t),c=Math.cos(t),l=r+o;e[0]=c*a*l,e[1]=i*a*l,e[2]=s*l}function T(e,t,n,o,r,a){const s=r[0===n?1:3];L(e,r[0===t?0:2],s,o,a)}function U(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}function N(e,t){return e*t}function j(e,t,n){return e?e=>U(e,t):e=>N(e,n)}function Z(e,t,n,o,r,a,s){const i=0===t?r[0]:r[2],c=0===n?r[1]:r[3],l=o;e[0]=i*a,e[1]=s(c),e[2]=l}function C(o,r){const a=o.geometryState,s=o.tile,i=s.extent,c=n(a.clippingArea,i),l=o.geometryInfo,u=l.boundingBox,f=l.outerEdges,g=a.neighborData.cornerNeighborData,d=l.uvOffsetAndScale[0],m=l.uvOffsetAndScale[1],x=l.uvOffsetAndScale[2],p=l.uvOffsetAndScale[3],b=x>0?1/x:1,M=p>0?1/p:1,S=-d*b,y=-m*M,v=s.surface.isWebMercatorOnPlateeCarree,D=j(v,v?s.ellipsoid.radius:0,r),O=a.samplerData,V=a.neighborData.edgeNeighbours,R=o.localOrigin,E=(n,o,a,l,f)=>{const d=i[0]*(1-l)+i[2]*l,m=i[1]*(1-f)+i[3]*f,x=e(d,c[0],c[2]),p=e(m,c[1],c[3]),v=[p===i[3],x===i[2],p===i[1],x===i[0]],E=!v[3]&&!v[1]||!v[0]&&!v[2],A=E?v[0]&&t(V[0])?V[0]:v[1]&&t(V[1])?V[1]:v[2]&&t(V[2])?V[2]:v[3]&&t(V[3])?V[3]:null:null,P=E?A?A.neighborTile.level===s.level?.5*(h(x,p,O)+h(x,p,A.neighborSamplerData)):h(x,p,A.neighborSamplerData):h(x,p,O):g[a].elevation,B=x*r-R[0],w=D(p)-R[1],I=P-R[2];ue(B,w,I,u);const L=e(S+l*b,0,1),T=e(y+f*M,0,1);n.setVertexRawXYZUV(o,B,w,I,L,T)};for(let e=0;e<4;++e){const t=f[e];E(t,0,0===e?3:1===e?1:2,1===e?1:0,0===e?1:0);const n=2===e?1:3===e?3:0,o=3===e?0:1,r=2===e?0:1;E(t,t.count-1,n,o,r)}}function H(e){_(e,((t,n,o,r)=>T(t,n,o,r,e.tile.extentInRadians,e.tile.ellipsoid.radius)))}function W(e,n){const o=e.tile;t(o.renderData.geometryState.clippingArea)?C(e,n):_(e,((t,r,a,s)=>Z(t,r,a,s,e.tile.extent,n,j(o.surface.isWebMercatorOnPlateeCarree,o.ellipsoid.radius,n))))}function _(e,t){const n=e.geometryInfo,o=n.outerEdges,r=e.geometryState.neighborData.cornerNeighborData,a=n.boundingBox,s=e.localOrigin,i=(e,n,o,i,c)=>{t(me,o,i,r[n].elevation);for(let t=0;t<3;++t)me[t]-=s[t];ue(me[0],me[1],me[2],a),e.setVertexRawXYZUV(c,me[0],me[1],me[2],o,i)};for(let c=0;c<4;++c){const e=o[c];i(e,0===c?3:1===c?1:2,1===c?1:0,0===c?1:0,0);i(e,2===c?1:3===c?3:0,3===c?0:1,2===c?0:1,e.count-1)}}function X(e){const t=e.vao,n=e.geometryInfo.vertexAttributes;t?.vertexBuffers?.geometry?.setSubData(n.position.typedBuffer)}function Y(e){H(e);for(let t=0;t<4;++t)q(e,t);te(e)}function q(e,t){const n=e.geometryState,c=n.neighborData,l=e.tile;l.level;const f=l.extent,g=f[2]-f[0],d=f[3]-f[1],m=l.extentInRadians,x=m[0];m[1];const p=m[2];m[3];const b=l.ellipsoid.radius,M=ee(e),y=e=>{if(!e)return 0;const t=D,n=O?0:1,o=e.lij[n+1]*L,r=l.lij[n+1]-o;return(O?L-1-r:r)*t},v=c.edgeNeighbours[t],D=c.edgeResolutions[t],O=1===t||3===t,V=1===t?1:0,R=0===t?1:0,E=f[0]+V*g,A=f[1]+R*d,P=x*(1-V)+p*V,B=M(R),w=v?.neighborTile,I=l.level-(w?.level??l.level),L=2**I,T=D*L,U=y(w),N=w?.extent,j=(t+2)%4,Z=n.samplerData,C=w?.renderData?.geometryState?.samplerData,H=w&&0===I,W=(e,t,n,o)=>.5*(h(e,t,C)+h(n,o,Z)),_=(e,t)=>h(e,t,C),X=H?W:_;let Y=N?1===j?N[2]:N[0]:E,q=N?0===j?N[3]:N[1]:A;const k=(e,t,n)=>{const o=(U+e)/T;return q=N[1]*(1-o)+N[3]*o,X(Y,q,t,n)},G=(e,t,n)=>{const o=(U+e)/T;return Y=N[0]*(1-o)+N[2]*o,X(Y,q,t,n)},z=w?O?k:G:(e,t,n)=>h(t,n,Z),F=(e,t,n)=>z(e,t,n);let J=V,K=E,Q=P,$=R,te=A,ne=B,oe=Math.sin(Q),re=Math.cos(Q),ae=Math.cos(ne),se=Math.sin(ne);const ie=O?()=>M($):()=>B,ce=O?e=>{$=e,te=f[1]*(1-e)+f[3]*e,ne=ie(),ae=Math.cos(ne),se=Math.sin(ne)}:e=>{J=e,K=f[0]*(1-e)+f[2]*e,Q=x*(1-J)+p*J,oe=Math.sin(Q),re=Math.cos(Q)},le=e.geometryInfo,fe=le.boundingBox,ge=le.vertexAttributes,de=ge.position.typedBuffer,me=ge.uv0.typedBuffer,Se=ge.normal.typedBuffer,De=le.outerEdges[t];let Oe=De.getVertexOffset(1);const Ve=D+1,Re=e.localOrigin,Ee=Re[0],Ae=Re[1],Pe=Re[2],Be=l.surface.shadingEnabled,we=1===t?-1:3===t?1:0,Ie=0===t?-1:2===t?1:0,Le=g/D,Te=we*Le,Ue=Ie*Le,Ne=we*(1/D),je=Ie*(1/D),Ze=e=>{s(xe,e,Me),i(pe,xe,ye),i(be,pe,xe),a(ve,ve,be)};for(let a=1;a<Ve-1;++a){ce(a/D);const e=F(a,K,te),t=b+e,n=re*ae*t,s=oe*ae*t,i=se*t,c=n-Ee,l=s-Ae,f=i-Pe;ue(c,l,f,fe);const g=S*Oe;if(de[g+0]=c,de[g+1]=l,de[g+2]=f,me[g+0]=J,me[g+1]=$,Be){o(ve,0,0,0),o(Me,n,s,i),r(ye,Me);const e=(e,t)=>{const n=h(K+e*Te,te+e*Ue,t),o=b+n,r=J+e*Ne,a=x*(1-r)+p*r,s=Math.sin(a),i=Math.cos(a),c=M($+e*je),l=Math.sin(c),f=Math.cos(c),g=u(i*f*o,s*f*o,l*o);Ze(g)};w&&e(-1,C),w&&!H||e(1,Z),Se[g+0]=ve[0],Se[g+1]=ve[1],Se[g+2]=ve[2]}++Oe}if(Be)for(let o=1;o<Ve-1;++o)De.getVertexRawNormal(ve,o),De.getVertex(Me,o),r(ye,Me),De.getVertex(he,o-1),Ze(he),De.getVertex(he,o+1),Ze(he),r(ve,ve),De.setVertexRawNormal(o,ve[0],ve[1],ve[2])}function k(e,n){const o=e.geometryState.clippingArea,r=e.tile.extent,a=t(o)&&(r[0]<o[0]||r[2]>o[2]||r[1]<o[1]||r[3]>o[3])?J:F;for(let t=0;t<4;++t)a(e,t,n)}function G(e,t,n,o,r,a,s){return s===r?!e||t?(e,t)=>h(e,t,n):null:s===a?e?(e,t)=>h(e,t,o):null:null}function z(e,t,n,o){if(t!==e)return()=>0;const r=t?3:2,a=t?1:0,s=o(r,a),i=o(a,r),c=(null!=s?1:0)+(null!=i?1:0),l=t?n:0,u=t?0:n;return(e,t,n)=>((null!=s?-(s(e+l,t+u)-n):0)+(null!=i?+(i(e-l,t-u)-n):0))/c}function F(e,n,o){const r=e.geometryState.neighborData,a=r.edgeNeighbours,s=e.tile,i=s.level,c=s.surface,l=c.shadingEnabled,u=a[n],f=r.edgeResolutions[n],g=f,d=s.extent,m=e.geometryState,x=g+1,p=u,b=e.localOrigin,M=m.samplerData,S=(e,t)=>h(e,t,M),y=(e,t)=>.5*(h(e,t,p.neighborSamplerData)+h(e,t,M)),v=(e,t)=>h(e,t,p.neighborSamplerData),D=p?.neighborTile.level===i,O=D?y:v,V=t(p)?O:S,R=e.geometryInfo,E=R.outerEdges[n],A=j(c.isWebMercatorOnPlateeCarree,s.ellipsoid.radius,o),P=R.boundingBox,B=1===n||3===n,w=1===n?d[2]:d[0],I=0===n?d[3]:d[1],L=1===n?1:0,T=0===n?1:0,U=(d[2]-d[0])/f,N=p?.neighborSamplerData,Z=t(p),C=(e,t)=>G(Z,D,M,N,e,t,n),H=z(B,!0,U,C),W=z(B,!1,U,C);for(let t=1;t<x-1;++t){const e=t/g,n=B?w:d[0]*(1-e)+d[2]*e,r=B?d[1]*(1-e)+d[3]*e:I,a=B?L:e,s=B?e:T,i=V(n,r),c=n*o-b[0],u=A(r)-b[1],f=i-b[2];if(ue(c,u,f,P),l){const e=H(n,r,i),o=W(n,r,i),l=U;E.setVertexRawXYZUVN(t,c,u,f,a,s,e,o,l)}else E.setVertexRawXYZUV(t,c,u,f,a,s)}if(l){const e=B?0:1,t=B?1:0;for(let n=1;n<x-1;++n){E.getNormal(De,n);const o=E.getVertexZ(n-1)-E.getVertexZ(n+1),r=De[0]+.5*e*o,a=De[1]+.5*t*o,s=2*U,i=1/Math.sqrt(r*r+a*a+s*s);E.setVertexRawNormal(n,i*r,i*a,i*s)}}}function J(o,r,a){const s=o.geometryState.neighborData,i=s.edgeNeighbours,c=o.tile,l=c.level,u=c.surface,f=u.shadingEnabled,g=i[r],d=s.edgeResolutions[r],m=d,x=c.extent,p=o.geometryState,b=n(p.clippingArea,de),M=o.geometryInfo,S=M.uvOffsetAndScale[0],y=M.uvOffsetAndScale[1],v=S+M.uvOffsetAndScale[2],D=y+M.uvOffsetAndScale[3],O=v>S?1/(v-S):1,V=D>y?1/(D-y):1,R=-S*O,E=-y*V,A=m+1,P=[x[3]>b[3],x[2]>b[2],x[1]<b[1],x[0]<b[0]],B=g,w=p.samplerData,I=(e,t)=>h(e,t,w),L=B?.neighborTile.level===l,T=(e,t)=>{const n=h(e,t,B.neighborSamplerData);return L?.5*(n+h(e,t,w)):n},U=I,N=t(B)?T:I,Z=P[r]?U:N,C=M.outerEdges[r],H=M.boundingBox,W=1===r||3===r,_=e(1===r?x[2]:x[0],b[0],b[2]),X=e(0===r?x[3]:x[1],b[1],b[3]),Y=1===r?1:0,q=0===r?1:0,k=o.localOrigin,F=j(u.isWebMercatorOnPlateeCarree,c.ellipsoid.radius,a),J=(x[2]-x[0])/d,K=B?.neighborSamplerData,Q=t(B),$=B?.neighborTile.level===l,ee=(e,t)=>G(Q,$,w,K,e,t,r),te=z(W,!0,J,ee),ne=z(W,!1,J,ee);for(let t=1;t<A-1;++t){const n=t/m,o=W?_:e(x[0]*(1-n)+x[2]*n,b[0],b[2]),r=W?e(x[1]*(1-n)+x[3]*n,b[1],b[3]):X,s=W?Y:e(R+n*O,0,1),i=W?e(E+n*V,0,1):q,c=Z(o,r),l=o*a-k[0],u=F(r)-k[1],g=c-k[2];if(ue(l,u,g,H),f){const e=te(o,r,c),n=ne(o,r,c),a=J;C.setVertexRawXYZUVN(t,l,u,g,s,i,e,n,a)}else C.setVertexRawXYZUV(t,l,u,g,s,i)}if(f){const e=W?0:1,t=W?1:0;for(let n=1;n<A-1;++n){C.getNormal(De,n);const o=C.getVertexZ(n-1)-C.getVertexZ(n+1),r=De[0]+.5*e*o,a=De[1]+.5*t*o,s=2*J,i=1/Math.sqrt(r*r+a*a+s*s);C.setVertexRawNormal(n,i*r,i*a,i*s)}}}function K(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function Q(e,t,n,o){return K(e+o*(t-e),n)}function $(e,t,n){return e*(1-n)+t*n}function ee(e){const t=e.tile;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius;return t=>Q(e[1],e[3],n,t)}const n=t.extentInRadians;return e=>$(n[1],n[3],e)}function te(e){e.tile.surface.shadingEnabled&&le(e,((e,t,n,o,r,a,s)=>oe(t,e,n,o,r,a,s)))}function ne(e,t){e.tile.surface.shadingEnabled&&le(e,((n,o,r,a,s,i,c)=>re(se(e,t),n,r,s,i,c)))}function oe(e,t,n,o,r,a,c){ae(e,he,r,a,c),s(xe,he,n),i(pe,xe,o),i(t,pe,xe)}function re(e,t,n,o,r,a){e(he,o,r,a);const s=he[0]-n[0],i=he[1]-n[1],c=he[2]-n[2];t[0]=-s*c,t[1]=-i*c,t[2]=s*s+i*i}function ae(e,t,n,o,r){const a=ee(e),s=e.tile,i=s.extent;y(m(i,n,o,1));const c=(n-i[0])/(i[2]-i[0]),l=(o-i[1])/(i[3]-i[1]),u=s.extentInRadians;L(t,u[0]*(1-c)+u[2]*c,a(l),r,s.ellipsoid.radius)}function se(e,t){return e.tile.surface.isWebMercatorOnPlateeCarree?(n,o,r,a)=>ce(t,e.tile.ellipsoid.radius,n,o,r,a):(e,n,o,r)=>ie(t,e,n,o,r)}function ie(e,t,n,o,r){t[0]=n*e,t[1]=o*e,t[2]=r}function ce(e,t,n,o,r,a){n[0]=o*e,n[1]=(Math.PI/2-2*Math.atan(Math.exp(-r/t)))*t,n[2]=a}function le(e,t){if(!e.tile.surface.shadingEnabled)return;const n=e.geometryState.neighborData.cornerNeighborData,s=e.tile,i=s.extent,c="local"===e.tile.surface.view?.viewingMode;c&&o(ye,0,0,1);{const l=(e,n,o,r)=>{t(be,e.renderData,Me,ye,n,o,r),a(ve,ve,be)},u=1,f=(e,t,n,o,r,a)=>{const s=1===a?r.extent[0]:3===a?r.extent[2]:e,i=0===a?r.extent[1]:2===a?r.extent[3]:t,c=s+fe[n][0]*o,f=i+fe[n][1]*o;y(m(r.extent,c,f,u));const g=h(c,f,r.renderData.geometryState.samplerData);l(r,c,f,g)},g=(e,t,n)=>e.extent[0===t||1===t?2:0]+n,d=(e,t,n)=>e.extent[0===t||3===t?3:1]+n,x=(e,t,n,o)=>{const r=g(n,o,fe[e][0]*t),a=d(n,o,fe[e][1]*t);y(m(n.extent,r,a,u));const s=h(r,a,n.renderData.geometryState.samplerData);l(n,r,a,s)},p=(e,t,n,o,r,a)=>{const s=fe[e][0]*t,i=fe[e][1]*t,c=g(n,o,s),f=d(n,o,i),x=g(r,a,s),p=d(r,a,i);y(m(n.extent,c,f,u)),y(m(r.extent,x,p,u));const b=h(c,f,n.renderData.geometryState.samplerData),M=h(x,p,r.renderData.geometryState.samplerData);l(n,c,f,.5*(b+M))},b=e=>{const t=0===e||1===e?i[2]:i[0],o=0===e||3===e?i[3]:i[1],r=n[e].cornerTiles,a=r.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);for(let n=0;n<4;++n){const e=r[n];Ve[n]=e?.level===a?e:null}for(let n=0;n<4;++n){const e=Ve[(n+3)%4],r=Ve[n];if(null!=e&&e!==s&&e===r){const r=e,a=(n+2)%4,i=r.renderData.geometryState.neighborData.edgeResolutions[a],c=Math.max(i,2**(s.level-r.level)),l=(r.extent[2]-r.extent[0])/c,u=(n+0)%4,g=(n+1)%4;return f(t,o,(n+3)%4,l,r,n),f(t,o,u,l,r,n),f(t,o,g,l,r,n),ve}}{y(Ve.some((e=>e?.isLoaded||e===s)));const e=Ve.reduce(((e,t)=>t?t.extent[2]-t.extent[0]:e),0)/Ve.reduce(((e,t)=>Math.max(e,t?.renderData.geometryState.numVerticesPerSide??1)),1);for(let t=0;t<4;++t){const n=Ve[(t+3)%4],o=Ve[(t+0)%4];if(!n&&!o)continue;const r=0===t?1:1===t?2:2===t?3:0,a=0===t?2:1===t?3:2===t?0:1;if(n&&o)p(t,e,n,r,o,a);else{x(t,e,n??o,n?r:a)}}}return ve};for(let t=0;t<4;++t){const n=e.geometryInfo.outerEdges[t],a=1===t||2===t?0:n.count-1;n.getVertex(Me,a),c||r(ye,Me),o(ve,0,0,0);const s=b(t);r(Oe[t],s)}}{const t=(e,t,n,o,r)=>{e.setVertexRawNormal(r,t,n,o)},n=e.geometryInfo.outerEdges;for(let e=0;e<4;++e){const o=n[e];{const n=Oe[0===e?3:1===e?1:2];t(o,n[0],n[1],n[2],0)}{const n=Oe[2===e?1:3===e?3:0];t(o,n[0],n[1],n[2],o.count-1)}}}}function ue(e,t,n,o){e<o[0]?o[0]=e:e>o[3]&&(o[3]=e),t<o[1]?o[1]=t:t>o[4]&&(o[4]=t),n<o[2]?o[2]=n:n>o[5]&&(o[5]=n)}const fe=[[0,1],[1,0],[0,-1],[-1,0]],ge=new M,de=d(-1/0,-1/0,1/0,1/0),me=l(),he=l(),xe=l(),pe=l(),be=l(),Me=l(),Se=l(),ye=l(),ve=l(),De=l(),Oe=[l(),l(),l(),l()],Ve=[null,null,null,null];export{V as createPlanarGlobePatch,O as createSphericalGlobePatch,B as updateCornerElevationsPlanar,A as updateCornerElevationsSpherical,w as updateEdgesElevationsAndNormalsPlanar,P as updateEdgesElevationsSpherical};
