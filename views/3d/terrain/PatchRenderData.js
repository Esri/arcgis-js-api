/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/arrayUtils","../../../core/mathUtils","../../../core/maybe","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/Ellipsoid","../support/buffer/glUtil","./GeometryState","./interfaces","./LayerClass","./PatchGeometry","./terrainUtils","./TextureFader","./Tile","./TileOverlayData","./tileUtils","../webgl-engine/lib/VertexArrayObject","../webgl-engine/shaders/TerrainTechnique","../../webgl/BufferObject"],(function(e,t,r,i,s,n,a,o,l,h,d,c,g,u,m,f,y,_,p,A,x,E,S){"use strict";let b=function(){function e(){this.geometryInfo=new m.PatchGeometry,this.intersectionData=null,this.geometryState=null,this._textureRef=new y.TextureFader((()=>this.tile.surface.textureFadeDuration)),this.overlay=new p,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1,this._shadingChanged=!1,this._dirtyEdgeResolutions=15,this._dirtyEdges=15,this._dirtyCorners=15}var b=e.prototype;return b.init=function(e){this.clear(),this._tile=e;const t=this.geometryInfo;t.indices=null,t.vertexAttributes=null,o.empty(t.boundingBox),t.indexCount=0,t.numVerticesPerSide=0,this.intersectionData=null,this.geometryState=new c.GeometryState,this.localOrigin=null,this.overlay.clear()},b.clear=function(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null},b.updateGeometryIfNeeded=function(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this._wireframeChanged||this._shadingChanged||this._clippingAreaChanged||this._samplerDataChanged||this._numVerticesPerSideChanged||this._dirtyCorners||this._dirtyEdgeResolutions||this._dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),f.ENABLE_TERRAIN_INTERNAL_CHECKS&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)f.internalAssert(this.geometryInfo.outerEdges[t].count===this.geometryState.neighborData.edgeResolutions[t]+1)},b._calculateEdgeResolution=function(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(s.isSome(t)&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const n=r.level,a=f.neighborEdgeIndices[e];if(!t)return f.internalAssert(s.isNone(r.surface?.rootTiles)||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(a)),i;if(t.isLoaded){const r=t,s=r.renderData.geometryState,a=n-r.level;if(f.internalAssert(a>=0),0===a){const e=s.numVerticesPerSide-1;return Math.max(e,i)}const o=2**a,l=s.neighborData.edgeResolutions[(e+2)%4]/o;return Math.max(1,l)}f.internalAssert(!t.isLeaf);let o=i;return t.forAllSubtreeOnSide(f.oppositeEdge(a),(e=>e===r||(e.isLoaded?(o=Math.max(o,2**(e.level-n)),!0):(f.internalAssert(!e.isLeaf),!1)))),o},b.updateNeighborData=function(){const e=this.tile;if(!e.intersectsClippingArea)return;const t=e.renderData.geometryState.neighborData,r=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,s=t.edgePeerNeighbors,n=t.edgePeerNeighborSamplerVersions;for(let o=0;o<4;++o){const a=e.findNeighborTile(f.neighborEdgeIndices[o],r),l=L(e,a),h=l?.renderData?.geometryState.samplerDataVersion??-1,d=s[o],c=l!==L(e,d),g=n[o]!==h;s[o]=a,(c||g)&&(n[o]=h,this._markEdgeDirty(o));const u=t.edgeResolutions[o],m=this._calculateEdgeResolution(o,a);f.internalAssert(i.isPowerOfTwo(m)),f.internalAssert(m>=1),t.edgeResolutions[o]=m,u!==m&&this._markEdgeResolutionDirty(o)}const a=t.cornerPeerNeighbors;for(let i=0;i<4;++i){const n=e.findNeighborTile(f.neighborCornerIndices[i],r);a[i]=n;const o=L(e,s[i]),l=L(e,s[(i+1)%4]),h=L(e,n);I[i]=h,I[(i+1)%4]=l,I[(i+2)%4]=e,I[(i+3)%4]=o,f.internalAssert(I.some((t=>t?.isLoaded||t===e)));const d=I.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);I.forEach(((e,t)=>{e&&e?.level>d&&(I[t]=null)})),f.internalAssert(I.some((t=>t?.isLoaded||t===e)));const c=t.cornerNeighborData[i].cornerTiles,g=t.cornerNeighborData[i].cornerTileSamplerVersions;for(let e=0;e<4;++e){const t=I[e],r=t?.renderData.geometryState.samplerDataVersion??-1,s=c[e]!==t,n=!s&&g[e]!==r;(s||n)&&(c[e]=t,g[e]=r,this._markCornerDirty(i))}f.internalAssert(c.some((t=>t?.isLoaded||t===e)))}f.ENABLE_TERRAIN_INTERNAL_CHECKS&&f.internalAssert(this.geometryState.neighborData.edgeResolutions.every((e=>e>0)));for(let i=0;i<4;++i)I[i]=null},b._updateGeometry=function(e){if(!this.tile.intersectsClippingArea)return;f.ENABLE_TERRAIN_INTERNAL_CHECKS&&f.internalAssert(!this.tile.intersectsClippingArea||this.geometryState.neighborData.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const t=this.tile,r=this._vao,i=this.geometryInfo.vertexAttributes,s=!r||!i||this._wireframeChanged||this._shadingChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._dirtyEdgeResolutions,n=!s&&(0!==this._dirtyEdges||0!==this._dirtyEdgeResolutions),a=!n&&0!==this._dirtyCorners;s?(this.releaseGeometry(),this._createGeometry(e)):n||a?t.updateEdgeElevations():a?t.updateCornerElevations():console.warn("Update for no reason?"),this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._dirtyEdgeResolutions=0,this._dirtyEdges=0,this._dirtyCorners=0,this._clippingAreaChanged=!1,this._wireframeChanged=!1,this._shadingChanged=!1},b.releaseGeometry=function(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao.dispose(),this._vao=null,m.releaseGeometry(this.geometryInfo),!0)},b.ensureTexture=function(e,t){return s.isSome(this._texture)&&this._texture.descriptor.width!==e&&this.releaseTexture(),s.isNone(this._texture)&&(this._texture=t(),this.tile.setMemoryDirty()),this._texture},b.releaseTexture=function(){s.isSome(this._texture)&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())},b._markCornerDirty=function(e){const t=1<<e;this._dirtyCorners|=t},b._markEdgeDirty=function(e){const t=1<<e;this._dirtyEdges|=t},b._markEdgeResolutionDirty=function(e){const t=1<<e;this._dirtyEdgeResolutions|=t,this._dirtyEdges|=t},b._markAllEdgesAndCornersDirty=function(){this._dirtyCorners=15,this._dirtyEdges=15,this._dirtyEdgeResolutions=15},b.updateGeometryState=function(){const e=this._getElevationInfo(),t=this.tile,i=e.samplerData?t.getElevationVerticesPerSide(e.maxTileLevel):t.getDefaultVerticesPerSide(),s=Math.max(i,5);let n=t.clippingArea;t.intersectsClippingArea&&!t.isWithinClippingArea||(n=null);const a=this.geometryState;let o=!1;a.numVerticesPerSide!==s&&(this._numVerticesPerSideChanged=!0,a.numVerticesPerSide=s,a.samplerDataVersion++,o=!0),e.changed&&(this._samplerDataChanged=!0,a.samplerData=e.samplerData,a.samplerDataVersion++,o=!0),r.equals(a.clippingArea,n)||(this._clippingAreaChanged=!0,a.clippingArea=n,o=!0);const l=t.surface,h=l.wireframe;a.wireframe!==h&&(this._wireframeChanged=!0,a.wireframe=h,o=!0);const d=l.shading;return a.shading!==d&&(this._shadingChanged=d,a.shading=d,o=d),this._geometryStateChangedSinceLastUpdate||(this._geometryStateChangedSinceLastUpdate=o),o&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate},b._createGeometry=function(e){this.tile.createGeometry();const t=this.geometryInfo.vertexAttributes,r=this.geometryInfo.indices,i=e.gl;this._vao=new x.VertexArrayObject(e,E.terrainVertexAttributeLocations,{geometry:d.glLayout(t.layout)},{geometry:S.BufferObject.createVertex(e,i.STATIC_DRAW,t.buffer)},S.BufferObject.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0},b.setTextureReference=function(e,t=y.ActivationTime.Immediate){s.isSome(e)&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)},b._getElevationInfo=function(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[u.LayerClass.ELEVATION],r=t.length,i=new Array(r);let n=0,a=0,o=!1;for(let d=0;d<r;d++){const r=t[d];if(s.isSome(r.upsampleInfo)){const t=r.upsampleInfo.tile,s=t.layerInfo[u.LayerClass.ELEVATION][d].data,l=s&&s.samplerData;e&&e[n]===l||(o=!0),i[n++]=l,a=Math.max(a,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(d,u.LayerClass.ELEVATION);if(A.fallsWithinLayer(this.tile,t.layer,!1)){const t=r.data;e&&e[n]===t.samplerData||(o=!0),i[n++]=t.samplerData,a=this.tile.level}}}s.isSome(e)&&e.length!==n&&(o=!0);const l=n>0,h=l?i:null;return l&&(i.length=n),{changed:o,samplerData:h,maxTileLevel:a}},b.checkGeometryWaterproofness=function(){if(!f.ENABLE_TERRAIN_INTERNAL_CHECKS)return;const e=this.tile;if(f.internalAssert(e?.isLoaded),!e.isLoaded||!e.intersectsClippingArea)return;const t=e.renderData;if(0===e.level)return;const r=e.surface.extent;if(s.isSome(r)&&!e.intersectsExtent(r))return;const o=f.neighborEdgeIndices.map(((t,i)=>!!s.isSome(r)&&(i<2?-1:1)*(e.extent[3-i]-r[3-i])<0)),d=e.level;f.internalAssert(0===this._dirtyCorners),f.internalAssert(0===this._dirtyEdges),f.internalAssert(0===this._dirtyEdgeResolutions),f.internalAssert(!this._numVerticesPerSideChanged),f.internalAssert(!this._samplerDataChanged),f.internalAssert(!this._clippingAreaChanged),f.internalAssert(!this._wireframeChanged);const c=f.neighborCornerIndices.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),u=this.geometryState.neighborData;for(let i=0;i<4;++i){const t=u.cornerPeerNeighbors[i],r=c[i];f.internalAssert(r===t,`Tile[${e.lij}].corner[${i}] out of date: cur=[${t?.lij}] exp=[${r?.lij}]`)}f.neighborEdgeIndices.forEach(((r,c)=>{if(o[c])return;const u=e.findNeighborTile(r,(e=>(e.level===d||e?.isLoaded)&&e?.intersectsClippingArea));if(!u){const t=!e.surface.updatingRootTiles&&s.isSome(e.surface.rootTiles)&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(r);return void f.internalAssert(!t)}f.internalAssert(u.isLoaded||u.level===e.level),f.internalAssert(u===this.geometryState.neighborData.edgePeerNeighbors[c]);const m=d-u.level;if(!u.isLoaded)return f.internalAssert(!u.isLeaf),void f.internalAssert(0===m);const y=u.renderData;f.internalAssert(_.isEdgeNeighbor(e,u,r)),f.internalAssert(m>=0);const p=2**m;if(m<0)return void f.internalAssert(!1);const A=t.geometryInfo,x=A.outerEdges[c],E=A.numVerticesPerSide-1,S=y.geometryInfo;if(!S)return void f.internalAssert(!1);{const e=this.geometryState.neighborData.edgePeerNeighbors[c];if(e?.isLoaded){const r=e.renderData;f.internalAssert(e==e),f.internalAssert(t.geometryState.neighborData.edgePeerNeighborSamplerVersions[c]===r.geometryState.samplerDataVersion),f.internalAssert(this.geometryState.neighborData.edgePeerNeighborSamplerVersions[c]===r.geometryState.samplerDataVersion)}}const b=(c+2)%4,I=S.outerEdges[b],L=x.count-1,V=I.count-1;f.internalAssert(L*p===V,`Tile[${e.lij}]:e${c},res=${L} edgeRes mismatch with Neighbor[${u.lij}]:e${b},res=${V} (expected:${L*p})`);const P=e.extent,w=r===g.NeighborIndex.NORTH||r===g.NeighborIndex.SOUTH,O=I.count-1,G=O/2**m,j=x.count-1;if(G<1)return void f.internalAssert(1===j);f.internalAssert(G===j),f.internalAssert(i.isPowerOfTwo(G));const k=S.numVerticesPerSide-1;f.internalAssert(m>0||G===Math.max(k,E));const M=e.getNeighborEdgeStartVertexIndex(c,u);f.internalAssert(0<=M&&M<p);const U=M*G;f.internalAssert(0<=U&&U<=O-G);let B=0,H=U;x.getVertexPos(C,0),x.getVertexPos(v,x.count-1);const F=n.distance(C,v),X=Math.max(R,1e-4*F);for(let i=0;i<=G;++i){x.getVertexPos(C,B),I.getVertexPos(v,H);const o=i/G,d=w?P[0]+o*(P[2]-P[0]):r===g.NeighborIndex.WEST?P[0]:P[2],m=w?r===g.NeighborIndex.SOUTH?P[1]:P[3]:P[1]+o*(P[3]-P[1]),_=e.surface.extent;if(s.isNone(_)||l.containsXY(_,d,m)){const r=n.dist(C,v),i=n.len(C)-h.earth.radius,o=n.len(v)-h.earth.radius,l=r<X;if(!l){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${c}[${B}/${x.count}] and [${u.lij}].edge${b}[${H}/${I.count}]`),s.isSome(_)&&console.warn("  surface extent= ",_," x,y=",d,",",m);const h=a.create();n.subtract(h,t.localOrigin,y.localOrigin),n.len(h)>0&&console.warn(`   localOrigins: ${t.localOrigin} vs ${y.localOrigin} d=${n.len(h)} [${h}]`);(()=>{const t=a.clone(C),r=a.clone(v);e.updateEdgeElevations(),u.updateEdgeElevations(),x.getVertexPos(C,B),I.getVertexPos(v,H);const i=a.create();n.sub(i,C,t),n.len(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${C} d=${n.len(i)} [${i}]`),n.sub(i,v,r),n.len(i)>0&&console.warn(`  XXX Neighbor[${u.lij}] edge out of date: ${r} vs ${v} d=${n.len(i)} [${i}]`)})(),f.internalAssert(l,`Mismatch in tile [${e.lij}].edge[${c}][${B}/${x.count}] vs neighbor [${u.lij}].edge[${b}][${H}/${I.count}] ${f.v32s(C)} vs ${f.v32s(v)}  dist=${r} h(t|n|d)=${i}|${o}|${o-i}`)}if(e.surface.shading){x.getNormal(D,B),I.getNormal($,H),n.normalize(T,D),n.normalize(N,$);const t=n.dot(T,N),r=1-t<.01||!1||e===u;if(!r){const i=a.create();n.sub(i,D,$);const s=()=>`Mismatch in tile edge normal ${f.lij2s(e.lij)} (${B}/${x.count-1}) edge ${c} vs neighbor ${f.lij2s(u.lij)}  (${H}/${I.count-1}) nedge ${b} :${f.v32s(D)} vs ${f.v32s($)}  dot = ${t} : ${f.v32s(i)}`;console.warn("Mismatch in tile edge normal: ",s());{e.updateEdgeElevations(),u.updateEdgeElevations();const t=a.create(),r=a.create();x.getNormal(t,B),I.getNormal(r,H),n.equals(D,t)||console.warn("Missing update in tile normal: ",f.v32s(D)," => ",f.v32s(t)),n.equals($,r)||console.warn("Missing update in neighbor normal: ",f.v32s($)," => ",f.v32s(r))}f.internalAssert(r,s())}}}B+=1,H+=1}}))},t._createClass(e,[{key:"tile",get:function(){return this._tile}},{key:"hasGeometry",get:function(){return this._hasGeometry}},{key:"vao",get:function(){return this._vao}},{key:"textureReference",get:function(){return this._textureRef.current}},{key:"nextTextureReference",get:function(){return this._textureRef.next}},{key:"textureFadeFactor",get:function(){return this._textureRef.fadeFactor}},{key:"textureIsFading",get:function(){return this._textureRef.isFading}},{key:"estimatedGeometryMemoryUsage",get:function(){const e=s.mapOr(this.intersectionData,0,(e=>e.estimatedMemoryUsage));return(this.geometryInfo.indices?.byteLength??0)+(this.geometryInfo.vertexAttributes?.byteLength??0)+e}},{key:"textureDescriptor",get:function(){return s.isSome(this._texture)?this._texture.descriptor:null}},{key:"test",get:function(){return{hasTexture:null!=this._texture}}}]),e}();const C=a.create(),v=a.create(),D=a.create(),$=a.create(),T=a.create(),N=a.create(),R=1,I=[null,null,null,null];function L(e,t){return t?.isLoaded||t===e?t:null}Object.defineProperty(e,"ActivationTime",{enumerable:!0,get:()=>y.ActivationTime}),e.PatchRenderData=b,e.neighborTileIfLoadedOrSelf=L,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
