/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/arrayUtils","../../../core/mathUtils","../../../core/maybe","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/Ellipsoid","../support/buffer/glUtil","./GeometryState","./interfaces","./LayerClass","./PatchGeometry","./terrainUtils","./TextureFader","./Tile","./TileOverlayData","./tileUtils","../webgl-engine/lib/VertexArrayObject","../webgl-engine/shaders/TerrainTechnique","../../webgl/BufferObject"],(function(e,t,r,i,s,n,a,o,l,d,h,c,g,u,m,f,y,_,p,A,x,E,S){"use strict";let b=function(){function e(){this.geometryInfo=new m.PatchGeometry,this.intersectionData=null,this.geometryState=null,this._textureRef=new y.TextureFader((()=>this.tile.surface.textureFadeDuration)),this.overlay=new p,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1,this._shadingChanged=!1,this._dirtyEdgeResolutions=15,this._dirtyEdges=15,this._dirtyCorners=15}var b=e.prototype;return b.init=function(e){this.clear(),this._tile=e;const t=this.geometryInfo;t.indices=null,t.vertexAttributes=null,o.empty(t.boundingBox),t.indexCount=0,t.numVerticesPerSide=0,this.intersectionData=null,this.geometryState=new c.GeometryState,this.localOrigin=null,this.overlay.clear()},b.clear=function(){this._releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null},b.updateGeometryIfNeeded=function(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this._wireframeChanged||this._shadingChanged||this._clippingAreaChanged||this._samplerDataChanged||this._numVerticesPerSideChanged||this._dirtyCorners||this._dirtyEdgeResolutions||this._dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),f.ENABLE_TERRAIN_INTERNAL_CHECKS&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)f.internalAssert(this.geometryInfo.outerEdges[t].count===this.geometryState.neighborData.edgeResolutions[t]+1)},b._calculateEdgeResolution=function(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(s.isSome(t)&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const n=r.level,a=f.neighborEdgeIndices[e];if(!t)return f.internalAssert(s.isNone(r.surface?.rootTiles)||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(a)),i;if(t.isLoaded){const r=t,s=r.renderData.geometryState,a=n-r.level;if(f.internalAssert(a>=0),0===a){const e=s.numVerticesPerSide-1;return Math.max(e,i)}const o=2**a,l=s.neighborData.edgeResolutions[(e+2)%4]/o;return Math.max(1,l)}f.internalAssert(!t.isLeaf);let o=i;return t.forAllSubtreeOnSide(f.oppositeEdge(a),(e=>e===r||(e.isLoaded?(o=Math.max(o,2**(e.level-n)),!0):(f.internalAssert(!e.isLeaf),!1)))),o},b.updateNeighborData=function(){const e=this.tile;if(!e.intersectsClippingArea)return;const t=e.renderData.geometryState.neighborData,r=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,s=t.edgePeerNeighbors,n=t.edgePeerNeighborSamplerVersions;for(let o=0;o<4;++o){const a=e.findNeighborTile(f.neighborEdgeIndices[o],r),l=I(e,a),d=l?.renderData?.geometryState.samplerDataVersion??-1,h=s[o],c=l!==I(e,h),g=n[o]!==d;s[o]=a,(c||g)&&(n[o]=d,this._markEdgeDirty(o));const u=t.edgeResolutions[o],m=this._calculateEdgeResolution(o,a);f.internalAssert(i.isPowerOfTwo(m)),f.internalAssert(m>=1),t.edgeResolutions[o]=m,u!==m&&this._markEdgeResolutionDirty(o)}const a=t.cornerPeerNeighbors;for(let i=0;i<4;++i){const n=e.findNeighborTile(f.neighborCornerIndices[i],r);a[i]=n;const o=I(e,s[i]),l=I(e,s[(i+1)%4]),d=I(e,n);L[i]=d,L[(i+1)%4]=l,L[(i+2)%4]=e,L[(i+3)%4]=o,f.internalAssert(L.some((t=>t?.isLoaded||t===e)));const h=L.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);L.forEach(((e,t)=>{e?.level>h&&(L[t]=null)})),f.internalAssert(L.some((t=>t?.isLoaded||t===e)));const c=t.cornerNeighborData[i].cornerTiles,g=t.cornerNeighborData[i].cornerTileSamplerVersions;for(let e=0;e<4;++e){const t=L[e],r=t?.renderData.geometryState.samplerDataVersion??-1,s=c[e]!==t,n=!s&&g[e]!==r;(s||n)&&(c[e]=t,g[e]=r,this._markCornerDirty(i))}f.internalAssert(c.some((t=>t?.isLoaded||t===e)))}f.ENABLE_TERRAIN_INTERNAL_CHECKS&&f.internalAssert(this.geometryState.neighborData.edgeResolutions.every((e=>e>0)));for(let i=0;i<4;++i)L[i]=null},b._updateGeometry=function(e){if(!this.tile.intersectsClippingArea)return;f.ENABLE_TERRAIN_INTERNAL_CHECKS&&f.internalAssert(!this.tile.intersectsClippingArea||this.geometryState.neighborData.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const t=this.tile,r=this._vao,i=this.geometryInfo.vertexAttributes,s=!r||!i||this._wireframeChanged||this._shadingChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._dirtyEdgeResolutions,n=!s&&(0!==this._dirtyEdges||0!==this._dirtyEdgeResolutions),a=!n&&0!==this._dirtyCorners;s?(this._releaseGeometry(),this._createGeometry(e)):n||a?t.updateEdgeElevations():a?t.updateCornerElevations():console.warn("Update for no reason?"),this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._dirtyEdgeResolutions=0,this._dirtyEdges=0,this._dirtyCorners=0,this._clippingAreaChanged=!1,this._wireframeChanged=!1},b.releaseGeometry=function(){return this._releaseGeometry()},b.ensureTexture=function(e,t){return s.isSome(this._texture)&&this._texture.descriptor.width!==e&&this.releaseTexture(),s.isNone(this._texture)&&(this._texture=t(),this.tile.setMemoryDirty()),this._texture},b.releaseTexture=function(){s.isSome(this._texture)&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())},b._markCornerDirty=function(e){const t=1<<e;this._dirtyCorners|=t},b._markEdgeDirty=function(e){const t=1<<e;this._dirtyEdges|=t},b._markEdgeResolutionDirty=function(e){const t=1<<e;this._dirtyEdgeResolutions|=t,this._dirtyEdges|=t},b._markAllEdgesAndCornersDirty=function(){this._dirtyCorners=15,this._dirtyEdges=15,this._dirtyEdgeResolutions=15},b.updateGeometryState=function(){const e=this._getElevationInfo(),t=this.tile,i=e.samplerData?t.getElevationBasedVerticesPerSide(e.maxTileLevel):t.getDefaultVerticesPerRowOnLevel(),s=Math.max(i,5);let n=t.clippingArea;t.intersectsClippingArea&&!t.isWithinClippingArea||(n=null);const a=this.geometryState;let o=!1;a.numVerticesPerSide!==s&&(this._numVerticesPerSideChanged=!0,a.numVerticesPerSide=s,a.samplerDataVersion++,o=!0),e.changed&&(this._samplerDataChanged=!0,a.samplerData=e.samplerData,a.samplerDataVersion++,o=!0),r.equals(a.clippingArea,n)||(this._clippingAreaChanged=!0,a.clippingArea=n,o=!0);const l=t.surface,d=l.wireframe;a.wireframe!==d&&(this._wireframeChanged=!0,a.wireframe=d,o=!0);const h=l.shading;return a.shading!==h&&(this._shadingChanged=h,a.shading=h,o=h),this._geometryStateChangedSinceLastUpdate||(this._geometryStateChangedSinceLastUpdate=o),o&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate},b._createGeometry=function(e){this.tile.createGeometry();const t=this.geometryInfo.vertexAttributes,r=this.geometryInfo.indices,i=e.gl;this._vao=new x.VertexArrayObject(e,E.terrainVertexAttributeLocations,{geometry:h.glLayout(t.layout)},{geometry:S.BufferObject.createVertex(e,i.STATIC_DRAW,t.buffer)},S.BufferObject.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0},b._releaseGeometry=function(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao.dispose(),this._vao=null,m.releaseGeometry(this.geometryInfo),!0)},b.setTextureReference=function(e,t=y.ActivationTime.Immediate){s.isSome(e)&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)},b._getElevationInfo=function(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[u.LayerClass.ELEVATION],r=t.length;let i=new Array(r),n=0,a=0,o=!1;for(let l=0;l<r;l++){const r=t[l];if(s.isSome(r.upsampleInfo)){const t=r.upsampleInfo.tile,s=t.layerInfo[u.LayerClass.ELEVATION][l].data,d=s&&s.samplerData;e&&e[n]===d||(o=!0),i[n++]=d,a=Math.max(a,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(l,u.LayerClass.ELEVATION);if(A.fallsWithinLayer(this.tile,t.layer,!1)){const t=r.data;e&&e[n]===t.samplerData||(o=!0),i[n++]=t.samplerData,a=this.tile.level}}}return s.isSome(e)&&e.length!==n&&(o=!0),n>0?i.length=n:i=null,{changed:o,samplerData:i,maxTileLevel:a}},b.checkGeometryWaterproofness=function(){if(!f.ENABLE_TERRAIN_INTERNAL_CHECKS)return;const e=this.tile;if(f.internalAssert(e?.isLoaded),!e.isLoaded||!e.intersectsClippingArea)return;if(0===e.level)return;const t=e.surface.extent;if(s.isSome(t)&&!e.intersectsExtent(t))return;const r=f.neighborEdgeIndices.map(((r,i)=>!!s.isSome(t)&&(i<2?-1:1)*(e.extent[3-i]-t[3-i])<0)),o=e.level;f.internalAssert(0===this._dirtyCorners),f.internalAssert(0===this._dirtyEdges),f.internalAssert(0===this._dirtyEdgeResolutions),f.internalAssert(!this._numVerticesPerSideChanged),f.internalAssert(!this._samplerDataChanged),f.internalAssert(!this._clippingAreaChanged),f.internalAssert(!this._wireframeChanged);const h=f.neighborCornerIndices.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),c=this.geometryState.neighborData;for(let i=0;i<4;++i){const t=c.cornerPeerNeighbors[i],r=h[i];f.internalAssert(r===t,`Tile[${e.lij}].corner[${i}] out of date: cur=[${t?.lij}] exp=[${r?.lij}]`)}f.neighborEdgeIndices.forEach(((t,h)=>{if(r[h])return;const c=e.findNeighborTile(t,(e=>(e.level===o||e?.isLoaded)&&e?.intersectsClippingArea));if(!c){const r=!e.surface.updatingRootTiles&&s.isSome(e.surface.rootTiles)&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(t);return void f.internalAssert(!r)}f.internalAssert(c.isLoaded||c.level===e.level),f.internalAssert(c===this.geometryState.neighborData.edgePeerNeighbors[h]);const u=o-c.level;if(!c.isLoaded)return f.internalAssert(!c.isLeaf),void f.internalAssert(0===u);f.internalAssert(_.isEdgeNeighbor(e,c,t)),f.internalAssert(u>=0);const m=2**u;if(u<0)return void f.internalAssert(!1);const y=e.renderData.geometryInfo,p=y.outerEdges[h],A=y.numVerticesPerSide-1,x=c.renderData.geometryInfo;if(!x)return void f.internalAssert(!1);{const t=this.geometryState.neighborData.edgePeerNeighbors[h];(t?.isLoaded||t.isLoaded)&&(f.internalAssert(t==t),f.internalAssert(e.renderData.geometryState.neighborData.edgePeerNeighborSamplerVersions[h]===t.renderData.geometryState.samplerDataVersion),f.internalAssert(this.geometryState.neighborData.edgePeerNeighborSamplerVersions[h]===t.renderData.geometryState.samplerDataVersion))}const E=(h+2)%4,S=x.outerEdges[E],b=p.count-1,L=S.count-1;f.internalAssert(b*m===L,`Tile[${e.lij}]:e${h},res=${b} edgeRes mismatch with Neighbor[${c.lij}]:e${E},res=${L} (expected:${b*m})`);const I=e.extent,V=t===g.NeighborIndex.NORTH||t===g.NeighborIndex.SOUTH,P=S.count-1,w=P/2**u,G=p.count-1;if(w<1)return void f.internalAssert(1===G);f.internalAssert(w===G),f.internalAssert(i.isPowerOfTwo(w));const O=x.numVerticesPerSide-1;f.internalAssert(u>0||w===Math.max(O,A));const j=e.getNeighborEdgeStartVertexIndex(h,c);f.internalAssert(0<=j&&j<m);const k=j*w;f.internalAssert(0<=k&&k<=P-w);let M=0,U=k;p.getVertexPos(v,0),p.getVertexPos(C,p.count-1);const B=n.distance(v,C),H=Math.max(R,1e-4*B);for(let r=0;r<=w;++r){p.getVertexPos(v,M),S.getVertexPos(C,U);const i=r/w,o=V?I[0]+i*(I[2]-I[0]):t===g.NeighborIndex.WEST?I[0]:I[2],u=V?t===g.NeighborIndex.SOUTH?I[1]:I[3]:I[1]+i*(I[3]-I[1]),m=e.surface.extent;if(s.isNone(m)||l.containsXY(m,o,u)){const t=n.dist(v,C),r=n.len(v)-d.earth.radius,i=n.len(C)-d.earth.radius,l=t<H;if(!l){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${h}[${M}/${p.count}] and [${c.lij}].edge${E}[${U}/${S.count}]`),s.isSome(m)&&console.warn("  surface extent= ",m," x,y=",o,",",u);const d=a.create();n.subtract(d,e.renderData.localOrigin,c.renderData.localOrigin),n.len(d)>0&&console.warn(`   localOrigins: ${e.renderData.localOrigin} vs ${c.renderData.localOrigin} d=${n.len(d)} [${d}]`);(()=>{const t=a.clone(v),r=a.clone(C);e.updateEdgeElevations(),c.updateEdgeElevations(),p.getVertexPos(v,M),S.getVertexPos(C,U);const i=a.create();n.sub(i,v,t),n.len(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${v} d=${n.len(i)} [${i}]`),n.sub(i,C,r),n.len(i)>0&&console.warn(`  XXX Neighbor[${c.lij}] edge out of date: ${r} vs ${C} d=${n.len(i)} [${i}]`)})(),f.internalAssert(l,`Mismatch in tile [${e.lij}].edge[${h}][${M}/${p.count}] vs neighbor [${c.lij}].edge[${E}][${U}/${S.count}] ${f.v32s(v)} vs ${f.v32s(C)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}if(e.surface.shading){p.getNormal(D,M),S.getNormal($,U),n.normalize(T,D),n.normalize(N,$);const t=n.dot(T,N),r=!1,i=1-t<.01||r||e===c;if(!i){const r=a.create();n.sub(r,D,$);const s=()=>`Mismatch in tile edge normal ${f.lij2s(e.lij)} (${M}/${p.count-1}) edge ${h} vs neighbor ${f.lij2s(c.lij)}  (${U}/${S.count-1}) nedge ${E} :${f.v32s(D)} vs ${f.v32s($)}  dot = ${t} : ${f.v32s(r)}`;console.warn("Mismatch in tile edge normal: ",s());{e.updateEdgeElevations(),c.updateEdgeElevations();const t=a.create(),r=a.create();p.getNormal(t,M),S.getNormal(r,U),n.equals(D,t)||console.warn("Missing update in tile normal: ",f.v32s(D)," => ",f.v32s(t)),n.equals($,r)||console.warn("Missing update in neighbor normal: ",f.v32s($)," => ",f.v32s(r))}f.internalAssert(i,s())}}}M+=1,U+=1}}))},t._createClass(e,[{key:"tile",get:function(){return this._tile}},{key:"hasGeometry",get:function(){return this._hasGeometry}},{key:"vao",get:function(){return this._vao}},{key:"textureReference",get:function(){return this._textureRef.current}},{key:"nextTextureReference",get:function(){return this._textureRef.next}},{key:"textureFadeFactor",get:function(){return this._textureRef.fadeFactor}},{key:"textureIsFading",get:function(){return this._textureRef.isFading}},{key:"estimatedGeometryMemoryUsage",get:function(){const e=s.mapOr(this.intersectionData,0,(e=>e.estimatedMemoryUsage));return(this.geometryInfo.indices?.byteLength??0)+(this.geometryInfo.vertexAttributes?.byteLength??0)+e}},{key:"textureDescriptor",get:function(){return s.isSome(this._texture)?this._texture.descriptor:null}},{key:"test",get:function(){return{hasTexture:null!=this._texture}}}]),e}();const v=a.create(),C=a.create(),D=a.create(),$=a.create(),T=a.create(),N=a.create(),R=1,L=[null,null,null,null];function I(e,t){return t?.isLoaded||t===e?t:null}Object.defineProperty(e,"ActivationTime",{enumerable:!0,get:()=>y.ActivationTime}),e.PatchRenderData=b,e.neighborTileIfLoadedOrSelf=I,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
