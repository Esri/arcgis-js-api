/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import{lerp as t}from"../../../core/mathUtils.js";import{isSome as r,isNone as i,mapOr as s}from"../../../core/maybe.js";import{empty as a}from"../../../geometry/support/aaBoundingBox.js";import"../../../core/has.js";import"../../../geometry/Extent.js";import"../../../geometry/support/Ellipsoid.js";import{glLayout as o}from"../support/buffer/glUtil.js";import{sampleElevationOrZero as n}from"./ElevationData.js";import{GeometryState as l}from"./GeometryState.js";import"./interfaces.js";import{LayerClass as h}from"./LayerClass.js";import{PatchGeometry as d,releaseGeometry as u}from"./PatchGeometry.js";import{neighborEdgeIndices as g,internalAssert as m,oppositeEdge as c,eps as p,neighborCornerIndices as f,oppositeCorner as y}from"./terrainUtils.js";import{TextureFader as _,ActivationTime as x}from"./TextureFader.js";export{ActivationTime}from"./TextureFader.js";import"./Tile.js";import v from"./TileOverlayData.js";import{fallsWithinLayer as b}from"./tileUtils.js";import{Default3D as D}from"../webgl-engine/lib/DefaultVertexAttributeLocations.js";import{BufferObject as C}from"../../webgl/BufferObject.js";import{VertexArrayObject as S}from"../../webgl/VertexArrayObject.js";class T{constructor(){this.geometryInfo=new d,this.intersectionData=null,this.geometryState=null,this._textureRef=new _((()=>this.tile.surface.textureFadeDuration)),this.overlay=new v,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._edgeResolutionChanged=!1,this._edgeNeighborChanged=!1,this._cornerElevationChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1}get tile(){return this._tile}init(e){this._tile=e,this.clear();const t=this.geometryInfo;t.indices=null,t.vertexAttributes=null,a(t.boundingBox),t.indexCount=0,t.numVerticesPerSide=0,this.intersectionData=null,this.geometryState=new l,this.localOrigin=null,this.overlay.clear()}clear(){this._releaseGeometry(),this.releaseTexture(),this._textureRef.clear()}updateGeometryIfChanged(e,t){const r=this.updateGeometryStateAndPrepareForGeometryGeneration(t);this._hasGeometry=!0;return this.updateNeighborDataAndGeometryIfNeeded(r,e)}updateNeighborDataAndGeometryIfNeeded(e=!1,t=this.vao.context){const r=this._updateNeighborData(),i=e||this._geometryStateChangedSinceLastUpdate||r;return i&&(this._updateGeometry(t),this._geometryStateChangedSinceLastUpdate=!1),i}_calculateEdgeResolution(e,t){const s=this.tile,a=this.geometryState.numVerticesPerSide-1;if(!s.surface.isGlobal){const t=s.surface.extent;if(r(t)&&(0===e&&s.extent[3]>t[3]||1===e&&s.extent[2]>t[2]||2===e&&s.extent[1]<t[1]||3===e&&s.extent[0]<t[0]))return a}const o=s.level,n=g[e],l=t||s.findNeighborTile(n,(e=>e.isLoaded||e.level===o));if(!l||l.isLeaf&&!l.isLoaded)return m(i(s.surface?.rootTiles)||s.surface.updatingRootTiles||!s.shouldHaveNeighbor(n)),a;if(l.isLoaded){const t=l,r=t.renderData.geometryState,i=o-t.level;if(0===i){const e=r.numVerticesPerSide-1;return Math.max(e,a)}const s=2**i,n=r.neighborData.edgeResolutions[(e+2)%4]/s;return Math.max(1,n)}m(!l.isLeaf);let h=a;return l.forAllSubtreeOnSide(c(n),(e=>e===s||(e.isLoaded?(h=Math.max(h,2**(e.level-o)),!0):(m(!e.isLeaf),!1)))),h}_updateNeighborData(){const e=this.tile,r=t=>t.isLoaded||t.level===e.level,i=e=>e.isLoaded,s=[null,null,null,null],a=[null,null,null,null];(()=>{for(let t=0;t<4;++t){const i=e.findNeighborTile(g[t],r);s[t]=i,a[t]=i?.isLoaded?i:null}})();const o=[null,null,null,null];(()=>{for(let t=0;t<4;++t)o[t]=e.findNeighborTile(f[t],i)})();const l=this.geometryState.neighborData;let h=!1;(()=>{for(let t=0;t<4;++t){const r=l.edgeResolutions[t],i=s[t],a=this._calculateEdgeResolution(t,i);l.edgeResolutions[t]=a,r!==a&&(h=!0,this._edgeResolutionChanged=!0,i&&i!==e&&!i.isLoaded&&i.level===e.level&&(l.modifiedEdgeResolutions[t]=!0))}})();(()=>{const r=(r,i)=>{const s=r.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);for(let l=0;l<4;++l){const s=r[(l+3)%4],a=r[l];if(s&&s.level<e.level&&s===a){const r=s,a=1==(1&l),o=(e.getNeighborEdgeStartVertexIndex(l,r)+(0===i||1===i&&!a||3===i&&a?1:0))/2**(e.level-r.level),h=a?0===i||1===i?r.extent[0]:r.extent[2]:t(r.extent[0],r.extent[2],o),d=a?t(r.extent[1],r.extent[3],o):0===i||3===i?r.extent[1]:r.extent[3];return n(h,d,r.renderData.geometryState.samplerData)}}let a=0,o=0;for(let e=0;e<4;++e){const t=r[e];if(t&&t.level===s){const r=0===e||1===e,i=0===e||3===e,s=t.extent;o+=n(s[r?0:2],s[i?1:3],t.renderData?.geometryState?.samplerData),a++}}return a?o/a:0},i=l.cornerNeighborData,s=(t,s)=>{const a=i[t],o=a.cornerTiles;for(let r=0;r<4;++r){const t=f[r],i=s[r]?.findCorner(y(t),(t=>t?.isLoaded||t===e));o[r]=i}const n=r(o,t);return a.elevation!==n&&(a.elevation=n,!0)};for(let t=0;t<4;++t){const r=o[t],i=a[t],n=[r,a[(t+1)%4],e,i],l=n.map(((e,r)=>n[(r+4-t)%4]));s(t,l)&&(this._cornerElevationChanged=!0,h=!0)}})();return(()=>{const t=(t,r)=>{if(!t?.isLoaded||t.lij[0]>e.lij[0])return null;const i=t.renderData.geometryState;return{neighborSamplerData:i.samplerData,neighborEdgeOverlapResolution:i.neighborData.edgeResolutions[r+2],version:i.samplerDataVersion,neighborVerticesPerSide:i.numVerticesPerSide,neighborTile:t}},r=l.edgeNeighbours;for(let i=0;i<4;++i){const s=a[i];s&&(m(s?.isLoaded),m(s?.lij[0]<=e.lij[0]));const o=r[i],n=o?.version,l=t(s,i),d=l?.version??null,u=null!=o!=(null!=l),g=o&&l&&n!==d,c=o&&l&&o?.neighborTile!==l?.neighborTile,p=u||g||c;this._edgeNeighborChanged||(this._edgeNeighborChanged=p),h||(h=p),!p&&n||(r[i]=l)}})(),h}updateEdgeAfterResolutionChange(e){const t=this._calculateEdgeResolution(e),r=this.geometryState.neighborData.edgeResolutions,i=r[e];m((this.geometryState.neighborData.edgeNeighbours[e]?.neighborTile.level??0)<=this.tile.level),t!==i&&(r[e]=t,this._edgeResolutionChanged=!0,T.deferTileNeighborUpdate?T.neighborTilesToUpdate.add(this.tile):this._updateGeometry(this.vao.context))}_updateGeometry(e){this.intersectionData=null;const t=this.tile,r=t.lij,i=T.updatedGeometryTiles.get(r)||0;T.updatedGeometryTiles.set(r,i+1);const s=this._vao,a=this.geometryInfo.vertexAttributes,o=!s||!a||this._wireframeChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._edgeResolutionChanged,n=!o&&this._edgeNeighborChanged,l=!n&&this._cornerElevationChanged;this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._edgeResolutionChanged=!1,this._edgeNeighborChanged=!1,this._cornerElevationChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1,o?(this._releaseGeometry(),this._createGeometry(e)):n?t.updateEdgeElevations():l?t.updateCornerElevations():console.warn("Update for no reason?")}releaseGeometry(){return this._releaseGeometry()}get hasGeometry(){return this._hasGeometry}ensureTexture(e,t){return r(this._texture)&&this._texture.descriptor.width!==e&&this.releaseTexture(),i(this._texture)&&(this._texture=t(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){r(this._texture)&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}updateGeometryStateAndPrepareForGeometryGeneration(t){const r=this._getElevationInfo(),i=r.samplerData?this.tile.getElevationBasedVerticesPerSide(r.maxTileLevel):this.tile.getDefaultVerticesPerRowOnLevel(),s=Math.max(i,5);let a=this.tile.clippingArea;this.tile.intersectsClippingArea&&!this.tile.isWithinClippingArea||(a=null);const o=this.geometryState;let n=!1;return o.numVerticesPerSide!==s&&(this._numVerticesPerSideChanged=!0,o.numVerticesPerSide=s,o.samplerDataVersion++,n=!0),r.changed&&(this._samplerDataChanged=!0,o.samplerData=r.samplerData,o.samplerDataVersion++,n=!0),e(o.clippingArea,a)||(this._clippingAreaChanged=!0,o.clippingArea=a,n=!0),o.wireframe!==t&&(this._wireframeChanged=!0,o.wireframe=t,n=!0),this._geometryStateChangedSinceLastUpdate||(this._geometryStateChangedSinceLastUpdate=n),this._hasGeometry=!0,n}_createGeometry(e){this.tile.createGeometry();const t=this.geometryInfo.vertexAttributes,r=this.geometryInfo.indices,i=e.gl;this._vao=new S(e,D,{geometry:o(t.layout)},{geometry:C.createVertex(e,i.STATIC_DRAW,t.buffer)},C.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}_releaseGeometry(){return this._hasGeometry=!1,!!this._vao&&(this._vao.dispose(),this._vao=null,u(this.geometryInfo),!0)}get vao(){return this._vao}setTextureReference(e,t=x.Immediate){r(e)&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[h.ELEVATION],i=t.length;let s=new Array(i),a=0,o=0,n=!1;for(let l=0;l<i;l++){const i=t[l];if(r(i.upsampleInfo)){const t=i.upsampleInfo.tile,r=t.layerInfo[h.ELEVATION][l].data,d=r&&r.samplerData;e&&e[a]===d||(n=!0),s[a++]=d,o=Math.max(o,t.lij[0])}else if(i.data){const t=this.tile.surface.layerViewByIndex(l,h.ELEVATION);if(b(this.tile,t.layer,!1)){const t=i.data;e&&e[a]===t.samplerData||(n=!0),s[a++]=t.samplerData,o=this.tile.level}}}return r(e)&&e.length!==a&&(n=!0),a>0?s.length=a:s=null,{changed:n,samplerData:s,maxTileLevel:o}}get estimatedGeometryMemoryUsage(){const e=s(this.intersectionData,0,(e=>e.estimatedMemoryUsage));return this.geometryInfo.indices.byteLength+this.geometryInfo.vertexAttributes.byteLength+e}get textureDescriptor(){return r(this._texture)?this._texture.descriptor:null}get test(){return{hasTexture:null!=this._texture}}checkGeometryWaterproofness(){}}function G(e,t,i){if(r(i))for(const r of i)if(r){const i=r.x0,s=r.width,a=i+(s-1)/r.dx,o=r.y1,n=o-(s-1)/r.dy;if(e>=i-p&&e<=a+p&&n-p<=t&&t<=o+p)return!0}return!1}T.updatedGeometryTiles=new Map,T.deferTileNeighborUpdate=!1,T.neighborTilesToUpdate=new Set;export{T as PatchRenderData,G as isElevationSampleIn};
