/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{nextHighestPowerOfTwo as e}from"../../../core/mathUtils.js";import{disposeMaybe as t,releaseMaybe as r,isNone as s,isSome as o}from"../../../core/maybe.js";import{a,c as i}from"../../../chunks/vec2.js";import{Z as n}from"../../../chunks/vec2f64.js";import{isBaseLayer as u}from"../../../layers/support/layerUtils.js";import{ImageWithType as c}from"../support/StreamDataLoader.js";import{BlendLayersPassParameters as l}from"./BlendLayersTechnique.js";import{TextureUpdate as p}from"./interfaces.js";import{LayerClass as d}from"./LayerClass.js";import{isBlendableLayerView as h,isGroupLayer as m,isVectorTileLayerView as _,isVectorTileRenderInfo as T,isImageryTileRenderInfo as f,isRasterTileRenderInfo as x,isTextureTileRenderInfo as y}from"./terrainUtils.js";import{ActivationTime as g}from"./TextureFader.js";import{TextureReference as b}from"./TextureReference.js";import{TileCompositor as k}from"./TileCompositor.js";import I from"./TileTexture.js";import{TileUpdate as P}from"./TileUpdate.js";import{LayerBlendMode as D,blendModeFromString as w}from"../webgl-engine/core/shaderLibrary/output/BlendOptions.js";import{B as L}from"../../../chunks/BlendLayers.glsl.js";import{createColorTexture as A,createEmptyTexture as E}from"../webgl-engine/lib/glUtil3D.js";import{TextureSamplingMode as R,TextureType as M,PixelFormat as j,PixelType as O,TextureWrapMode as N}from"../../webgl/enums.js";import{Texture as U}from"../../webgl/Texture.js";class C{constructor(e,t,r){this._rctx=e,this.tileSize=t,this._techniqueRepository=r,this._passParameters=new l,this._backgroundTexture=null,this._backgroundColor=null,this._backgroundDirty=!1,this._blackTex=null,this._numTexturedLayer=0,this._maxAnisotropy=this._rctx.parameters.maxMaxAnisotropy,this._composition=new k(this._rctx,this._techniqueRepository),this._blackTex=new I(A(this._rctx,[0,0,0,1])),this._ensureBackgroundTexture(this.tileSize)}dispose(){this._composition=t(this._composition),this._backgroundTexture=r(this._backgroundTexture),this._blackTex=r(this._blackTex)}get backgroundIsGrid(){return s(this._backgroundColor)}get backgroundColor(){return this._backgroundColor}updateTileTexture(e,t){if(!e.renderData)return;const r=e.surface,s=r.baseOpacity;this._numTexturedLayer=0;let o=0,a=this.tileSize,i=!1;const n=r.view.state.pixelRatio;let c=!1;const l=e.layerInfo[d.MAP];let p=l.length,T=0;for(;T<l.length;T++){const t=r.layerViewByIndex(T,d.MAP),f=t.fullOpacity;if(G[T]=f,u(t.layer)&&p>=l.length&&(p=T),0===f){l[T].pendingUpdates&=~(P.TEXTURE_NOFADING&P.TEXTURE_FADING);continue}++o;const x=F(e,T);if(x){if(l[T].pendingUpdates&=~(P.TEXTURE_NOFADING&P.TEXTURE_FADING),h(t)){const e=m(t.layer.parent)?"normal":t.layer.blendMode;S[T]=e;const r="normal"!==e;r&&(c=r,i=!1)}_(t)?a=Math.max(a,this.tileSize*n):1===s&&1===f&&(t.isOpaque||this._dataToTexture(x)&&x.sourceLayerInfo.data.descriptor.isOpaque)&&(i=!0),++this._numTexturedLayer}}this._composition.cleanupFBOPool(n,l.length),a=B(a);const f=a/this.tileSize,x=T-1;this._ensureBackgroundTexture(this.tileSize),0!==this._numTexturedLayer?1===this._numTexturedLayer&&!c&&this._useLayerTexture(e,x,p,G[x])||this._composeMapLayers(e,t,x,p,G,S,a,f,!i||c):this._useBackgroundTexture(e,o)}_ensureBackgroundTexture(e){s(this._backgroundTexture)&&(this._backgroundTexture=this._buildTexture(e),this._backgroundDirty=!0),this._backgroundDirty&&(this._composition.bindPool(0,e),this._passParameters.offset=n,this._passParameters.scale=1,this._passParameters.opacity=1,this._passParameters.blendMode=D.Normal,o(this.backgroundColor)&&(this._passParameters.backgroundColor=this.backgroundColor),this._composition.drawBackground(this._passParameters,o(this.backgroundColor)?L.ColorOnly:L.GridOnly),this._composition.copyFBOToTexture(this._backgroundTexture),this._composition.releasePool(),this._backgroundDirty=!1)}_useBackgroundTexture(e,t){let r=g.Immediate;(e.surface.view.layerViewManager.updating||t>0)&&(r=g.Delayed),this._backgroundTexture&&s(e.renderData.textureReference)&&(r=g.Immediate),e.renderData.setTextureReference(o(this._backgroundTexture)?new b(this._backgroundTexture,p.FADING,z,e.surface.baseOpacity,1,0):null,r)}_useLayerTexture(e,t,r,s){const o=t<r,a=o?1:e.surface.baseOpacity,i=o?e.surface.baseOpacity:1,n=F(e,t);return!!this._dataToTexture(n)&&(e.renderData.setTextureReference(new b(n.sourceLayerInfo.data,p.FADING,n,a,s,i)),!0)}_composeMapLayers(e,t,r,s,o,a,i,n,u){this._composition.bindPool(0,i);const c=e.surface.baseOpacity;let l=!1,p=R.LINEAR_MIPMAP_LINEAR,d=!1,h=0;for(let _=r;_>=0;_--){const t=F(e,_);if(!t)continue;if(0===o[_])continue;const r=_<s&&c<1&&!l;this._passParameters.baseOpacity=r?c:1,r&&(l=!0);const m=0===h,x=u&&m?this.backgroundIsGrid?L.GridComposite:L.ColorComposite:L.Composite;T(t)?(this._passParameters.opacity=o[_],this._passParameters.blendMode=w[a[_]],d=this._composition.drawVectorData(this._passParameters,t,n,this.tileSize,i,d,x)):f(t)?(this._passParameters.opacity=o[_],this._passParameters.blendMode=w[a[_]],this._composition.drawImageryTileData(t,x,this._passParameters),this._hasNearestInterpolation(t)&&(p=R.NEAREST)):this._dataToTexture(t)&&(this._passParameters.texture=t.sourceLayerInfo.data.texture,this._passParameters.offset=t.offset,this._passParameters.scale=t.scale,this._passParameters.opacity=o[_],this._passParameters.blendMode=w[a[_]],this._composition.drawRasterData(x,this._passParameters)),h++}const m=e.renderData.ensureTexture(i,(()=>this._buildTexture(i,p)));this._composition.copyFBOToTexture(m),this._composition.releasePool(),e.renderData.setTextureReference(new b(m,t,z,l?1:c,1,0))}_hasNearestInterpolation(e){const t=e.sourceLayerInfo.data;return!!t.source&&"nearest"===t.interpolation}_dataToTexture(e){return x(e)&&this._rasterDataToTexture(e),y(e)}_rasterDataToTexture(e){const t=e.sourceLayerInfo;t.data=this._buildTexture(t.data),e.tile.setMemoryDirty()}setBackground(e){this._backgroundColor!==e&&(this._backgroundColor=e,this._backgroundDirty=!0)}_buildTexture(e,t=R.LINEAR_MIPMAP_LINEAR){if(s(e))return null;const r={target:M.TEXTURE_2D,pixelFormat:j.RGBA,dataType:O.UNSIGNED_BYTE,wrapMode:N.CLAMP_TO_EDGE,samplingMode:t,maxAnisotropy:this._maxAnisotropy,flipped:!0,hasMipmap:!0},o=this._rctx;let a;if("number"==typeof e)r.width=r.height=e,a=new I(new U(o,r));else if(e instanceof c)r.isOpaque=e.isOpaque,a=new I(new U(o,r,e.image)),e.release();else try{a=new I(new U(o,r,e))}catch(n){a=new I(E(o)),console.warn("TileRenderer: failed to execute 'texImage2D', cross-origin image may not be loaded.")}const i=o.bindTexture(a.texture,U.TEXTURE_UNIT_FOR_UPDATES);return a.generateMipmap(),o.bindTexture(i,U.TEXTURE_UNIT_FOR_UPDATES),a}get test(){return{backgroundTexture:this._backgroundTexture}}}function B(t){const r=e(t),s=r*r,o=t*t;if(s===o)return t;const a=r/2;return s-o<o-a*a?r:a}function F(e,t){q.layerIndex=t;const r=e.layerInfo[d.MAP][t];if(o(r.data))return a(q.offset,0,0),q.tile=e,q.scale=1,q.sourceLod=e.lij,q.sourceLayerInfo=r,q;const s=r.upsampleInfo;if(o(s)){const e=s.tile.layerInfo[d.MAP][t];return q.tile=s.tile,i(q.offset,s.offset),q.scale=s.scale,q.sourceLod=s.tile.lij,q.sourceLayerInfo=e,q}return null}const G=new Array,S=new Array,q={tile:null,sourceLayerInfo:null,sourceLod:null,offset:[0,0],scale:1,layerIndex:0},z={offset:[0,0],scale:1};export{C as TileRenderer};
