/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{asinClamped as i}from"../../../../../core/mathUtils.js";import{createScreenPointArray as e,screenPointObjectToArray as n}from"../../../../../core/screenUtils.js";import{property as o}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as s}from"../../../../../core/accessorSupport/decorators/subclass.js";import{o as r,c as a,e as m,g as h,b as c,n as l,l as p,a as u}from"../../../../../chunks/vec3.js";import{c as d,f as C}from"../../../../../chunks/vec3f64.js";import{wrapAxisAngle as g}from"../../../../../geometry/support/axisAngle.js";import{create as v,fromNormalAndOffset as M,setOffsetFromPoint as b,negate as f,normal as w}from"../../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as E,applyAll as S}from"../../../camera/constraintUtils.js";import{ConstraintTypes as P,InteractionType as V,TiltMode as j}from"../../../camera/constraintUtils/common.js";import{ExponentialFalloff as z}from"../../../input/util.js";import{InteractiveController as H}from"../InteractiveController.js";import{PanPlanarMomentumController as O}from"../momentum/PanPlanarMomentumController.js";import{RotationMomentumController as y}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as T}from"../momentum/ZoomPlanarMomentumController.js";import{NavigationMode as A,centroid as F,applyZoomToPoint as L,applyPanPlanar as x,normalizeRotationDelta as R,applyRotation as U,intersectPlaneFromScreenPointAtEye as D}from"../../utils/navigationUtils.js";import{Camera as N}from"../../../webgl-engine/lib/Camera.js";import{PanPlanarMomentumEstimator as _}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as k}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as I}from"../../../../navigation/ZoomMomentumEstimator.js";const G=C(0,0,1),Z={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI},B=80;let W=class extends H{constructor(t){super(t),this.view=null,this.rotationValueSmooth=new z(.05),this.scalingValueSmooth=new z(.05),this.planeHorizontal=v(),this.planeVertical=v(),this.rotationMomentumEstimator=new k,this.panMomentumEstimator=new _(300,12,.9),this.zoomMomentumEstimator=new I,this.beginCenter=d(),this.tmpPoints=[],this.beginCenterScreen=e(),this.tmpCentroid3d=d(),this.tmpCentroid2d=e(),this.tmp2d=e(),this.constraintOptions={selection:P.ALL,interactionType:V.NONE,interactionFactor:0,interactionStartCamera:new N,interactionDirection:null,tiltMode:j.TUMBLE}}get intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;const e=this.view.navigation.momentumEnabled;this.zoomMomentumEstimator.enabled=e,this.rotationMomentumEstimator.enabled=e,this.panMomentumEstimator.enabled=e,this.beginRadius=t.radius,this.pointerCount=t.pointers.size,this.beginAngle=t.angle,this.rotationValueSmooth.reset(),this.scalingValueSmooth.reset(),n(t.center,this.beginCenterScreen),M(G,0,this.planeHorizontal);const o=d(),s=this.intersectionHelper.intersectScreenFreePointFallback(this.beginCenterScreen,o),C=d();r(C,this.startCamera.viewForward);const g=d();a(g,G);const v=m(C,g),w=i(v<0?-v:v);if(this.panMode=w>=Z.ANGLE_THRESHOLD?A.Horizontal:A.Vertical,b(this.planeHorizontal,this.planeHorizontal,o),this.startCamera.aboveGround||f(this.planeHorizontal,this.planeHorizontal),this.panMode===A.Vertical){h(g,g,v),c(this.planeVertical,C,g),l(this.planeVertical,this.planeVertical),b(this.planeVertical,this.planeVertical,o);const i=d(),e=d(),n=d();c(i,o,this.currentCamera.eye);const r=p(i);l(i,i);const M=5*Math.max(Math.abs(this.view.camera.position.z),50),f=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,this.beginCenterScreen[0],this.beginCenterScreen[1],this.view.state.camera,B);let w=f?Math.min(f,M):M;w=s?Math.min(w,r):w,a(n,u(e,this.currentCamera.eye,h(e,i,w))),this.planeVertical[3]=-m(this.planeVertical,n),this.computePlanePoints(t.pointers,this.planeVertical,this.startCamera,this.tmpPoints),F(this.tmpPoints,this.beginCenter)}else this.computePlanePoints(t.pointers,this.planeHorizontal,this.startCamera,this.tmpPoints),F(this.tmpPoints,this.beginCenter);this.constraintOptions.interactionStartCamera.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,e=this.panMode===A.Horizontal?this.planeHorizontal:this.planeVertical,o=this.beginCenter;if(i){const i=this.beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this.scalingValueSmooth.gain=e,this.scalingValueSmooth.update(i),L(this.currentCamera,o,this.scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this.zoomMomentumEstimator.add(this.scalingValueSmooth.value,.001*t.timestamp),this.constraintOptions.interactionType=V.ZOOM,this.constraintOptions.interactionFactor=E(Math.abs(t.radius-this.beginRadius)),S(this.view,this.currentCamera,this.constraintOptions)}if(this.computePlanePoints(t.pointers,e,this.currentCamera,this.tmpPoints),F(this.tmpPoints,this.tmpCentroid3d),n(t.center,this.tmpCentroid2d),x(this.currentCamera,o,this.tmpCentroid3d),this.panMomentumEstimator.add(this.tmpCentroid2d,this.tmpCentroid3d,.001*t.timestamp),this.constraintOptions.interactionType=V.PAN,this.constraintOptions.interactionFactor=E(this.beginCenterScreen,this.tmpCentroid2d),S(this.view,this.currentCamera,this.constraintOptions),i){const i=this.planeHorizontal,e=o,n=this.rotationValueSmooth.value,s=n+R(t.angle-n),r=.00125*Math.min(Math.max(t.radius,40),120);this.rotationValueSmooth.gain=r,this.rotationValueSmooth.update(s);const a=this.rotationValueSmooth.value-this.beginAngle;this.rotationMomentumEstimator.add(a,.001*t.timestamp),U(this.currentCamera,e,g(i,a)),this.constraintOptions.interactionType=V.TUMBLE,this.constraintOptions.interactionFactor=E(Math.abs(t.radius*a)),S(this.view,this.currentCamera,this.constraintOptions)}}end(t){t.pointers.size===this.pointerCount&&this.update(t),this.finishController();const i=this.zoomMomentumEstimator.evaluateMomentum();if(i)return new T({view:this.view,momentum:i,zoomCenter:this.beginCenter});const e=this.rotationMomentumEstimator.evaluateMomentum();if(e)return new y({view:this.view,momentum:e,center:this.beginCenter,axis:w(this.planeHorizontal)});const n=this.panMomentumEstimator.evaluateMomentum();return n?new O({view:this.view,momentum:n}):null}computePlanePoints(t,i,e,n){n.length=t.size;const o=this.tmp2d;let s=0;return t.forEach((t=>{o[0]=t.x,o[1]=t.y,void 0===n[s]&&(n[s]=d()),D(i,e,o,n[s]),s+=1})),n}};t([o({constructOnly:!0})],W.prototype,"view",void 0),W=t([s("esri.views.3d.state.controllers.local.PinchAndPanController")],W);export{W as PinchAndPanController};
