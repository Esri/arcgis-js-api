/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{acosClamped as i,clamp as s}from"../../../../core/mathUtils.js";import{createScreenPointArray as o}from"../../../../core/screenUtils.js";import{property as r}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as e}from"../../../../core/accessorSupport/decorators/subclass.js";import{d as a,e as n}from"../../../../chunks/mat4.js";import{c as h}from"../../../../chunks/mat4f64.js";import{c as p}from"../../../../chunks/vec2.js";import{a as c}from"../../../../chunks/vec2f64.js";import{c as m,b as l,l as v,n as u,a as C,g as f,e as P,f as E,m as d}from"../../../../chunks/vec3.js";import{c as w}from"../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as R}from"../../../../geometry/projectionEllipsoid.js";import{applyAll as T}from"../../camera/constraintUtils.js";import{ConstraintTypes as j,InteractionType as y,TiltMode as O}from"../../camera/constraintUtils/common.js";import{TiltDefault as U}from"../Constraints.js";import{InteractiveController as M}from"./InteractiveController.js";import{normalizeCoordinate as D,decideNavigationMode as x,NavigationMode as N}from"../utils/navigationUtils.js";var g;!function(t){t[t.CENTER=0]="CENTER",t[t.EYE=1]="EYE"}(g||(g={}));const k=7,A=90;let L=class extends M{constructor(t){super(t),this.view=null,this.pivot=g.CENTER,this.lastPoint=c(),this.tmpWorldUp=w(),this.tmpViewDir=w(),this.tmpRotCurPoint=c(),this.tmpTransf=h(),this.tmpAxis=w(),this.tmpPivotPoint=w(),this.pivotPos=w(),this.constraintOptions={selection:j.ALL,interactionType:y.TUMBLE,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:O.TUMBLE}}get intersectionHelper(){return this.view.sceneIntersectionHelper}initialize(){this.rotScale=this.pivot===g.CENTER?3:1.5}begin(t){if(this.active){switch(this.pivot){case g.EYE:m(this.pivotPos,this.startCamera.eye),this.constraintOptions.interactionType=y.LOOK_AROUND,this.constraintOptions.tiltMode=O.LOOK_AROUND,this.constraintOptions.selection=j.NONE;break;case g.CENTER:{const i=this.intersectionHelper.intersectRayFreePointFallback(this.startCamera.ray,this.pivotPos);i||m(this.pivotPos,this.startCamera.center),this._constrainPivotPoint(t,i),this.startCamera.center=this.pivotPos,this.constraintOptions.interactionType=y.TUMBLE,this.constraintOptions.tiltMode=O.TUMBLE,this.constraintOptions.selection=j.ALL&~j.DISTANCE;break}}this.constraintOptions.interactionStartCamera=this.startCamera,D(this.startCamera,t,this.lastPoint)}}_constrainPivotPoint(t,i){const s=this.startCamera,r=w();l(r,this.pivotPos,s.eye);const e=v(r);let a=Math.min(e,k*Math.abs(this.view.camera.position.z));const n=R(this.view.spatialReference),h=o(s.width/s.pixelRatio*.5,s.height/s.pixelRatio*.5),p=x(this.startCamera,h,!0,n);let c=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,s.fullWidth/s.pixelRatio*.5,s.fullHeight/s.pixelRatio*.5,s,2.5*A,A),P=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,t[0],t[1],s,A);void 0===c&&void 0===P||(c=void 0===c?P:c,P=void 0===P||p===N.Horizontal?c:P,a=c>P?P:c,a=i?Math.min(a,e):a),u(r,r),m(this.pivotPos,C(this.tmpPivotPoint,s.eye,f(this.tmpPivotPoint,r,a)))}update(t){if(this.active){switch(this.pivot){case g.EYE:this.currentCamera.center=this._applyRotation(this.currentCamera,t,this.currentCamera.center,this.pivotPos);break;case g.CENTER:this.currentCamera.center=this.pivotPos,this.currentCamera.eye=this._applyRotation(this.currentCamera,t,this.currentCamera.eye,this.pivotPos)}T(this.view,this.currentCamera,this.constraintOptions)}}end(){this.active&&this.finishController()}_applyRotation(t,o,r,e){this.view.renderCoordsHelper.worldUpAtPosition(e,this.tmpWorldUp),D(t,o,this.tmpRotCurPoint);let h=(this.lastPoint[1]-this.tmpRotCurPoint[1])*this.rotScale,c=(this.tmpRotCurPoint[0]-this.lastPoint[0])*this.rotScale;l(this.tmpViewDir,r,e);const m=v(this.tmpViewDir),u=i(P(this.tmpViewDir,this.tmpWorldUp)/m);if(this.pivot===g.EYE){h*=-.5;const t=.5*Math.PI-u,i=.5*Math.PI*.99;h=t-Math.max(-i,Math.min(i,t+h))}return h=s(h+u,U.min,U.max)-u,E(this.tmpAxis,t.up,this.tmpViewDir),this.pivot===g.CENTER&&(c=-c),a(this.tmpTransf,c,this.tmpWorldUp),n(this.tmpTransf,this.tmpTransf,h,this.tmpAxis),d(this.tmpViewDir,this.tmpViewDir,this.tmpTransf),t.up=d(V,t.up,this.tmpTransf),C(V,e,this.tmpViewDir),p(this.lastPoint,this.tmpRotCurPoint),V}};t([r({constructOnly:!0})],L.prototype,"view",void 0),t([r()],L.prototype,"pivot",void 0),L=t([e("esri.views.3d.state.controllers.RotateController")],L);const V=w();export{g as PivotPoint,L as RotateController};
