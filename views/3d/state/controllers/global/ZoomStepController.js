/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/_rollupPluginBabelHelpers","../../../../../chunks/tslib.es6","../../../../../core/maybe","../../../../../core/time","../../../../../core/Logger","../../../../../core/accessorSupport/ensureType","../../../../../core/arrayUtils","../../../../../core/Error","../../../../../core/has","../../../../../core/accessorSupport/decorators/subclass","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../geometry/projectionEllipsoid","../../../../../chunks/sphere","../../../camera/constraintUtils","../../../camera/constraintUtils/ConstraintTypes","../../../camera/constraintUtils/InteractionType","../../../camera/constraintUtils/surfaceCollision","../../../camera/constraintUtils/TiltMode","../PointToPointAnimationController","../../utils/navigationUtils","../../../support/geometryUtils/ray","../../../support/geometryUtils/sphere","../../../webgl-engine/lib/Camera","../../../webgl-engine/lib/Intersector","../../../webgl-engine/lib/verticalOffsetUtils","../../../../animation/easing"],(function(t,e,i,r,n,a,o,s,c,h,l,m,p,_,u,d,y,g,C,w,v,D,f,M,b,S,R,T){"use strict";const L=.6,z=4,O=12,U=60,E=200;t.ZoomStepController=function(t){function i(){var e;return(e=t.apply(this,arguments)||this)._zoomLocation=p.create(),e._tmpCamera=new b.Camera,e._tmpViewDir=p.create(),e._tmpRayDir={origin:p.create(),direction:p.create()},e._targetOnSphere=p.create(),e._tmpCenter=p.create(),e._constraintOptions={selection:y.ConstraintTypes.ALL_EXCEPT_COLLISION,interactionType:g.InteractionType.ZOOM,interactionFactor:null,interactionStartCamera:new b.Camera,interactionDirection:null,tiltMode:w.TiltMode.TUMBLE},e._sphere=u.create(),e}e._inheritsLoose(i,t);var a=i.prototype;return a.initialize=function(){this._intersector=S.newIntersector(this.view.state.viewingMode)},a.zoomStep=function(t,e){if(!this.active)return;const i=this.view.state,{interactionStartCamera:r}=this._constraintOptions;this.animation.finished?r.copyFrom(i.camera):this.animation.cameraAt(1,r);let n=!1,a=!1;this.intersectionHelper.intersectScreen(e,this._zoomLocation,0===this.view.map.ground.opacity?I:{})&&(n=t>0,a=!0),this._tmpCamera.copyFrom(i.camera),n?this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._tmpCenter)&&(this._tmpCamera.center=this._tmpCenter):this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._zoomLocation)?this._tmpCamera.center=this._zoomLocation:m.copy(this._zoomLocation,this._tmpCamera.center),this._updateCamera(this._tmpCamera,t,this._zoomLocation,e,a),this.begin(this._tmpCamera)},a.animationSettings=function(){return{apex:null,duration:n.Milliseconds(600),easing:T.outExpo}},a._updateCamera=function(t,e,i,n,a){const o=_.getReferenceEllipsoid(this.view.spatialReference),s=D.decideNavigationMode(t,n,a,o);let c;this.view.camera.position.hasZ&&(c=Math.abs(this.view.camera.position.z)),m.normalize(A,t.eye),m.scale(A,A,-1),f.fromScreenAtEye(t,n,this._tmpRayDir),m.normalize(this._tmpRayDir.direction,this._tmpRayDir.direction);const h=Math.max(Math.min(O,1/Math.abs(m.dot(A,this._tmpRayDir.direction)))*c,E);if(s===D.NavigationMode.Horizontal){let r=L**e;this._sphere[3]=m.length(i),m.subtract(this._tmpViewDir,t.center,t.eye);const a=Math.min(m.length(this._tmpViewDir),h);let o=a*r;if(r<=1&&o<z&&(o=z,r=o/a),Math.abs(a-o)<1e-6)return;const s=m.length(t.center);if(this._sphere[3]!==s){const e=this._sphere[3]+r*(s-this._sphere[3]);t.center=m.scale(V,t.center,e/s)}m.scale(this._tmpViewDir,this._tmpViewDir,-r),t.eye=m.add(V,t.center,this._tmpViewDir),d.applyAll(this.view,t,this._constraintOptions),m.squaredDistance(i,t.center)>1e-12&&M.intersectScreen(this._sphere,t,n,this._targetOnSphere)&&D.panToPosition(this._sphere,t,i,this._targetOnSphere,this.view.camera.heading,this.view.camera.tilt,!0)}else{let o=L**Math.abs(e);const s=e>0?1:-1;m.subtract(this._tmpViewDir,i,t.eye);const c=m.length(this._tmpViewDir),l=this.view._stage.renderView.getMinimalDepthForArea(null,n[0],n[1],this.view.state.camera,U);let p=r.isSome(l)?Math.min(h,l):h;p=a?Math.min(p,c):p,m.scale(this._tmpRayDir.direction,this._tmpRayDir.direction,p),m.add(i,this._tmpRayDir.origin,this._tmpRayDir.direction);let _=p*o;const u=Math.max(z,1.01*t.nearFar[0]);if(e>0&&_<u&&(_=u,o=_/p),Math.abs(p-_)<1e-6)return;m.scale(this._tmpRayDir.direction,this._tmpRayDir.direction,s*(1-o)),t.eye=m.add(V,t.eye,this._tmpRayDir.direction),t.center=m.add(V,t.center,this._tmpRayDir.direction)}C.applySurfaceCollisionConstraint(this.view,t)},i}(v.PointToPointAnimationController),t.ZoomStepController=i.__decorate([l.subclass("esri.views.3d.state.controllers.global.ZoomStepController")],t.ZoomStepController);const V=p.create(),A=p.create(),I={exclude:new Set([R.TERRAIN_ID])};Object.defineProperties(t,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
