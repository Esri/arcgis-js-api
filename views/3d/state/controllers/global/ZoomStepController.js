/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{Milliseconds as i}from"../../../../../core/time.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/set.js";import{subclass as e}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as r,n as s,g as o,e as a,l as n,b as m,a as c,d as h}from"../../../../../chunks/vec3.js";import{c as p}from"../../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as l}from"../../../../../geometry/projectionEllipsoid.js";import{c as y}from"../../../../../chunks/sphere.js";import{applyAll as f}from"../../../camera/constraintUtils.js";import{ConstraintTypes as w,InteractionType as g,TiltMode as u}from"../../../camera/constraintUtils/common.js";import{PointToPointAnimationController as d}from"../PointToPointAnimationController.js";import{decideNavigationMode as j,NavigationMode as D,panToPosition as C}from"../../utils/navigationUtils.js";import{fromScreenAtEye as v}from"../../../support/geometryUtils/ray.js";import{intersectScreen as b}from"../../../support/geometryUtils/sphere.js";import{Camera as M}from"../../../webgl-engine/lib/Camera.js";import{newIntersector as R}from"../../../webgl-engine/lib/Intersector.js";import{TERRAIN_ID as S}from"../../../webgl-engine/lib/verticalOffsetUtils.js";import{outExpo as L}from"../../../../animation/easing.js";import{applySurfaceCollisionConstraint as O}from"../../../camera/constraintUtils/surfaceCollision.js";const z=.6,U=4,V=12,x=60,_=200;let F=class extends d{constructor(){super(...arguments),this.zoomLocation=p(),this.tmpCamera=new M,this.tmpViewDir=p(),this.tmpRayDir={origin:p(),direction:p()},this.targetOnSphere=p(),this.tmpCenter=p(),this.constraintOptions={selection:w.ALL_EXCEPT_COLLISION,interactionType:g.ZOOM,interactionFactor:null,interactionStartCamera:new M,interactionDirection:null,tiltMode:u.TUMBLE},this.sphere=y()}initialize(){this.intersector=R(this.view.state.viewingMode)}zoomStep(t,i){if(!this.active)return;const e=this.view.state,{interactionStartCamera:s}=this.constraintOptions;this.animation.finished?s.copyFrom(e.camera):this.animation.cameraAt(1,s);let o=!1,a=!1;this.intersectionHelper.intersectScreen(i,this.zoomLocation,0===this.view.map.ground.opacity?A:{})&&(o=t>0,a=!0),this.tmpCamera.copyFrom(e.camera),o?this.intersectionHelper.intersectRay(this.tmpCamera.ray,this.intersector,this.tmpCenter)&&(this.tmpCamera.center=this.tmpCenter):this.intersectionHelper.intersectRay(this.tmpCamera.ray,this.intersector,this.zoomLocation)?this.tmpCamera.center=this.zoomLocation:r(this.zoomLocation,this.tmpCamera.center),this._updateCamera(this.tmpCamera,t,this.zoomLocation,i,a),this.begin(this.tmpCamera)}animationSettings(){return{apex:null,duration:i(600),easing:L}}_updateCamera(t,i,e,r,p){const y=l(this.view.spatialReference),w=j(t,r,p,y);let g;this.view.camera.position.hasZ&&(g=Math.abs(this.view.camera.position.z)),s(k,t.eye),o(k,k,-1),v(t,r,this.tmpRayDir),s(this.tmpRayDir.direction,this.tmpRayDir.direction);const u=Math.max(Math.min(V,1/Math.abs(a(k,this.tmpRayDir.direction)))*g,_);if(w===D.Horizontal){let s=z**i;this.sphere[3]=n(e),m(this.tmpViewDir,t.center,t.eye);const a=Math.min(n(this.tmpViewDir),u);let p=a*s;if(s<=1&&p<U&&(p=U,s=p/a),Math.abs(a-p)<1e-6)return;const l=n(t.center);if(this.sphere[3]!==l){const i=this.sphere[3]+s*(l-this.sphere[3]);t.center=o(T,t.center,i/l)}o(this.tmpViewDir,this.tmpViewDir,-s),t.eye=c(T,t.center,this.tmpViewDir),f(this.view,t,this.constraintOptions),h(e,t.center)>1e-12&&b(this.sphere,t,r,this.targetOnSphere)&&C(this.sphere,t,e,this.targetOnSphere,this.view.camera.heading,this.view.camera.tilt,!0)}else{let s=z**Math.abs(i);const a=i>0?1:-1;m(this.tmpViewDir,e,t.eye);const h=n(this.tmpViewDir),l=this.view._stage.renderView.getMinimalDepthForArea(null,r[0],r[1],this.view.state.camera,x);let y=l?Math.min(u,l):u;y=p?Math.min(y,h):y,o(this.tmpRayDir.direction,this.tmpRayDir.direction,y),c(e,this.tmpRayDir.origin,this.tmpRayDir.direction);let f=y*s;const w=Math.max(U,1.01*t.nearFar[0]);if(i>0&&f<w&&(f=w,s=f/y),Math.abs(y-f)<1e-6)return;o(this.tmpRayDir.direction,this.tmpRayDir.direction,a*(1-s)),t.eye=c(T,t.eye,this.tmpRayDir.direction),t.center=c(T,t.center,this.tmpRayDir.direction)}O(this.view,t)}};F=t([e("esri.views.3d.state.controllers.global.ZoomStepController")],F);const T=p(),k=p(),A={exclude:new Set([S])};export{F as ZoomStepController};
