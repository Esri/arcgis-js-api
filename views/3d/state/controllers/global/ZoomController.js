/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{clamp as i}from"../../../../../core/mathUtils.js";import{createScreenPointArray as e}from"../../../../../core/screenUtils.js";import{property as r}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as s}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as a}from"../../../../../chunks/vec2.js";import{a as n}from"../../../../../chunks/vec2f64.js";import{n as o,b as c,l as h,g as m,a as p}from"../../../../../chunks/vec3.js";import{c as l}from"../../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as u}from"../../../../../geometry/projectionEllipsoid.js";import{create as P,fromPoints as y}from"../../../../../geometry/support/axisAngle.js";import{c as C}from"../../../../../chunks/sphere.js";import{pixelDistanceToInteractionFactor as f,applyAll as d}from"../../../camera/constraintUtils.js";import{ConstraintTypes as g,InteractionType as v,TiltMode as j}from"../../../camera/constraintUtils/common.js";import{InteractiveController as k}from"../InteractiveController.js";import{normalizeCoordinate as R,pickPointAndInitSphere as w,SpherePickPointFallback as D,decideNavigationMode as A,NavigationMode as O,DISTANCE_CLAMP_VALUES as M,PIVOT_DISTANCE_MODIFIER as b,SCREEN_PIXEL_AREA as S,sphereOrPlanePointFromScreenPoint as U,applyRotation as x}from"../../utils/navigationUtils.js";import{fromScreenAtEye as z}from"../../../support/geometryUtils/ray.js";import{TERRAIN_ID as B}from"../../../webgl-engine/lib/verticalOffsetUtils.js";import{applySurfaceCollisionConstraint as E}from"../../../camera/constraintUtils/surfaceCollision.js";let H=class extends k{constructor(t){super(t),this.view=null,this.pickPoint=l(),this.tmpP0=n(),this.panAxisAngle=P(),this.tmpRayDir=l(),this.tmpRayDirPick=l(),this.targetOnSphere=l(),this.tmpRay={origin:l(),direction:l()},this.dragBeginPoint=e(),this.normalizedAnchorPoint=n(),this.constraintOptions={selection:g.ALL_EXCEPT_COLLISION,interactionType:v.ZOOM,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:j.TUMBLE},this.sphere=C(),this.hasPickPoint=!1}get intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;a(this.dragBeginPoint,t),R(this.startCamera,t,this.normalizedAnchorPoint);const e=u(this.view.spatialReference),r=w(this.intersectionHelper,this.startCamera,t,e,D.Ellipsoid,0===this.view.map.ground.opacity?L:{});if(this.navMode=A(this.startCamera,t,r.hasGeometryIntersection,e),this.navMode===O.Horizontal)this.hasPickPoint=!!r.scenePickPoint,this.pickPoint=r.scenePickPoint,this.sphere=r.sphere;else{let e,s;z(this.startCamera,t,this.tmpRay),o(this.tmpRay.direction,this.tmpRay.direction),r.scenePickPoint&&(c(this.tmpRayDirPick,this.startCamera.eye,r.scenePickPoint),s=h(this.tmpRayDirPick)),this.view.camera.position.hasZ&&(e=Math.abs(this.view.camera.position.z));let a=i(b*e,M[0],M[1]);const n=this.view._stage.renderView.getMinimalDepthForArea(null,t[0],t[1],this.view.state.camera,S);a=n?Math.min(a,n):a,a=r.scenePickPoint?Math.min(a,s):a,this.hasPickPoint=!0,m(this.tmpRay.direction,this.tmpRay.direction,a),p(this.pickPoint,this.tmpRay.origin,this.tmpRay.direction)}this.constraintOptions.interactionStartCamera=this.startCamera}update(t){if(this.active){if(this.currentCamera.eye=this.startCamera.eye,this.currentCamera.center=this.startCamera.center,this.currentCamera.up=this.startCamera.up,this.navMode===O.Horizontal){c(this.tmpRayDir,this.currentCamera.center,this.currentCamera.eye);const i=h(this.tmpRayDir);R(this.currentCamera,t,this.tmpP0);const e=12*(this.normalizedAnchorPoint[1]-this.tmpP0[1]);let r=i*2**e;const s=this.view.state.constraints.minimumPoiDistance;if(e<0&&r<s&&(r=s),Math.abs(i-r)<1e-6)return;if(this.hasPickPoint&&r<i){const t=1-(1-r/i)*(1-this.sphere[3]/h(this.currentCamera.center));this.currentCamera.center=m(I,this.currentCamera.center,t)}m(this.tmpRayDir,this.tmpRayDir,-r/i),this.currentCamera.eye=p(I,this.currentCamera.center,this.tmpRayDir),this.constraintOptions.interactionFactor=f(this.dragBeginPoint,t),d(this.view,this.currentCamera,this.constraintOptions),this.hasPickPoint&&(U(this.sphere,this.currentCamera,this.dragBeginPoint,this.targetOnSphere),y(this.pickPoint,this.targetOnSphere,this.panAxisAngle),x(this.currentCamera,this.sphere,this.panAxisAngle))}else{const i=h(this.tmpRay.direction);R(this.currentCamera,t,this.tmpP0);const e=12*(this.normalizedAnchorPoint[1]-this.tmpP0[1]);let r=i*2**e;const s=this.view.state.constraints.minimumPoiDistance;if(e<0&&r<s&&(r=s),Math.abs(i-r)<1e-6)return;m(this.tmpRayDir,this.tmpRay.direction,1-r/i),this.currentCamera.eye=p(I,this.currentCamera.eye,this.tmpRayDir),this.currentCamera.center=p(I,this.currentCamera.center,this.tmpRayDir)}E(this.view,this.currentCamera)}}end(){this.active&&this.finishController()}};t([r({constructOnly:!0})],H.prototype,"view",void 0),H=t([s("esri.views.3d.state.controllers.global.ZoomController")],H);const I=l(),L={exclude:new Set([B])};export{H as ZoomController};
