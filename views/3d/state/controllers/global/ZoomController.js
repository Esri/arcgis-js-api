/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/_rollupPluginBabelHelpers","../../../../../chunks/tslib.es6","../../../../../core/mathUtils","../../../../../core/screenUtils","../../../../../core/accessorSupport/decorators/property","../../../../../core/arrayUtils","../../../../../core/has","../../../../../core/accessorSupport/ensureType","../../../../../core/accessorSupport/decorators/subclass","../../../../../chunks/vec2","../../../../../chunks/vec2f64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../../geometry/projectionEllipsoid","../../../../../geometry/support/axisAngle","../../../../../chunks/sphere","../../../camera/constraintUtils","../../../camera/constraintUtils/common","../InteractiveController","../../utils/navigationUtils","../../../support/geometryUtils/ray","../../../camera/constraintUtils/surfaceCollision"],(function(t,e,i,r,n,a,s,o,c,h,l,p,m,u,C,d,y,P,g,v,A,f,R){"use strict";t.ZoomController=function(t){function i(e){var i;return(i=t.call(this,e)||this).view=null,i.pickPoint=u.create(),i.tmpP0=p.create(),i.panAxisAngle=d.create(),i.tmpRayDir=u.create(),i.targetOnSphere=u.create(),i.tmpRay={origin:u.create(),direction:u.create()},i.dragBeginPoint=n.createScreenPointArray(),i.normalizedAnchorPoint=p.create(),i.constraintOptions={selection:g.ConstraintTypes.ALL_EXCEPT_COLLISION,interactionType:g.InteractionType.ZOOM,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:g.TiltMode.TUMBLE},i.sphere=y.create(),i.hasPickPoint=!1,i}e._inheritsLoose(i,t);var a=i.prototype;return a.begin=function(t){if(!this.active)return;l.copy(this.dragBeginPoint,t),A.normalizeCoordinate(this.startCamera,t,this.normalizedAnchorPoint);const e=C.getReferenceEllipsoid(this.view.spatialReference),i=A.pickPointAndInitSphere(this.intersectionHelper,this.startCamera,t,!1,e);if(this.navMode=A.decideNavigationMode(this.startCamera,t,i.hasGeometryIntersection,e),this.navMode===A.NavigationMode.Horizontal)this.hasPickPoint=!!i.scenePickPoint,this.pickPoint=i.scenePickPoint,this.sphere=i.sphere;else{let e;f.fromScreenAtEye(this.startCamera,t,this.tmpRay),m.normalize(this.tmpRay.direction,this.tmpRay.direction),this.view.camera.position.hasZ&&(e=Math.abs(this.view.camera.position.z));let i=r.clamp(A.PIVOT_DISTANCE_MODIFIER*e,A.DISTANCE_CLAMP_VALUES[0],A.DISTANCE_CLAMP_VALUES[1]);const n=this.view._stage.renderView.getMinimalDepthForArea(null,t[0],t[1],this.view.state.camera,A.SCREEN_PIXEL_AREA);i=i>n?n:i,this.hasPickPoint=!0,m.scale(this.tmpRay.direction,this.tmpRay.direction,i),m.add(this.pickPoint,this.tmpRay.origin,this.tmpRay.direction)}this.constraintOptions.interactionStartCamera=this.startCamera},a.update=function(t){if(this.active){if(this.currentCamera.eye=this.startCamera.eye,this.currentCamera.center=this.startCamera.center,this.currentCamera.up=this.startCamera.up,this.navMode===A.NavigationMode.Horizontal){m.subtract(this.tmpRayDir,this.currentCamera.center,this.currentCamera.eye);const e=m.length(this.tmpRayDir);A.normalizeCoordinate(this.currentCamera,t,this.tmpP0);const i=12*(this.normalizedAnchorPoint[1]-this.tmpP0[1]);let r=e*2**i;const n=this.view.state.constraints.minimumPoiDistance;if(i<0&&r<n&&(r=n),Math.abs(e-r)<1e-6)return;if(this.hasPickPoint&&r<e){const t=1-(1-r/e)*(1-this.sphere[3]/m.length(this.currentCamera.center));this.currentCamera.center=m.scale(S,this.currentCamera.center,t)}m.scale(this.tmpRayDir,this.tmpRayDir,-r/e),this.currentCamera.eye=m.add(S,this.currentCamera.center,this.tmpRayDir),this.constraintOptions.interactionFactor=P.pixelDistanceToInteractionFactor(this.dragBeginPoint,t),P.applyAll(this.view,this.currentCamera,this.constraintOptions),this.hasPickPoint&&(A.sphereOrPlanePointFromScreenPoint(this.sphere,this.currentCamera,this.dragBeginPoint,this.targetOnSphere),d.fromPoints(this.pickPoint,this.targetOnSphere,this.panAxisAngle),A.applyRotation(this.currentCamera,this.sphere,this.panAxisAngle))}else{const e=m.length(this.tmpRay.direction);A.normalizeCoordinate(this.currentCamera,t,this.tmpP0);const i=12*(this.normalizedAnchorPoint[1]-this.tmpP0[1]);let r=e*2**i;const n=this.view.state.constraints.minimumPoiDistance;if(i<0&&r<n&&(r=n),Math.abs(e-r)<1e-6)return;m.scale(this.tmpRayDir,this.tmpRay.direction,1-r/e),this.currentCamera.eye=m.add(S,this.currentCamera.eye,this.tmpRayDir),this.currentCamera.center=m.add(S,this.currentCamera.center,this.tmpRayDir)}R.applySurfaceCollisionConstraint(this.view,this.currentCamera)}},a.end=function(){this.active&&this.finishController()},e._createClass(i,[{key:"intersectionHelper",get:function(){return this.view.sceneIntersectionHelper}}]),i}(v.InteractiveController),i.__decorate([a.property({constructOnly:!0})],t.ZoomController.prototype,"view",void 0),t.ZoomController=i.__decorate([h.subclass("esri.views.3d.state.controllers.global.ZoomController")],t.ZoomController);const S=u.create();Object.defineProperties(t,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
