/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../Camera.js";import i from"../../../Viewpoint.js";import r from"../../../core/Accessor.js";import a from"../../../core/Handles.js";import s from"../../../core/Logger.js";import{isNone as o,isSome as n}from"../../../core/maybe.js";import{watch as h,on as p,when as l}from"../../../core/reactiveUtils.js";import{addFrameTask as c}from"../../../core/scheduling.js";import{createScreenPoint as m}from"../../../core/screenUtils.js";import{property as d}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as v}from"../../../core/accessorSupport/decorators/subclass.js";import{d as u}from"../../../chunks/vec3.js";import{d as w}from"../../../chunks/vec3f64.js";import{s as y}from"../../../chunks/vec4.js";import{c as C}from"../../../chunks/vec4f64.js";import f from"../../../geometry/Extent.js";import g from"../../../geometry/Point.js";import{canProject as _}from"../../../geometry/support/webMercatorUtils.js";import{ViewingMode as x}from"../../ViewingMode.js";import{applyAll as R}from"../camera/constraintUtils.js";import{cameraOnContentAlongViewDirection as P,surfaceElevationBelowRenderLocation as O}from"../camera/intersectionUtils.js";import{ConstraintsManager as T}from"./ConstraintsManager.js";import{Frustum as b}from"./Frustum.js";import{GoToOperation as S}from"./GoToOperation.js";import{SurfaceCollisionCorrectionController as j}from"./controllers/SurfaceCollisionCorrectionController.js";import{internalToExternal as M,externalToInternal as I,toExtent as B,distanceToScale as U,scaleToZoom as k,fromExtent as z,OrientationMode as E,getObserverForPointAtDistance as V,scaleToDistance as A,zoomToScale as D}from"../support/cameraUtils.js";import{PropertiesPool as H}from"../support/PropertiesPool.js";import{fromCamera as N,toCamera as F}from"../support/viewpointUtils.js";import{Camera as G,PaddingSide as L}from"../webgl-engine/lib/Camera.js";const q=s.getLogger("esri.views.3d.state.ViewStateManager");let W=class extends r{constructor(e){super(e),this.propertiesPool=new H({frustum:b},this),this.handles=new a,this.cameraSetByUser=!1,this.gotoOperation=null,this.ready=!1,this._windowDevicePixelRatio=1,this._devicePixelRatioOverride=null,this._maximumPixelRatioOverride=null,this.test={contentCameraResetState:new Map,setDevicePixelRatio:e=>this._devicePixelRatioOverride=e,setMaximumPixelRatio:e=>this._maximumPixelRatioOverride=e}}get camera(){const e=this._get("camera");if(!this.ready)return e;const t=M(this.view,this.view.state.camera);return t&&e&&t.equals(e)?e:t}set camera(e){this._updatePropertyBeforeReady("camera",e)||(this.view.elevationProvider.enableElevationCache(!0),this.setStateCamera(I(this.view,e),{applyConstraints:!1})||q.error("#camera=","Invalid camera",e),this.view.elevationProvider.enableElevationCache(!1))}get contentCamera(){const e=this._get("contentCamera");if(!this.ready)return e;const t=M(this.view,this.view.state.contentCamera);return t&&e&&t.equals(e)?e:t}set contentCamera(e){if(this._updatePropertyBeforeReady("contentCamera",e))return;const t=I(this.view,e);o(t)?this.view.state.contentCamera=null:(this._updateElevation(t),this.view.state.contentCamera=t)}installContentCameraReset(e){if(this.handles.remove("contentCameraReset"),this.test.contentCameraResetState.clear(),!this.view.state.fixedContentCamera)return!1;const t=this.zoom,i=this.view.state.camera.distance**2,r=w(this.view.state.camera.center),a=e.sticky?this.contentCamera.clone():null;return this.handles.add([h((()=>this.contentCamera),(()=>{e.sticky||(this.handles.remove("contentCameraReset"),this.test.contentCameraResetState.clear())})),h((()=>this.zoom),(e=>{this.test.contentCameraResetState.set("view.zoom",Math.abs(e-t)/2),Math.abs(e-t)>2?this.contentCamera=null:this.view.state.fixedContentCamera||(this.contentCamera=a)})),h((()=>this.view.state.camera),(e=>{const t=u(r,e.center);this.test.contentCameraResetState.set("camera.center",t/i),t>i?this.contentCamera=null:this.view.state.fixedContentCamera||(this.contentCamera=a)}))],"contentCameraReset"),!0}get center(){return this.ready?this.view.pointsOfInterest.centerOnContent.location:this._get("center")}set center(e){this._updatePropertyBeforeReady("center",e)||(e?this.isCompatible(e)?this.setStateCamera(this._centerToCamera(e),{applyConstraints:!0})?this.view.pointsOfInterest.centerOnContent.runTask():q.error("#center=","Invalid center",e):q.error("#center=","Center has an incompatible spatial reference (center: "+(e.spatialReference?e.spatialReference.wkid:"none")+", view: "+this.view.spatialReference.wkid+")",e):q.error("#center=","Center may not be null or undefined"))}get extent(){if(!this.ready)return this._get("extent");const e=this.view,t=B(e,e.state.camera,e.pointsOfInterest.centerOnContent.renderLocation);return n(t)?t:this._get("extent")}set extent(e){this._updatePropertyBeforeReady("extent",e)||(e?this.isCompatible(e)?this.setStateCamera(this._extentToCamera(e),{applyConstraints:!0})||q.error("#extent=","Invalid extent",e):q.error("#extent=","Extent has an incompatible spatial reference (extent: "+(e.spatialReference?e.spatialReference.wkid:"none")+", view: "+this.view.spatialReference.wkid+")",e):q.error("#extent=","Extent may not be null or undefined"))}get frustum(){const e=this.propertiesPool.get("frustum");return e.renderCoordsHelper=this.view.renderCoordsHelper,e.update(this.view.state.camera),e}get hasInitialView(){return!!this.view.get("map.initialViewProperties.viewpoint")}get scale(){if(this.ready){const e=this.view.pointsOfInterest.centerOnContent;return U(this.view,e.distance,e.location.latitude)}return this._get("scale")}set scale(e){this._updatePropertyBeforeReady("scale",e)||this.setStateCamera(this._scaleToCamera(e),{applyConstraints:!0})||q.error("#scale=","Invalid scale",e)}get padding(){if(!this.ready)return this._get("padding");const e=this.view.state.camera,t=e.padding,i=e.pixelRatio,r=this._get("padding"),a=Math.round(t[L.TOP]/i),s=Math.round(t[L.RIGHT]/i),o=Math.round(t[L.BOTTOM]/i),n=Math.round(t[L.LEFT]/i);return null!=r&&r.top===a&&r.right===s&&r.bottom===o&&r.left===n?r:{top:a,right:s,bottom:o,left:n}}set padding(e){this._updatePropertyBeforeReady("padding",e)||(this._paddingToArray(e,this.view.state.camera.pixelRatio,$),this.view.state.updateCamera((e=>e.padding=$)))}_paddingToArray(e,t,i){e?y(i,e.top||0,e.right||0,e.bottom||0,e.left||0):y(i,0,0,0,0);for(let r=0;r<4;r++)i[r]=Math.round(i[r]*t)}get screenCenter(){const e=this.padding;return m((this.view.width-(e.left+e.right))/2+e.left,(this.view.height-(e.top+e.bottom))/2+e.top)}get viewpoint(){return this.ready?N(this.view,this.camera):this._get("viewpoint")}set viewpoint(e){if(!this._updatePropertyBeforeReady("viewpoint",e))if(e)if(this.isCompatible(e))this.setStateCamera(this._viewpointToCamera(e),{applyConstraints:!e.camera})||q.error("#viewpoint=","Invalid viewpoint",e);else{const t=n(e.camera)?e.camera.position:e.targetGeometry,i=n(t)&&t.spatialReference;q.error("#viewpoint=","Viewpoint has an incompatible spatial reference (viewpoint: "+(i?i.wkid:"none")+", view: "+this.view.spatialReference.wkid+")",e)}else q.error("#viewpoint=","Viewpoint may not be null or undefined")}get zoom(){return this.ready?k(this.view,this.scale):this._get("zoom")}set zoom(e){this._updatePropertyBeforeReady("zoom",e)||this.setStateCamera(this._zoomToCamera(e),{applyConstraints:!0})||q.error("#zoom=","Invalid zoom",e)}get maximumPixelRatio(){if(n(this._maximumPixelRatioOverride))return this._maximumPixelRatioOverride;let e=1/0;const{maximumPixelRatio:t,maximumRenderResolution:i}=this.view.qualitySettings;if(null!=t&&(e=Math.min(e,t)),null!=i){const t=i/Math.max(this.view.width,this.view.height);e=Math.min(e,t)}return e}get _devicePixelRatio(){return o(this._devicePixelRatioOverride)?Math.min(this._windowDevicePixelRatio,this.maximumPixelRatio):this._devicePixelRatioOverride}initialize(){this.handles.add([p((()=>this.view.state.events),"before-camera-change",(e=>this._updateElevation(e.camera)))]),h((()=>this.view.state.camera),(e=>this._updateElevation(e)),{once:!0,sync:!0}),this.handles.add(c({prepare:()=>this._prepareFrame()})),this.handles.add(h((()=>this.view.state.cameraController),(()=>{this.cameraSetByUser=!0,this.handles.remove(ee)}))),this.handles.add(p((()=>this.view.state.events),"camera-projection-changed",(()=>this.notifyChange("scale"))))}destroy(){this.deinit(),this.handles&&(this.handles.destroy(),this.handles=null),this.propertiesPool&&(this.propertiesPool.destroy(),this.propertiesPool=null)}init(){this.constraintsManager=new T({view:this.view}),this._prepareFrame();const e=this._getInitialProperties();this.cameraSetByUser=!1,this._set("ready",!0);for(const t of e)this.set(t.name,t.value);if(!this.cameraSetByUser){const e=this.view.get("map.initialViewProperties.viewpoint")||this.view.initialExtent;e&&this.isCompatible(e)?this._setInitialView(e):this.view.state.viewingMode===x.Local&&this.handles.add(l((()=>this.view.basemapTerrain.ready),(()=>{this.handles.remove(ee),this._setInitialView(this.view.dataExtent)}),{once:!0,initial:!0}),ee)}}deinit(){this._cancelGoToOperation(),this.ready&&(this._override("padding",this.padding),this._set("ready",!1),this._clearOverride("hasInitialView"),this.cameraSetByUser=!1,this.handles.remove(ee),this.constraintsManager&&(this.constraintsManager.destroy(),this.constraintsManager=null))}async goTo(e,t){const i={animate:!0,...t};return n(this.gotoOperation)&&this.gotoOperation.abort(i.animate),this.gotoOperation=new S(e,i,this.view),this.view.resourceController.scheduler.stopFrame(),this.gotoOperation}debugSetCameraOnContent(){this.setStateCamera(P(this.view),{applyConstraints:!1})}step(e){const t=this.view.state,i=t&&this.view.state.cameraController;i&&(t.updateCamera((t=>{i.stepController(e,t)})),i.steppingFinished&&i.finishController())}_cancelGoToOperation(){n(this.gotoOperation)&&(this.gotoOperation.abort(),this.gotoOperation=null)}_getInitialProperties(){const e=new Set,t=[];for(const{propertyName:i,overrides:r}of Q){const a=e.has(i),s=this._isOverridden(i);!a&&s&&t.push({name:i,value:this._get(i)}),this._clearOverride(i),(a||s)&&r.forEach((t=>e.add(t)))}return t}_setInitialView(e){if(o(e)||this.cameraSetByUser)return;if(e instanceof t)return void this.setStateCamera(I(this.view,e),{applyConstraints:!1});if(e instanceof i){if(e.targetGeometry instanceof f){const t=z(this.view,e.targetGeometry,0,.5,E.LOCKED);return void(n(t)&&this.setStateCamera(I(this.view,t),{applyConstraints:!0}))}const t={applyConstraints:!e.camera},i=this._viewpointToCamera(e);return void this.setStateCamera(i,t)}const r=z(this.view,e,0,.5,E.LOCKED);n(r)&&this.setStateCamera(I(this.view,r),{applyConstraints:!0})}_updatePropertyBeforeReady(e,t){return!this.ready&&(this._override(e,t),t&&K.includes(e)&&this._override("hasInitialView",!0),!0)}isCompatible(e){return!o(e)&&(e instanceof i?e.camera?this.isCompatible(e.camera):this.isCompatible(e.targetGeometry):e instanceof t?this.isCompatible(e.position):e.spatialReference&&_(e.spatialReference,this.view.spatialReference))}_getPreservingHeadingTilt(e=X){return this.cameraSetByUser?(e.heading=this.camera.heading,e.tilt=this.camera.tilt):(e.heading=0,e.tilt=.5),e}_centerPointAtDistanceToCamera(e,t,i=Z){const{heading:r,tilt:a}=this._getPreservingHeadingTilt(),s=V(this.view,r,a,e,t,E.ADJUST);return o(s)?null:(i.copyFrom(this.view.state.camera),i.eye=s.eye,i.center=s.center,i.up=s.up,i)}_centerToCamera(e){const t=this.view.pointsOfInterest.centerOnContent;t.runTask();const i=t.distance;return this._centerPointAtDistanceToCamera(e,i)}_extentToCamera(e){const{heading:t,tilt:i}=this._getPreservingHeadingTilt(),r=z(this.view,e,t,i,E.ADJUST,Y);return n(r)?I(this.view,r):null}_scaleToCamera(e){if(null==e)return null;const t=this.view.pointsOfInterest.centerOnContent;t.runTask();const i=t.renderLocation,r=t.location.latitude,a=A(this.view,e,r);return this._centerPointAtDistanceToCamera(i,a)}_zoomToCamera(e){return this._scaleToCamera(D(this.view,e))}_viewpointToCamera(e){return I(this.view,F(this.view,e))}setStateCamera(e,t){return!(o(e)||!this.view.state.stopActiveCameraController())&&(this.cameraSetByUser=!0,t.doNotCancelGoToOperation||this._cancelGoToOperation(),this.view.state.updateCamera((i=>{t.positionAndOrientationOnly?(i.eye=e.eye,i.center=e.center,i.up=e.up):i.copyFrom(e),t.applyConstraints&&R(this.view,i)})),t.applyConstraints||(this.view.state.cameraController=new j({view:this.view,desiredCamera:e})),!0)}_prepareFrame(){const{surface:e,canvas:t}=this.view;if(!e||!t)return;this._windowDevicePixelRatio=window.devicePixelRatio;const i=this._devicePixelRatio,r=Math.round(e.clientWidth*i),a=Math.round(e.clientHeight*i);if(0!==r&&0!==a&&(t.width===r&&t.height===a||(t.width=r,t.height=a),this.view.state)){const e=this.view.state.camera;e.fullWidth===r&&e.fullHeight===a&&e.pixelRatio===i||(Z.copyFrom(e),Z.pixelRatio!==i&&(this._paddingToArray(this.padding,i,$),Z.padding=$),Z.fullWidth=r,Z.fullHeight=a,Z.pixelRatio=i,this.view.state.camera=Z)}}_updateElevation(e){const t=this.view.basemapTerrain&&this.view.basemapTerrain.spatialReference,i=this.view.renderCoordsHelper.getAltitude(e.eye),r=t?O(this.view,e.eye):0;e.relativeElevation=i-r}};e([d({type:t,dependsOn:["view.state.camera","ready"]})],W.prototype,"camera",null),e([d({type:t,dependsOn:["view.state.contentCamera","ready"]})],W.prototype,"contentCamera",null),e([d({type:g})],W.prototype,"center",null),e([d({type:f})],W.prototype,"extent",null),e([d({readOnly:!0})],W.prototype,"frustum",null),e([d({readOnly:!0})],W.prototype,"hasInitialView",null),e([d({readOnly:!0,type:Boolean})],W.prototype,"ready",void 0),e([d({type:Number})],W.prototype,"scale",null),e([d()],W.prototype,"padding",null),e([d({readOnly:!0})],W.prototype,"screenCenter",null),e([d({constructOnly:!0})],W.prototype,"view",void 0),e([d({type:i})],W.prototype,"viewpoint",null),e([d({type:Number})],W.prototype,"zoom",null),e([d()],W.prototype,"maximumPixelRatio",null),e([d()],W.prototype,"_devicePixelRatio",null),e([d()],W.prototype,"_windowDevicePixelRatio",void 0),e([d()],W.prototype,"_devicePixelRatioOverride",void 0),e([d()],W.prototype,"_maximumPixelRatioOverride",void 0),W=e([v("esri.views.3d.state.ViewStateManager")],W);const J=W,K=["camera","viewpoint","extent","scale","center","zoom"],Q=[{propertyName:"camera",overrides:["viewpoint"]},{propertyName:"viewpoint",overrides:["extent"]},{propertyName:"extent",overrides:["center","scale"]},{propertyName:"center",overrides:[]},{propertyName:"scale",overrides:["zoom"]},{propertyName:"zoom",overrides:[]},{propertyName:"padding",overrides:[]}],X={heading:0,tilt:0},Y=new t,Z=new G,$=C(),ee="pending-initial-view";export{J as default};
