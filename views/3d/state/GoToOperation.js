/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../core/maybe","../../../core/Error","../../../core/promiseUtils","../../../Camera","../../../Viewpoint","../../../core/watchUtils","../camera/constraintUtils/surfaceCollision","../../animation/easing","../camera/constraintUtils","./controllers/CameraController","./controllers/PointToPointAnimationController","../support/cameraUtils","./controllers/SurfaceCollisionCorrectionController","../support/viewpointUtils"],(function(t,e,i,a,n,o,r,s,l,c,h,w,m,v,p){"use strict";let u=function(){function t(t,i,n){this.target=t,this.options=i,this.view=n,this.state="pending",this.abortController=null,this.animationController=null,this.promise=a.create(((t,i)=>{this.resolveCallback=t,this.rejectCallback=i;const n=a.createAbortController();e.isSome(this.options.signal)&&a.onAbort(this.options.signal,(()=>{this.abort()})),this.abortController=n,this.waitForReady()}))}var u=t.prototype;return u.then=function(t,e){return this.promise.then(t,e)},u.catch=function(t){return this.promise.catch(t)},u.resolve=function(t){return this.state="finished",this.resolveCallback(t)},u.reject=function(t){return this.state="finished",this.rejectCallback(t)},u.goTo=function(e,a){switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":a.animate&&this.options.animate?this.reject(new i("AbortError")):this.abort()}return new t(e,a,this.view)},u.waitForReady=function(){this.state="wait-for-ready",this.view.stateManager.view.ready?this.createViewPoint():r.whenOnce(this.view.stateManager.view,"ready",this.abortController.signal).then((()=>{this.createViewPoint()}),(t=>{this.reject(t)}))},u.createViewPoint=function(){"finished"!==this.state&&(this.state="wait-for-viewpoint",this.animationController=this.options.animate?this.getAnimationController():null,p.create(this.view.stateManager.view,this.target,this.abortController.signal).then((t=>{if("finished"===this.state)return;const i=this.getCameraFromViewpoint(t);if(!e.isNone(i))if(this.options.animate){if(e.isNone(this.animationController))return;this.startAnimation(i,this.animationController)}else this.view.stateManager.setStateCamera(i.camera,{applyConstraints:!i.isFullySpecified,positionAndOrientationOnly:!0,doNotCancelGoToOperation:!0}),this.resolve()}),(t=>{this.reject(t)})))},u.internalAnimateOptions=function(t){const e={};return t&&(null!=t.speedFactor&&(e.speedFactor=t.speedFactor),null!=t.duration&&(e.duration=t.duration/1e3),null!=t.maxDuration&&(e.maxDuration=t.maxDuration/1e3),null!=t.easing&&("string"==typeof t.easing?e.easing=l.named[t.easing]:e.easing=t.easing)),e},u.getCameraFromViewpoint=function(t){const a=!!(this.target instanceof o&&this.target.camera||this.target instanceof n),r=t.camera;if(e.isNone(r))return null;if(!this.view.stateManager.isCompatible(r)){const t=r.position,e=t&&t.spatialReference,a=e?e.wkid:"none",n=this.view.stateManager.view.spatialReference.wkid;return this.reject(new i("GotoAnimation:incompatible-spatialreference",`Resulting camera has an incompatible spatial reference (camera: ${a}, view: ${n})`,{camera:r})),null}const s=m.externalToInternal(this.view.stateManager.view,r);return s?{viewpoint:t,camera:s,isFullySpecified:a}:(this.reject(new i("GotoAnimation:invalid-camera","Resulting camera is invalid")),null)},u.startAnimation=function(t,a){this.state="wait-for-animation-finish";const n=a.viewAnimation;if(e.isNone(n))return void this.reject(new i("GotoAnimation:missing-animation","Unreachable code in view.stateManager"));if(n.update(t.viewpoint,"running"),!a.active||e.isNone(a.viewAnimation)||a.viewAnimation.target!==t.viewpoint||this.view.stateManager.view.state.cameraController!==a)return this.abort();let o;t.isFullySpecified?(o=new v.SurfaceCollisionCorrectionController({view:this.view.stateManager.view,desiredCamera:t.camera}),s.applySurfaceCollisionConstraint(this.view.stateManager.view,t.camera,1)):c.applyAll(this.view.stateManager.view,t.camera),a.begin(t.camera,this.internalAnimateOptions(this.options));const r=t=>{if(!e.isNone(this.view.stateManager.view.state))switch(a.state){case h.State.Finished:switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":this.resolve()}break;case h.State.Ready:case h.State.Rejected:case h.State.Running:case h.State.Stopped:switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":this.reject(t)}}};n.when((()=>{const i=this.view.stateManager.view.state.cameraController;o&&(i&&i.active?i instanceof w.PointToPointAnimationController&&e.isSome(i.viewAnimation)&&i.viewAnimation.target===t.viewpoint&&(this.view.stateManager.view.state.cameraController=o):e.isSome(a.viewAnimation)&&a.viewAnimation.target===t.viewpoint&&"finished"===a.state&&(this.view.stateManager.view.state.cameraController=o))}),(t=>r(t))),a.asyncResult={resolve:()=>r(),reject:t=>r(t)}},u.getAnimationController=function(){let t,a=null;const n=this.view.stateManager.view.state.cameraController;return n instanceof w.PointToPointAnimationController&&(n.updateStateFromViewAnimation(),n.active&&(t=n,a=t.viewAnimation)),null!=t||(t=new w.PointToPointAnimationController({view:this.view.stateManager.view,mode:"animation"}),a=t.viewAnimation,this.view.stateManager.view.state.switchCameraController(t))?t:(e.isSome(a)&&a.stop(),this.reject(new i("GotoAnimation:goto-cannot-interrupt","Cannot start an animation while interacting")),null)},u.abort=function(){switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":this.reject(a.createAbortError());break;case"wait-for-animation-finish":e.isSome(this.animationController)&&this.view.stateManager.view.state.cameraController===this.animationController&&this.animationController.active&&this.animationController.stopController(),this.reject(a.createAbortError())}},t}();t.GoToOperation=u,Object.defineProperty(t,"__esModule",{value:!0})}));
