/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import i from"../../../core/Accessor.js";import a from"../../../core/Handles.js";import{deg2rad as e,rad2deg as s}from"../../../core/mathUtils.js";import{destroyMaybe as r,isNone as n}from"../../../core/maybe.js";import{watch as o,sync as c,initial as l}from"../../../core/reactiveUtils.js";import{property as h}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as u}from"../../../core/accessorSupport/decorators/subclass.js";import{ViewingMode as p}from"../../ViewingMode.js";import{applyAll as d}from"../camera/constraintUtils.js";import{surfaceElevationBelowRenderLocation as m}from"../camera/intersectionUtils.js";import{ConstraintTypes as v,InteractionType as w,TiltMode as _}from"../camera/constraintUtils/common.js";import{createNearFarHeuristic as C}from"./NearFarHeuristic.js";import{SurfaceCollisionConstraint as f}from"./SurfaceCollisionConstraint.js";let M=class extends i{constructor(t){super(t),this._handles=new a,this.nearFarHeuristic=C(t.view.state.viewingMode,t.view.basemapTerrain,t.view.renderCoordsHelper.spatialReference)}initialize(){this._handles.add([o((()=>[this.view.constraints?.clipDistance?.near,this.view.constraints?.clipDistance?.far]),(()=>this._clipDistanceNearFarChanged())),o((()=>this.view.constraints?.clipDistance?.mode),(()=>this._updateNearFar())),this.view.state.events.on("before-camera-change",(t=>this._updateCameraNearFar(t.camera))),o((()=>this.view.renderDataExtent),(()=>this._updateNearFar()),c),o((()=>[this.view.constraints?.altitude?.min,this.view.constraints?.altitude?.max]),(()=>this._updateAltitude()),c),o((()=>this.view.constraints?.tilt?.max),(()=>this._updateTiltMax()),c),o((()=>this.view.constraints?.tilt?.mode),(()=>this._updateTilt()),c),o((()=>this.view.state?.camera),(()=>this._updateTiltAutoMax()),c),o((()=>[this.view.map?.ground?.navigationConstraint?.type,this.view.state?.constraints?.collision?.enabled]),(()=>this._updateCollision()),c)]),this.view.state.isLocal&&this._handles.add(o((()=>this.view.renderDataExtent),(t=>this._updateLocalSurfaceDistance(t)),l)),this._updateNearFar(),this.view.state.viewingMode!==p.Local&&this._updateAltitude(),this._updateTilt(),this._updateCollision(),this._set("surfaceCollisionConstraint",new f({view:this.view}))}destroy(){this._handles=r(this._handles),this.surfaceCollisionConstraint&&(this.surfaceCollisionConstraint.destroy(),this._set("surfaceCollisionConstraint",null))}_clipDistanceNearFarChanged(){const t=this.view.constraints?.clipDistance;t&&"auto"!==t.mode&&this.view.state.updateCamera((i=>(this._updateCameraNearFarManual(i,t),!0)))}_updateNearFar(){this.view.state.updateCamera((t=>(this._updateCameraNearFar(t),!0)))}_updateCameraNearFar(t){const i=this.view.constraints&&this.view.constraints.clipDistance;"manual"===(i?i.mode:"auto")?this._updateCameraNearFarManual(t,i):this._updateCameraNearFarAuto(t,i)}_updateCameraNearFarAuto(t,i){this.nearFarHeuristic.compute(t.eye,t.center,this.view.renderDataExtent,m(this.view,t.eye),t),i&&i.autoUpdate(t.near,t.far)}_updateCameraNearFarManual(t,i){i&&(t.near=i.near,t.far=i.far)}_updateCollision(){const t=this.view.map?.ground?.navigationConstraint?.type,i=!t||"stay-above"===t,a=this.view.state.constraints.collision;if(i!==a.enabled){a.enabled=i,i&&this._reapplyConstraints(v.COLLISION);const t=this.view.constraints&&this.view.constraints.tilt;t&&"auto"!==t.mode||this._updateTiltAuto()}}_updateAltitude(){const t=this.view.constraints&&this.view.constraints.altitude;t&&this.view.state.viewingMode!==p.Local?this.view.state.constraints.altitude={min:t.min,max:t.max}:this.view.state.constraints.altitude=null,this._reapplyConstraints()}_updateTiltMax(){const t=this.view.constraints&&this.view.constraints.tilt;t&&"auto"!==t.mode&&(this._updateTiltManual(t),this._reapplyConstraints())}_updateTilt(){const t=this.view.constraints&&this.view.constraints.tilt;"manual"===(t?t.mode:"auto")?this._updateTiltManual(t):this._updateTiltAuto(),this._reapplyConstraints()}_updateTiltManual(t){const i=this.view.state.constraints;i.tilt=i.createConstantMaxTilt(e(t.max))}_updateTiltAuto(){const t=this.view.state.constraints;t.tilt=t.createDefaultTilt(),this._updateTiltAutoMax()}_updateTiltAutoMax(){const t=this.view.constraints&&this.view.constraints.tilt;if(!t||"auto"!==t.mode)return;const i=this.view.state.constraints;if(i.tilt){const a=i.tilt(this.view.state.camera.distance).max;t.autoUpdate(s(a))}}_updateLocalSurfaceDistance(t){if(n(t))return;let i=Math.max(t.width,t.height);if(i<=0)return;t.hasZ&&(i=Math.max(i,t.zmax-t.zmin));const a=this.view.state,e=3*i/Math.atan(a.camera.fov/2);e!==a.constraints.distance&&(a.constraints.distance=e)}_reapplyConstraints(t=v.ALL){this.view.state.updateCamera((i=>d(this.view,i,{selection:t,interactionType:w.NONE,interactionFactor:null,interactionStartCamera:null,interactionDirection:null,tiltMode:_.TUMBLE})))}};t([h({constructOnly:!0})],M.prototype,"view",void 0),t([h({readOnly:!0})],M.prototype,"surfaceCollisionConstraint",void 0),M=t([u("esri.views.3d.state.ConstraintsManager")],M);export{M as ConstraintsManager};
