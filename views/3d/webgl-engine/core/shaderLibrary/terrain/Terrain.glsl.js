// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.17/esri/copyright.txt for details.

define(["require","exports","tslib","../Slice.glsl","../Transform.glsl","../attributes/VertexTangent.glsl","../output/OutputDepth.glsl","../output/OutputHighlight.glsl","../shading/EvaluateSceneLighting.glsl","../shading/NormalUtils.glsl","./Overlay.glsl","./Skirts.glsl","./TerrainTexture.glsl","../util/HeaderComment.glsl","../../shaderModules/interfaces","../../shaderModules/ShaderBuilder"],(function(e,o,n,a,r,l,i,t,v,s,c,m,d,g,p,u){"use strict";var f,C,h,w,y,b,x,_,S,z,O,T,F,k,P,L,D,j,N,M,W,U,H,V;Object.defineProperty(o,"__esModule",{value:!0}),o.build=void 0,o.build=function(e){var o=new u.ShaderBuilder;if(o.include(g.HeaderComment,{name:"Terrain Shader",output:e.output}),o.include(m.Skirts),o.attributes.add("position","vec3"),o.attributes.add("uv0","vec2"),o.vertex.uniforms.add("proj","mat4").add("view","mat4").add("origin","vec3").add("skirtScale","float"),0===e.output){o.include(r.Transform,{linearDepth:!1}),o.include(s.NormalUtils,e),o.include(d.TerrainTexture,e);var B=0!==e.overlayMode,A=2===e.overlayMode;B&&o.include(c.Overlay,{pbrMode:3,useCustomDTRExponentForWater:!1,ssrEnabled:e.ssrEnabled,highStepCount:e.highStepCount}),A&&o.include(l.VertexTangent,e),o.varyings.add("vnormal","vec3"),o.varyings.add("vpos","vec3"),o.vertex.uniforms.add("viewNormal","mat4"),e.receiveShadows&&o.varyings.add("linearDepth","float"),e.tileBorders&&o.varyings.add("vuv","vec2"),e.atmosphere&&(o.vertex.uniforms.add("lightingMainDirection","vec3"),o.varyings.add("wnormal","vec3"),o.varyings.add("wlight","vec3")),e.screenSizePerspective&&(o.vertex.uniforms.add("screenSizePerspective","vec4"),o.varyings.add("screenSizeDistanceToCamera","float"),o.varyings.add("screenSizeCosAngle","float")),o.vertex.code.add(p.glsl(_||(_=n.__makeTemplateObject(["\n      void main(void) {\n        vpos = position;\n        vnormal = getLocalUp(vpos, origin);\n\n        vec2 uv = uv0;\n        vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n        ","\n        ","\n        ","\n        gl_Position = transformPosition(proj, view, vpos);\n        ","\n        forwardTextureCoordinates(uv);\n        ","\n        ","\n      }\n    "],["\n      void main(void) {\n        vpos = position;\n        vnormal = getLocalUp(vpos, origin);\n\n        vec2 uv = uv0;\n        vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n        ","\n        ","\n        ","\n        gl_Position = transformPosition(proj, view, vpos);\n        ","\n        forwardTextureCoordinates(uv);\n        ","\n        ","\n      }\n    "])),e.atmosphere?p.glsl(f||(f=n.__makeTemplateObject(["\n        wnormal = (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight = (view  * vec4(-lightingMainDirection, 1.0)).xyz;"],["\n        wnormal = (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight = (view  * vec4(-lightingMainDirection, 1.0)).xyz;"]))):"",e.tileBorders?p.glsl(C||(C=n.__makeTemplateObject(["vuv = uv;"],["vuv = uv;"]))):"",e.screenSizePerspective?p.glsl(h||(h=n.__makeTemplateObject(["\n        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera = length(viewPos);\n        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle = abs(viewSpaceNormal.z);"],["\n        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera = length(viewPos);\n        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle = abs(viewSpaceNormal.z);"]))):"",e.receiveShadows?p.glsl(w||(w=n.__makeTemplateObject(["linearDepth = gl_Position.w;"],["linearDepth = gl_Position.w;"]))):"",B?p.glsl(y||(y=n.__makeTemplateObject(["setOverlayVTC(uv);"],["setOverlayVTC(uv);"]))):"",A?p.glsl(b||(b=n.__makeTemplateObject(["forwardVertexTangent(vnormal);"],["forwardVertexTangent(vnormal);"]))):p.glsl(x||(x=n.__makeTemplateObject([""],[""]))))),o.extensions.add("GL_OES_standard_derivatives"),o.extensions.add("GL_EXT_shader_texture_lod"),o.include(a.Slice,e),o.include(v.EvaluateSceneLighting,e),o.fragment.uniforms.add("camPos","vec3").add("viewDirection","vec3").add("ssaoTex","sampler2D").add("viewportPixelSz","vec4").add("opacity","float"),e.screenSizePerspective&&o.fragment.uniforms.add("screenSizePerspective","vec4"),A&&(o.fragment.uniforms.add("ovInnerWaterTex","sampler2D"),o.fragment.uniforms.add("ovOuterWaterTex","sampler2D"),o.fragment.uniforms.add("view","mat4")),o.fragment.code.add(p.glsl(S||(S=n.__makeTemplateObject(["\n      const vec3 ambient = vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse = vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness = 2.5;\n      const float sliceOpacity = 0.2;\n\n      float lum(vec3 c) {\n        float max = max(max(c.r, c.g), c.b);\n        float min = min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "],["\n      const vec3 ambient = vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse = vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness = 2.5;\n      const float sliceOpacity = 0.2;\n\n      float lum(vec3 c) {\n        float max = max(max(c.r, c.g), c.b);\n        float min = min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "])))),e.atmosphere&&o.fragment.code.add(p.glsl(z||(z=n.__makeTemplateObject(["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   = vec3(0.0);\n        vec3 fuzzySpecColor = vec3(1.0);\n        vec3 subColor       = vec3(0.0);\n        float rollOff       = 1.0;\n\n        vec3 Ln = normalize(lightPos);\n        vec3 Nn = normalize(normal);\n        vec3 Hn = normalize(view + Ln);\n\n        float ldn = dot(Ln, Nn);\n        float diffComp = max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv = dot(view, Ln);\n\n        vec3 diffContrib = surfaceColor * diffComp;\n        float subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib = subLamb * subColor;\n        vec3 vecColor = vec3(vdn);\n\n        vec3 diffuseContrib = (subContrib + diffContrib);\n        vec3 specularContrib = (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "],["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   = vec3(0.0);\n        vec3 fuzzySpecColor = vec3(1.0);\n        vec3 subColor       = vec3(0.0);\n        float rollOff       = 1.0;\n\n        vec3 Ln = normalize(lightPos);\n        vec3 Nn = normalize(normal);\n        vec3 Hn = normalize(view + Ln);\n\n        float ldn = dot(Ln, Nn);\n        float diffComp = max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv = dot(view, Ln);\n\n        vec3 diffContrib = surfaceColor * diffComp;\n        float subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib = subLamb * subColor;\n        vec3 vecColor = vec3(vdn);\n\n        vec3 diffuseContrib = (subContrib + diffContrib);\n        vec3 specularContrib = (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "])))),o.fragment.code.add(p.glsl(j||(j=n.__makeTemplateObject(["\n      void main() {\n        ","\n        float vndl = dot(normalize(vnormal), -lightingMainDirection);\n        float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        vec4 tileColor = getTileColor() * opacity;\n        ","\n        if (rejectBySlice(vpos)) {\n          tileColor *= sliceOpacity;\n        }\n        vec3 atm = vec3(0.0);\n        ","\n        vec3 albedo = atm + tileColor.rgb;\n        vec3 normal = normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor = vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n      void main() {\n        ","\n        float vndl = dot(normalize(vnormal), -lightingMainDirection);\n        float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        vec4 tileColor = getTileColor() * opacity;\n        ","\n        if (rejectBySlice(vpos)) {\n          tileColor *= sliceOpacity;\n        }\n        vec3 atm = vec3(0.0);\n        ","\n        vec3 albedo = atm + tileColor.rgb;\n        vec3 normal = normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor = vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "])),e.receiveShadows?p.glsl(O||(O=n.__makeTemplateObject(["float shadow = readShadowMap(vpos, linearDepth);"],["float shadow = readShadowMap(vpos, linearDepth);"]))):p.glsl(T||(T=n.__makeTemplateObject(["float shadow = 0.0;"],["float shadow = 0.0;"]))),B?p.glsl(F||(F=n.__makeTemplateObject(["\n            vec4 overlayColorOpaque = getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n            vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n            vec4 groundColor = tileColor;\n            tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;"],["\n            vec4 overlayColorOpaque = getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n            vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n            vec4 groundColor = tileColor;\n            tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;"]))):"",e.atmosphere?p.glsl(k||(k=n.__makeTemplateObject(["\n            float ndotl = max(0.0, min(1.0, vndl));\n            atm = atmosphere(wlight, wnormal, -viewDirection);\n            atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n            atm *= max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n            atm *= tileColor.a; // premultiply with tile alpha"],["\n            float ndotl = max(0.0, min(1.0, vndl));\n            atm = atmosphere(wlight, wnormal, -viewDirection);\n            atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n            atm *= max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n            atm *= tileColor.a; // premultiply with tile alpha"]))):"",A?p.glsl(P||(P=n.__makeTemplateObject(["\n            vec4 overlayWaterMask = getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n            float waterNormalLength = length(overlayWaterMask);\n            if (waterNormalLength > 0.95) {\n              mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n              vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);\n              vec4 viewPosition = view*vec4(vpos, 1.0);\n              vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - camPos), shadow, vnormal, tbnMatrix, viewPosition.xyz);\n              vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n              // un-gamma the ground color to mix in linear space\n              gl_FragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w);\n            }"],["\n            vec4 overlayWaterMask = getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n            float waterNormalLength = length(overlayWaterMask);\n            if (waterNormalLength > 0.95) {\n              mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n              vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);\n              vec4 viewPosition = view*vec4(vpos, 1.0);\n              vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - camPos), shadow, vnormal, tbnMatrix, viewPosition.xyz);\n              vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n              // un-gamma the ground color to mix in linear space\n              gl_FragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w);\n            }"]))):"",e.screenSizePerspective?p.glsl(L||(L=n.__makeTemplateObject(["\n          float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n          if (perspectiveScale <= 0.25) {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n          }\n          else if (perspectiveScale <= 0.5) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n          }\n          else if (perspectiveScale >= 0.99) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n          }\n          else {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n          }"],["\n          float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n          if (perspectiveScale <= 0.25) {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n          }\n          else if (perspectiveScale <= 0.5) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n          }\n          else if (perspectiveScale >= 0.99) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n          }\n          else {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n          }"]))):"",e.tileBorders?p.glsl(D||(D=n.__makeTemplateObject(["\n            vec2 dVuv = fwidth(vuv);\n            vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n            float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);"],["\n            vec2 dVuv = fwidth(vuv);\n            vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n            float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);"]))):""))}return 1!==e.output&&3!==e.output||(o.include(r.Transform,{linearDepth:!0}),o.include(i.OutputDepth,{output:e.output}),o.include(s.NormalUtils,e),o.varyings.add("linearDepth","float"),o.vertex.uniforms.add("nearFar","vec2"),o.vertex.code.add(p.glsl(N||(N=n.__makeTemplateObject(["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "],["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "])))),o.fragment.code.add(p.glsl(M||(M=n.__makeTemplateObject(["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "],["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "]))))),2===e.output&&(o.include(r.Transform,{linearDepth:!1}),o.include(s.NormalUtils,e),o.varyings.add("vnormal","vec3"),o.varyings.add("vpos","vec3"),o.vertex.uniforms.add("viewNormal","mat4"),o.vertex.code.add(p.glsl(W||(W=n.__makeTemplateObject(["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vpos = applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position = transformPosition(proj, view, vpos);\n          vnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "],["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vpos = applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position = transformPosition(proj, view, vpos);\n          vnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "])))),o.fragment.code.add(p.glsl(U||(U=n.__makeTemplateObject(["\n        void main() {\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) {\n            normal = -normal;\n          }\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n        }\n    "],["\n        void main() {\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) {\n            normal = -normal;\n          }\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n        }\n    "]))))),4===e.output&&(o.include(r.Transform,{linearDepth:!1}),o.include(s.NormalUtils,e),o.include(c.Overlay,{pbrMode:0}),o.vertex.code.add(p.glsl(H||(H=n.__makeTemplateObject(["\n          void main() {\n            vec3 vnormal = getLocalUp(position, origin);\n            vec2 uv = uv0;\n            vec3 vpos = applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position = transformPosition(proj, view, vpos);\n          }\n      "],["\n          void main() {\n            vec3 vnormal = getLocalUp(position, origin);\n            vec2 uv = uv0;\n            vec3 vpos = applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position = transformPosition(proj, view, vpos);\n          }\n      "])))),o.include(t.OutputHighlight),o.fragment.code.add(p.glsl(V||(V=n.__makeTemplateObject(["\n        void main() {\n          vec4 overlayColor = getCombinedOverlayColor();\n\n          if (overlayColor.a == 0.0) {\n            gl_FragColor = vec4(0.0);\n            return;\n          }\n\n          outputHighlight();\n        }\n      "],["\n        void main() {\n          vec4 overlayColor = getCombinedOverlayColor();\n\n          if (overlayColor.a == 0.0) {\n            gl_FragColor = vec4(0.0);\n            return;\n          }\n\n          outputHighlight();\n        }\n      "]))))),o}}));