/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{isSome as t,unwrapOr as s}from"../../../../core/maybe.js";import{f as i}from"../../../../chunks/mat3.js";import{c as r}from"../../../../chunks/mat3f64.js";import{a as n}from"../../../../chunks/mat4.js";import{c as a}from"../../../../chunks/mat4f64.js";import{c as o}from"../../../../chunks/vec2.js";import{a as c,f as l}from"../../../../chunks/vec2f64.js";import{s as f,m as h,n as u,b as p,g as m,c as d,l as g,i as O,t as S,e as v,a as A}from"../../../../chunks/vec3.js";import{c as P,f as b}from"../../../../chunks/vec3f64.js";import{c as x}from"../../../../chunks/vec4f64.js";import{isMat4 as C}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import{create as y}from"../../../../geometry/support/aaBoundingRect.js";import{newLayout as I}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as z}from"../core/shaderLibrary/ShaderOutputOptions.js";import{HUDSpace as T}from"../core/shaderLibrary/hud/HUD.glsl.js";import{computeAttachmentOriginPoints as _}from"../lib/geometryDataUtils.js";import{GLTextureMaterial as M,GLTextureMaterialBindParameters as j}from"../lib/GLTextureMaterial.js";import{Material as U,RenderOccludedFlag as q}from"../lib/Material.js";import{RenderSlot as w}from"../lib/RenderSlot.js";import{applyScaleFactor as D,applyPrecomputedScaleFactor as L,precomputeScaleFactor as E}from"../lib/screenSizePerspectiveUtils.js";import{assert as R}from"../lib/Util.js";import{VertexAttribute as V}from"../lib/VertexAttribute.js";import{writePosition as N,writeNormal as G,writeColor as H,writeBufferVec4 as B}from"./internal/bufferWriterUtils.js";import{verticalOffsetAtDistance as X}from"./internal/MaterialUtil.js";import{isInstanceHidden as k}from"./renderers/utils.js";import{c as F}from"../../../../chunks/HUDMaterial.glsl.js";import{HUDMaterialTechnique as W}from"../shaders/HUDMaterialTechnique.js";import{HUDMaterialTechniqueConfiguration as Z}from"../shaders/HUDMaterialTechniqueConfiguration.js";class J extends U{constructor(e){super(e,new Se),this.techniqueConfig=new Z}getConfiguration(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.hasSlicePlane=this.parameters.hasSlicePlane,this.techniqueConfig.hasVerticalOffset=!!this.parameters.verticalOffset,this.techniqueConfig.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?T.Screen:T.World,this.techniqueConfig.hasPolygonOffset=this.parameters.polygonOffset,this.techniqueConfig.isDraped=this.parameters.isDraped,this.techniqueConfig.occlusionTestEnabled=this.parameters.occlusionTest,this.techniqueConfig.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this.techniqueConfig.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this.techniqueConfig.vvSize=!!this.parameters.vvSizeEnabled,this.techniqueConfig.vvColor=!!this.parameters.vvColorEnabled,e===z.Color&&(this.techniqueConfig.debugDrawLabelBorder=!!this.parameters.debugDrawLabelBorder),e===z.Highlight&&(this.techniqueConfig.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this.techniqueConfig.depthEnabled=this.parameters.depthEnabled,this.techniqueConfig.transparencyPassType=t.transparencyPassType,this.techniqueConfig.hasMultipassGeometry=t.multipassGeometry.enabled,this.techniqueConfig.hasMultipassTerrain=t.multipassTerrain.enabled,this.techniqueConfig.cullAboveGround=t.multipassTerrain.cullAboveGround,this.techniqueConfig}intersect(e,s,i,r,n,a,o,c,l){t(l)?this._intersectDrapedHudGeometry(e,a,o,c,l):this._intersectHudGeometry(e,s,i,r,o,c)}_intersectDrapedHudGeometry(e,s,i,r,n){const a=e.vertexAttributes.get(V.POSITION),o=e.vertexAttributes.get(V.SIZE),c=this.parameters,l=F(c);let f=1,h=1;if(t(r)){const e=r(pe);f=e[0],h=e[5]}f*=e.screenToWorldRatio,h*=e.screenToWorldRatio;const u=de*e.screenToWorldRatio;for(let t=0;t<a.data.length/a.size;t++){const r=t*a.size,p=a.data[r],m=a.data[r+1],d=t*o.size;let g;ge[0]=o.data[d]*f,ge[1]=o.data[d+1]*h,c.textureIsSignedDistanceField&&(g=c.outlineSize*e.screenToWorldRatio/2),ee(s,p,m,ge,u,g,c,l)&&i(n.dist,n.normal,-1,!1)}}_intersectHudGeometry(e,s,r,a,o,c){if(!a.options.selectionMode||!a.options.hud||k(s))return;const l=this.parameters;let S=1,v=1;if(i(ce,r),t(c)){const e=c(pe);S=e[0],v=e[5],$(ce)}const A=e.vertexAttributes.get(V.POSITION),b=e.vertexAttributes.get(V.SIZE),x=e.vertexAttributes.get(V.NORMAL),C=e.vertexAttributes.get(V.AUXPOS1);R(A.size>=3);const y=a.point,I=a.camera,z=F(l);S*=I.pixelRatio,v*=I.pixelRatio;const T="screen"===this.parameters.centerOffsetUnits;for(let t=0;t<A.data.length/A.size;t++){const e=t*A.size;f(ie,A.data[e],A.data[e+1],A.data[e+2]),h(ie,ie,r);const s=t*b.size;ge[0]=b.data[s]*S,ge[1]=b.data[s+1]*v,h(ie,ie,I.viewMatrix);const i=t*C.size;if(f(he,C.data[i+0],C.data[i+1],C.data[i+2]),!T&&(ie[0]+=he[0],ie[1]+=he[1],0!==he[2])){const e=he[2];u(he,ie),p(ie,ie,m(he,he,e))}const c=t*x.size;if(f(re,x.data[c],x.data[c+1],x.data[c+2]),this._normalAndViewAngle(re,ce,I,ue),this._applyVerticalOffsetTransformationView(ie,ue,I,te),I.applyProjection(ie,ne),ne[0]>-1){ne[0]=Math.floor(ne[0]),ne[1]=Math.floor(ne[1]),T&&(he[0]||he[1])&&(ne[0]+=he[0],0!==he[1]&&(ne[1]+=D(he[1],te.factorAlignment)),I.unapplyProjection(ne,ie)),ne[0]+=this.parameters.screenOffset[0],ne[1]+=this.parameters.screenOffset[1],L(ge,te.factor,ge);const e=me*I.pixelRatio;let t;if(l.textureIsSignedDistanceField&&(t=l.outlineSize*I.pixelRatio/2),ee(y,ne[0],ne[1],ge,e,t,l,z)){const e=a.ray;if(h(oe,ie,n(fe,I.viewMatrix)),ne[0]=y[0],ne[1]=y[1],I.unprojectFromRenderScreen(ne,ie)){const t=P();d(t,e.direction);const s=1/g(t);m(t,t,s);o(O(e.origin,ie)*s,t,-1,!0,1,oe)}}}}}computeAttachmentOrigin(e,t){const s=e.vertexAttributes;if(!s)return!1;const i=s.get(V.POSITION),r=e.indices.get(V.POSITION);return _(i,r,t)}createBufferWriter(){return new Ae(this)}_normalAndViewAngle(e,t,s,r){return C(t)&&(t=i(le,t)),S(r.normal,e,t),h(r.normal,r.normal,s.viewInverseTransposeMatrix),r.cosAngle=v(ae,Oe),r}_updateScaleInfo(e,s,i){const r=this.parameters;t(r.screenSizePerspective)?E(i,s,r.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),t(r.screenSizePerspectiveAlignment)?E(i,s,r.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,t,s,i,r,n,a){const o=this._normalAndViewAngle(t,s,r,ue);return this._applyVerticalGroundOffsetView(e,o,r,a),this._applyVerticalOffsetTransformationView(a,o,r,n),this._applyPolygonOffsetView(a,o,i[3],r,a),this._applyCenterOffsetView(a,i,a),a}applyShaderOffsetsNDC(e,s,i,r,n){return this._applyCenterOffsetNDC(e,s,i,r),t(n)&&d(n,r),this._applyPolygonOffsetNDC(r,s,i,r),r}_applyPolygonOffsetView(t,s,i,r,n){const a=r.aboveGround?1:-1;let o=Math.sign(i);0===o&&(o=a);const c=a*o;if(this.parameters.shaderPolygonOffset<=0)return d(n,t);const l=e(Math.abs(s.cosAngle),.01,1),f=1-Math.sqrt(1-l*l)/l/r.viewport[2];return m(n,t,c>0?f:1/f),n}_applyVerticalGroundOffsetView(e,t,s,i){const r=g(e),n=s.aboveGround?1:-1,a=.5*s.computeRenderPixelSizeAtDist(r),o=m(ie,t.normal,n*a);return A(i,e,o),i}_applyVerticalOffsetTransformationView(e,t,i,r){const n=this.parameters;if(!n.verticalOffset||!n.verticalOffset.screenLength){if(n.screenSizePerspective||n.screenSizePerspectiveAlignment){const s=g(e);this._updateScaleInfo(r,s,t.cosAngle)}else r.factor.scale=1,r.factorAlignment.scale=1;return e}const a=g(e),o=s(n.screenSizePerspectiveAlignment,n.screenSizePerspective),c=X(i,a,n.verticalOffset,t.cosAngle,o);return this._updateScaleInfo(r,a,t.cosAngle),m(t.normal,t.normal,c),A(e,e,t.normal)}_applyCenterOffsetView(e,t,s){const i="screen"!==this.parameters.centerOffsetUnits;return s!==e&&d(s,e),i&&(s[0]+=t[0],s[1]+=t[1],t[2]&&(u(re,s),A(s,s,m(re,re,t[2])))),s}_applyCenterOffsetNDC(e,t,s,i){const r="screen"!==this.parameters.centerOffsetUnits;return i!==e&&d(i,e),r||(i[0]+=t[0]/s.fullWidth*2,i[1]+=t[1]/s.fullHeight*2),i}_applyPolygonOffsetNDC(e,t,s,i){const r=this.parameters.shaderPolygonOffset;if(e!==i&&d(i,e),r){const e=s.aboveGround?1:-1,n=e*Math.sign(t[3]);i[2]-=(n||e)*r}return i}requiresSlot(e){if(e===w.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:s}=this.parameters;return e===(t?w.LABEL_MATERIAL:w.HUD_MATERIAL)||s&&e===w.OCCLUSION_PIXELS}createGLMaterial(e){return e.output===z.Color||e.output===z.Alpha?new Q(e):e.output===z.Highlight?new K(e):null}calculateRelativeScreenBounds(e,t,s=y()){return Y(this.parameters,e,t,s),s[2]=s[0]+e[0],s[3]=s[1]+e[1],s}}class K extends M{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(W,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}class Q extends K{_isOcclusionSlot(e){return e.slot===w.OCCLUSION_PIXELS&&this._material.parameters.occlusionTest&&(this._output===z.Color||this._output===z.Alpha)}selectProgram(e){return this.ensureTechnique(W,e,this._isOcclusionSlot(e)?z.Occlusion:this._output)}}function Y(e,t,s,i=se){return o(i,e.anchorPosition),i[0]*=-t[0],i[1]*=-t[1],i[0]+=e.screenOffset[0]*s,i[1]+=e.screenOffset[1]*s,i}function $(e){const t=e[0],s=e[1],i=e[2],r=e[3],n=e[4],a=e[5],o=e[6],c=e[7],l=e[8],f=1/Math.sqrt(t*t+s*s+i*i),h=1/Math.sqrt(r*r+n*n+a*a),u=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*f,e[1]=s*f,e[2]=i*f,e[3]=r*h,e[4]=n*h,e[5]=a*h,e[6]=o*u,e[7]=c*u,e[8]=l*u,e}function ee(e,s,i,r,n,a,o,c){let l=s-n-(c[0]>0?r[0]*c[0]:0),f=l+r[0]+2*n,h=i-n-(c[1]>0?r[1]*c[1]:0),u=h+r[1]+2*n;const p=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&t(p)&&(l+=r[0]*p[0],h+=r[1]*p[1],f-=r[0]*(1-p[2]),u-=r[1]*(1-p[3]),l-=a,f+=a,h-=a,u+=a),e[0]>l&&e[0]<f&&e[1]>h&&e[1]<u}const te={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},se=c(),ie=P(),re=P(),ne=x(),ae=P(),oe=P(),ce=r(),le=r(),fe=a(),he=P(),ue={normal:ae,cosAngle:0},pe=a(),me=1,de=2,ge=[0,0],Oe=b(0,0,1);class Se extends j{constructor(){super(...arguments),this.renderOccluded=q.Occlude,this.color=[1,1,1,1],this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=l(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.outlineColor=[1,1,1,1],this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSizeMinSize=[1,1,1],this.vvSizeMaxSize=[100,100,100],this.vvSizeOffset=[0,0,0],this.vvSizeFactor=[1,1,1],this.vvColorEnabled=!1,this.vvColorValues=[0,0,0,0,0,0,0,0],this.vvColorColors=[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.binaryHighlightOcclusion=!0,this.debugDrawLabelBorder=!1,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const ve=I().vec3f(V.POSITION).vec3f(V.NORMAL).vec2f(V.UV0).vec4u8(V.COLOR).vec2f(V.SIZE).vec4f(V.AUXPOS1).vec4f(V.AUXPOS2);class Ae{constructor(e){this.material=e,this.vertexBufferLayout=ve}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices.get(V.POSITION).length}write(e,t,s,i){N(t.indices.get(V.POSITION),t.vertexAttributes.get(V.POSITION).data,e.transformation,s.position,i,6),G(t.indices.get(V.NORMAL),t.vertexAttributes.get(V.NORMAL).data,e.invTranspTransformation,s.normal,i,6);{const e=t.vertexAttributes.get(V.UV0).data;let r,n,a,o;if(null==e||e.length<4){const e=this.material.parameters;r=0,n=0,a=e.texCoordScale[0],o=e.texCoordScale[1]}else r=e[0],n=e[1],a=e[2],o=e[3];a=Math.min(1.99999,a+1),o=Math.min(1.99999,o+1);const c=t.indices.get(V.POSITION).length,l=s.uv0;let f=i;for(let t=0;t<c;++t)l.set(f,0,r),l.set(f,1,n),f+=1,l.set(f,0,a),l.set(f,1,n),f+=1,l.set(f,0,a),l.set(f,1,o),f+=1,l.set(f,0,a),l.set(f,1,o),f+=1,l.set(f,0,r),l.set(f,1,o),f+=1,l.set(f,0,r),l.set(f,1,n),f+=1}H(t.indices.get(V.COLOR),t.vertexAttributes.get(V.COLOR).data,4,s.color,i,6);{const e=t.indices.get(V.SIZE),r=t.vertexAttributes.get(V.SIZE).data,n=e.length,a=s.size;let o=i;for(let t=0;t<n;++t){const s=r[2*e[t]],i=r[2*e[t]+1];for(let e=0;e<6;++e)a.set(o,0,s),a.set(o,1,i),o+=1}}t.indices.get(V.AUXPOS1)&&t.vertexAttributes.get(V.AUXPOS1)&&B(t.indices.get(V.AUXPOS1),t.vertexAttributes.get(V.AUXPOS1).data,s.auxpos1,i,6),t.indices.get(V.AUXPOS2)&&t.vertexAttributes.get(V.AUXPOS2)&&B(t.indices.get(V.AUXPOS2),t.vertexAttributes.get(V.AUXPOS2).data,s.auxpos2,i,6)}}export{J as HUDMaterial,Se as Parameters};
