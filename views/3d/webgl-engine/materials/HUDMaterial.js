/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/mathUtils","../../../../core/maybe","../../../../core/screenUtils","../../../../chunks/mat3","../../../../chunks/mat3f64","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../core/libs/gl-matrix-2/types/mat4","../../../../geometry/support/aaBoundingRect","../../support/buffer/InterleavedLayout","../core/shaderLibrary/ShaderOutputOptions","../core/shaderLibrary/hud/HUD.glsl","../lib/geometryDataUtils","../lib/GLMaterialTexture","../lib/Material","../lib/RenderSlot","../lib/screenSizePerspectiveUtils","../lib/Util","../lib/VertexAttribute","./internal/bufferWriterUtils","./internal/MaterialUtil","./renderers/utils","../../../../chunks/HUDMaterial.glsl","../shaders/HUDMaterialTechnique"],(function(e,t,r,i,n,s,a,o,c,l,u,f,h,p,d,g,m,S,b,A,O,x,v,P,y,V,C,M,I,T){"use strict";let _=function(e){function n(t){var r;return(r=e.call(this,t,$)||this).techniqueConfig=new T.HUDMaterialTechniqueConfiguration,r}t._inheritsLoose(n,e);var a=n.prototype;return a.getTechniqueConfig=function(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.verticalOffset=!!this.parameters.verticalOffset,this.techniqueConfig.screenSizePerspective=!!this.parameters.screenSizePerspective,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?S.HUDSpace.Screen:S.HUDSpace.World,this.techniqueConfig.polygonOffsetEnabled=this.parameters.polygonOffset,this.techniqueConfig.isDraped=this.parameters.isDraped,this.techniqueConfig.occlusionTestEnabled=this.parameters.occlusionTest,this.techniqueConfig.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this.techniqueConfig.sdf=this.parameters.textureIsSignedDistanceField,this.techniqueConfig.vvSize=!!this.parameters.vvSizeEnabled,this.techniqueConfig.vvColor=!!this.parameters.vvColorEnabled,e===m.ShaderOutput.Color&&(this.techniqueConfig.debugDrawLabelBorder=!!this.parameters.debugDrawLabelBorder),e===m.ShaderOutput.Highlight&&(this.techniqueConfig.binaryHighlightOcclusion=this.parameters.binaryHighlightOcclusion),this.techniqueConfig.depthEnabled=this.parameters.depthEnabled,this.techniqueConfig.transparencyPassType=t.transparencyPassType,this.techniqueConfig.multipassGeometryEnabled=t.multipassGeometryEnabled,this.techniqueConfig.multipassTerrainEnabled=t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=t.cullAboveGround,this.techniqueConfig},a.intersect=function(e,t,r,n,s,a,o,c,l){i.isSome(l)?this._intersectDrapedHudGeometry(e,a,o,c,l):this._intersectHudGeometry(e,t,r,n,o,c)},a._intersectDrapedHudGeometry=function(e,t,r,n,s){const a=e.vertexAttributes.get(y.VertexAttribute.POSITION),o=e.vertexAttributes.get(y.VertexAttribute.SIZE),c=this.parameters,l=I.calculateAnchorPosForRendering(c);let u=1,f=1;if(i.isSome(n)){const e=n(j);u=e[0],f=e[5]}u*=e.screenToWorldRatio,f*=e.screenToWorldRatio;const h=K*e.screenToWorldRatio;for(let i=0;i<a.data.length/a.size;i++){const n=i*a.size,p=a.data[n],d=a.data[n+1],g=i*o.size;let m;Q[0]=o.data[g]*u,Q[1]=o.data[g+1]*f,c.textureIsSignedDistanceField&&(m=c.outlineSize*e.screenToWorldRatio/2),q(t,p,d,Q,h,m,c,l)&&r(s.dist,s.normal,-1,!0)}},a._intersectHudGeometry=function(e,t,r,n,a,c){if(!n.options.selectionMode||!n.options.hud||M.isInstanceHidden(t))return;const l=this.parameters;let u=1,p=1;if(s.fromMat4(G,r),i.isSome(c)){const e=c(j);u=e[0],p=e[5],D(G)}const d=e.vertexAttributes.get(y.VertexAttribute.POSITION),g=e.vertexAttributes.get(y.VertexAttribute.SIZE),m=e.vertexAttributes.get(y.VertexAttribute.NORMAL),S=e.vertexAttributes.get(y.VertexAttribute.AUXPOS1);P.assert(d.size>=3);const b=n.point,A=n.camera,O=I.calculateAnchorPosForRendering(l);u*=A.pixelRatio,p*=A.pixelRatio;const x="screen"===this.parameters.centerOffsetUnits;for(let i=0;i<d.data.length/d.size;i++){const e=i*d.size;f.set(L,d.data[e],d.data[e+1],d.data[e+2]),f.transformMat4(L,L,r);const t=i*g.size;Q[0]=g.data[t]*u,Q[1]=g.data[t+1]*p,f.transformMat4(L,L,A.viewMatrix);const s=i*S.size;if(f.set(W,S.data[s+0],S.data[s+1],S.data[s+2]),!x&&(L[0]+=W[0],L[1]+=W[1],0!==W[2])){const e=W[2];f.normalize(W,L),f.subtract(L,L,f.scale(W,W,e))}const c=i*m.size;if(f.set(H,m.data[c],m.data[c+1],m.data[c+2]),this._normalAndViewAngle(H,G,A,Z),this._applyVerticalOffsetTransformationView(L,Z,A,E),A.applyProjection(L,N),N[0]>-1){let e=Math.floor(N[0])+this.parameters.screenOffset[0],t=Math.floor(N[1])+this.parameters.screenOffset[1];x&&(e+=W[0],0!==W[1]&&(t+=v.applyScaleFactor(W[1],E.factorAlignment))),v.applyPrecomputedScaleFactor(Q,E.factor,Q);const r=J*A.pixelRatio;let i;if(l.textureIsSignedDistanceField&&(i=l.outlineSize*A.pixelRatio/2),q(b,e,t,Q,r,i,l,O)){const e=n.ray;if(f.transformMat4(F,L,o.invert(k,A.viewMatrix)),N[0]=b[0],N[1]=b[1],A.unprojectFromRenderScreen(N,L)){const t=h.create();f.copy(t,e.direction);const r=1/f.length(t);f.scale(t,t,r);a(f.distance(e.origin,L)*r,t,-1,!0,1,F)}}}}},a.computeAttachmentOrigin=function(e,t){const r=e.vertexAttributes;if(!r)return!1;const i=r.get(y.VertexAttribute.POSITION),n=e.indices.get(y.VertexAttribute.POSITION);return b.computeAttachmentOriginPoints(i,n,t)},a.createBufferWriter=function(){return new te(this)},a._normalAndViewAngle=function(e,t,r,i){return p.isMat4(t)&&(t=s.fromMat4(X,t)),f.transformMat3(i.normal,e,t),f.transformMat4(i.normal,i.normal,r.viewInverseTransposeMatrix),i.cosAngle=f.dot(B,Y),i},a._updateScaleInfo=function(e,t,r){const i=this.parameters;i.screenSizePerspective?v.precomputeScaleFactor(r,t,i.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),i.screenSizePerspectiveAlignment?v.precomputeScaleFactor(r,t,i.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)},a.applyShaderOffsetsView=function(e,t,r,i,n,s,a){const o=this._normalAndViewAngle(t,r,n,Z);return this._applyVerticalGroundOffsetView(e,o,n,a),this._applyVerticalOffsetTransformationView(a,o,n,s),this._applyPolygonOffsetView(a,o,i[3],n,a),this._applyCenterOffsetView(a,i,a),a},a.applyShaderOffsetsNDC=function(e,t,r,n,s){return this._applyCenterOffsetNDC(e,t,r,n),i.isSome(s)&&f.copy(s,n),this._applyPolygonOffsetNDC(n,t,r,n),n},a._applyPolygonOffsetView=function(e,t,i,n,s){const a=n.aboveGround?1:-1;let o=Math.sign(i);0===o&&(o=a);const c=a*o;if(this.parameters.shaderPolygonOffset<=0)return f.copy(s,e);const l=r.clamp(Math.abs(t.cosAngle),.01,1),u=1-Math.sqrt(1-l*l)/l/n.viewport[2];return c>0?f.scale(s,e,u):f.scale(s,e,1/u),s},a._applyVerticalGroundOffsetView=function(e,t,r,i){const n=f.length(e),s=r.aboveGround?1:-1,a=.5*r.computeRenderPixelSizeAtDist(n),o=f.scale(L,t.normal,s*a);return f.add(i,e,o),i},a._applyVerticalOffsetTransformationView=function(e,t,r,i){const n=this.parameters;if(!n.verticalOffset||!n.verticalOffset.screenLength){if(n.screenSizePerspective||n.screenSizePerspectiveAlignment){const r=f.length(e);this._updateScaleInfo(i,r,t.cosAngle)}else i.factor.scale=1,i.factorAlignment.scale=1;return e}const s=f.length(e),a=n.screenSizePerspectiveAlignment||n.screenSizePerspective,o=C.verticalOffsetAtDistance(r,s,n.verticalOffset,t.cosAngle,a);return this._updateScaleInfo(i,s,t.cosAngle),f.scale(t.normal,t.normal,o),f.add(e,e,t.normal)},a._applyCenterOffsetView=function(e,t,r){const i="screen"!==this.parameters.centerOffsetUnits;return r!==e&&f.copy(r,e),i&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(f.normalize(H,r),f.add(r,r,f.scale(H,H,t[2])))),r},a._applyCenterOffsetNDC=function(e,t,r,i){const n="screen"!==this.parameters.centerOffsetUnits;return i!==e&&f.copy(i,e),n||(i[0]+=t[0]/r.fullWidth*2,i[1]+=t[1]/r.fullHeight*2),i},a._applyPolygonOffsetNDC=function(e,t,r,i){const n=this.parameters.shaderPolygonOffset;if(e!==i&&f.copy(i,e),n){const e=r.aboveGround?1:-1,s=e*Math.sign(t[3]);i[2]-=(s||e)*n}return i},a.requiresSlot=function(e){if(e===x.RenderSlot.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:r}=this.parameters;return e===(t?x.RenderSlot.LABEL_MATERIAL:x.RenderSlot.HUD_MATERIAL)||r&&e===x.RenderSlot.OCCLUSION_PIXELS},a.createGLMaterial=function(e){return e.output===m.ShaderOutput.Color||e.output===m.ShaderOutput.Alpha?new U(e):e.output===m.ShaderOutput.Highlight?new z(e):null},a.calculateRelativeScreenBounds=function(e,t,r=d.create()){return w(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r},n}(O.Material),z=function(e){function r(t){return e.call(this,{...t,...t.material.parameters})||this}t._inheritsLoose(r,e);var i=r.prototype;return i.updateParameters=function(e){return this.updateTexture(this._material.parameters.textureId),this.selectProgram(e)},i.selectProgram=function(e){return this.ensureTechnique(T.HUDMaterialTechnique,e)},i.beginSlot=function(e){return this.updateParameters(e)},i.bind=function(e,t){this.bindTextures(t.program),this.bindTextureScale(t.program),t.bindPass(this._material.parameters,e)},r}(A),U=function(e){function r(){return e.apply(this,arguments)||this}t._inheritsLoose(r,e);var i=r.prototype;return i._isOcclusionSlot=function(e){return e.slot===x.RenderSlot.OCCLUSION_PIXELS&&this._material.parameters.occlusionTest&&(this._output===m.ShaderOutput.Color||this._output===m.ShaderOutput.Alpha)},i.selectProgram=function(e){return this.ensureTechnique(T.HUDMaterialTechnique,e,this._isOcclusionSlot(e)?m.ShaderOutput.Occlusion:this._output)},i.bind=function(e,t){this._isOcclusionSlot(e)||(this.bindTextures(t.program),this.bindTextureScale(t.program)),t.bindPass(this._material.parameters,e)},r}(z);function w(e,t,r,i=R){return l.copy(i,e.anchorPos),i[0]*=-t[0],i[1]*=-t[1],i[0]+=e.screenOffset[0]*r,i[1]+=e.screenOffset[1]*r,i}function D(e){const t=e[0],r=e[1],i=e[2],n=e[3],s=e[4],a=e[5],o=e[6],c=e[7],l=e[8],u=1/Math.sqrt(t*t+r*r+i*i),f=1/Math.sqrt(n*n+s*s+a*a),h=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*u,e[1]=r*u,e[2]=i*u,e[3]=n*f,e[4]=s*f,e[5]=a*f,e[6]=o*h,e[7]=c*h,e[8]=l*h,e}function q(e,t,r,i,n,s,a,o){let c=t-n-(o[0]>0?i[0]*o[0]:0),l=c+i[0]+2*n,u=r-n-(o[1]>0?i[1]*o[1]:0),f=u+i[1]+2*n;if(a.textureIsSignedDistanceField){const e=a.distanceFieldBoundingBox;c+=i[0]*e[0],u+=i[1]*e[1],l-=i[0]*(1-e[2]),f-=i[1]*(1-e[3]),c-=s,l+=s,u-=s,f+=s}return e[0]>c&&e[0]<l&&e[1]>u&&e[1]<f}const E={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},R=u.create(),L=h.create(),H=h.create(),N=n.createRenderScreenPointArray3(),B=h.create(),F=h.create(),G=a.create(),X=a.create(),k=c.create(),W=h.create(),Z={normal:B,cosAngle:0},j=c.create(),J=1,K=2,Q=[0,0],Y=h.fromValues(0,0,1),$={texCoordScale:[1,1],occlusionTest:!0,binaryHighlightOcclusion:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,slicePlaneEnabled:!1,anchorPos:u.fromValues(.5,.5),shaderPolygonOffset:1e-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",depthEnabled:!0,pixelSnappingEnabled:!0,debugDrawLabelBorder:!1,isDraped:!1,...O.DefaultMaterialParameters},ee=g.newLayout().vec3f(y.VertexAttribute.POSITION).vec3f(y.VertexAttribute.NORMAL).vec2f(y.VertexAttribute.UV0).vec4u8(y.VertexAttribute.COLOR).vec2f(y.VertexAttribute.SIZE).vec4f(y.VertexAttribute.AUXPOS1).vec4f(y.VertexAttribute.AUXPOS2);let te=function(){function e(e){this.material=e,this.vertexBufferLayout=ee}var t=e.prototype;return t.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},t.elementCount=function(e){return 6*e.indices.get(y.VertexAttribute.POSITION).length},t.write=function(e,t,r,i){V.writePosition(t.indices.get(y.VertexAttribute.POSITION),t.vertexAttributes.get(y.VertexAttribute.POSITION).data,e.transformation,r.position,i,6),V.writeNormal(t.indices.get(y.VertexAttribute.NORMAL),t.vertexAttributes.get(y.VertexAttribute.NORMAL).data,e.invTranspTransformation,r.normal,i,6);{const e=t.vertexAttributes.get(y.VertexAttribute.UV0).data;let n,s,a,o;if(null==e||e.length<4){const e=this.material.parameters;n=0,s=0,a=e.texCoordScale[0],o=e.texCoordScale[1]}else n=e[0],s=e[1],a=e[2],o=e[3];a=Math.min(1.99999,a+1),o=Math.min(1.99999,o+1);const c=t.indices.get(y.VertexAttribute.POSITION).length,l=r.uv0;let u=i;for(let t=0;t<c;++t)l.set(u,0,n),l.set(u,1,s),u+=1,l.set(u,0,a),l.set(u,1,s),u+=1,l.set(u,0,a),l.set(u,1,o),u+=1,l.set(u,0,a),l.set(u,1,o),u+=1,l.set(u,0,n),l.set(u,1,o),u+=1,l.set(u,0,n),l.set(u,1,s),u+=1}V.writeColor(t.indices.get(y.VertexAttribute.COLOR),t.vertexAttributes.get(y.VertexAttribute.COLOR).data,4,r.color,i,6);{const e=t.indices.get(y.VertexAttribute.SIZE),n=t.vertexAttributes.get(y.VertexAttribute.SIZE).data,s=e.length,a=r.size;let o=i;for(let t=0;t<s;++t){const r=n[2*e[t]],i=n[2*e[t]+1];for(let e=0;e<6;++e)a.set(o,0,r),a.set(o,1,i),o+=1}}t.indices.get(y.VertexAttribute.AUXPOS1)&&t.vertexAttributes.get(y.VertexAttribute.AUXPOS1)&&V.writeBufferVec4(t.indices.get(y.VertexAttribute.AUXPOS1),t.vertexAttributes.get(y.VertexAttribute.AUXPOS1).data,r.auxpos1,i,6),t.indices.get(y.VertexAttribute.AUXPOS2)&&t.vertexAttributes.get(y.VertexAttribute.AUXPOS2)&&V.writeBufferVec4(t.indices.get(y.VertexAttribute.AUXPOS2),t.vertexAttributes.get(y.VertexAttribute.AUXPOS2).data,r.auxpos2,i,6)},e}();e.HUDMaterial=_,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
