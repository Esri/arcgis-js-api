/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/has","../../../../core/mathUtils","../../../../core/maybe","../../../../chunks/mat3","../../../../chunks/mat3f64","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../chunks/vec4f64","../../../../core/libs/gl-matrix-2/types/mat4","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/buffer/BufferView","../../support/buffer/InterleavedLayout","../core/shaderLibrary/ShaderOutput","../core/shaderLibrary/hud/HUD.glsl","../lib/geometryDataUtils","../lib/GLTextureMaterial","../lib/Material","../lib/RenderSlot","../lib/screenSizePerspectiveUtils","../lib/Util","../lib/VertexAttribute","./internal/bufferWriterUtils","./internal/MaterialUtil","./renderers/utils","../../../../chunks/HUDMaterial.glsl","../shaders/HUDMaterialTechnique","../shaders/HUDMaterialTechniqueConfiguration"],(function(e,t,r,i,n,a,s,o,c,l,u,f,d,p,h,g,m,A,S,O,b,x,v,P,y,V,_,I,M,C,T,L,z){"use strict";let w=function(e){function r(t){var r;return(r=e.call(this,t,new te)||this)._configuration=new z.HUDMaterialTechniqueConfiguration,r}t._inheritsLoose(r,e);var s=r.prototype;return s.getConfiguration=function(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?O.HUDSpace.Screen:O.HUDSpace.World,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.isDraped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.vvSize=!!this.parameters.vvSizeEnabled,this._configuration.vvColor=!!this.parameters.vvColorEnabled,this._configuration.occlusionPass=t.slot===P.RenderSlot.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(e===S.ShaderOutput.Color||e===S.ShaderOutput.Alpha),e===S.ShaderOutput.Color&&(this._configuration.debugDrawLabelBorder=!!this.parameters.debugDrawLabelBorder),e===S.ShaderOutput.Highlight&&(this._configuration.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassGeometry=t.multipassGeometry.enabled,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration},s.intersect=function(e,t,r,i,a,s,o,c,l){n.isSome(l)?this._intersectDrapedHudGeometry(e,s,o,c,l):this._intersectHudGeometry(e,t,r,i,o,c)},s._intersectDrapedHudGeometry=function(e,t,r,i,a){const s=e.vertexAttributes.get(_.VertexAttribute.POSITION),o=e.vertexAttributes.get(_.VertexAttribute.SIZE),c=this.parameters,l=T.calculateAnchorPosForRendering(c);let u=1,f=1;if(n.isSome(i)){const e=i(Y);u=e[0],f=e[5]}u*=e.screenToWorldRatio,f*=e.screenToWorldRatio;const d=Q*e.screenToWorldRatio;for(let n=0;n<s.data.length/s.size;n++){const i=n*s.size,p=s.data[i],h=s.data[i+1],g=n*o.size;let m;$[0]=o.data[g]*u,$[1]=o.data[g+1]*f,c.textureIsSignedDistanceField&&(m=c.outlineSize*e.screenToWorldRatio/2),E(t,p,h,$,d,m,c,l)&&r(a.dist,a.normal,-1,!1)}},s._intersectHudGeometry=function(e,t,r,i,s,c){if(!i.options.selectionMode||!i.options.hud||C.isInstanceHidden(t))return;const l=this.parameters;let u=1,p=1;if(a.fromMat4(j,r),n.isSome(c)){const e=c(Y);u=e[0],p=e[5],R(j)}const h=e.vertexAttributes.get(_.VertexAttribute.POSITION),g=e.vertexAttributes.get(_.VertexAttribute.SIZE),m=e.vertexAttributes.get(_.VertexAttribute.NORMAL),A=e.vertexAttributes.get(_.VertexAttribute.AUXPOS1);V.assert(h.size>=3);const S=i.point,O=i.camera,b=T.calculateAnchorPosForRendering(l);u*=O.pixelRatio,p*=O.pixelRatio;const x="screen"===this.parameters.centerOffsetUnits;for(let n=0;n<h.data.length/h.size;n++){const e=n*h.size;f.set(B,h.data[e],h.data[e+1],h.data[e+2]),f.transformMat4(B,B,r);const t=n*g.size;$[0]=g.data[t]*u,$[1]=g.data[t+1]*p,f.transformMat4(B,B,O.viewMatrix);const a=n*A.size;if(f.set(Z,A.data[a+0],A.data[a+1],A.data[a+2]),!x&&(B[0]+=Z[0],B[1]+=Z[1],0!==Z[2])){const e=Z[2];f.normalize(Z,B),f.subtract(B,B,f.scale(Z,Z,e))}const c=n*m.size;if(f.set(F,m.data[c],m.data[c+1],m.data[c+2]),this._normalAndViewAngle(F,j,O,J),this._applyVerticalOffsetTransformationView(B,J,O,N),O.applyProjection(B,G),G[0]>-1){G[0]=Math.floor(G[0]),G[1]=Math.floor(G[1]),x&&(Z[0]||Z[1])&&(G[0]+=Z[0],0!==Z[1]&&(G[1]+=y.applyScaleFactor(Z[1],N.factorAlignment)),O.unapplyProjection(G,B)),G[0]+=this.parameters.screenOffset[0],G[1]+=this.parameters.screenOffset[1],y.applyPrecomputedScaleFactor($,N.factor,$);const e=K*O.pixelRatio;let t;if(l.textureIsSignedDistanceField&&(t=l.outlineSize*O.pixelRatio/2),E(S,G[0],G[1],$,e,t,l,b)){const e=i.ray;if(f.transformMat4(k,B,o.invert(W,O.viewMatrix)),G[0]=S[0],G[1]=S[1],O.unprojectFromRenderScreen(G,B)){const t=d.create();f.copy(t,e.direction);const r=1/f.length(t);f.scale(t,t,r);s(f.distance(e.origin,B)*r,t,-1,!0,1,k)}}}}},s.computeAttachmentOrigin=function(e,t){const r=e.vertexAttributes;if(!r)return!1;const i=r.get(_.VertexAttribute.POSITION),n=e.indices.get(_.VertexAttribute.POSITION);return b.computeAttachmentOriginPoints(i,n,t)},s.createBufferWriter=function(){return new ne(this)},s._normalAndViewAngle=function(e,t,r,i){return h.isMat4(t)&&(t=a.fromMat4(q,t)),f.transformMat3(i.normal,e,t),f.transformMat4(i.normal,i.normal,r.viewInverseTransposeMatrix),i.cosAngle=f.dot(X,ee),i},s._updateScaleInfo=function(e,t,r){const i=this.parameters;n.isSome(i.screenSizePerspective)?y.precomputeScaleFactor(r,t,i.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),n.isSome(i.screenSizePerspectiveAlignment)?y.precomputeScaleFactor(r,t,i.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)},s.applyShaderOffsetsView=function(e,t,r,i,n,a,s){const o=this._normalAndViewAngle(t,r,n,J);return this._applyVerticalGroundOffsetView(e,o,n,s),this._applyVerticalOffsetTransformationView(s,o,n,a),this._applyPolygonOffsetView(s,o,i[3],n,s),this._applyCenterOffsetView(s,i,s),s},s.applyShaderOffsetsNDC=function(e,t,r,i,a){return this._applyCenterOffsetNDC(e,t,r,i),n.isSome(a)&&f.copy(a,i),this._applyPolygonOffsetNDC(i,t,r,i),i},s._applyPolygonOffsetView=function(e,t,r,n,a){const s=n.aboveGround?1:-1;let o=Math.sign(r);0===o&&(o=s);const c=s*o;if(this.parameters.shaderPolygonOffset<=0)return f.copy(a,e);const l=i.clamp(Math.abs(t.cosAngle),.01,1),u=1-Math.sqrt(1-l*l)/l/n.viewport[2];return c>0?f.scale(a,e,u):f.scale(a,e,1/u),a},s._applyVerticalGroundOffsetView=function(e,t,r,i){const n=f.length(e),a=r.aboveGround?1:-1,s=.5*r.computeRenderPixelSizeAtDist(n),o=f.scale(B,t.normal,a*s);return f.add(i,e,o),i},s._applyVerticalOffsetTransformationView=function(e,t,r,i){const a=this.parameters;if(!a.verticalOffset||!a.verticalOffset.screenLength){if(a.screenSizePerspective||a.screenSizePerspectiveAlignment){const r=f.length(e);this._updateScaleInfo(i,r,t.cosAngle)}else i.factor.scale=1,i.factorAlignment.scale=1;return e}const s=f.length(e),o=n.unwrapOr(a.screenSizePerspectiveAlignment,a.screenSizePerspective),c=M.verticalOffsetAtDistance(r,s,a.verticalOffset,t.cosAngle,o);return this._updateScaleInfo(i,s,t.cosAngle),f.scale(t.normal,t.normal,c),f.add(e,e,t.normal)},s._applyCenterOffsetView=function(e,t,r){const i="screen"!==this.parameters.centerOffsetUnits;return r!==e&&f.copy(r,e),i&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(f.normalize(F,r),f.add(r,r,f.scale(F,F,t[2])))),r},s._applyCenterOffsetNDC=function(e,t,r,i){const n="screen"!==this.parameters.centerOffsetUnits;return i!==e&&f.copy(i,e),n||(i[0]+=t[0]/r.fullWidth*2,i[1]+=t[1]/r.fullHeight*2),i},s._applyPolygonOffsetNDC=function(e,t,r,i){const n=this.parameters.shaderPolygonOffset;if(e!==i&&f.copy(i,e),n){const e=r.aboveGround?1:-1,a=e*Math.sign(t[3]);i[2]-=(a||e)*n}return i},s.requiresSlot=function(e,t){if(t===S.ShaderOutput.Color||t===S.ShaderOutput.Alpha||t===S.ShaderOutput.Highlight||t===S.ShaderOutput.ObjectAndLayerIdColor){if(e===P.RenderSlot.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:r}=this.parameters;return e===(t?P.RenderSlot.LABEL_MATERIAL:P.RenderSlot.HUD_MATERIAL)||r&&e===P.RenderSlot.OCCLUSION_PIXELS}return!1},s.createGLMaterial=function(e){return new D(e)},s.calculateRelativeScreenBounds=function(e,t,r=g.create()){return U(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r},r}(v.Material),D=function(e){function r(t){return e.call(this,{...t,...t.material.parameters})||this}t._inheritsLoose(r,e);var i=r.prototype;return i.selectProgram=function(e){return this.ensureTechnique(L.HUDMaterialTechnique,e)},i.beginSlot=function(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)},r}(x.GLTextureMaterial);function U(e,t,r,i=H){return l.copy(i,e.anchorPosition),i[0]*=-t[0],i[1]*=-t[1],i[0]+=e.screenOffset[0]*r,i[1]+=e.screenOffset[1]*r,i}function R(e){const t=e[0],r=e[1],i=e[2],n=e[3],a=e[4],s=e[5],o=e[6],c=e[7],l=e[8],u=1/Math.sqrt(t*t+r*r+i*i),f=1/Math.sqrt(n*n+a*a+s*s),d=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*u,e[1]=r*u,e[2]=i*u,e[3]=n*f,e[4]=a*f,e[5]=s*f,e[6]=o*d,e[7]=c*d,e[8]=l*d,e}function E(e,t,r,i,a,s,o,c){let l=t-a-(c[0]>0?i[0]*c[0]:0),u=l+i[0]+2*a,f=r-a-(c[1]>0?i[1]*c[1]:0),d=f+i[1]+2*a;const p=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&n.isSome(p)&&(l+=i[0]*p[0],f+=i[1]*p[1],u-=i[0]*(1-p[2]),d-=i[1]*(1-p[3]),l-=s,u+=s,f-=s,d+=s),e[0]>l&&e[0]<u&&e[1]>f&&e[1]<d}const N={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},H=u.create(),B=d.create(),F=d.create(),G=p.create(),X=d.create(),k=d.create(),j=s.create(),q=s.create(),W=c.create(),Z=d.create(),J={normal:X,cosAngle:0},Y=c.create(),K=1,Q=2,$=[0,0],ee=d.fromValues(0,0,1);let te=function(e){function r(){var t;return(t=e.apply(this,arguments)||this).renderOccluded=v.RenderOccludedFlag.Occlude,t.color=p.fromValues(1,1,1,1),t.texCoordScale=[1,1],t.polygonOffset=!1,t.anchorPosition=u.fromValues(.5,.5),t.screenOffset=[0,0],t.shaderPolygonOffset=1e-5,t.textureIsSignedDistanceField=!1,t.outlineColor=p.fromValues(1,1,1,1),t.outlineSize=0,t.vvSizeEnabled=!1,t.vvSizeMinSize=[1,1,1],t.vvSizeMaxSize=[100,100,100],t.vvSizeOffset=[0,0,0],t.vvSizeFactor=[1,1,1],t.vvColorEnabled=!1,t.vvColorValues=[0,0,0,0,0,0,0,0],t.vvColorColors=[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],t.hasSlicePlane=!1,t.pixelSnappingEnabled=!0,t.occlusionTest=!0,t.binaryHighlightOcclusion=!0,t.debugDrawLabelBorder=!1,t.centerOffsetUnits="world",t.drawInSecondSlot=!1,t.depthEnabled=!0,t.isDraped=!1,t}return t._inheritsLoose(r,e),r}(x.GLTextureMaterialBindParameters);const re=A.newLayout().vec3f(_.VertexAttribute.POSITION).vec3f(_.VertexAttribute.NORMAL).vec2f(_.VertexAttribute.UV0).vec4u8(_.VertexAttribute.COLOR).vec2f(_.VertexAttribute.SIZE).vec4f(_.VertexAttribute.AUXPOS1).vec4f(_.VertexAttribute.AUXPOS2),ie=re.clone().vec4u8(_.VertexAttribute.OBJECTANDLAYERIDCOLOR);let ne=function(){function e(e){this._material=e,this.vertexBufferLayout=r("enable-feature:objectAndLayerId-rendering")?ie:re}var t=e.prototype;return t.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},t.elementCount=function(e){return 6*e.indices.get(_.VertexAttribute.POSITION).length},t.write=function(e,t,r,i,a){I.writePosition(r.indices.get(_.VertexAttribute.POSITION),r.vertexAttributes.get(_.VertexAttribute.POSITION).data,e,i.position,a,6),I.writeNormal(r.indices.get(_.VertexAttribute.NORMAL),r.vertexAttributes.get(_.VertexAttribute.NORMAL).data,t,i.normal,a,6);{const e=r.vertexAttributes.get(_.VertexAttribute.UV0).data;let t,n,s,o;if(null==e||e.length<4){const e=this._material.parameters;t=0,n=0,s=e.texCoordScale[0],o=e.texCoordScale[1]}else t=e[0],n=e[1],s=e[2],o=e[3];s=Math.min(1.99999,s+1),o=Math.min(1.99999,o+1);const c=r.indices.get(_.VertexAttribute.POSITION).length,l=i.uv0;let u=a;for(let r=0;r<c;++r)l.set(u,0,t),l.set(u,1,n),u+=1,l.set(u,0,s),l.set(u,1,n),u+=1,l.set(u,0,s),l.set(u,1,o),u+=1,l.set(u,0,s),l.set(u,1,o),u+=1,l.set(u,0,t),l.set(u,1,o),u+=1,l.set(u,0,t),l.set(u,1,n),u+=1}I.writeColor(r.indices.get(_.VertexAttribute.COLOR),r.vertexAttributes.get(_.VertexAttribute.COLOR).data,4,i.color,a,6);{const e=r.indices.get(_.VertexAttribute.SIZE),t=r.vertexAttributes.get(_.VertexAttribute.SIZE).data,n=e.length,s=i.size;let o=a;for(let r=0;r<n;++r){const i=t[2*e[r]],n=t[2*e[r]+1];for(let e=0;e<6;++e)s.set(o,0,i),s.set(o,1,n),o+=1}}if(r.indices.get(_.VertexAttribute.AUXPOS1)&&r.vertexAttributes.get(_.VertexAttribute.AUXPOS1)&&I.writeBufferVec4(r.indices.get(_.VertexAttribute.AUXPOS1),r.vertexAttributes.get(_.VertexAttribute.AUXPOS1).data,i.auxpos1,a,6),r.indices.get(_.VertexAttribute.AUXPOS2)&&r.vertexAttributes.get(_.VertexAttribute.AUXPOS2)&&I.writeBufferVec4(r.indices.get(_.VertexAttribute.AUXPOS2),r.vertexAttributes.get(_.VertexAttribute.AUXPOS2).data,i.auxpos2,a,6),n.isSome(r.objectAndLayerIdColor)&&4===r.objectAndLayerIdColor.length){if(r.indices.get(_.VertexAttribute.POSITION)){const e=r.indices.get(_.VertexAttribute.POSITION).length,t=i.getField(_.VertexAttribute.OBJECTANDLAYERIDCOLOR,m.BufferViewVec4u8);I.writeObjectAndLayerIdColor(r.objectAndLayerIdColor,t,e,a,6)}}},e}();e.HUDMaterial=w,e.Parameters=te,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
