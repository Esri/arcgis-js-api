/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/mathUtils","../../../../core/maybe","../../../../core/screenUtils","../../../../chunks/mat3","../../../../chunks/mat3f64","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../core/libs/gl-matrix-2/types/mat4","../../../../geometry/support/aaBoundingRect","../../support/buffer/InterleavedLayout","../lib/geometryDataUtils","../lib/GLMaterialTexture","../lib/Material","../lib/screenSizePerspectiveUtils","../lib/Util","./internal/bufferWriterUtils","./internal/MaterialUtil","./renderers/utils","../../../../chunks/HUDMaterial.glsl","../shaders/HUDMaterialTechnique"],(function(e,t,i,n,s,r,a,o,c,l,u,f,h,p,d,g,m,v,x,S,b,y,P,A,q,O){"use strict";let C=function(e){function s(t){var i;return(i=e.call(this,t,X)||this).techniqueConfig=new O.HUDMaterialTechniqueConfiguration,i}t._inheritsLoose(s,e);var a=s.prototype;return a.getTechniqueConfig=function(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.verticalOffset=!!this.params.verticalOffset,this.techniqueConfig.screenSizePerspective=!!this.params.screenSizePerspective,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.params.centerOffsetUnits?1:0,this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig.isDraped=this.params.isDraped,this.techniqueConfig.occlusionTestEnabled=this.params.occlusionTest,this.techniqueConfig.pixelSnappingEnabled=this.params.pixelSnappingEnabled,this.techniqueConfig.sdf=this.params.textureIsSignedDistanceField,this.techniqueConfig.vvSize=!!this.params.vvSizeEnabled,this.techniqueConfig.vvColor=!!this.params.vvColorEnabled,0===e&&(this.techniqueConfig.debugDrawBorder=!!this.params.debugDrawBorder),4===e&&(this.techniqueConfig.binaryHighlightOcclusion=this.params.binaryHighlightOcclusion),this.techniqueConfig.depthEnabled=this.params.depthEnabled,this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig.multipassGeometryEnabled=!!t&&t.multipassGeometryEnabled,this.techniqueConfig.multipassTerrainEnabled=!!t&&t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!t&&t.cullAboveGround,this.techniqueConfig},a.intersect=function(e,t,i,n,s,r,a,o,c){c?this.intersectDrapedHudGeometry(e,r,a,o):this.intersectHudGeometry(e,t,i,n,a,o)},a.intersectDrapedHudGeometry=function(e,t,i,s){const r=e.vertexAttributes.get("position"),a=e.vertexAttributes.get("size"),o=this.params,c=q.calculateAnchorPosForRendering(o);let l=1,u=1;if(n.isSome(s)){const e=s(N);l=e[0],u=e[5]}l*=e.screenToWorldRatio,u*=e.screenToWorldRatio;const f=J*e.screenToWorldRatio;for(let n=0;n<r.data.length/r.size;n++){const s=n*r.size,h=r.data[s],p=r.data[s+1],d=n*a.size;let g;K[0]=a.data[d]*l,K[1]=a.data[d+1]*u,o.textureIsSignedDistanceField&&(g=o.outlineSize*e.screenToWorldRatio/2),D(t,h,p,K,f,g,o,c)&&i()}},a.intersectHudGeometry=function(e,t,i,s,a,c){if(!s.options.selectionMode||!s.options.hud)return;if(A.isInstanceHidden(t))return;const l=this.params;let u=1,p=1;if(r.fromMat4(F,i),n.isSome(c)){const e=c(N);u=e[0],p=e[5],w(F)}const d=e.vertexAttributes.get("position"),g=e.vertexAttributes.get("size"),m=e.vertexAttributes.get("normal"),v=e.vertexAttributes.get("auxpos1");b.assert(d.size>=3);const x=s.point,y=s.camera,P=q.calculateAnchorPosForRendering(l);u*=y.pixelRatio,p*=y.pixelRatio;const O="screen"===this.params.centerOffsetUnits;for(let n=0;n<d.data.length/d.size;n++){const e=n*d.size;f.set(U,d.data[e],d.data[e+1],d.data[e+2]),f.transformMat4(U,U,i);const t=n*g.size;K[0]=g.data[t]*u,K[1]=g.data[t+1]*p,f.transformMat4(U,U,y.viewMatrix);const r=n*v.size;if(f.set(L,v.data[r+0],v.data[r+1],v.data[r+2]),!O&&(U[0]+=L[0],U[1]+=L[1],0!==L[2])){const e=L[2];f.normalize(L,U),f.subtract(U,U,f.scale(L,L,e))}const c=n*m.size;if(f.set(R,m.data[c],m.data[c+1],m.data[c+2]),this.normalAndViewAngle(R,F,y,W),this.applyVerticalOffsetTransformationView(U,W,y,V),y.applyProjection(U,H),H[0]>-1){let e=Math.floor(H[0])+this.params.screenOffset[0],t=Math.floor(H[1])+this.params.screenOffset[1];O&&(e+=L[0],0!==L[1]&&(t+=S.applyScaleFactor(L[1],V.factorAlignment))),S.applyPrecomputedScaleFactor(K,V.factor,K);const i=j*y.pixelRatio;let n;if(l.textureIsSignedDistanceField&&(n=l.outlineSize*y.pixelRatio/2),D(x,e,t,K,i,n,l,P)){const e=s.ray;if(f.transformMat4(I,U,o.invert(k,y.viewMatrix)),H[0]=x[0],H[1]=x[1],y.unprojectFromRenderScreen(H,U)){const t=h.create();f.copy(t,e.direction);const i=1/f.length(t);f.scale(t,t,i);a(f.distance(e.origin,U)*i,t,-1,1,!0,I)}}}}},a.computeAttachmentOrigin=function(e,t){const i=e.vertexAttributes;if(!i)return!1;const n=i.get("position"),s=e.indices.get("position");return m.computeAttachmentOriginPoints(n,s,t)},a.createBufferWriter=function(){return new Z(this)},a.normalAndViewAngle=function(e,t,i,n){return p.isMat4(t)&&(t=r.fromMat4(G,t)),f.transformMat3(n.normal,e,t),f.transformMat4(n.normal,n.normal,i.viewInverseTransposeMatrix),n.cosAngle=f.dot(B,Q),n},a.updateScaleInfo=function(e,t,i){const n=this.params;n.screenSizePerspective?S.precomputeScaleFactor(i,t,n.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),n.screenSizePerspectiveAlignment?S.precomputeScaleFactor(i,t,n.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)},a.applyShaderOffsetsView=function(e,t,i,n,s,r,a){const o=this.normalAndViewAngle(t,i,s,W);return this.applyVerticalGroundOffsetView(e,o,s,a),this.applyVerticalOffsetTransformationView(a,o,s,r),this.applyPolygonOffsetView(a,o,n[3],s,a),this.applyCenterOffsetView(a,n,a),a},a.applyShaderOffsetsNDC=function(e,t,i,s,r){return this.applyCenterOffsetNDC(e,t,i,s),n.isSome(r)&&f.copy(r,s),this.applyPolygonOffsetNDC(s,t,i,s),s},a.applyPolygonOffsetView=function(e,t,n,s,r){const a=s.aboveGround?1:-1;let o=i.sign(n);0===o&&(o=a);const c=a*o;if(this.params.shaderPolygonOffset<=0)return f.copy(r,e);const l=i.clamp(Math.abs(t.cosAngle),.01,1),u=1-Math.sqrt(1-l*l)/l/s.viewport[2];return c>0?f.scale(r,e,u):f.scale(r,e,1/u),r},a.applyVerticalGroundOffsetView=function(e,t,i,n){const s=f.length(e),r=i.aboveGround?1:-1,a=.5*i.computeRenderPixelSizeAtDist(s),o=f.scale(U,t.normal,r*a);return f.add(n,e,o),n},a.applyVerticalOffsetTransformationView=function(e,t,i,n){const s=this.params;if(!s.verticalOffset||!s.verticalOffset.screenLength){if(s.screenSizePerspective||s.screenSizePerspectiveAlignment){const i=f.length(e);this.updateScaleInfo(n,i,t.cosAngle)}else n.factor.scale=1,n.factorAlignment.scale=1;return e}const r=f.length(e),a=s.screenSizePerspectiveAlignment||s.screenSizePerspective,o=P.verticalOffsetAtDistance(i,r,s.verticalOffset,t.cosAngle,a);return this.updateScaleInfo(n,r,t.cosAngle),f.scale(t.normal,t.normal,o),f.add(e,e,t.normal)},a.applyCenterOffsetView=function(e,t,i){const n="screen"!==this.params.centerOffsetUnits;return i!==e&&f.copy(i,e),n&&(i[0]+=t[0],i[1]+=t[1],t[2]&&(f.normalize(R,i),f.add(i,i,f.scale(R,R,t[2])))),i},a.applyCenterOffsetNDC=function(e,t,i,n){const s="screen"!==this.params.centerOffsetUnits;return n!==e&&f.copy(n,e),s||(n[0]+=t[0]/i.fullWidth*2,n[1]+=t[1]/i.fullHeight*2),n},a.applyPolygonOffsetNDC=function(e,t,n,s){const r=this.params.shaderPolygonOffset;if(e!==s&&f.copy(s,e),r){const e=n.aboveGround?1:-1,a=e*i.sign(t[3]);s[2]-=(a||e)*r}return s},a.getGLMaterial=function(e){return 0===e.output||7===e.output?new _(e):4===e.output?new M(e):void 0},a.calculateRelativeScreenBounds=function(e,t,i=d.create()){return T(this.params,e,t,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i},s}(x.Material),z=function(e){function i(t){var i;return(i=e.call(this,{...t,...t.material.params})||this).updateParameters(),i}t._inheritsLoose(i,e);var n=i.prototype;return n.beginSlot=function(e){return e===(this._material.params.drawInSecondSlot?20:19)||23===e},n.updateParameters=function(e){this.updateTexture(this._material.params.textureId),this.selectProgram(e)},n.selectProgram=function(e){this._technique=this._techniqueRep.releaseAndAcquire(O.HUDMaterialTechnique,this._material.getTechniqueConfig(this._output,e),this._technique)},n.ensureParameters=function(e){this.updateParameters(e)},n.bind=function(e){this.bindTextures(this._technique.program),this.bindTextureScale(this._technique.program),this._technique.bindPass(this._material.params,e)},i}(v),_=function(e){function i(t){var i;return(i=e.call(this,t)||this)._isOcclusionSlot=!1,i}t._inheritsLoose(i,e);var n=i.prototype;return n.beginSlot=function(e){if(23===e)return!0;const t=this._material.params.drawInSecondSlot?20:19;return this._material.params.occlusionTest?(this._isOcclusionSlot=12===e,12===e||e===t):(this._isOcclusionSlot=!1,e===t)},n.selectProgram=function(e){this._technique=this._techniqueRep.releaseAndAcquire(O.HUDMaterialTechnique,this._material.getTechniqueConfig(this._output,e),this._technique),this._occlusionTechnique=this._techniqueRep.releaseAndAcquire(O.HUDMaterialTechnique,this._material.getTechniqueConfig(6,e),this._occlusionTechnique)},n.bind=function(e){const t=this.technique;this._isOcclusionSlot||(this.bindTextures(t.program),this.bindTextureScale(t.program)),t.bindPass(this._material.params,e)},t._createClass(i,[{key:"technique",get:function(){return this._isOcclusionSlot?this._occlusionTechnique:this._technique}}]),i}(z),M=function(e){function i(t){return e.call(this,{...t,output:4})||this}return t._inheritsLoose(i,e),i}(z);function T(e,t,i,n=E){return l.copy(n,e.anchorPos),n[0]*=-t[0],n[1]*=-t[1],n[0]+=e.screenOffset[0]*i,n[1]+=e.screenOffset[1]*i,n}function w(e){const t=e[0],i=e[1],n=e[2],s=e[3],r=e[4],a=e[5],o=e[6],c=e[7],l=e[8],u=1/Math.sqrt(t*t+i*i+n*n),f=1/Math.sqrt(s*s+r*r+a*a),h=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*u,e[1]=i*u,e[2]=n*u,e[3]=s*f,e[4]=r*f,e[5]=a*f,e[6]=o*h,e[7]=c*h,e[8]=l*h,e}function D(e,t,i,n,s,r,a,o){let c=t-s-(o[0]>0?n[0]*o[0]:0),l=c+n[0]+2*s,u=i-s-(o[1]>0?n[1]*o[1]:0),f=u+n[1]+2*s;if(a.textureIsSignedDistanceField){const e=a.distanceFieldBoundingBox;c+=n[0]*e[0],u+=n[1]*e[1],l-=n[0]*(1-e[2]),f-=n[1]*(1-e[3]),c-=r,l+=r,u-=r,f+=r}return e[0]>c&&e[0]<l&&e[1]>u&&e[1]<f}const V={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},E=u.create(),U=h.create(),R=h.create(),H=s.createRenderScreenPointArray3(),B=h.create(),I=h.create(),F=a.create(),G=a.create(),k=c.create(),L=h.create(),W={normal:B,cosAngle:0},N=c.create(),j=1,J=2,K=[0,0],Q=h.fromValues(0,0,1),X={texCoordScale:[1,1],occlusionTest:!0,binaryHighlightOcclusion:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,slicePlaneEnabled:!1,anchorPos:u.fromValues(.5,.5),shaderPolygonOffset:1e-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",depthEnabled:!0,pixelSnappingEnabled:!0,debugDrawBorder:!1,isDraped:!1,...x.materialParametersDefaults},Y=g.newLayout().vec3f("position").vec3f("normal").vec2f("uv0").vec4u8("color").vec2f("size").vec4f("auxpos1").vec4f("auxpos2");let Z=function(){function e(e){this.material=e,this.vertexBufferLayout=Y}var t=e.prototype;return t.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},t.elementCount=function(e){return 6*e.indices.get("position").length},t.write=function(e,t,i,n){y.writePosition(t.indices.get("position"),t.vertexAttributes.get("position").data,e.transformation,i.position,n,6),y.writeNormal(t.indices.get("normal"),t.vertexAttributes.get("normal").data,e.invTranspTransformation,i.normal,n,6);{const e=t.vertexAttributes.get("uv0").data;let s,r,a,o;if(null==e||e.length<4){const e=this.material.params;s=0,r=0,a=e.texCoordScale[0],o=e.texCoordScale[1]}else s=e[0],r=e[1],a=e[2],o=e[3];a=Math.min(1.99999,a+1),o=Math.min(1.99999,o+1);const c=t.indices.get("position").length,l=i.uv0;let u=n;for(let t=0;t<c;++t)l.set(u,0,s),l.set(u,1,r),u+=1,l.set(u,0,a),l.set(u,1,r),u+=1,l.set(u,0,a),l.set(u,1,o),u+=1,l.set(u,0,a),l.set(u,1,o),u+=1,l.set(u,0,s),l.set(u,1,o),u+=1,l.set(u,0,s),l.set(u,1,r),u+=1}y.writeColor(t.indices.get("color"),t.vertexAttributes.get("color").data,4,i.color,n,6);{const e=t.indices.get("size"),s=t.vertexAttributes.get("size").data,r=e.length,a=i.size;let o=n;for(let t=0;t<r;++t){const i=s[2*e[t]],n=s[2*e[t]+1];for(let e=0;e<6;++e)a.set(o,0,i),a.set(o,1,n),o+=1}}t.indices.get("auxpos1")&&t.vertexAttributes.get("auxpos1")&&y.writeBufferVec4(t.indices.get("auxpos1"),t.vertexAttributes.get("auxpos1").data,i.auxpos1,n,6),t.indices.get("auxpos2")&&t.vertexAttributes.get("auxpos2")&&y.writeBufferVec4(t.indices.get("auxpos2"),t.vertexAttributes.get("auxpos2").data,i.auxpos2,n,6)},e}();e.HUDMaterial=C,Object.defineProperty(e,"__esModule",{value:!0})}));
