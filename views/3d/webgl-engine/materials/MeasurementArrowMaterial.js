/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/vec3f64","../../../../chunks/vec3","../../support/buffer/InterleavedLayout","../lib/Util","../lib/GLMaterial","../lib/Material","../shaders/MeasurementArrowTechnique"],(function(t,e,n,r,i,s,o,a,u){"use strict";let c=function(t){function n(e,n){var r;return(r=t.call(this,n,e,l)||this).techniqueConfig=new u.MeasurementArrowTechniqueConfiguration,r}e._inheritsLoose(n,t);var r=n.prototype;return r.getTechniqueConfig=function(){return this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig},r.dispose=function(){},r.getPassParameters=function(){return this.params},r.intersect=function(){},r.createBufferWriter=function(){return new A},r.getGLMaterial=function(t){return 0===t.output?new f(t):void 0},n}(a.Material),f=function(t){function n(e){var n;return(n=t.call(this,e)||this).updateParameters(),n}e._inheritsLoose(n,t);var r=n.prototype;return r.updateParameters=function(){this.technique=this.techniqueRep.acquireAndReleaseExisting(u.MeasurementArrowTechnique,this.material.getTechniqueConfig(),this.technique)},r.beginSlot=function(t){return 3===t},r.bind=function(t,e){t.bindProgram(this.technique.program),this.technique.bindPass(t,this.material.getPassParameters(),e)},n}(o);const l={width:32,outlineSize:.2,outlineColor:[1,.5,0,1],stripeLength:1,stripeEvenColor:[1,1,1,1],stripeOddColor:[1,.5,0,1],polygonOffset:!1,...a.materialParametersDefaults},h=i.newLayout().vec3f(s.VertexAttrConstants.POSITION).vec3f(s.VertexAttrConstants.NORMAL).vec2f(s.VertexAttrConstants.UV0).f32(s.VertexAttrConstants.AUXPOS1),p=n.create(),m=n.create(),d=n.create(),g=n.create(),v=n.create();let A=function(){function t(){this.vertexBufferLayout=h}var e=t.prototype;return e.allocate=function(t){return this.vertexBufferLayout.createBuffer(t)},e.elementCount=function(t){return 2*(t.indices[s.VertexAttrConstants.POSITION].length/2+1)},e.write=function(t,e,n,i){const o=e.vertexAttr[s.VertexAttrConstants.POSITION].data,a=e.vertexAttr[s.VertexAttrConstants.NORMAL].data,u=o.length/3,c=e&&e.indices&&e.indices.position;c&&c.length!==2*(u-1)&&console.warn("MeasurementArrowMaterial does not support indices");const f=p,l=m,h=d,A=g,C=v,M=t.transformation,P=t.invTranspTransformation,q=n.position,x=n.normal,O=n.uv0;let b=0;for(let t=0;t<u;++t){const e=3*t;if(r.set(f,o[e],o[e+1],o[e+2]),t<u-1){const e=3*(t+1);r.set(l,o[e],o[e+1],o[e+2]),r.set(C,a[e],a[e+1],a[e+2]),r.normalize(C,C),r.subtract(h,l,f),r.normalize(h,h),r.cross(A,C,h),r.normalize(A,A)}const n=r.distance(f,l);M&&P&&(r.transformMat4(f,f,M),r.transformMat4(l,l,M),r.transformMat4(A,A,P));const s=i+2*t,c=s+1;q.setVec(s,f),q.setVec(c,f),x.setVec(s,A),x.setVec(c,A),O.set(s,0,b),O.set(s,1,-1),O.set(c,0,b),O.set(c,1,1),t<u-1&&(b+=n)}const w=n.auxpos1;for(let t=0;t<2*u;++t)w.set(i+t,b)},t}();t.MeasurementArrowMaterial=c,Object.defineProperty(t,"__esModule",{value:!0})}));
