/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{s as e,n as t,b as r,f as s,i as o,m as i}from"../../../../chunks/vec3.js";import{c as n}from"../../../../chunks/vec3f64.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as c}from"../core/shaderLibrary/ShaderOutputOptions.js";import{TransparencyPassType as u}from"../lib/basicInterfaces.js";import f from"../lib/GLMaterial.js";import{Material as l,MaterialParameters as p}from"../lib/Material.js";import{RenderSlot as h}from"../lib/RenderSlot.js";import{VertexAttribute as m}from"../lib/VertexAttribute.js";import{MeasurementArrowTechniqueConfiguration as d,MeasurementArrowTechnique as O}from"../shaders/MeasurementArrowTechnique.js";class g extends l{constructor(e){super(e,new v),this.techniqueConfig=new d}getConfiguration(e,t){return this.techniqueConfig.polygonOffsetEnabled=this.parameters.polygonOffset,this.techniqueConfig.transparent=this.parameters.stripeEvenColor[3]<1||this.parameters.stripeOddColor[3]<1||this.parameters.outlineColor[3]<1,this.techniqueConfig.transparencyPassType=t?.transparencyPassType??u.NONE,this.techniqueConfig}dispose(){}intersect(){}requiresSlot(e){return e===h.OPAQUE_MATERIAL}createGLMaterial(e){return e.output===c.Color?new b(e):null}createBufferWriter(){return new x}}class b extends f{beginSlot(e){return this.ensureTechnique(O,e)}}class v extends p{constructor(){super(...arguments),this.width=32,this.outlineSize=.2,this.outlineColor=[1,.5,0,1],this.stripeLength=1,this.stripeEvenColor=[1,1,1,1],this.stripeOddColor=[1,.5,0,1],this.polygonOffset=!1}}const C=a().vec3f(m.POSITION).vec3f(m.NORMAL).vec2f(m.UV0).f32(m.AUXPOS1),y=n(),A=n(),I=n(),T=n(),j=n();class x{constructor(){this.vertexBufferLayout=C}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 2*(e.indices.get(m.POSITION).length/2+1)}write(n,a,c,u){const f=a.vertexAttributes.get(m.POSITION).data,l=a.vertexAttributes.get(m.NORMAL).data,p=f.length/3,h=a&&a.indices&&a.indices.get(m.POSITION);h&&h.length!==2*(p-1)&&console.warn("MeasurementArrowMaterial does not support indices");const d=y,O=A,g=I,b=T,v=j,C=n.transformation,x=n.invTranspTransformation,L=c.position,S=c.normal,w=c.uv0;let M=0;for(let m=0;m<p;++m){const n=3*m;if(e(d,f[n],f[n+1],f[n+2]),m<p-1){const o=3*(m+1);e(O,f[o],f[o+1],f[o+2]),e(v,l[o],l[o+1],l[o+2]),t(v,v),r(g,O,d),t(g,g),s(b,v,g),t(b,b)}const a=o(d,O);C&&x&&(i(d,d,C),i(O,O,C),i(b,b,x));const c=u+2*m,h=c+1;L.setVec(c,d),L.setVec(h,d),S.setVec(c,b),S.setVec(h,b),w.set(c,0,M),w.set(c,1,-1),w.set(h,0,M),w.set(h,1,1),m<p-1&&(M+=a)}const q=c.auxpos1;for(let e=0;e<2*p;++e)q.set(u+e,M)}}export{g as MeasurementArrowMaterial,v as Parameters};
