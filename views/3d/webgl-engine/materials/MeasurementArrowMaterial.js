/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/vec3f64","../../../../chunks/vec3","../../support/buffer/InterleavedLayout","../lib/GLMaterial","../lib/Material","../shaders/MeasurementArrowTechnique"],(function(e,t,n,r,i,o,s,a){"use strict";let u=function(e){function n(t){var n;return(n=e.call(this,t,f)||this).techniqueConfig=new a.MeasurementArrowTechniqueConfiguration,n}t._inheritsLoose(n,e);var r=n.prototype;return r.getTechniqueConfig=function(){return this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig},r.dispose=function(){},r.getPassParameters=function(){return this.params},r.intersect=function(){},r.createBufferWriter=function(){return new v},r.getGLMaterial=function(e){return 0===e.output?new c(e):void 0},n}(s.Material),c=function(e){function n(t){var n;return(n=e.call(this,t)||this).updateParameters(),n}t._inheritsLoose(n,e);var r=n.prototype;return r.updateParameters=function(){this.technique=this.techniqueRep.acquireAndReleaseExisting(a.MeasurementArrowTechnique,this.material.getTechniqueConfig(),this.technique)},r.beginSlot=function(e){return 3===e},r.bind=function(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)},n}(o);const f={width:32,outlineSize:.2,outlineColor:[1,.5,0,1],stripeLength:1,stripeEvenColor:[1,1,1,1],stripeOddColor:[1,.5,0,1],polygonOffset:!1,...s.materialParametersDefaults},l=i.newLayout().vec3f("position").vec3f("normal").vec2f("uv0").f32("auxpos1"),h=n.create(),p=n.create(),m=n.create(),g=n.create(),d=n.create();let v=function(){function e(){this.vertexBufferLayout=l}var t=e.prototype;return t.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},t.elementCount=function(e){return 2*(e.indices.get("position").length/2+1)},t.write=function(e,t,n,i){const o=t.vertexAttributes.get("position").data,s=t.vertexAttributes.get("normal").data,a=o.length/3,u=t&&t.indices&&t.indices.get("position");u&&u.length!==2*(a-1)&&console.warn("MeasurementArrowMaterial does not support indices");const c=h,f=p,l=m,v=g,M=d,q=e.transformation,b=e.invTranspTransformation,w=n.position,y=n.normal,P=n.uv0;let C=0;for(let h=0;h<a;++h){const e=3*h;if(r.set(c,o[e],o[e+1],o[e+2]),h<a-1){const e=3*(h+1);r.set(f,o[e],o[e+1],o[e+2]),r.set(M,s[e],s[e+1],s[e+2]),r.normalize(M,M),r.subtract(l,f,c),r.normalize(l,l),r.cross(v,M,l),r.normalize(v,v)}const t=r.distance(c,f);q&&b&&(r.transformMat4(c,c,q),r.transformMat4(f,f,q),r.transformMat4(v,v,b));const n=i+2*h,u=n+1;w.setVec(n,c),w.setVec(u,c),y.setVec(n,v),y.setVec(u,v),P.set(n,0,C),P.set(n,1,-1),P.set(u,0,C),P.set(u,1,1),h<a-1&&(C+=t)}const L=n.auxpos1;for(let r=0;r<2*a;++r)L.set(i+r,C)},e}();e.MeasurementArrowMaterial=u,Object.defineProperty(e,"__esModule",{value:!0})}));
