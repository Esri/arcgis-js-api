/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/vec3","../../../../chunks/vec3f64","../../support/buffer/InterleavedLayout","../lib/GLMaterial","../lib/Material","../shaders/MeasurementArrowTechnique"],(function(e,t,n,r,i,o,s,a){"use strict";let u=function(e){function n(t){var n;return(n=e.call(this,t,f)||this).techniqueConfig=new a.MeasurementArrowTechniqueConfiguration,n}t._inheritsLoose(n,e);var r=n.prototype;return r.getTechniqueConfig=function(){return this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig},r.dispose=function(){},r.getPassParameters=function(){return this.params},r.intersect=function(){},r.createBufferWriter=function(){return new v},r.getGLMaterial=function(e){return 0===e.output?new c(e):void 0},n}(s.Material),c=function(e){function n(t){var n;return(n=e.call(this,t)||this).updateParameters(),n}t._inheritsLoose(n,e);var r=n.prototype;return r.updateParameters=function(){this._technique=this._techniqueRep.releaseAndAcquire(a.MeasurementArrowTechnique,this._material.getTechniqueConfig(),this._technique)},r.beginSlot=function(e){return 3===e},r.bind=function(e){this._technique.bindPass(this._material.getPassParameters(),e)},n}(o);const f={width:32,outlineSize:.2,outlineColor:[1,.5,0,1],stripeLength:1,stripeEvenColor:[1,1,1,1],stripeOddColor:[1,.5,0,1],polygonOffset:!1,...s.materialParametersDefaults},l=i.newLayout().vec3f("position").vec3f("normal").vec2f("uv0").f32("auxpos1"),h=r.create(),p=r.create(),m=r.create(),d=r.create(),g=r.create();let v=function(){function e(){this.vertexBufferLayout=l}var t=e.prototype;return t.allocate=function(e){return this.vertexBufferLayout.createBuffer(e)},t.elementCount=function(e){return 2*(e.indices.get("position").length/2+1)},t.write=function(e,t,r,i){const o=t.vertexAttributes.get("position").data,s=t.vertexAttributes.get("normal").data,a=o.length/3,u=t&&t.indices&&t.indices.get("position");u&&u.length!==2*(a-1)&&console.warn("MeasurementArrowMaterial does not support indices");const c=h,f=p,l=m,v=d,M=g,q=e.transformation,b=e.invTranspTransformation,w=r.position,y=r.normal,_=r.uv0;let C=0;for(let h=0;h<a;++h){const e=3*h;if(n.set(c,o[e],o[e+1],o[e+2]),h<a-1){const e=3*(h+1);n.set(f,o[e],o[e+1],o[e+2]),n.set(M,s[e],s[e+1],s[e+2]),n.normalize(M,M),n.subtract(l,f,c),n.normalize(l,l),n.cross(v,M,l),n.normalize(v,v)}const t=n.distance(c,f);q&&b&&(n.transformMat4(c,c,q),n.transformMat4(f,f,q),n.transformMat4(v,v,b));const r=i+2*h,u=r+1;w.setVec(r,c),w.setVec(u,c),y.setVec(r,v),y.setVec(u,v),_.set(r,0,C),_.set(r,1,-1),_.set(u,0,C),_.set(u,1,1),h<a-1&&(C+=t)}const P=r.auxpos1;for(let n=0;n<2*a;++n)P.set(i+n,C)},e}();e.MeasurementArrowMaterial=u,Object.defineProperty(e,"__esModule",{value:!0})}));
