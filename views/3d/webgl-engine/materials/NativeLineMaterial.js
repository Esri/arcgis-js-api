/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../../core/Logger.js";import{isSome as t,isNone as r}from"../../../../core/maybe.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{c as i}from"../../../../chunks/vec2.js";import{s as o,b as n,e as a,g as c,a as u,c as f,l,i as m,m as p}from"../../../../chunks/vec3.js";import{c as h}from"../../../../chunks/vec3f64.js";import{O as d}from"../../../../chunks/vec4f64.js";import{PlaneIndex as g}from"../../../../geometry/support/frustum.js";import{create as A,distance2 as O,fromPoints as S,closestLineSegmentPoint as j}from"../../../../geometry/support/lineSegment.js";import{create as T,fromPoints as _,signedDistance as C,normal as b}from"../../../../geometry/support/plane.js";import{BufferViewVec3f as y,BufferViewVec2f as P}from"../../../../geometry/support/buffer/BufferView.js";import{ShaderOutput as v}from"../core/shaderLibrary/ShaderOutputOptions.js";import{computeAttachmentOriginLines as x}from"../lib/geometryDataUtils.js";import N from"../lib/GLMaterial.js";import{Material as E,MaterialParameters as R}from"../lib/Material.js";import{RenderSlot as I}from"../lib/RenderSlot.js";import{isTranslationMatrix as L}from"../lib/Util.js";import{VertexAttribute as q}from"../lib/VertexAttribute.js";import{writeDefaultAttributes as w}from"./internal/bufferWriterUtils.js";import{PositionColorLayout as U,PositionLayout as B,DefaultBufferWriter as V}from"./internal/DefaultBufferWriter.js";import{intersectDrapedRenderLineGeometry as M}from"./internal/MaterialUtil.js";import{isInstanceHidden as D}from"./renderers/utils.js";import{NativeLineTechnique as k}from"../shaders/NativeLineTechnique.js";import{NativeLineTechniqueConfiguration as G}from"../shaders/NativeLineTechniqueConfiguration.js";const X=e.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");var F;!function(e){e[e.START=0]="START",e[e.END=1]="END"}(F||(F={}));class W extends E{constructor(e){super(e,new z),this._techniqueConfig=new G}getConfiguration(e,r){this._techniqueConfig.output=e,this._techniqueConfig.hasSlicePlane=this.parameters.hasSlicePlane,this._techniqueConfig.hasVertexColors=this.parameters.hasVertexColors,this._techniqueConfig.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._techniqueConfig.draped=r.slot===I.DRAPED_MATERIAL;const s=t(this.parameters.stipplePattern);return this._techniqueConfig.stippleEnabled=s,this._techniqueConfig.stippleOffColorEnabled=s&&t(this.parameters.stippleOffColor),this._techniqueConfig.hasOccludees=this.parameters.hasOccludees,this._techniqueConfig.stipplePreferContinuous=this.parameters.stipplePreferContinuous,this._techniqueConfig}intersect(e,r,s,i,o,n,a,c,u){t(u)?M(e,i,u,n,1,a):this._intersectLineGeometry(e,r,s,i,a)}_intersectLineGeometry(e,t,r,s,p){if(!s.options.selectionMode||D(t))return;if(!L(r))return void X.error("intersection assumes a translation-only matrix");const h=e.vertexAttributes.get(q.POSITION).data,d=s.camera,A=oe;i(A,s.point);const T=2;o(ne[0],A[0]-T,A[1]+T,0),o(ne[1],A[0]+T,A[1]+T,0),o(ne[2],A[0]+T,A[1]-T,0),o(ne[3],A[0]-T,A[1]-T,0);for(let i=0;i<4;i++)if(!d.unprojectFromRenderScreen(ne[i],ae[i]))return;_(d.eye,ae[0],ae[1],ce),_(d.eye,ae[1],ae[2],ue),_(d.eye,ae[2],ae[3],fe),_(d.eye,ae[3],ae[0],le);let y=Number.MAX_VALUE,P=0;for(let i=0;i<h.length-5;i+=3){if(J[0]=h[i]+r[12],J[1]=h[i+1]+r[13],J[2]=h[i+2]+r[14],K[0]=h[i+3]+r[12],K[1]=h[i+4]+r[13],K[2]=h[i+5]+r[14],C(ce,J)<0&&C(ce,K)<0||C(ue,J)<0&&C(ue,K)<0||C(fe,J)<0&&C(fe,K)<0||C(le,J)<0&&C(le,K)<0)continue;if(d.projectToRenderScreen(J,$),d.projectToRenderScreen(K,ee),$[2]<0&&ee[2]>0){n(Y,J,K);const e=d.frustum,t=-C(e[g.NEAR],J)/a(Y,b(e[g.NEAR]));c(Y,Y,t),u(J,J,Y),d.projectToRenderScreen(J,$)}else if($[2]>0&&ee[2]<0){n(Y,K,J);const e=d.frustum,t=-C(e[g.NEAR],K)/a(Y,b(e[g.NEAR]));c(Y,Y,t),u(K,K,Y),d.projectToRenderScreen(K,ee)}else if($[2]<0&&ee[2]<0)continue;$[2]=0,ee[2]=0;const e=O(S($,ee,se),A);e<y&&(y=e,f(te,J),f(re,K),P=i/3)}const v=s.rayBegin,x=s.rayEnd;if(y<T*T){let e=Number.MAX_VALUE;if(j(S(te,re,se),S(v,x,ie),Z)){n(Z,Z,v);const t=l(Z);c(Z,Z,1/t),e=t/m(v,x)}p(e,Z,P,!1)}}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return!1;const s=r.get(q.POSITION);return x(s,null,!1,t)}requiresSlot(e){return e===I.OPAQUE_MATERIAL||e===I.DRAPED_MATERIAL}createGLMaterial(e){return e.output===v.Color||e.output===v.Highlight?new H(e):null}createBufferWriter(){const e=this.parameters.hasVertexColors?U:B;return r(this.parameters.stipplePattern)?new V(e):new Q(e.clone().vec3f(q.AUXPOS1).vec2f(q.UV0))}}class H extends N{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output===v.Color&&this._updateOccludeeState(e),this.ensureTechnique(k,e)}}class Q{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(q.POSITION).length}write(e,t,r,s){w(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,r,s),this._writeAuxpos1(e,t,r,s),this._writeUV0(e,t,r,s)}_writeAuxpos1(e,t,r,s){const i=r.getField(q.AUXPOS1,y),o=t.indices.get(q.POSITION),n=t.vertexAttributes.get(q.POSITION).data,a=e.transformation,c=i.typedBufferStride,u=i.typedBuffer;s*=c;for(let f=0;f<o.length-1;f+=2)for(const e of[1,0]){const t=3*o[f+e],r=n[t],i=n[t+1],l=n[t+2],m=a[0]*r+a[4]*i+a[8]*l+a[12],p=a[1]*r+a[5]*i+a[9]*l+a[13],h=a[2]*r+a[6]*i+a[10]*l+a[14];u[s]=m,u[s+1]=p,u[s+2]=h,s+=c}}_writeUV0(e,t,r,s){const i=r.getField(q.UV0,P),n=t.indices.get(q.POSITION),a=t.vertexAttributes.get(q.POSITION).data,c=t.vertexAttributes.get(q.DISTANCETOSTART)?.data,u=e.transformation,l=i.typedBufferStride,h=i.typedBuffer;let d=0;h[s*=l]=F.START,h[s+1]=d,s+=l;const g=3*n[0],A=o(J,a[g],a[g+1],a[g+2]);u&&p(A,A,u);const O=K,S=n.length-1;let j=1;const T=c?(e,t,r)=>d=c[r]:(e,t,r)=>d+=m(e,t);for(let m=1;m<S;m+=2){const e=3*n[m];o(O,a[e],a[e+1],a[e+2]),u&&p(O,O,u),T(A,O,j++);for(let t=0;t<2;++t)h[s]=1-t,h[s+1]=d,s+=l;f(A,O)}const _=3*n[S];o(O,a[_],a[_+1],a[_+2]),u&&p(O,O,u),T(A,O,j),h[s]=F.END,h[s+1]=d}}class z extends R{constructor(){super(...arguments),this.color=d,this.hasVertexColors=!1,this.hasSlicePlane=!1,this.width=1,this.stipplePreferContinuous=!0,this.hasOccludees=!1}}const J=h(),K=h(),Y=h(),Z=h(),$=s(),ee=s(),te=h(),re=h(),se=A(),ie=A(),oe=h(),ne=[s(),s(),s(),s()],ae=[h(),h(),h(),h()],ce=T(),ue=T(),fe=T(),le=T();export{W as NativeLineMaterial,z as Parameters};
