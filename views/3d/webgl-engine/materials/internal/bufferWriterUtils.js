/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../support/buffer/BufferView","../../lib/Util"],(function(e,t,f){"use strict";function r(e,t,f,r,s){const o=f.typedBuffer,n=f.typedBufferStride,i=e.length;if(r*=n,null==s||1===s)for(let f=0;f<i;++f){const s=2*e[f];o[r]=t[s],o[r+1]=t[s+1],r+=n}else for(let f=0;f<i;++f){const i=2*e[f];for(let e=0;e<s;++e)o[r]=t[i],o[r+1]=t[i+1],r+=n}}function s(e,t,f,r,s){const o=f.typedBuffer,n=f.typedBufferStride,i=e.length;if(r*=n,null==s||1===s)for(let f=0;f<i;++f){const s=3*e[f];o[r]=t[s],o[r+1]=t[s+1],o[r+2]=t[s+2],r+=n}else for(let f=0;f<i;++f){const i=3*e[f];for(let e=0;e<s;++e)o[r]=t[i],o[r+1]=t[i+1],o[r+2]=t[i+2],r+=n}}function o(e,t,f,r,s){const o=f.typedBuffer,n=f.typedBufferStride,i=e.length;if(r*=n,null==s||1===s)for(let f=0;f<i;++f){const s=4*e[f];o[r]=t[s],o[r+1]=t[s+1],o[r+2]=t[s+2],o[r+3]=t[s+3],r+=n}else for(let f=0;f<i;++f){const i=4*e[f];for(let e=0;e<s;++e)o[r]=t[i],o[r+1]=t[i+1],o[r+2]=t[i+2],o[r+3]=t[i+3],r+=n}}function n(e,t,f,r,o,n){if(f){const s=f,i=r.typedBuffer,l=r.typedBufferStride,c=e.length;if(o*=l,null==n||1===n)for(let f=0;f<c;++f){const r=3*e[f],n=t[r],c=t[r+1],a=t[r+2];i[o]=s[0]*n+s[4]*c+s[8]*a+s[12],i[o+1]=s[1]*n+s[5]*c+s[9]*a+s[13],i[o+2]=s[2]*n+s[6]*c+s[10]*a+s[14],o+=l}else for(let f=0;f<c;++f){const r=3*e[f],c=t[r],a=t[r+1],u=t[r+2],d=s[0]*c+s[4]*a+s[8]*u+s[12],B=s[1]*c+s[5]*a+s[9]*u+s[13],V=s[2]*c+s[6]*a+s[10]*u+s[14];for(let e=0;e<n;++e)i[o]=d,i[o+1]=B,i[o+2]=V,o+=l}}else s(e,t,r,o,n)}function i(e,t,f,r,o,n){if(f){const s=f,i=r.typedBuffer,l=r.typedBufferStride,c=e.length,a=s[0],u=s[1],d=s[2],B=s[4],V=s[5],p=s[6],w=s[8],y=s[9],g=s[10],A=Math.abs(1-a*a+B*B+w*w)>1e-5||Math.abs(1-u*u+V*V+y*y)>1e-5||Math.abs(1-d*d+p*p+g*g)>1e-5;if(o*=l,null==n||1===n)for(let f=0;f<c;++f){const r=3*e[f],s=t[r],n=t[r+1],c=t[r+2];let b=a*s+B*n+w*c,C=u*s+V*n+y*c,h=d*s+p*n+g*c;if(A){const e=b*b+C*C+h*h;if(e<.999999&&e>1e-6){const t=Math.sqrt(e);b/=t,C/=t,h/=t}}i[o+0]=b,i[o+1]=C,i[o+2]=h,o+=l}else for(let f=0;f<c;++f){const r=3*e[f],s=t[r],c=t[r+1],b=t[r+2];let C=a*s+B*c+w*b,h=u*s+V*c+y*b,O=d*s+p*c+g*b;if(A){const e=C*C+h*h+O*O;if(e<.999999&&e>1e-6){const t=Math.sqrt(e);C/=t,h/=t,O/=t}}for(let e=0;e<n;++e)i[o+0]=C,i[o+1]=h,i[o+2]=O,o+=l}}else s(e,t,r,o,n)}function l(e,t,f,r,s,o){const n=r.typedBuffer,i=r.typedBufferStride,l=e.length;if(s*=i,null==o||1===o){if(4===f)for(let f=0;f<l;++f){const r=4*e[f];n[s]=t[r],n[s+1]=t[r+1],n[s+2]=t[r+2],n[s+3]=t[r+3],s+=i}else if(3===f)for(let f=0;f<l;++f){const r=3*e[f];n[s]=t[r],n[s+1]=t[r+1],n[s+2]=t[r+2],n[s+3]=255,s+=i}}else if(4===f)for(let f=0;f<l;++f){const r=4*e[f];for(let e=0;e<o;++e)n[s]=t[r],n[s+1]=t[r+1],n[s+2]=t[r+2],n[s+3]=t[r+3],s+=i}else if(3===f)for(let f=0;f<l;++f){const r=3*e[f];for(let e=0;e<o;++e)n[s]=t[r],n[s+1]=t[r+1],n[s+2]=t[r+2],n[s+3]=255,s+=i}}e.writeBufferMat3f=function(e,t,f,r){const s=f.typedBuffer,o=f.typedBufferStride,n=e.length;r*=o;for(let f=0;f<n;++f){const n=9*e[f];for(let e=0;e<9;++e)s[r+e]=t[n+e];r+=o}},e.writeBufferMat4f=function(e,t,f,r){const s=f.typedBuffer,o=f.typedBufferStride,n=e.length;r*=o;for(let f=0;f<n;++f){const n=16*e[f];for(let e=0;e<16;++e)s[r+e]=t[n+e];r+=o}},e.writeBufferVec2=r,e.writeBufferVec3=s,e.writeBufferVec4=o,e.writeColor=l,e.writeDefaultAttributes=function(e,s,c,a,u,d){for(const B of s.fieldNames){const s=e.vertexAttr[B],V=e.indices[B];if(s&&V)switch(B){case f.VertexAttrConstants.POSITION:{f.assert(3===s.size);const e=u.getField(B,t.BufferViewVec3f);e&&n(V,s.data,c,e,d);break}case f.VertexAttrConstants.NORMAL:{f.assert(3===s.size);const e=u.getField(B,t.BufferViewVec3f);e&&i(V,s.data,a,e,d);break}case f.VertexAttrConstants.UV0:{f.assert(2===s.size);const e=u.getField(B,t.BufferViewVec2f);e&&r(V,s.data,e,d);break}case f.VertexAttrConstants.UVMAPSPACE:{f.assert(4===s.size);const e=u.getField(B,t.BufferViewVec4f);e&&o(V,s.data,e,d);break}case f.VertexAttrConstants.MEANVERTEXPOSITION:{f.assert(3===s.size);const e=u.getField(B,t.BufferViewVec3f);e&&n(V,s.data,c,e,d);break}case f.VertexAttrConstants.BOUND1:case f.VertexAttrConstants.BOUND2:case f.VertexAttrConstants.BOUND3:{f.assert(3===s.size);const e=u.getField(B,t.BufferViewVec3f);e&&n(V,s.data,c,e,d);break}case f.VertexAttrConstants.COLOR:{f.assert(3===s.size||4===s.size);const e=u.getField(B,t.BufferViewVec4u8);e&&l(V,s.data,s.size,e,d);break}case f.VertexAttrConstants.SYMBOLCOLOR:{f.assert(3===s.size||4===s.size);const e=u.getField(B,t.BufferViewVec4u8);e&&l(V,s.data,s.size,e,d);break}case f.VertexAttrConstants.TANGENT:{f.assert(4===s.size);const e=u.getField(B,t.BufferViewVec4f);e&&o(V,s.data,e,d);break}}}},e.writeMultipliedColor=function(e,t,f,r,s,o,n){const i=s.typedBuffer,l=s.typedBufferStride,c=e.length;if(o*=l,null==n||1===n){if(4===f)for(let f=0;f<c;++f){const s=4*e[f];i[o]=t[s]*r[0],i[o+1]=t[s+1]*r[1],i[o+2]=t[s+2]*r[2],i[o+3]=t[s+3]*r[3],o+=l}else if(3===f){const f=255*r[3];for(let s=0;s<c;++s){const n=3*e[s];i[o]=t[n]*r[0],i[o+1]=t[n+1]*r[1],i[o+2]=t[n+2]*r[2],i[o+3]=f,o+=l}}}else if(4===f)for(let f=0;f<c;++f){const s=4*e[f];for(let e=0;e<n;++e)i[o]=t[s]*r[0],i[o+1]=t[s+1]*r[1],i[o+2]=t[s+2]*r[2],i[o+3]=t[s+3]*r[3],o+=l}else if(3===f){const f=255*r[3];for(let s=0;s<c;++s){const c=3*e[s];for(let e=0;e<n;++e)i[o]=t[c]*r[0],i[o+1]=t[c+1]*r[1],i[o+2]=t[c+2]*r[2],i[o+3]=f,o+=l}}},e.writeNormal=i,e.writePosition=n,Object.defineProperty(e,"__esModule",{value:!0})}));
