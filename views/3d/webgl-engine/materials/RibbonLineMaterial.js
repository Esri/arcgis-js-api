/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../../core/Logger.js";import{clamp as t}from"../../../../core/mathUtils.js";import{isSome as r}from"../../../../core/maybe.js";import{createRenderScreenPointArray3 as i}from"../../../../core/screenUtils.js";import{c as s}from"../../../../chunks/vec2.js";import{s as a,b as n,e as o,g as h,a as l,c,l as u,i as p,m}from"../../../../chunks/vec3.js";import{c as f}from"../../../../chunks/vec3f64.js";import{O as T}from"../../../../chunks/vec4f64.js";import{PlaneIndex as E}from"../../../../geometry/support/frustum.js";import{create as d,distance2 as A,fromPoints as v,closestLineSegmentPoint as _}from"../../../../geometry/support/lineSegment.js";import{create as R,fromPoints as S,signedDistance as O,normal as I}from"../../../../geometry/support/plane.js";import{newLayout as g}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as b}from"../core/shaderLibrary/ShaderOutputOptions.js";import{computeAttachmentOriginLines as C}from"../lib/geometryDataUtils.js";import L from"../lib/GLMaterial.js";import{outputFromPass as N}from"../lib/GLMaterials.js";import{Material as P,RenderOccludedFlag as y}from"../lib/Material.js";import{RenderSlot as D}from"../lib/RenderSlot.js";import{isTranslationMatrix as j}from"../lib/Util.js";import{VertexAttribute as U}from"../lib/VertexAttribute.js";import{VisualVariablePassParameters as F}from"./VisualVariablePassParameters.js";import{isInstanceHidden as x}from"./renderers/utils.js";import{N as q}from"../../../../chunks/RibbonLine.glsl.js";import{ribbonVertexAttributeLocations as M,RibbonLineTechnique as w}from"../shaders/RibbonLineTechnique.js";import{RibbonLineTechniqueConfiguration as G,CapType as J}from"../shaders/RibbonLineTechniqueConfiguration.js";const z=e.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial");var B;!function(e){e[e.LEFT_JOIN_START=-2]="LEFT_JOIN_START",e[e.LEFT_JOIN_END=-1]="LEFT_JOIN_END",e[e.LEFT_CAP_START=-4]="LEFT_CAP_START",e[e.LEFT_CAP_END=-5]="LEFT_CAP_END",e[e.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",e[e.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",e[e.RIGHT_CAP_START=4]="RIGHT_CAP_START",e[e.RIGHT_CAP_END=5]="RIGHT_CAP_END"}(B||(B={}));class H extends P{constructor(e){super(e,new V),this._vertexAttributeLocations=M,this.techniqueConfig=new G,this.layout=this.createLayout()}isClosed(e,t){return Y(this.parameters,e,t)}getConfiguration(e,t){this.techniqueConfig.output=e,this.techniqueConfig.draped=t.slot===D.DRAPED_MATERIAL;const i=r(this.parameters.stipplePattern)&&e!==b.Highlight;return this.techniqueConfig.stippleEnabled=i,this.techniqueConfig.stippleOffColorEnabled=i&&r(this.parameters.stippleOffColor),this.techniqueConfig.stippleScaleWithLineWidth=i&&this.parameters.stippleScaleWithLineWidth,this.techniqueConfig.stipplePreferContinuous=i&&this.parameters.stipplePreferContinuous,this.techniqueConfig.hasSlicePlane=this.parameters.hasSlicePlane,this.techniqueConfig.hasOccludees=this.parameters.hasOccludees,this.techniqueConfig.roundJoins="round"===this.parameters.join,this.techniqueConfig.capType=this.parameters.cap,this.techniqueConfig.hasPolygonOffset=this.parameters.hasPolygonOffset,this.techniqueConfig.writeDepth=this.parameters.writeDepth,this.techniqueConfig.vvColor=this.parameters.vvColorEnabled,this.techniqueConfig.vvOpacity=this.parameters.vvOpacityEnabled,this.techniqueConfig.vvSize=this.parameters.vvSizeEnabled,this.techniqueConfig.innerColorEnabled=this.parameters.innerWidth>0&&r(this.parameters.innerColor),this.techniqueConfig.falloffEnabled=this.parameters.falloff>0,this.techniqueConfig.occluder=this.parameters.renderOccluded===y.OccludeAndTransparentStencil,this.techniqueConfig.transparencyPassType=t.transparencyPassType,this.techniqueConfig.hasMultipassTerrain=t.multipassTerrain.enabled,this.techniqueConfig.cullAboveGround=t.multipassTerrain.cullAboveGround,this.techniqueConfig.wireframe=this.parameters.wireframe,this.techniqueConfig}intersect(e,t,i,s,a,n,o,h,l){r(l)?this._intersectDrapedLineGeometry(e,s,l,n,o):this._intersectLineGeometry(e,t,i,s,o)}_intersectDrapedLineGeometry(e,r,i,s,a){if(!r.options.selectionMode)return;const n=e.vertexAttributes.get(U.POSITION).data,o=e.vertexAttributes.get(U.SIZE);let h=this.parameters.width;if(this.parameters.vvSizeEnabled){const r=e.vertexAttributes.get(U.SIZEFEATUREATTRIBUTE).data[0];h*=t(this.parameters.vvSizeOffset[0]+r*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else o&&(h*=o.data[0]);const l=s[0],c=s[1],u=(h/2+4)*e.screenToWorldRatio;let p=Number.MAX_VALUE,m=0;for(let f=0;f<n.length-5;f+=3){const e=n[f],r=n[f+1],i=l-e,s=c-r,a=n[f+3]-e,o=n[f+4]-r,h=t((a*i+o*s)/(a*a+o*o),0,1),u=a*h-i,T=o*h-s,E=u*u+T*T;E<p&&(p=E,m=f/3)}p<u*u&&a(i.dist,i.normal,m,!1)}_intersectLineGeometry(e,r,i,m,f){if(!m.options.selectionMode||x(r))return;if(!j(i))return void z.error("intersection assumes a translation-only matrix");const T=e.vertexAttributes,d=T.get(U.POSITION).data;let R=this.parameters.width;if(this.parameters.vvSizeEnabled){const e=T.get(U.SIZEFEATUREATTRIBUTE).data[0];R*=t(this.parameters.vvSizeOffset[0]+e*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else T.has(U.SIZE)&&(R*=T.get(U.SIZE).data[0]);const g=m.camera,b=te;s(b,m.point);const C=R*g.pixelRatio/2+4*g.pixelRatio;a(ue[0],b[0]-C,b[1]+C,0),a(ue[1],b[0]+C,b[1]+C,0),a(ue[2],b[0]+C,b[1]-C,0),a(ue[3],b[0]-C,b[1]-C,0);for(let t=0;t<4;t++)if(!g.unprojectFromRenderScreen(ue[t],pe[t]))return;S(g.eye,pe[0],pe[1],me),S(g.eye,pe[1],pe[2],fe),S(g.eye,pe[2],pe[3],Te),S(g.eye,pe[3],pe[0],Ee);let L=Number.MAX_VALUE,N=0;const P=X(this.parameters,T,e.indices)?d.length-2:d.length-5;for(let t=0;t<P;t+=3){Q[0]=d[t]+i[12],Q[1]=d[t+1]+i[13],Q[2]=d[t+2]+i[14];const e=(t+3)%d.length;if(K[0]=d[e]+i[12],K[1]=d[e+1]+i[13],K[2]=d[e+2]+i[14],O(me,Q)<0&&O(me,K)<0||O(fe,Q)<0&&O(fe,K)<0||O(Te,Q)<0&&O(Te,K)<0||O(Ee,Q)<0&&O(Ee,K)<0)continue;if(g.projectToRenderScreen(Q,re),g.projectToRenderScreen(K,ie),re[2]<0&&ie[2]>0){n($,Q,K);const e=g.frustum,t=-O(e[E.NEAR],Q)/o($,I(e[E.NEAR]));h($,$,t),l(Q,Q,$),g.projectToRenderScreen(Q,re)}else if(re[2]>0&&ie[2]<0){n($,K,Q);const e=g.frustum,t=-O(e[E.NEAR],K)/o($,I(e[E.NEAR]));h($,$,t),l(K,K,$),g.projectToRenderScreen(K,ie)}else if(re[2]<0&&ie[2]<0)continue;re[2]=0,ie[2]=0;const r=A(v(re,ie,ne),b);r<L&&(L=r,c(se,Q),c(ae,K),N=t/3)}const y=m.rayBegin,D=m.rayEnd;if(L<C*C){let e=Number.MAX_VALUE;if(_(v(se,ae,ne),v(y,D,oe),ee)){n(ee,ee,y);const t=u(ee);h(ee,ee,1/t),e=t/p(y,D)}f(e,ee,N,!1)}}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return null;const i=e.indices,s=r.get(U.POSITION);return C(s,i?i.get(U.POSITION):null,i&&X(this.parameters,r,i),t)}createLayout(){const e=g().vec3f(U.POSITION).f32(U.SUBDIVISIONFACTOR).vec2f(U.UV0).vec3f(U.AUXPOS1).vec3f(U.AUXPOS2);return this.parameters.vvSizeEnabled?e.f32(U.SIZEFEATUREATTRIBUTE):e.f32(U.SIZE),this.parameters.vvColorEnabled?e.f32(U.COLORFEATUREATTRIBUTE):e.vec4f(U.COLOR),this.parameters.vvOpacityEnabled&&e.f32(U.OPACITYFEATUREATTRIBUTE),e}createBufferWriter(){return new Z(this.layout,this.parameters)}requiresSlot(e,t){if(e===D.DRAPED_MATERIAL)return!0;if(this.parameters.renderOccluded===y.OccludeAndTransparentStencil)return e===D.OPAQUE_MATERIAL||e===D.OCCLUDER_MATERIAL||e===D.TRANSPARENT_OCCLUDER_MATERIAL;const r=N(t);if(r===b.Color||r===b.Alpha){return e===(this.parameters.writeDepth?D.TRANSPARENT_MATERIAL:D.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL)}return e===D.OPAQUE_MATERIAL}createGLMaterial(e){return e.output===b.Color||e.output===b.Alpha||e.output===b.Highlight||e.output===b.Depth?new W(e):null}validateParameters(e){"miter"!==e.join&&(e.miterLimit=0)}}class W extends L{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output!==b.Color&&this._output!==b.Alpha||this._updateOccludeeState(e),this.ensureTechnique(w,e)}}class V extends F{constructor(){super(...arguments),this.width=0,this.color=T,this.join="miter",this.cap=J.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class Z{constructor(e,t){this.parameters=t,this.numJoinSubdivisions=0,this.vertexBufferLayout=e;const r=t.stipplePattern?1:0;switch(this.parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=r;break;case"round":this.numJoinSubdivisions=q+r}}_isClosed(e){return X(this.parameters,e.vertexAttributes,e.indices)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=2,r=e.indices.get(U.POSITION).length/2+1,i=this._isClosed(e);let s=i?2:2*t;return s+=((i?r:r-1)-(i?0:1))*(2*this.numJoinSubdivisions+4),s+=2,this.parameters.wireframe&&(s=2+4*(s-2)),s}write(e,t,r,i){const s=he,n=le,o=ce,h=t.vertexAttributes.get(U.POSITION).data,l=t.indices&&t.indices.get(U.POSITION),u=t.vertexAttributes.get(U.DISTANCETOSTART)?.data;l&&l.length!==2*(h.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let f=1,T=0;this.parameters.vvSizeEnabled?T=t.vertexAttributes.get(U.SIZEFEATUREATTRIBUTE).data[0]:t.vertexAttributes.has(U.SIZE)&&(f=t.vertexAttributes.get(U.SIZE).data[0]);let E=[1,1,1,1],d=0;this.parameters.vvColorEnabled?d=t.vertexAttributes.get(U.COLORFEATUREATTRIBUTE).data[0]:t.vertexAttributes.has(U.COLOR)&&(E=t.vertexAttributes.get(U.COLOR).data);let A=0;this.parameters.vvOpacityEnabled&&(A=t.vertexAttributes.get(U.OPACITYFEATUREATTRIBUTE).data[0]);const v=h.length/3,_=e.transformation,R=new Float32Array(r.buffer),S=this.vertexBufferLayout.stride/4;let O=i*S;const I=O;let g=0;const b=u?(e,t,r)=>g=u[r]:(e,t,r)=>g+=p(e,t),C=(e,t,r,i,s,a,n)=>{if(R[O++]=t[0],R[O++]=t[1],R[O++]=t[2],R[O++]=i,R[O++]=n,R[O++]=s,R[O++]=e[0],R[O++]=e[1],R[O++]=e[2],R[O++]=r[0],R[O++]=r[1],R[O++]=r[2],this.parameters.vvSizeEnabled?R[O++]=T:R[O++]=f,this.parameters.vvColorEnabled)R[O++]=d;else{const e=Math.min(4*a,E.length-4);R[O++]=E[e+0],R[O++]=E[e+1],R[O++]=E[e+2],R[O++]=E[e+3]}this.parameters.vvOpacityEnabled&&(R[O++]=A)};O+=S,a(n,h[0],h[1],h[2]),_&&m(n,n,_);const L=this._isClosed(t);if(L){const e=h.length-3;a(s,h[e],h[e+1],h[e+2]),_&&m(s,s,_)}else a(o,h[3],h[4],h[5]),_&&m(o,o,_),C(n,n,o,1,B.LEFT_CAP_START,0,0),C(n,n,o,1,B.RIGHT_CAP_START,0,0),c(s,n),c(n,o);const N=L?0:1,P=L?v:v-1;for(let p=N;p<P;p++){const e=(p+1)%v*3;a(o,h[e+0],h[e+1],h[e+2]),_&&m(o,o,_),b(s,n,p),C(s,n,o,0,B.LEFT_JOIN_END,p,g),C(s,n,o,0,B.RIGHT_JOIN_END,p,g);const t=this.numJoinSubdivisions;for(let r=0;r<t;++r){const e=(r+1)/(t+1);C(s,n,o,e,B.LEFT_JOIN_END,p,g),C(s,n,o,e,B.RIGHT_JOIN_END,p,g)}C(s,n,o,1,B.LEFT_JOIN_START,p,g),C(s,n,o,1,B.RIGHT_JOIN_START,p,g),c(s,n),c(n,o)}L?(a(o,h[3],h[4],h[5]),_&&m(o,o,_),g=b(s,n,P),C(s,n,o,0,B.LEFT_JOIN_END,N,g),C(s,n,o,0,B.RIGHT_JOIN_END,N,g)):(g=b(s,n,P),C(s,n,n,0,B.LEFT_CAP_END,P,g),C(s,n,n,0,B.RIGHT_CAP_END,P,g)),k(R,I+S,R,I,S);O=k(R,O-S,R,O,S),this.parameters.wireframe&&this._addWireframeVertices(r,I,O,S)}_addWireframeVertices(e,t,r,i){const s=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT),a=new Float32Array(e.buffer,t*Float32Array.BYTES_PER_ELEMENT,r-t);let n=0;const o=e=>n=k(a,e,s,n,i);for(let h=0;h<a.length-1;h+=2*i)o(h),o(h+2*i),o(h+1*i),o(h+2*i),o(h+1*i),o(h+3*i)}}function k(e,t,r,i,s){for(let a=0;a<s;a++)r[i++]=e[t++];return i}function X(e,t,r){return Y(e,t.get(U.POSITION).data,r?r.get(U.POSITION):null)}function Y(e,t,r){return!!e.isClosed&&(r?r.length>2:t.length>6)}const Q=f(),K=f(),$=f(),ee=f(),te=f(),re=i(),ie=i(),se=f(),ae=f(),ne=d(),oe=d(),he=f(),le=f(),ce=f(),ue=[i(),i(),i(),i()],pe=[f(),f(),f(),f()],me=R(),fe=R(),Te=R(),Ee=R();export{V as Parameters,H as RibbonLineMaterial};
