// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.17/esri/copyright.txt for details.

define(["require","exports","tslib","../../../../../../../geometry/support/geodesicConstants","./ComponentData.glsl","./VertexDiscardByOpacity.glsl","../../../../core/shaderLibrary/ForwardLinearDepth.glsl","../../../../core/shaderLibrary/Slice.glsl","../../../../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl","../../../../core/shaderLibrary/attributes/VertexColor.glsl","../../../../core/shaderLibrary/attributes/VertexNormal.glsl","../../../../core/shaderLibrary/attributes/VertexPosition.glsl","../../../../core/shaderLibrary/output/OutputDepth.glsl","../../../../core/shaderLibrary/output/OutputHighlight.glsl","../../../../core/shaderLibrary/shading/ComputeMaterialColor.glsl","../../../../core/shaderLibrary/shading/ComputeNormalTexture.glsl","../../../../core/shaderLibrary/shading/ComputeShadingNormal.glsl","../../../../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../../../../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl","../../../../core/shaderLibrary/shading/ReadBaseColorTexture.glsl","../../../../core/shaderLibrary/shading/ReadShadowMap.glsl","../../../../core/shaderLibrary/terrain/Overlay.glsl","../../../../core/shaderLibrary/util/AlphaDiscard.glsl","../../../../core/shaderModules/interfaces","../../../../core/shaderModules/ShaderBuilder"],(function(e,a,o,r,n,l,t,i,d,s,c,m,v,g,u,h,p,C,b,x,y,w,O,f,_){"use strict";var T,S,L,N,j,M,W,k,P,B,A,R,D,V,z,F,E,I,G,q,H,J,K,Q,U,X,Y,Z,$,ee,ae,oe,re;Object.defineProperty(a,"__esModule",{value:!0}),a.build=a.attributeLocations=void 0,a.attributeLocations={position:0,normal:1,normalCompressed:1,color:2,uv0:3,uvRegion:4,componentIndex:5},a.build=function(e){var a=new _.ShaderBuilder;a.include(m.VertexPosition,e),a.include(c.VertexNormal,e),a.include(s.VertexColor,e),a.include(d.TextureCoordinateAttribute,e),a.include(t.ForwardLinearDepth,e),a.include(n.ComponentData,e),a.include(O.DiscardOrAdjustAlpha,e),a.include(i.Slice,e),a.include(x.ReadBaseColorTexture,e),a.include(l.VertexDiscardByOpacity,e),a.fragment.uniforms.add("view","mat4"),1!==e.pbrMode&&2!==e.pbrMode||(a.include(b.PhysicallyBasedRenderingParameters,e),a.include(h.ComputeNormalTexture,e)),3===e.output&&1===e.componentData?a.vertex.code.add(f.glsl(T||(T=o.__makeTemplateObject(["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "],["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "])))):a.vertex.code.add(f.glsl(S||(S=o.__makeTemplateObject(["\n      #define discardShadows(castShadows) {}\n    "],["\n      #define discardShadows(castShadows) {}\n    "]))));var ne=e.overlayEnabled&&0===e.output&&4===e.pbrMode;return e.overlayEnabled&&(a.include(w.Overlay,e),1===e.viewingMode?a.vertex.code.add(f.glsl(L||(L=o.__makeTemplateObject(["\n      const float invEarthRadius = ",";\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEarthRadius * pos.z);\n      }\n      "],["\n      const float invEarthRadius = ",";\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEarthRadius * pos.z);\n      }\n      "])),f.glsl.float(1/r.earthRadius))):a.vertex.code.add(f.glsl(N||(N=o.__makeTemplateObject(["\n      vec2 projectOverlay(vec3 pos) { return pos.xy; }\n      "],["\n      vec2 projectOverlay(vec3 pos) { return pos.xy; }\n      "]))))),ne&&(a.varyings.add("tbnTangent","vec3"),a.varyings.add("tbnBiTangent","vec3"),a.varyings.add("groundNormal","vec3"),a.varyings.add("positionView","vec3")),a.vertex.code.add(f.glsl(P||(P=o.__makeTemplateObject(["\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a < ",") {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n      forwardPosition();\n      forwardNormal();\n      ","\n\n      ","\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "],["\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a < ",") {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n      forwardPosition();\n      forwardNormal();\n      ","\n\n      ","\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "])),f.glsl.float(O.symbolAlphaCutoff),ne?f.glsl(W||(W=o.__makeTemplateObject(["\n        positionView = position_view();\n        ","\n        "],["\n        positionView = position_view();\n        ","\n        "])),1===e.viewingMode?f.glsl(j||(j=o.__makeTemplateObject(["\n        groundNormal = normalize(positionWorld());\n        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));"],["\n        groundNormal = normalize(positionWorld());\n        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));"]))):f.glsl(M||(M=o.__makeTemplateObject(["\n        groundNormal = vec3(0.0, 0.0, 1.0);\n        tbnTangent = vec3(1.0, 0.0, 0.0);\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));"],["\n        groundNormal = vec3(0.0, 0.0, 1.0);\n        tbnTangent = vec3(1.0, 0.0, 0.0);\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));"])))):"",e.overlayEnabled?f.glsl(k||(k=o.__makeTemplateObject(["setOverlayVTC(projectOverlay(position));"],["setOverlayVTC(projectOverlay(position));"]))):"")),0===e.output&&(a.include(u.ComputeMaterialColor,e),a.include(p.ComputeShadingNormal,e),a.include(C.EvaluateSceneLighting,e),ne&&(a.fragment.uniforms.add("ovInnerNormalTex","sampler2D"),a.fragment.uniforms.add("ovOuterNormalTex","sampler2D")),e.receiveShadows?(a.include(y.ReadShadowMap,e),a.fragment.code.add(f.glsl(B||(B=o.__makeTemplateObject(["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "],["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "]))))):a.fragment.code.add(f.glsl(A||(A=o.__makeTemplateObject(["\n        float evaluateShadow() { return 0.0; }\n      "],["\n        float evaluateShadow() { return 0.0; }\n      "])))),a.fragment.code.add(f.glsl(D||(D=o.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ","\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ","\n    "])),e.overlayEnabled?f.glsl(R||(R=o.__makeTemplateObject(["\n        vec4 overlayColorOpaque = getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n        vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;"],["\n        vec4 overlayColorOpaque = getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n        vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;"]))):"")),e.alphaPass?a.fragment.code.add(f.glsl(V||(V=o.__makeTemplateObject(["\n        gl_FragColor = materialColor.aaaa;\n      }\n    "],["\n        gl_FragColor = materialColor.aaaa;\n      }\n    "])))):(1===e.pbrMode||2===e.pbrMode?(a.fragment.code.add(f.glsl(F||(F=o.__makeTemplateObject(["\n        ","\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * lightingMainIntensity[2];\n      "],["\n        ","\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * lightingMainIntensity[2];\n      "])),1===e.pbrMode?f.glsl(z||(z=o.__makeTemplateObject(["\n        applyPBRFactors();\n        if (int(externalColorMixMode) == 3) {\n          mrr = vec3(0.0, 0.6, 0.2);\n        }"],["\n        applyPBRFactors();\n        if (int(externalColorMixMode) == 3) {\n          mrr = vec3(0.0, 0.6, 0.2);\n        }"]))):"")),e.hasNormalTexture?a.fragment.code.add(f.glsl(E||(E=o.__makeTemplateObject(["\n        mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);\n        "])))):a.fragment.code.add(f.glsl(I||(I=o.__makeTemplateObject(["\n        vec3 shadingNormal = normalVertex;\n        "],["\n        vec3 shadingNormal = normalVertex;\n        "])))),a.fragment.code.add(f.glsl(H||(H=o.__makeTemplateObject(["","\n      "],["","\n      "])),1===e.viewingMode?f.glsl(G||(G=o.__makeTemplateObject(["vec3 normalGround = normalize(positionWorld());"],["vec3 normalGround = normalize(positionWorld());"]))):f.glsl(q||(q=o.__makeTemplateObject(["vec3 normalGround = vec3(0.0, 0.0, 1.0);"],["vec3 normalGround = vec3(0.0, 0.0, 1.0);"]))))),a.fragment.code.add(f.glsl(J||(J=o.__makeTemplateObject(["\n        vec3 viewDir = normalize(vPositionWorldCameraRelative);\n        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\n        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);\n        "],["\n        vec3 viewDir = normalize(vPositionWorldCameraRelative);\n        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\n        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);\n        "]))))):(e.receiveShadows?a.fragment.code.add(f.glsl(K||(K=o.__makeTemplateObject(["\n      float shadow = evaluateShadow();\n        "],["\n      float shadow = evaluateShadow();\n        "])))):1===e.viewingMode?a.fragment.code.add(f.glsl(Q||(Q=o.__makeTemplateObject(["\n      float additionalAmbientScale = _oldHeuristicLighting(positionWorld());\n      float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "],["\n      float additionalAmbientScale = _oldHeuristicLighting(positionWorld());\n      float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "])))):a.fragment.code.add(f.glsl(U||(U=o.__makeTemplateObject(["\n      float shadow = 0.0;\n      "],["\n      float shadow = 0.0;\n      "])))),a.fragment.code.add(f.glsl(Y||(Y=o.__makeTemplateObject(["\n      float ambientOcclusion = evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ","\n      "],["\n      float ambientOcclusion = evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ","\n      "])),ne?f.glsl(X||(X=o.__makeTemplateObject(["\n          vec4 overlayWaterMask = getOverlayColor(ovInnerNormalTex, ovOuterNormalTex, vtcOverlay);\n          float waterNormalLength = length(overlayWaterMask);\n          if (waterNormalLength > 0.95) {\n            mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);\n            vec4 waterOverlayColor = vec4(overlayColorOpaque.xyz, overlayColor.w);\n            vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, positionView);\n            vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n            // un-gamma the ground color to mix in linear space\n            shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);\n          }"],["\n          vec4 overlayWaterMask = getOverlayColor(ovInnerNormalTex, ovOuterNormalTex, vtcOverlay);\n          float waterNormalLength = length(overlayWaterMask);\n          if (waterNormalLength > 0.95) {\n            mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);\n            vec4 waterOverlayColor = vec4(overlayColorOpaque.xyz, overlayColor.w);\n            vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, positionView);\n            vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n            // un-gamma the ground color to mix in linear space\n            shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);\n          }"]))):""))),a.fragment.code.add(f.glsl($||($=o.__makeTemplateObject(["\n        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);\n        ","\n      }\n    "],["\n        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);\n        ","\n      }\n    "])),e.OITEnabled?f.glsl(Z||(Z=o.__makeTemplateObject(["\n          //For order-independent transparency we need to sum together colors premultiplied with alpha. For opaque rendering this has no effect.\n          gl_FragColor.rgb *= shadedColor.a;\n        "],["\n          //For order-independent transparency we need to sum together colors premultiplied with alpha. For opaque rendering this has no effect.\n          gl_FragColor.rgb *= shadedColor.a;\n        "]))):"")))),1!==e.output&&3!==e.output||(a.include(v.OutputDepth,e),a.fragment.code.add(f.glsl(ee||(ee=o.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "]))))),2===e.output&&(a.include(p.ComputeShadingNormal,e),a.fragment.code.add(f.glsl(ae||(ae=o.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha = ",";\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha = ",";\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    "])),2===e.normalType?"0.0":"1.0"))),4===e.output&&(a.include(g.OutputHighlight),a.fragment.code.add(f.glsl(re||(re=o.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ","\n\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ","\n\n        outputHighlight();\n      }\n    "])),e.overlayEnabled?f.glsl(oe||(oe=o.__makeTemplateObject(["\n        vec4 overlayColor = getCombinedOverlayColor();\n\n        if (overlayColor.a == 0.0) {\n          gl_FragColor = vec4(0.0);\n          return;\n        }"],["\n        vec4 overlayColor = getCombinedOverlayColor();\n\n        if (overlayColor.a == 0.0) {\n          gl_FragColor = vec4(0.0);\n          return;\n        }"]))):""))),a}}));