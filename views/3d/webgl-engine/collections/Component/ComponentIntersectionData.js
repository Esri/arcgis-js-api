/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/_rollupPluginBabelHelpers","../../../../../core/mathUtils","../../../../../chunks/vec3f64","../../../../../geometry/support/aaBoundingBox","../../materials/internal/MaterialUtil"],(function(t,e,n,i,r,s){"use strict";const o=200,a=40,c=.8,l=10,f=1e-6;function u(t,e,n){const i=e,r=n;let s=0,o=1/0;for(let a=0;a<3;++a){{const e=t[a];if(i[a]<e){if(r[a]<=f)return!1;const t=(e-i[a])/r[a];s=Math.max(s,t)}else if(r[a]<=-f){const t=(e-i[a])/r[a];o=Math.min(o,t)}if(s>o)return!1}{const e=t[a+3];if(i[a]>e){if(r[a]>=-f)return!1;const t=(e-i[a])/r[a];s=Math.max(s,t)}else if(r[a]>=f){const t=(e-i[a])/r[a];o=Math.min(o,t)}if(s>o)return!1}}return!0}let h=function(t,e,n,i,r){this.aabb=t,this.axis=e,this.d=n,this.midStartIndex=i,this.rightStartIndex=r},d=function(){function t(t,e,r,s){this.globalTriangleVertexIndices=t,this.firstTriangleIndex=e,this.positionAttribute=s,this._rayDirection=i.create(),this.bspNodeTree=new Array;const o=r-e,f=o<=M?new Uint16Array(o):new Uint32Array(o);this.indices=f;for(let n=0;n<o;++n)f[n]=n;{const i=p(t,e,r,s.data,s.stride),u=n.clamp(Math.log2(o/a),2,l),d=(t,e,n)=>{const r=N(f,i,t,e),s=e-t;if(s<=a){const n=new h(r,void 0,0,t,e);return this.bspNodeTree.push(n),n}const{axis:o,midValue:l}=b(r),m=x(f,i,t,e,o,l),g=(t,e)=>{if(n>u)return;const i=e-t;return i<a||i>=c*s?void 0:d(t,e,n+1)},y=new h(r,o,l,m.next,m.mid);return this.bspNodeTree.push(y),y.leftNode=g(t,m.next),y.rightNode=g(m.mid,e),y};d(0,o,0),this.triangleVertexIndices=I(f,t,e,r)}}var r=t.prototype;return r.intersectRayTriangleRange=function(e,n){{if(e>=n)return;const t=this.triangleVertexIndices,i=this.positionAttribute.data,r=this.positionAttribute.stride,o=this._rayOrigin,a=o[0],c=o[1],l=o[2],f=this._rayDirection,u=f[0],h=f[1],d=f[2];for(let g=e,y=3*e;g<n;++g){let e=t[y++]*r;const n=i[e++],o=i[e++],f=i[e];e=t[y++]*r;const x=i[e++],N=i[e++],b=i[e];e=t[y++]*r;const p=x-n,I=N-o,M=b-f,T=i[e++]-n,S=i[e++]-o,R=i[e]-f,V=h*R-S*d,_=d*T-R*u,A=u*S-T*h,w=p*V+I*_+M*A;if(Math.abs(w)<=Number.EPSILON)continue;const v=a-n,B=c-o,P=l-f,U=v*V+B*_+P*A;if(w>0){if(U<0||U>w)continue}else if(U>0||U<w)continue;const D=B*M-I*P,k=P*p-M*v,F=v*I-p*B,O=u*D+h*k+d*F;if(w>0){if(O<0||U+O>w)continue}else if(O>0||U+O<w)continue;const L=(T*D+S*k+R*F)/w;if(L>=0){const t=this.indices[g]+this.firstTriangleIndex,e=s.computeNormal(p,I,M,T,S,R,m);this._callback(L,e,t,!1)}}}t.numFacesTested+=n-e},r.intersectRay=function(e,n){t.numFacesTested=0;const r=i.fromValues(e.r0[0],e.r0[1],e.r0[2]),s=i.fromValues(e.r1[0],e.r1[1],e.r1[2]),o=s[0]-r[0],a=s[1]-r[1],c=s[2]-r[2];if(o*o+a*a+c*c<f)return;this._rayOrigin=r;const l=this._rayDirection;l[0]=o,l[1]=a,l[2]=c;const u=this.triangleVertexIndices.length/3;this._callback=n;const h=this.bspNodeTree[0];this.intersectRayBSP(h,0,u)},r.intersectRayBSP=function(t,e,n){const i=this._rayOrigin,r=this._rayDirection;if(!u(t.aabb,i,r))return;const s=t.axis,o=t.d;if(i[s]<o||r[s]<0){const n=e,i=t.midStartIndex;if(n<i){const e=t.leftNode;void 0!==e?this.intersectRayBSP(e,n,i):this.intersectRayTriangleRange(n,i)}}if(this.intersectRayTriangleRange(t.midStartIndex,t.rightStartIndex),i[s]>o||r[s]>0){const e=t.rightStartIndex,i=n;if(e<i){const n=t.rightNode;void 0!==n?this.intersectRayBSP(n,e,i):this.intersectRayTriangleRange(e,i)}}},e._createClass(t,[{key:"estimatedMemoryUsage",get:function(){return this.triangleVertexIndices.byteLength+this.indices.byteLength}}]),t}();d.numFacesTested=0;const m=i.create(),g=[1/0,1/0,1/0],y=[-1/0,-1/0,-1/0];function x(t,e,n,i,r,s){let o=n,a=i;for(;o<a;){const n=t[o];e[6*n+r+3]<=s?++o:(--a,t[o]=t[a],t[a]=n)}let c=o;for(a=i;c<a;){const n=t[a-1];e[6*n+r]>=s?--a:(t[a-1]=t[c],t[c]=n,++c)}return{next:o,mid:c}}function N(t,e,n,i){if(i<=n)return r.fromValues(NaN,NaN,NaN,NaN,NaN,NaN);{const i=6*t[n];for(let t=0;t<3;++t)g[t]=e[i+0+t],y[t]=e[i+3+t]}for(let r=n+1;r<i;++r){const n=6*t[r];for(let t=0;t<3;++t)g[t]=Math.min(g[t],e[n+0+t]),y[t]=Math.max(y[t],e[n+3+t])}return r.fromValues(g[0],g[1],g[2],y[0],y[1],y[2])}function b(t){const e=t[3]-t[0],n=t[4]-t[1],i=t[5]-t[2],r=e>n?e>i?0:n>i?1:2:n>i?1:i>e?2:0;return{axis:r,midValue:(t[r]+t[r+3])/2}}function p(t,e,n,i,r){const s=n-e,o=new Float32Array(6*s);for(let a=0;a<s;++a){const n=3*(a+e),s=t[n+0]*r,c=t[n+1]*r,l=t[n+2]*r;for(let t=0;t<3;++t){const e=i[s+t],n=i[c+t],r=i[l+t];o[6*a+t]=Math.min(e,n,r),o[6*a+3+t]=Math.max(e,n,r)}}return o}function I(t,e,n,i){const r=i-n;let s=0;for(let a=n;a<i;++a)for(let t=0;t<3;++t)s=Math.max(e[3*a+t],s);const o=s<=M?new Uint16Array(3*r):new Uint32Array(3*r);for(let a=0;a<r;++a){const i=3*(t[a]+n);for(let t=0;t<3;++t){const n=e[i+t];o[3*a+t]=n}}return o}const M=65535;t.ComponentIntersectionData=d,t.componentMinimalSizeForIntersectionData=o,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
