/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{clamp as t}from"../../../../../core/mathUtils.js";import{c as e,f as i}from"../../../../../chunks/vec3f64.js";import{fromValues as n}from"../../../../../geometry/support/aaBoundingBox.js";import{computeNormal as r}from"../../materials/internal/MaterialUtil.js";const s=200,o=40,a=.8,c=10,h=1e-6;function f(t,e,i){const n=e,r=i;let s=0,o=1/0;for(let a=0;a<3;++a){{const e=t[a];if(n[a]<e){if(r[a]<=h)return!1;const t=(e-n[a])/r[a];s=Math.max(s,t)}else if(r[a]<=-h){const t=(e-n[a])/r[a];o=Math.min(o,t)}if(s>o)return!1}{const e=t[a+3];if(n[a]>e){if(r[a]>=-h)return!1;const t=(e-n[a])/r[a];s=Math.max(s,t)}else if(r[a]>=h){const t=(e-n[a])/r[a];o=Math.min(o,t)}if(s>o)return!1}}return!0}class l{constructor(t,e,i,n,r){this.aabb=t,this.axis=e,this.d=i,this.midStartIndex=n,this.rightStartIndex=r}}class d{constructor(i,n,r,s){this.globalTriangleVertexIndices=i,this.firstTriangleIndex=n,this.positionAttribute=s,this.rayDirection=e(),this.bspNodeTree=new Array,this.vertexPositionBuffer=s.data,this.vertexPositionStride=s.stride;const h=r-n,f=h<=I?new Uint16Array(h):new Uint32Array(h);this.indices=f;for(let t=0;t<h;++t)f[t]=t;{const e=b(i,n,r,s.data,s.stride),d=t(Math.log2(h/o),2,c),u=(t,i,n)=>{const r=y(f,e,t,i),s=i-t;if(s<=o){const e=new l(r,void 0,0,t,i);return this.bspNodeTree.push(e),e}const{axis:c,midValue:h}=N(r),m=x(f,e,t,i,c,h),g=(t,e)=>{if(n>d)return;const i=e-t;return i<o||i>=a*s?void 0:u(t,e,n+1)},b=new l(r,c,h,m.next,m.mid);return this.bspNodeTree.push(b),b.leftNode=g(t,m.next),b.rightNode=g(m.mid,i),b};u(0,h,0),this.triangleVertexIndices=p(f,i,n,r)}}intersectRayTriangleRange(t,e){{if(t>=e)return;const i=this.triangleVertexIndices,n=this.positionAttribute.data,s=this.positionAttribute.stride,o=this.rayOrigin,a=o[0],c=o[1],h=o[2],f=this.rayDirection,l=f[0],d=f[1],m=f[2];for(let g=t,x=3*t;g<e;++g){const t=i[x]*s,e=n[t],o=n[t+1],f=n[t+2],y=i[x+1]*s,N=n[y],b=n[y+1],p=n[y+2],I=i[x+2]*s,T=n[I],M=n[I+1],R=n[I+2];x+=3;const S=N-e,A=b-o,w=p-f,V=T-e,v=M-o,B=R-f,P=d*B-v*m,U=m*V-B*l,j=l*v-V*d,D=S*P+A*U+w*j;if(Math.abs(D)<=Number.EPSILON)continue;const F=a-e,O=c-o,k=h-f,L=F*P+O*U+k*j;if(D>0){if(L<0||L>D)continue}else if(L>0||L<D)continue;const E=O*w-A*k,q=k*S-w*F,z=F*A-S*O,C=l*E+d*q+m*z;if(D>0){if(C<0||L+C>D)continue}else if(C>0||L+C<D)continue;const G=(V*E+v*q+B*z)/D;if(G>=0){const t=this.indices[g]+this.firstTriangleIndex,e=r(S,A,w,V,v,B,u);this.callback(G,e,t,!1)}}}d.numFacesTested+=e-t}intersectRay(t,e){d.numFacesTested=0;const n=i(t.r0[0],t.r0[1],t.r0[2]),r=i(t.r1[0],t.r1[1],t.r1[2]),s=r[0]-n[0],o=r[1]-n[1],a=r[2]-n[2];if(s*s+o*o+a*a<h)return;this.rayOrigin=n;const c=this.rayDirection;c[0]=s,c[1]=o,c[2]=a;const f=this.triangleVertexIndices.length/3;this.callback=e;const l=this.bspNodeTree[0];this.intersectRayBSP(l,0,f)}intersectRayBSP(t,e,i){const n=this.rayOrigin,r=this.rayDirection;if(!f(t.aabb,n,r))return;const s=t.axis,o=t.d;if(n[s]<o||r[s]<0){const i=e,n=t.midStartIndex;if(i<n){const e=t.leftNode;void 0!==e?this.intersectRayBSP(e,i,n):this.intersectRayTriangleRange(i,n)}}if(this.intersectRayTriangleRange(t.midStartIndex,t.rightStartIndex),n[s]>o||r[s]>0){const e=t.rightStartIndex,n=i;if(e<n){const i=t.rightNode;void 0!==i?this.intersectRayBSP(i,e,n):this.intersectRayTriangleRange(e,n)}}}get estimatedMemoryUsage(){return this.triangleVertexIndices.byteLength+this.indices.byteLength}}d.numFacesTested=0;const u=e(),m=[1/0,1/0,1/0],g=[-1/0,-1/0,-1/0];function x(t,e,i,n,r,s){let o=i,a=n;for(;o<a;){const i=t[o];e[6*i+r+3]<=s?++o:(--a,t[o]=t[a],t[a]=i)}let c=o;for(a=n;c<a;){const i=t[a-1];e[6*i+r]>=s?--a:(t[a-1]=t[c],t[c]=i,++c)}return{next:o,mid:c}}function y(t,e,i,r){if(r<=i)return n(NaN,NaN,NaN,NaN,NaN,NaN);{const n=6*t[i];for(let t=0;t<3;++t)m[t]=e[n+0+t],g[t]=e[n+3+t]}for(let n=i+1;n<r;++n){const i=6*t[n];for(let t=0;t<3;++t)m[t]=Math.min(m[t],e[i+0+t]),g[t]=Math.max(g[t],e[i+3+t])}return n(m[0],m[1],m[2],g[0],g[1],g[2])}function N(t){const e=t[3]-t[0],i=t[4]-t[1],n=t[5]-t[2],r=e>i?e>n?0:i>n?1:2:i>n?1:n>e?2:0;return{axis:r,midValue:(t[r]+t[r+3])/2}}function b(t,e,i,n,r){const s=i-e,o=new Float32Array(6*s);for(let a=0;a<s;++a){const i=3*(a+e),s=t[i+0]*r,c=t[i+1]*r,h=t[i+2]*r;for(let t=0;t<3;++t){const e=n[s+t],i=n[c+t],r=n[h+t];o[6*a+t]=Math.min(e,i,r),o[6*a+3+t]=Math.max(e,i,r)}}return o}function p(t,e,i,n){const r=n-i;let s=0;for(let a=i;a<n;++a)for(let t=0;t<3;++t)s=Math.max(e[3*a+t],s);const o=s<=I?new Uint16Array(3*r):new Uint32Array(3*r);for(let a=0;a<r;++a){const n=3*(t[a]+i);for(let t=0;t<3;++t){const i=e[n+t];o[3*a+t]=i}}return o}const I=65535;export{d as ComponentIntersectionData,s as componentMinimalSizeForIntersectionData};
