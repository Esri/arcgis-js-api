// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.17/esri/copyright.txt for details.

define(["require","exports","tslib","../core/shaderLibrary/ForwardLinearDepth.glsl","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/Transform.glsl","../core/shaderLibrary/attributes/PathVertexPosition.glsl","../core/shaderLibrary/output/OutputDepth.glsl","../core/shaderLibrary/output/OutputHighlight.glsl","../core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl","../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../core/shaderLibrary/shading/Normals.glsl","../core/shaderLibrary/shading/NormalUtils.glsl","../core/shaderLibrary/shading/ReadShadowMap.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder"],(function(a,e,o,n,i,l,r,t,d,s,c,m,v,g,p,h){"use strict";var u,f,b,_,w,y,P,S,O,L,F,j;Object.defineProperty(e,"__esModule",{value:!0}),e.build=void 0,e.build=function(a){var e=new h.ShaderBuilder;return e.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3"),e.varyings.add("vpos","vec3"),e.include(r.PathVertexPosition,a),0===a.output&&(e.include(l.Transform,{linearDepth:!1}),a.receiveShadows&&e.include(g.ReadShadowMap,a),e.include(n.ForwardLinearDepth,a),e.varyings.add("vnormal","vec3"),e.varyings.add("vcolor","vec4"),e.vertex.code.add(p.glsl(u||(u=o.__makeTemplateObject(["\n      void main() {\n        vpos = calculateVPos();\n        vnormal = normalize(localNormal());\n\n        gl_Position = transformPosition(proj, view, vpos);\n\n        forwardLinearDepth();\n\n        vcolor = getColor();\n      }\n    "],["\n      void main() {\n        vpos = calculateVPos();\n        vnormal = normalize(localNormal());\n\n        gl_Position = transformPosition(proj, view, vpos);\n\n        forwardLinearDepth();\n\n        vcolor = getColor();\n      }\n    "])))),e.include(i.Slice,a),e.include(c.EvaluateSceneLighting,a),e.include(s.EvaluateAmbientOcclusion,a),a.receiveShadows&&e.include(g.ReadShadowMap,a),e.include(m.Normals,a),e.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("specular","vec3").add("opacity","float"),e.fragment.code.add(p.glsl(f||(f=o.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vpos);\n\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        shadingParams.normalView = vnormal;\n        vec3 normal = shadingNormal(shadingParams);\n        float ssao = evaluateAmbientOcclusionInverse();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "],["\n      void main() {\n        discardBySlice(vpos);\n\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        shadingParams.normalView = vnormal;\n        vec3 normal = shadingNormal(shadingParams);\n        float ssao = evaluateAmbientOcclusionInverse();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "])))),a.receiveShadows?e.fragment.code.add(p.glsl(b||(b=o.__makeTemplateObject(["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "])))):1===a.viewingMode?e.fragment.code.add(p.glsl(_||(_=o.__makeTemplateObject(["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "],["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "])))):e.fragment.code.add(p.glsl(w||(w=o.__makeTemplateObject(["\n        float shadow = 0.0;\n      "],["\n        float shadow = 0.0;\n      "])))),e.fragment.code.add(p.glsl(y||(y=o.__makeTemplateObject(["\n        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one\n        float combinedOpacity = vcolor.a * opacity;\n        albedo += 0.25 * specular; // don't completely ignore specular for now\n\n        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);\n        gl_FragColor = vec4(shadedColor, combinedOpacity);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one\n        float combinedOpacity = vcolor.a * opacity;\n        albedo += 0.25 * specular; // don't completely ignore specular for now\n\n        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);\n        gl_FragColor = vec4(shadedColor, combinedOpacity);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "]))))),1!==a.output&&3!==a.output||(e.include(l.Transform,{linearDepth:!0}),e.vertex.uniforms.add("nearFar","vec2"),e.varyings.add("depth","float"),e.vertex.code.add(p.glsl(P||(P=o.__makeTemplateObject(["\n        void main() {\n          vpos = calculateVPos();\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        }\n    "],["\n        void main() {\n          vpos = calculateVPos();\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        }\n    "])))),e.include(i.Slice,a),e.include(t.OutputDepth,a),e.fragment.uniforms.add("timeElapsed","float"),e.fragment.code.add(p.glsl(S||(S=o.__makeTemplateObject(["\n        void main() {\n          discardBySlice(vpos);\n          outputDepth(depth);\n        }\n    "],["\n        void main() {\n          discardBySlice(vpos);\n          outputDepth(depth);\n        }\n    "]))))),2===a.output&&(e.include(l.Transform,{linearDepth:!1}),e.include(v.NormalUtils,a),e.vertex.uniforms.add("viewNormal","mat4"),e.varyings.add("vnormal","vec3"),e.vertex.code.add(p.glsl(O||(O=o.__makeTemplateObject(["\n        void main(void) {\n          vpos = calculateVPos();\n          vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vpos = calculateVPos();\n          vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "])))),e.include(i.Slice,a),e.fragment.uniforms.add("waterColor","vec4"),e.fragment.code.add(p.glsl(L||(L=o.__makeTemplateObject(["\n        void main() {\n          discardBySlice(vpos);\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) normal = -normal;\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n        }\n    "],["\n        void main() {\n          discardBySlice(vpos);\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) normal = -normal;\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n        }\n    "]))))),4===a.output&&(e.include(l.Transform,{linearDepth:!1}),e.include(v.NormalUtils,a),e.vertex.uniforms.add("viewNormal","mat4"),e.varyings.add("vnormal","vec3"),e.vertex.code.add(p.glsl(F||(F=o.__makeTemplateObject(["\n        void main(void) {\n          vpos = calculateVPos();\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vpos = calculateVPos();\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "])))),e.include(i.Slice,a),e.include(d.OutputHighlight),e.fragment.code.add(p.glsl(j||(j=o.__makeTemplateObject(["\n      void main() {\n        discardBySlice(vpos);\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        outputHighlight();\n      }\n    "]))))),e}}));