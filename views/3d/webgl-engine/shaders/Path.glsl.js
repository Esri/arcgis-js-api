// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.15/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/makeTemplateObjectHelper","../core/shaderLibrary/ForwardLinearDepth.glsl","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/Transform.glsl","../core/shaderLibrary/attributes/PathVertexPosition.glsl","../core/shaderLibrary/output/OutputDepth.glsl","../core/shaderLibrary/output/OutputHighlight.glsl","../core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl","../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../core/shaderLibrary/shading/Normals.glsl","../core/shaderLibrary/shading/NormalUtils.glsl","../core/shaderLibrary/shading/ReadShadowMap.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder"],(function(a,o,n,e,i,l,r,d,t,s,c,m,v,g,p,h){var u,f,b,w,y,P,S,L,F,_,N,D;Object.defineProperty(o,"__esModule",{value:!0}),o.build=function(a){var o=new h.ShaderBuilder;return o.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4").add("modelNormal","mat4").add("camPos","vec3").add("localOrigin","vec3"),o.varyings.add("vpos","vec3"),o.include(r.PathVertexPosition,a),0===a.output&&(o.include(l.Transform,{linearDepth:!1}),a.receiveShadows&&o.include(g.ReadShadowMap,a),o.include(e.ForwardLinearDepth,a),o.varyings.add("vnormal","vec3"),o.varyings.add("vcolor","vec4"),o.vertex.code.add(p.glsl(u||(u=n(["\n      void main() {\n        vpos = calculateVPos();\n\n        vnormal = normalize((modelNormal * localNormal()).xyz);\n\n        gl_Position = transformPosition(proj, view, vpos);\n\n        forwardLinearDepth();\n\n        vcolor = getColor();\n      }\n    "],["\n      void main() {\n        vpos = calculateVPos();\n\n        vnormal = normalize((modelNormal * localNormal()).xyz);\n\n        gl_Position = transformPosition(proj, view, vpos);\n\n        forwardLinearDepth();\n\n        vcolor = getColor();\n      }\n    "])))),o.include(i.Slice,a),o.include(c.EvaluateSceneLighting,a),o.include(s.EvaluateAmbientOcclusion,a),a.receiveShadows&&o.include(g.ReadShadowMap,a),o.include(m.Normals,a),o.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("specular","vec3").add("opacity","float"),o.fragment.code.add(p.glsl(f||(f=n(["\n      void main() {\n        discardBySlice(vpos);\n\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        shadingParams.normalView = vnormal;\n        vec3 normal = shadingNormal(shadingParams);\n        float ssao = evaluateAmbientOcclusionInverse();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "],["\n      void main() {\n        discardBySlice(vpos);\n\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        shadingParams.normalView = vnormal;\n        vec3 normal = shadingNormal(shadingParams);\n        float ssao = evaluateAmbientOcclusionInverse();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "])))),a.receiveShadows?o.fragment.code.add(p.glsl(b||(b=n(["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "])))):0===a.viewingMode?o.fragment.code.add(p.glsl(w||(w=n(["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "],["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "])))):o.fragment.code.add(p.glsl(y||(y=n(["\n        float shadow = 0.0;\n      "],["\n        float shadow = 0.0;\n      "])))),o.fragment.code.add(p.glsl(P||(P=n(["\n        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one\n        float combinedOpacity = vcolor.a * opacity;\n        albedo += 0.25 * specular; // don't completely ignore specular for now\n\n        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);\n        gl_FragColor = vec4(shadedColor, combinedOpacity);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one\n        float combinedOpacity = vcolor.a * opacity;\n        albedo += 0.25 * specular; // don't completely ignore specular for now\n\n        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);\n        gl_FragColor = vec4(shadedColor, combinedOpacity);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "]))))),1!==a.output&&3!==a.output||(o.include(l.Transform,{linearDepth:!0}),o.vertex.uniforms.add("nearFar","vec2"),o.varyings.add("depth","float"),o.vertex.code.add(p.glsl(S||(S=n(["\n        void main() {\n          vpos = calculateVPos();\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        }\n    "],["\n        void main() {\n          vpos = calculateVPos();\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        }\n    "])))),o.include(i.Slice,a),o.include(d.OutputDepth,a),o.fragment.uniforms.add("timeElapsed","float"),o.fragment.code.add(p.glsl(L||(L=n(["\n        void main() {\n          discardBySlice(vpos);\n          outputDepth(depth);\n        }\n    "],["\n        void main() {\n          discardBySlice(vpos);\n          outputDepth(depth);\n        }\n    "]))))),2===a.output&&(o.include(l.Transform,{linearDepth:!1}),o.include(v.NormalUtils,a),o.vertex.uniforms.add("viewNormal","mat4"),o.varyings.add("vnormal","vec3"),o.vertex.code.add(p.glsl(F||(F=n(["\n        void main(void) {\n          vpos = calculateVPos();\n          vnormal = normalize((viewNormal * modelNormal * localNormal()).xyz);\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vpos = calculateVPos();\n          vnormal = normalize((viewNormal * modelNormal * localNormal()).xyz);\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "])))),o.include(i.Slice,a),o.fragment.uniforms.add("waterColor","vec4"),o.fragment.code.add(p.glsl(_||(_=n(["\n        void main() {\n          discardBySlice(vpos);\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) normal = -normal;\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n        }\n    "],["\n        void main() {\n          discardBySlice(vpos);\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) normal = -normal;\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n        }\n    "]))))),4===a.output&&(o.include(l.Transform,{linearDepth:!1}),o.include(v.NormalUtils,a),o.vertex.uniforms.add("viewNormal","mat4"),o.varyings.add("vnormal","vec3"),o.vertex.code.add(p.glsl(N||(N=n(["\n        void main(void) {\n          vpos = calculateVPos();\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vpos = calculateVPos();\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "])))),o.include(i.Slice,a),o.include(t.OutputHighlight),o.fragment.code.add(p.glsl(D||(D=n(["\n      void main() {\n        discardBySlice(vpos);\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        outputHighlight();\n      }\n    "]))))),o}}));