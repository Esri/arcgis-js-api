// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.17/esri/copyright.txt for details.

define(["require","exports","tslib","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/Transform.glsl","../core/shaderLibrary/attributes/VertexColor.glsl","../core/shaderLibrary/output/OutputHighlight.glsl","../core/shaderLibrary/util/AlphaDiscard.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder"],(function(e,n,t,a,o,l,i,r,c,d){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.build=void 0;var s,p,v,m,f,u,g,h,x,b,y,j,S,w,P,T,_,V=.70710678118;n.build=function(e){var n=new d.ShaderBuilder;e.draped||n.extensions.add("GL_OES_standard_derivatives"),n.include(o.Transform,{linearDepth:!1}),n.include(l.VertexColor,e),n.vertex.uniforms.add("proj","mat4"),n.vertex.uniforms.add("view","mat4"),e.draped?n.vertex.uniforms.add("worldToScreenRatio","float"):(n.vertex.uniforms.add("worldToScreenPerDistanceRatio","float"),n.vertex.uniforms.add("camPos","vec3"),n.vertex.uniforms.add("viewForward","vec3"),n.attributes.add("bound1","vec3"),n.attributes.add("bound2","vec3"),n.attributes.add("bound3","vec3")),n.attributes.add("position","vec3"),n.attributes.add("uvMapSpace","vec4"),n.varyings.add("vpos","vec3"),n.varyings.add("vuv","vec2");var O=3===e.style||4===e.style||5===e.style;return O&&n.vertex.code.add(c.glsl(s||(s=t.__makeTemplateObject(["\n      const mat2 rotate45 = mat2(",", ",",\n                                 ",", ",");\n    "],["\n      const mat2 rotate45 = mat2(",", ",",\n                                 ",", ",");\n    "])),c.glsl.float(V),c.glsl.float(-.70710678118),c.glsl.float(.70710678118),c.glsl.float(V))),e.draped||(n.vertex.code.add(c.glsl(p||(p=t.__makeTemplateObject(["\n      vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\n        float projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\n        return center + halfVector * clamp(projectedLength, -1.0, 1.0);\n      }\n    "],["\n      vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\n        float projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\n        return center + halfVector * clamp(projectedLength, -1.0, 1.0);\n      }\n    "])))),n.vertex.code.add(c.glsl(v||(v=t.__makeTemplateObject(["\n      vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\n        float d = dot(planeNormal, planePoint);\n        float t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\n\n        return rayOrigin + t * rayDir;\n      }\n    "],["\n      vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\n        float d = dot(planeNormal, planePoint);\n        float t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\n\n        return rayOrigin + t * rayDir;\n      }\n    "])))),n.vertex.code.add(c.glsl(m||(m=t.__makeTemplateObject(["\n      float boundingRectDistanceToCamera() {\n        vec3 halfU = (bound2 - bound1) * 0.5;\n        vec3 halfV = (bound3 - bound1) * 0.5;\n        vec3 center = bound1 + halfU + halfV;\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = viewForward;\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ",";\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, camPos, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - camPos);\n      }\n    "],["\n      float boundingRectDistanceToCamera() {\n        vec3 halfU = (bound2 - bound1) * 0.5;\n        vec3 halfV = (bound3 - bound1) * 0.5;\n        vec3 center = bound1 + halfU + halfV;\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = viewForward;\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ",";\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, camPos, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - camPos);\n      }\n    "])),c.glsl.float(.08715574274)))),n.vertex.code.add(c.glsl(g||(g=t.__makeTemplateObject(["\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ",";\n      vec2 uvCellOrigin = uvMapSpace.zw ",";\n\n      ","\n\n      vec2 uvOffset = mod(uvCellOrigin * ratio, ",");\n      return uvOffset + (uv * ratio);\n    }\n  "],["\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ",";\n      vec2 uvCellOrigin = uvMapSpace.zw ",";\n\n      ","\n\n      vec2 uvOffset = mod(uvCellOrigin * ratio, ",");\n      return uvOffset + (uv * ratio);\n    }\n  "])),O?" * rotate45":"",O?" * rotate45":"",e.draped?c.glsl(f||(f=t.__makeTemplateObject(["\n            float ratio = worldToScreenRatio;\n          "],["\n            float ratio = worldToScreenRatio;\n          "]))):c.glsl(u||(u=t.__makeTemplateObject(["\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float ratio = worldToScreenPerDistanceRatio / distanceToCamera;\n\n            // Logarithmically discretize ratio to avoid jittering\n            float step = 0.1;\n            ratio = log(ratio);\n            ratio = ceil(ratio / step) * step;\n            ratio = exp(ratio);\n          "],["\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float ratio = worldToScreenPerDistanceRatio / distanceToCamera;\n\n            // Logarithmically discretize ratio to avoid jittering\n            float step = 0.1;\n            ratio = log(ratio);\n            ratio = ceil(ratio / step) * step;\n            ratio = exp(ratio);\n          "]))),c.glsl.float(e.patternSpacing))),n.vertex.code.add(c.glsl(h||(h=t.__makeTemplateObject(["\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n    }\n  "],["\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      forwardNormalizedVertexColor();\n      gl_Position = transformPosition(proj, view, vpos);\n    }\n  "])))),n.include(a.Slice,e),n.fragment.uniforms.add("matColor","vec4"),e.draped&&n.fragment.uniforms.add("texelSize","float"),4===e.output&&n.include(i.OutputHighlight),0===e.output&&(n.fragment.code.add(c.glsl(x||(x=t.__makeTemplateObject(["\n      const float lineWidth = ",";\n      const float spacing = ",";\n      const float spacingINV = ",";\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    "],["\n      const float lineWidth = ",";\n      const float spacing = ",";\n      const float spacingINV = ",";\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    "])),c.glsl.float(e.lineWidth),c.glsl.float(e.patternSpacing),c.glsl.float(1/e.patternSpacing))),e.draped||n.fragment.code.add(c.glsl(b||(b=t.__makeTemplateObject(["\n        const int maxSamples = 5;\n\n        float sample(float p) {\n          vec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\n          float fwidth = dxdy.x + dxdy.y;\n\n          ivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\n          vec2 invSamples = 1.0 / vec2(samples);\n\n          float accumulator = 0.0;\n\n          for (int j = 0; j < maxSamples; j++) {\n            if(j >= samples.y) {\n              break;\n            }\n\n            for (int i = 0; i < maxSamples; i++) {\n              if(i >= samples.x) {\n                break;\n              }\n\n              vec2 step = vec2(i,j) * invSamples - 0.5;\n              accumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n            }\n          }\n\n          accumulator /= float(samples.x * samples.y);\n          return accumulator;\n        }\n      "],["\n        const int maxSamples = 5;\n\n        float sample(float p) {\n          vec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\n          float fwidth = dxdy.x + dxdy.y;\n\n          ivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\n          vec2 invSamples = 1.0 / vec2(samples);\n\n          float accumulator = 0.0;\n\n          for (int j = 0; j < maxSamples; j++) {\n            if(j >= samples.y) {\n              break;\n            }\n\n            for (int i = 0; i < maxSamples; i++) {\n              if(i >= samples.x) {\n                break;\n              }\n\n              vec2 step = vec2(i,j) * invSamples - 0.5;\n              accumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n            }\n          }\n\n          accumulator /= float(samples.x * samples.y);\n          return accumulator;\n        }\n      "]))))),n.fragment.code.add(c.glsl(w||(w=t.__makeTemplateObject(["\n    void main() {\n      discardBySlice(vpos);\n      vec4 color = ","\n      color = highlightSlice(color, vpos);\n\n      ","\n\n      if (color.a < ",") {\n        discard;\n      }\n\n      ","\n      ","\n    }\n  "],["\n    void main() {\n      discardBySlice(vpos);\n      vec4 color = ","\n      color = highlightSlice(color, vpos);\n\n      ","\n\n      if (color.a < ",") {\n        discard;\n      }\n\n      ","\n      ","\n    }\n  "])),e.attributeColor?"vColor * matColor;":"matColor;",0===e.output?c.glsl(y||(y=t.__makeTemplateObject(["color.a *= ",";"],["color.a *= ",";"])),function(e){function n(n){return e.draped?c.glsl(P||(P=t.__makeTemplateObject(["coverage(vuv.",", texelSize)"],["coverage(vuv.",", texelSize)"])),n):c.glsl(T||(T=t.__makeTemplateObject(["sample(vuv.",")"],["sample(vuv.",")"])),n)}switch(e.style){case 3:case 0:return n("y");case 4:case 1:return n("x");case 5:case 2:return c.glsl(_||(_=t.__makeTemplateObject(["\n        1.0 - (1.0 - ",") * (1.0 - ",")\n      "],["\n        1.0 - (1.0 - ",") * (1.0 - ",")\n      "])),n("x"),n("y"));default:return"0.0"}}(e)):"",c.glsl.float(r.symbolAlphaCutoff),0===e.output?c.glsl(j||(j=t.__makeTemplateObject(["gl_FragColor = color;"],["gl_FragColor = color;"]))):"",4===e.output?c.glsl(S||(S=t.__makeTemplateObject(["outputHighlight();"],["outputHighlight();"]))):"")),n}}));