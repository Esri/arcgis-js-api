// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.17/esri/copyright.txt for details.

define(["require","exports","tslib","../../../../core/libs/gl-matrix-2/vec2","../../../../core/libs/gl-matrix-2/vec2f64","../../../../core/libs/gl-matrix-2/vec4f64","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/hud/AlignPixel.glsl","../core/shaderLibrary/hud/HUD.glsl","../core/shaderLibrary/hud/HUDOcclusionPass.glsl","../core/shaderLibrary/output/OutputHighlight.glsl","../core/shaderLibrary/shading/VisualVariables.glsl","../core/shaderLibrary/util/AlphaDiscard.glsl","../core/shaderLibrary/util/ColorConversion.glsl","../core/shaderLibrary/util/RgbaFloatEncoding.glsl","../core/shaderLibrary/util/ScreenSizePerspective.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder"],(function(e,o,l,n,i,r,t,a,s,c,d,u,p,v,f,g,m,x){"use strict";function b(e,o){var l,i,r;return void 0===o&&(o=U),e.textureIsSignedDistanceField?(l=e.anchorPos,i=e.distanceFieldBoundingBox,(r=o)[0]=l[0]*(i[2]-i[0])+i[0],r[1]=l[1]*(i[3]-i[1])+i[1]):n.vec2.copy(o,e.anchorPos),o}Object.defineProperty(o,"__esModule",{value:!0}),o.calculateAnchorPosForRendering=o.HUDMaterial=o.build=void 0,o.build=function(e){var o=new x.ShaderBuilder,n=e.signedDistanceFieldEnabled;if(o.include(a.AlignPixel),o.include(s.HUD,e),o.include(t.Slice,e),6===e.output)return o.include(c.HUDOcclusionPass,e),o;o.include(g.ScreenSizePerspective),o.fragment.include(f.RgbaFloatEncoding),o.fragment.include(v.ColorConversion),o.include(u.VisualVariables,e),o.varyings.add("vcolor","vec4"),o.varyings.add("vtc","vec2"),o.varyings.add("vsize","vec2"),e.binaryHighlightOcclusionEnabled&&o.varyings.add("voccluded","float"),o.vertex.uniforms.add("screenOffset","vec2").add("anchorPos","vec2").add("textureCoordinateScaleFactor","vec2").add("materialColor","vec4"),n&&o.vertex.uniforms.add("outlineColor","vec4"),e.screenSizePerspectiveEnabled&&o.vertex.uniforms.add("screenSizePerspective","vec4"),(e.debugDrawBorder||e.binaryHighlightOcclusionEnabled)&&o.varyings.add("debugBorderCoords","vec4"),o.attributes.add("uv0","vec2"),o.attributes.add("color","vec4"),o.attributes.add("size","vec2"),o.attributes.add("auxpos2","vec4"),o.vertex.code.add(m.glsl(z||(z=l.__makeTemplateObject(["\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n\n      if (rejectBySlice(projectAux.posModel)) {\n        // Project outside of clip plane\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n        return;\n      }\n      vec2 inputSize;\n      ","\n\n      ","\n\n      vec2 combinedSize = inputSize * pixelRatio;\n      vec4 quadOffset = vec4(0.0);\n\n      ","\n\n      ","\n    "],["\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n\n      if (rejectBySlice(projectAux.posModel)) {\n        // Project outside of clip plane\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n        return;\n      }\n      vec2 inputSize;\n      ","\n\n      ","\n\n      vec2 combinedSize = inputSize * pixelRatio;\n      vec4 quadOffset = vec4(0.0);\n\n      ","\n\n      ","\n    "])),e.screenSizePerspectiveEnabled?m.glsl(h||(h=l.__makeTemplateObject(["\n      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n         "],["\n      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n         "]))):m.glsl(C||(C=l.__makeTemplateObject(["\n      inputSize = size;\n      vec2 screenOffsetScaled = screenOffset;"],["\n      inputSize = size;\n      vec2 screenOffsetScaled = screenOffset;"]))),e.vvSize?"inputSize *= vvScale(auxpos2).xx;":"",e.occlusionTestEnabled||e.binaryHighlightOcclusionEnabled?"bool visible = testVisibilityHUD(posProj);":"",e.binaryHighlightOcclusionEnabled?"voccluded = visible ? 0.0 : 1.0;":""));var i=m.glsl(P||(P=l.__makeTemplateObject(["\n      vec2 uv01 = floor(uv0);\n      vec2 uv = uv0 - uv01;\n      quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n  "],["\n      vec2 uv01 = floor(uv0);\n      vec2 uv = uv0 - uv01;\n      quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n  "]))),r=n?m.glsl(S||(S=l.__makeTemplateObject(["\n  posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;"],["\n  posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;"]))):m.glsl(_||(_=l.__makeTemplateObject(["\n  posProj += quadOffset;\n  if (inputSize.x == size.x) {\n    posProj = alignToPixelOrigin(posProj, viewport.zw);\n  }"],["\n  posProj += quadOffset;\n  if (inputSize.x == size.x) {\n    posProj = alignToPixelOrigin(posProj, viewport.zw);\n  }"])));o.vertex.code.add(m.glsl(A||(A=l.__makeTemplateObject(["\n      ","\n      ","\n      ","\n\n      bool alphaDiscard = vcolor.a < ",";\n      ",'\n      if (alphaDiscard) {\n        // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      } else {\n        ',"\n        gl_Position = posProj;\n      }\n\n      vtc = uv * textureCoordinateScaleFactor;\n\n      ","\n      vsize = inputSize;\n      ","\n    }\n    "],["\n      ","\n      ","\n      ","\n\n      bool alphaDiscard = vcolor.a < ",";\n      ",'\n      if (alphaDiscard) {\n        // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      } else {\n        ',"\n        gl_Position = posProj;\n      }\n\n      vtc = uv * textureCoordinateScaleFactor;\n\n      ","\n      vsize = inputSize;\n      ","\n    }\n    "])),e.occlusionTestEnabled?"if (visible) {":"",i,e.vvColor?"vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors) * materialColor;":"vcolor = color / 255.0 * materialColor;",m.glsl.float(p.symbolAlphaCutoff),n?"alphaDiscard = alphaDiscard && outlineColor.a < "+m.glsl.float(p.symbolAlphaCutoff)+";":"",r,e.debugDrawBorder?"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);":"",e.occlusionTestEnabled?m.glsl(j||(j=l.__makeTemplateObject(["} else { vtc = vec2(0.0);\n        ",""],["} else { vtc = vec2(0.0);\n        ",""])),e.debugDrawBorder?"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}":"}"):"")),o.fragment.uniforms.add("tex","sampler2D"),n&&(o.fragment.uniforms.add("outlineColor","vec4"),o.fragment.uniforms.add("outlineSize","float"));var b=e.debugDrawBorder?m.glsl(O||(O=l.__makeTemplateObject(["(isBorder > 0.0 ? 0.0 : ",")"],["(isBorder > 0.0 ? 0.0 : ",")"])),m.glsl.float(p.defaultMaskAlphaCutoff)):m.glsl.float(p.defaultMaskAlphaCutoff),U=m.glsl(T||(T=l.__makeTemplateObject(["\n    ","\n\n    ","\n\n    ","\n  "],["\n    ","\n\n    ","\n\n    ","\n  "])),e.debugDrawBorder?m.glsl(y||(y=l.__makeTemplateObject(["\n      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));"],["\n      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));"]))):"",n?m.glsl(F||(F=l.__makeTemplateObject(["\n      vec4 fillPixelColor = vcolor;\n\n      // Attempt to sample texel centers to avoid that thin cross outlines\n      // disappear with large symbol sizes.\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\n      const float txSize = 128.0;\n      const float texelSize = 1.0 / txSize;\n      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel\n      vec2 scaleFactor = (vsize - txSize) * texelSize;\n      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n\n      // Get distance and map it into [-0.5, 0.5]\n      float d = rgba2float(texture2D(tex, samplePos)) - 0.5;\n\n      // Distance in output units (i.e. pixels)\n      float dist = d * vsize.x;\n\n      // Create smooth transition from the icon into its outline\n      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);\n      fillPixelColor.a *= fillAlphaFactor;\n\n      if (outlineSize > 0.25) {\n        vec4 outlinePixelColor = outlineColor;\n        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n\n        // Create smooth transition around outline\n        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n        outlinePixelColor.a *= outlineAlphaFactor;\n\n        if (\n          outlineAlphaFactor + fillAlphaFactor < "," ||\n          fillPixelColor.a + outlinePixelColor.a < ","\n        ) {\n          discard;\n        }\n\n        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\n        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n\n        gl_FragColor = vec4(compositeColor, compositeAlpha);\n      } else {\n        if (fillAlphaFactor < ",") {\n          discard;\n        }\n\n        gl_FragColor = premultiplyAlpha(fillPixelColor);\n      }\n\n      // visualize SDF:\n      // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\n      "],["\n      vec4 fillPixelColor = vcolor;\n\n      // Attempt to sample texel centers to avoid that thin cross outlines\n      // disappear with large symbol sizes.\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\n      const float txSize = 128.0;\n      const float texelSize = 1.0 / txSize;\n      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel\n      vec2 scaleFactor = (vsize - txSize) * texelSize;\n      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n\n      // Get distance and map it into [-0.5, 0.5]\n      float d = rgba2float(texture2D(tex, samplePos)) - 0.5;\n\n      // Distance in output units (i.e. pixels)\n      float dist = d * vsize.x;\n\n      // Create smooth transition from the icon into its outline\n      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);\n      fillPixelColor.a *= fillAlphaFactor;\n\n      if (outlineSize > 0.25) {\n        vec4 outlinePixelColor = outlineColor;\n        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n\n        // Create smooth transition around outline\n        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n        outlinePixelColor.a *= outlineAlphaFactor;\n\n        if (\n          outlineAlphaFactor + fillAlphaFactor < "," ||\n          fillPixelColor.a + outlinePixelColor.a < ","\n        ) {\n          discard;\n        }\n\n        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\n        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n\n        gl_FragColor = vec4(compositeColor, compositeAlpha);\n      } else {\n        if (fillAlphaFactor < ",") {\n          discard;\n        }\n\n        gl_FragColor = premultiplyAlpha(fillPixelColor);\n      }\n\n      // visualize SDF:\n      // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\n      "])),b,m.glsl.float(p.symbolAlphaCutoff),b):m.glsl(D||(D=l.__makeTemplateObject(["\n          vec4 texColor = texture2D(tex, vtc, -0.5);\n          if (texColor.a < ",") {\n            discard;\n          }\n          gl_FragColor = texColor * premultiplyAlpha(vcolor);\n          "],["\n          vec4 texColor = texture2D(tex, vtc, -0.5);\n          if (texColor.a < ",") {\n            discard;\n          }\n          gl_FragColor = texColor * premultiplyAlpha(vcolor);\n          "])),b),e.debugDrawBorder?m.glsl(w||(w=l.__makeTemplateObject(["gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);"],["gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);"]))):"");return 0===e.output&&o.fragment.code.add(m.glsl(B||(B=l.__makeTemplateObject(["\n    void main() {\n      ","\n    }\n    "],["\n    void main() {\n      ","\n    }\n    "])),U)),4===e.output&&(o.include(d.OutputHighlight),o.fragment.code.add(m.glsl(H||(H=l.__makeTemplateObject(["\n    void main() {\n      ","\n      ","\n    }\n    "],["\n    void main() {\n      ","\n      ","\n    }\n    "])),U,e.binaryHighlightOcclusionEnabled?m.glsl(k||(k=l.__makeTemplateObject(["\n          if (voccluded == 1.0) {\n            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n          } else {\n            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n          }"],["\n          if (voccluded == 1.0) {\n            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n          } else {\n            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n          }"]))):"outputHighlight();"))),o},function(e){e.bindUniforms=function(e,o,l){e.setUniform4fv("materialColor",o.color),o.textureIsSignedDistanceField&&(o.outlineColor[3]<=0||o.outlineSize<=0?(e.setUniform4fv("outlineColor",r.vec4f64.ZEROS),e.setUniform1f("outlineSize",0)):(e.setUniform4fv("outlineColor",o.outlineColor),e.setUniform1f("outlineSize",o.outlineSize))),e.setUniform2f("screenOffset",2*o.screenOffset[0]*l,2*o.screenOffset[1]*l),e.setUniform2fv("anchorPos",b(o))}}(o.HUDMaterial||(o.HUDMaterial={})),o.calculateAnchorPosForRendering=b;var h,C,z,P,S,_,j,A,O,y,F,D,w,T,B,k,H,U=i.vec2f64.create()}));