/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../../core/maybe.js";import r from"../../../../core/PerformanceSampler.js";import{Milliseconds as t}from"../../../../core/time.js";import{once as s}from"../../../../core/accessorSupport/utils.js";import{startMeasurement as a}from"../../../webgl/Measurement.js";var i;!function(e){e[e.Prepare=0]="Prepare",e[e.Shadowmap=1]="Shadowmap",e[e.Lineardepth=2]="Lineardepth",e[e.Normals=3]="Normals",e[e.SSAO=4]="SSAO",e[e.Opaque=5]="Opaque",e[e.OpaqueEdges=6]="OpaqueEdges",e[e.Transparent=7]="Transparent",e[e.TransparentEdges=8]="TransparentEdges",e[e.Hudvisibility=9]="Hudvisibility",e[e.TransparentTerrain=10]="TransparentTerrain",e[e.Atmosphere=11]="Atmosphere",e[e.Laserline=12]="Laserline",e[e.Occluded=13]="Occluded",e[e.Antialiasing=14]="Antialiasing",e[e.Highlights=15]="Highlights",e[e.HudOccluded=16]="HudOccluded",e[e.HudNotoccluded=17]="HudNotoccluded"}(i||(i={}));const n=["prepare","shadowmap","lineardepth","normals","ssao","opaque","opaque edges","transparent","transparent edges","hudvisibility","transparent terrain","atmosphere","laserline","occluded","antialiasing","highlights","hudOccluded","hudNotoccluded"];class o extends r{constructor(){super("total"),this.total=0,this.frameCount=0}}class m{constructor(){this._startTime=t(0),this._lastSample=t(0),this._enableGPUTimer=0,this.totalTime=new o,this.gpuTime=new r("gpu",9),this.renderPassTimings=n.map((e=>new r(e)))}get elapsedTime(){return t(performance.now()-this._startTime)}enableGPUTimer(){return++this._enableGPUTimer,{remove:s((()=>--this._enableGPUTimer))}}prerender(e){this._startTime=this._lastSample=t(performance.now()),this._enableGPUTimer&&(this._gpuTimer=a(e))}advance(e){const r=t(performance.now());this.renderPassTimings[e].record(r-this._lastSample),this._lastSample=r}postrender(){e(this._gpuTimer)&&(this._gpuTimer.stop((r=>e(r)&&this.gpuTime.record(r)),16),this._gpuTimer=null);const r=performance.now()-this._startTime;this.totalTime.record(r),this.totalTime.total+=r,this.totalTime.frameCount++}}export{o as RenderTime,m as RendererPerformanceInfo,i as Statistics,n as performanceStatsCategories};
