/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{BufferViewVec3f as t,BufferViewMat3f as i,BufferViewVec4f as e}from"../../../../../geometry/support/buffer/BufferView.js";import{assert as s}from"../Util.js";import{VertexAttribute as a}from"../VertexAttribute.js";import r from"./BackedBufferObject.js";class h{constructor(s){this.modelOriginHi=s.getField(a.MODELORIGINHI,t),this.modelOriginLo=s.getField(a.MODELORIGINLO,t),this.model=s.getField(a.MODEL,i),this.modelNormal=s.getField(a.MODELNORMAL,i),this.color=s.getField(a.INSTANCECOLOR,e),this.featureAttribute=s.getField(a.INSTANCEFEATUREATTRIBUTE,e)}}class n{constructor(t,i){this._headIndex=0,this._tailIndex=0,this._captureFirstIndex=!0,this._updating=!1,this._prevHeadIndex=0,this._resized=!1,this._rctx=t,this._instanceBufferLayout=i,this._elementSize=i.stride,this._capacity=1}destroy(){this._buffer&&this._buffer.destroy()}get buffer(){return this._buffer.buffer}get view(){return this._view}get capacity(){return this._capacity}get size(){const t=this._headIndex,i=this._tailIndex;return t>=i?t-i:t+this._capacity-i}get isEmpty(){return this._headIndex===this._tailIndex}get isFull(){return this._tailIndex===(this._headIndex+1)%this._capacity}get headIndex(){return this._headIndex}get tailIndex(){return this._tailIndex}get firstIndex(){return this._firstIndex}get memoryUsage(){return this._buffer?this._buffer.memoryUsage:{cpu:0,gpu:0}}reset(){this._headIndex=0,this._tailIndex=0,this._firstIndex=null}startUpdateCylce(){this._captureFirstIndex=!0}beginUpdate(){s(!this._updating,"already updating"),this._updating=!0,this._prevHeadIndex=this._headIndex}endUpdate(){s(this._updating,"not updating"),this.size<c*this.capacity&&this._shrink(),this._resized?(this._buffer.transferAll(),this._resized=!1):this._transferRange(this._prevHeadIndex,this._headIndex),this._updating=!1}allocateHead(){s(this._updating,"not updating"),this.isFull&&this._grow();const t=this.headIndex;return this._captureFirstIndex&&(this._firstIndex=t,this._captureFirstIndex=!1),this._incrementHead(),s(this._headIndex!==this._tailIndex,"invalid pointers"),t}freeTail(){s(this._updating,"not updating"),s(this.size>0,"invalid size");const t=this._tailIndex===this._firstIndex;this._incrementTail(),t&&(this._firstIndex=this._tailIndex)}_grow(){const t=Math.max(_,Math.floor(this._capacity*d));this._resize(t)}_shrink(){const t=Math.max(_,Math.floor(this._capacity*f));this._resize(t)}_resize(t){if(s(this._updating,"not updating"),t===this._capacity)return;const i=new r(this._rctx,this._elementSize,t);if(this._buffer){this._firstIndex&&(this._firstIndex=(this._firstIndex+this._capacity-this._tailIndex)%this._capacity);const t=this.size,e=this._compactInstances(i);s(e===t,"invalid compaction"),this._buffer.destroy(),this._tailIndex=0,this._headIndex=e,this._prevHeadIndex=0}this._resized=!0,this._capacity=t,this._buffer=i,this._view=new h(this._instanceBufferLayout.createView(this._buffer.array))}_compactInstances(t){const i=this._headIndex,e=this._tailIndex;return e<i?(this._buffer.copyRange(e,i,t),i-e):e>i?(this._buffer.copyRange(e,this._capacity,t),i>0&&this._buffer.copyRange(0,i,t,this._capacity-e),i+(this._capacity-e)):0}_incrementHead(t=1){this._headIndex=(this._headIndex+t)%this._capacity}_incrementTail(t=1){this._tailIndex=(this._tailIndex+t)%this._capacity}_transferRange(t,i){t<i?this._buffer.transferRange(t,i):t>i&&(i>0&&this._buffer.transferRange(0,i),this._buffer.transferRange(t,this._capacity))}}const _=1024,d=2,c=.3,f=.5;export{n as RenderInstanceData,h as RenderInstanceDataView};
