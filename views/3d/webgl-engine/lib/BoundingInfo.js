/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["../../../../core/PooledArray","../../../../chunks/vec3f64","../../../../chunks/vec3","./Util"],(function(i,t,e,s){"use strict";let n=function(){function i(n,r,h,c){this.primitiveIndices=n,this._numIndexPerPrimitive=r,this.indices=h,this._position=c,this.center=t.create(),s.assert(n.length>=1),s.assert(h.length%this._numIndexPerPrimitive==0),s.assert(h.length>=n.length*this._numIndexPerPrimitive),s.assert(3===this._position.size||4===this._position.size);const{data:b,offsetIdx:a,strideIdx:o}=this._position;let d=0;const u=n.length;let l=a+o*h[this._numIndexPerPrimitive*n[d]];for(i.tmpIndices.clear(),i.tmpIndices.push(l),this.bbMin=t.fromValues(b[l],b[l+1],b[l+2]),this.bbMax=t.clone(this.bbMin);d<u;++d){const t=this._numIndexPerPrimitive*n[d];for(let e=0;e<this._numIndexPerPrimitive;++e){l=a+o*h[t+e],i.tmpIndices.push(l);let s=b[l];this.bbMin[0]=Math.min(s,this.bbMin[0]),this.bbMax[0]=Math.max(s,this.bbMax[0]),s=b[l+1],this.bbMin[1]=Math.min(s,this.bbMin[1]),this.bbMax[1]=Math.max(s,this.bbMax[1]),s=b[l+2],this.bbMin[2]=Math.min(s,this.bbMin[2]),this.bbMax[2]=Math.max(s,this.bbMax[2])}}e.lerp(this.center,this.bbMin,this.bbMax,.5),this.bsRadius=.5*Math.max(Math.max(this.bbMax[0]-this.bbMin[0],this.bbMax[1]-this.bbMin[1]),this.bbMax[2]-this.bbMin[2]);let m=this.bsRadius*this.bsRadius;for(d=0;d<i.tmpIndices.length;++d){l=i.tmpIndices.data[d];const t=b[l]-this.center[0],e=b[l+1]-this.center[1],s=b[l+2]-this.center[2],n=t*t+e*e+s*s;if(n<=m)continue;const r=Math.sqrt(n),h=.5*(r-this.bsRadius);this.bsRadius=this.bsRadius+h,m=this.bsRadius*this.bsRadius;const c=h/r;this.center[0]+=t*c,this.center[1]+=e*c,this.center[2]+=s*c}i.tmpIndices.clear()}var n=i.prototype;return n.getCenter=function(){return this.center},n.getBSRadius=function(){return this.bsRadius},n.getBBMin=function(){return this.bbMin},n.getBBMax=function(){return this.bbMax},n.getPrimitiveIndices=function(){return this.primitiveIndices},n.getIndices=function(){return this.indices},n.getPosition=function(){return this._position},n.getChildren=function(){if(this._children)return this._children;if(e.squaredDistance(this.bbMin,this.bbMax)>1){const s=e.lerp(t.create(),this.bbMin,this.bbMax,.5),n=this.primitiveIndices.length,r=new Uint8Array(n),h=new Array(8);for(let i=0;i<8;++i)h[i]=0;const{data:c,offsetIdx:b,strideIdx:a}=this._position;for(let i=0;i<n;++i){let t=0;const e=this._numIndexPerPrimitive*this.primitiveIndices[i];let n=b+a*this.indices[e],o=c[n],d=c[n+1],u=c[n+2];for(let i=1;i<this._numIndexPerPrimitive;++i){n=b+a*this.indices[e+i];const t=c[n],s=c[n+1],r=c[n+2];t<o&&(o=t),s<d&&(d=s),r<u&&(u=r)}o<s[0]&&(t|=1),d<s[1]&&(t|=2),u<s[2]&&(t|=4),r[i]=t,++h[t]}let o=0;for(let i=0;i<8;++i)h[i]>0&&++o;if(o<2)return;const d=new Array(8);for(let i=0;i<8;++i)d[i]=h[i]>0?new Uint32Array(h[i]):void 0;for(let i=0;i<8;++i)h[i]=0;for(let i=0;i<n;++i){const t=r[i];d[t][h[t]++]=this.primitiveIndices[i]}this._children=new Array(8);for(let t=0;t<8;++t)void 0!==d[t]&&(this._children[t]=new i(d[t],this._numIndexPerPrimitive,this.indices,this._position))}return this._children},i}();return function(t){t.tmpIndices=new i({deallocator:null})}(n||(n={})),n}));
