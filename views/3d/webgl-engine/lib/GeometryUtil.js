/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["../../../../chunks/vec3f64","../../../../chunks/vec3","../../../../chunks/vec3f32","../../support/geometryUtils","./BufferVectorMath","./Util","./geometryDataUtils","./Geometry"],(function(e,t,n,r,a,o,s,l){"use strict";const i=a.Vec3Compact;var c,u,f,m;!function(e){const t=.5,n=[[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t],[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t]],r=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],a=[0,0,1,0,1,1,0,1],o=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),s=new Uint16Array(36);for(let l=0;l<6;l++)for(let e=0;e<6;e++)s[6*l+e]=l;const i=new Uint16Array(36);for(let l=0;l<6;l++)i[6*l+0]=0,i[6*l+1]=1,i[6*l+2]=2,i[6*l+3]=2,i[6*l+4]=3,i[6*l+5]=0;function c(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(24);for(let r=0;r<8;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new l.Geometry([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}],["uv0",{size:2,data:a}]],[["position",o],["normal",s],["uv0",i]])}e.createGeometry=c}(c||(c={})),function(e){const t=.5,n=[[-t,0,-t],[t,0,-t],[t,0,t],[-t,0,t],[0,-t,0],[0,t,0]],r=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],a=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),o=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);function s(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(18);for(let r=0;r<6;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new l.Geometry([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}]],[["position",a],["normal",o]])}e.createGeometry=s}(u||(u={})),function(e){const r=.5,a=0,o=n.fromValues(-r,a,-r),s=n.fromValues(r,a,-r),i=n.fromValues(0,a,r),c=n.fromValues(0,a+r,0),u=n.create(),f=n.create(),m=n.create(),h=n.create(),y=n.create();t.subtract(u,o,c),t.subtract(f,o,s),t.cross(m,u,f),t.normalize(m,m),t.subtract(u,s,c),t.subtract(f,s,i),t.cross(h,u,f),t.normalize(h,h),t.subtract(u,i,c),t.subtract(f,i,o),t.cross(y,u,f),t.normalize(y,y);const d=[o,s,i,c],p=[0,-1,0,m[0],m[1],m[2],h[0],h[1],h[2],y[0],y[1],y[2]],g=[0,1,2,3,1,0,3,2,1,3,0,2],A=[0,0,0,1,1,1,2,2,2,3,3,3];function w(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(12);for(let n=0;n<4;n++)t[3*n]=d[n][0]*e[0],t[3*n+1]=d[n][1]*e[1],t[3*n+2]=d[n][2]*e[2];return new l.Geometry([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:p}]],[["position",new Uint16Array(g)],["normal",new Uint16Array(A)]])}e.createGeometry=w}(f||(f={})),function(a){function m(e,t,n,r={uv:!0}){const a=-Math.PI,o=2*Math.PI,s=-Math.PI/2,i=Math.PI,c=Math.max(3,Math.floor(t)),u=Math.max(2,Math.floor(n)),f=(c+1)*(u+1),m=new Float32Array(3*f),h=new Float32Array(3*f),y=new Float32Array(2*f),d=[];let p=0;for(let l=0;l<=u;l++){const t=[],n=l/u,r=s+n*i,f=Math.cos(r);for(let s=0;s<=c;s++){const l=s/c,i=a+l*o,u=Math.cos(i)*f,d=Math.sin(r),g=-Math.sin(i)*f;m[3*p]=u*e,m[3*p+1]=d*e,m[3*p+2]=g*e,h[3*p]=u,h[3*p+1]=d,h[3*p+2]=g,y[2*p]=l,y[2*p+1]=n,t.push(p),++p}d.push(t)}const g=new Uint32Array(2*c*(u-1)*3);p=0;for(let l=0;l<u;l++)for(let e=0;e<c;e++){const t=d[l][e],n=d[l][e+1],r=d[l+1][e+1],a=d[l+1][e];0===l?(g[p++]=t,g[p++]=r,g[p++]=a):l===u-1?(g[p++]=t,g[p++]=n,g[p++]=r):(g[p++]=t,g[p++]=n,g[p++]=r,g[p++]=r,g[p++]=a,g[p++]=t)}const A=[["position",g],["normal",g]],w=[["position",{size:3,data:m,exclusive:!0}],["normal",{size:3,data:h,exclusive:!0}]];return r.uv&&(w.push(["uv0",{size:2,data:y,exclusive:!0}]),A.push(["uv0",g])),r.offset&&(A[0][0]="offset",w[0][0]="offset",A.push(["position",new Uint32Array(g.length)]),w.push(["position",{size:3,data:Float64Array.from(r.offset),exclusive:!0}])),new l.Geometry(w,A)}function d(e,t,n){const r=e;let a,o;if(n)a=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const e=r*(1+Math.sqrt(5))/2;a=[-r,e,0,r,e,0,-r,-e,0,r,-e,0,0,-r,e,0,r,e,0,-r,-e,0,r,-e,e,0,-r,e,0,r,-e,0,-r,-e,0,r],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let l=0;l<a.length;l+=3)i.scale(a,l,e/i.length(a,l));let s={};function c(t,n){t>n&&([t,n]=[n,t]);const r=t.toString()+"."+n.toString();if(s[r])return s[r];let o=a.length;return a.length+=3,i.add(a,3*t,a,3*n,a,o),i.scale(a,o,e/i.length(a,o)),o/=3,s[r]=o,o}for(let l=0;l<t;l++){const e=o.length,t=new Uint32Array(4*e);for(let n=0;n<e;n+=3){const e=o[n],r=o[n+1],a=o[n+2],s=c(e,r),l=c(r,a),i=c(a,e),u=4*n;t[u]=e,t[u+1]=s,t[u+2]=i,t[u+3]=r,t[u+4]=l,t[u+5]=s,t[u+6]=a,t[u+7]=i,t[u+8]=l,t[u+9]=s,t[u+10]=l,t[u+11]=i}o=t,s={}}const u=new Float32Array(a);for(let l=0;l<u.length;l+=3)i.normalize(u,l);const f=[["position",o],["normal",o]],m=[["position",{size:3,data:new Float32Array(a),exclusive:!0}],["normal",{size:3,data:u,exclusive:!0}]];return new l.Geometry(m,f)}function p(e,t,n,r,a,o,s){const i=t?[t[0],t[1],t[2]]:[0,0,0],c=e?[e[0],e[1],e[2]]:[0,0,1];o=o||[0,0];const u=n?[255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]:[255,255,255,255],f=null!=r&&2===r.length?r:[1,1],m=[["position",{size:3,data:i,exclusive:!0}],["normal",{size:3,data:c,exclusive:!0}],["uv0",{size:o.length,data:o}],["color",{size:4,data:u,exclusive:!0}],["size",{size:2,data:f}]];if(null!=a){const e=new Float32Array([a[0],a[1],a[2],a[3]]);m.push(["auxpos1",{size:4,data:e}])}if(null!=s){const e=new Float32Array([s[0],s[1],s[2],s[3]]);m.push(["auxpos2",{size:4,data:e}])}return new l.Geometry(m,null,1)}function g(e,t,n,r,a,o,s,l){if(null!=e){const{data:t}=l.getMutableAttribute("normal");t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=t){const{data:e}=l.getMutableAttribute("position");e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=n){const{data:e}=l.getMutableAttribute("color");e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3]}if(null!=r){const{data:e}=l.getMutableAttribute("size");e[0]=r[0],e[1]=r[1]}if(null!=a){const{data:e}=l.getMutableAttribute("auxpos1");e[0]=a[0],e[1]=a[1],e[2]=a[2],e[3]=a[3]}if(null!=o){const{data:e}=l.getMutableAttribute("uv0");e[0]=o[0],e[1]=o[1]}if(null!=s){const{data:e}=l.getMutableAttribute("auxpos2");e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3]}}function A(e,t){const n=new Float32Array(3*e.length),r=new Float32Array(t?3*e.length:3),a=new Uint32Array(e.length),o=new Uint32Array(e.length);for(let l=0;l<e.length;l++)n[3*l]=e[l][0],n[3*l+1]=e[l][1],n[3*l+2]=e[l][2],t&&(r[3*l]=t[l][0],r[3*l+1]=t[l][1],r[3*l+2]=t[l][2]),a[l]=l,o[l]=0;t||(r[0]=0,r[1]=1,r[2]=0);const s=[["position",a],["normal",t?a:o],["uv0",o]],i=[["position",{size:3,data:n,exclusive:!0}],["normal",{size:3,data:r,exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]];return new l.Geometry(i,s,1)}function w(){const e=[0,0,0,0,0,100,100,0,0],t=[0,1,0],n=[0,0],r=[["position",new Uint16Array([0,1,2])],["normal",new Uint16Array([0,0,0])],["uv0",new Uint16Array([0,0,0])]],a=[["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:t,exclusive:!0}],["uv0",{size:2,data:n,exclusive:!0}]];return new l.Geometry(a,r)}a.createBoxGeometry=c.createGeometry,a.createDiamondGeometry=u.createGeometry,a.createTetrahedronGeometry=f.createGeometry,a.createSphereGeometry=m,a.createPolySphereGeometry=d,a.createPointGeometry=p,a.updatePointGeometry=g,a.createPointArrayGeometry=A,a.createTriangleGeometry=w;const z=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function v(e=z){const t=new Array(12);for(let l=0;l<4;l++)for(let n=0;n<3;n++)t[3*l+n]=e[l][n];const n=new Uint32Array([0,1,2,2,3,0]),r=[0,0,1],a=new Uint32Array([0,0,0,0,0,0]),o=[["position",n],["normal",a],["uv0",n],["color",a]],s=[["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r,exclusive:!0}],["uv0",{size:2,data:[0,0,1,0,1,1,0,1],exclusive:!0}],["color",{size:4,data:[255,255,255,255],exclusive:!0}]];return new l.Geometry(s,o)}function x(e,t,r,a,o=!0,s=!0){let i=0;const c=t,u=e;let f=n.fromValues(0,i,0),m=n.fromValues(0,i+u,0),h=n.fromValues(0,-1,0),y=n.fromValues(0,1,0);a&&(i=u,m=n.fromValues(0,0,0),f=n.fromValues(0,i,0),h=n.fromValues(0,1,0),y=n.fromValues(0,-1,0));const d=[m,f],p=[h,y],g=r+2,A=Math.sqrt(u*u+c*c);if(a)for(let l=r-1;l>=0;l--){const e=l*(2*Math.PI/r),t=n.fromValues(Math.cos(e)*c,i,Math.sin(e)*c);d.push(t);const a=n.fromValues(u*Math.cos(e)/A,-c/A,u*Math.sin(e)/A);p.push(a)}else for(let l=0;l<r;l++){const e=l*(2*Math.PI/r),t=n.fromValues(Math.cos(e)*c,i,Math.sin(e)*c);d.push(t);const a=n.fromValues(u*Math.cos(e)/A,c/A,u*Math.sin(e)/A);p.push(a)}const w=new Uint32Array(2*(r+2)*3),z=new Uint32Array(2*(r+2)*3);let v=0,x=0;if(o){for(let e=3;e<d.length;e++)w[v++]=1,w[v++]=e-1,w[v++]=e,z[x++]=0,z[x++]=0,z[x++]=0;w[v++]=d.length-1,w[v++]=2,w[v++]=1,z[x++]=0,z[x++]=0,z[x++]=0}if(s){for(let e=3;e<d.length;e++)w[v++]=e,w[v++]=e-1,w[v++]=0,z[x++]=e,z[x++]=e-1,z[x++]=1;w[v++]=0,w[v++]=2,w[v++]=d.length-1,z[x++]=1,z[x++]=2,z[x++]=p.length-1}const M=new Float32Array(3*g);for(let n=0;n<g;n++)M[3*n]=d[n][0],M[3*n+1]=d[n][1],M[3*n+2]=d[n][2];const G=new Float32Array(3*g);for(let n=0;n<g;n++)G[3*n]=p[n][0],G[3*n+1]=p[n][1],G[3*n+2]=p[n][2];const b=[["position",w],["normal",z]],U=[["position",{size:3,data:M,exclusive:!0}],["normal",{size:3,data:G,exclusive:!0}]];return new l.Geometry(U,b)}function M(e,r,a,o,s,i){const c=o?n.clone(o):n.fromValues(1,0,0),u=s?n.clone(s):n.fromValues(0,0,0);i=null==i||i;const f=n.create();t.normalize(f,c);const m=n.create();t.scale(m,f,Math.abs(e));const h=n.create();t.scale(h,m,-.5),t.add(h,h,u);const y=n.fromValues(0,1,0);Math.abs(1-t.dot(f,y))<.2&&t.set(y,0,0,1);const d=n.create();t.cross(d,f,y),t.normalize(d,d),t.cross(y,d,f);const p=2*a+(i?2:0),g=a+(i?2:0),A=new Float32Array(3*p),w=new Float32Array(3*g),z=new Float32Array(2*p),v=new Uint32Array(3*a*(i?4:2)),x=new Uint32Array(3*a*(i?4:2));i&&(A[3*(p-2)+0]=h[0],A[3*(p-2)+1]=h[1],A[3*(p-2)+2]=h[2],z[2*(p-2)]=0,z[2*(p-2)+1]=0,A[3*(p-1)+0]=A[3*(p-2)+0]+m[0],A[3*(p-1)+1]=A[3*(p-2)+1]+m[1],A[3*(p-1)+2]=A[3*(p-2)+2]+m[2],z[2*(p-1)]=1,z[2*(p-1)+1]=1,w[3*(g-2)+0]=-f[0],w[3*(g-2)+1]=-f[1],w[3*(g-2)+2]=-f[2],w[3*(g-1)+0]=f[0],w[3*(g-1)+1]=f[1],w[3*(g-1)+2]=f[2]);const M=function(e,t,n){v[e]=t,x[e]=n};let G=0;const b=n.create(),U=n.create();for(let n=0;n<a;n++){const e=n*(2*Math.PI/a);t.scale(b,y,Math.sin(e)),t.scale(U,d,Math.cos(e)),t.add(b,b,U),w[3*n+0]=b[0],w[3*n+1]=b[1],w[3*n+2]=b[2],t.scale(b,b,r),t.add(b,b,h),A[3*n+0]=b[0],A[3*n+1]=b[1],A[3*n+2]=b[2],z[2*n+0]=n/a,z[2*n+1]=0,A[3*(n+a)+0]=A[3*n+0]+m[0],A[3*(n+a)+1]=A[3*n+1]+m[1],A[3*(n+a)+2]=A[3*n+2]+m[2],z[2*(n+a)+0]=n/a,z[2*n+1]=1;const o=(n+1)%a;M(G++,n,n),M(G++,n+a,n),M(G++,o,o),M(G++,o,o),M(G++,n+a,n),M(G++,o+a,o)}if(i){for(let e=0;e<a;e++){const t=(e+1)%a;M(G++,p-2,g-2),M(G++,e,g-2),M(G++,t,g-2)}for(let e=0;e<a;e++){const t=(e+1)%a;M(G++,e+a,g-1),M(G++,p-1,g-1),M(G++,t+a,g-1)}}const V=[["position",v],["normal",x],["uv0",v]],P=[["position",{size:3,data:A,exclusive:!0}],["normal",{size:3,data:w,exclusive:!0}],["uv0",{size:2,data:z,exclusive:!0}]];return new l.Geometry(P,V)}function G(e,t,n,r,s){n=n||10,r=null==r||r,o.assert(e.length>1);const l=[[0,0,0]],i=[],c=[];for(let a=0;a<n;a++){i.push([0,-a-1,-(a+1)%n-1]);const e=a/n*2*Math.PI;c.push([Math.cos(e)*t,Math.sin(e)*t])}return a.createPathExtrusionGeometry(c,e,l,i,r,s)}function b(a,o,s,i,c,u=n.fromValues(0,0,0)){const f=a.length,m=new Float32Array(o.length*f*3+(6*s.length||0)),y=new Float32Array(o.length*f*3+(s?6:0)),d=(o.length-1)*f*6+3*i.length*2,p=new Uint32Array(d),g=new Uint32Array(d);let A=0,w=0,z=0,v=0;const x=n.create(),M=n.create(),G=n.create(),b=n.create(),U=n.create(),V=n.create(),P=n.create(),F=e.create(),I=n.create(),S=n.create(),D=n.create(),T=n.create(),B=n.create(),q=r.plane.create();t.set(I,0,1,0),t.subtract(M,o[1],o[0]),t.normalize(M,M),c?(t.add(F,o[0],u),t.normalize(G,F)):t.set(G,0,0,1),k(M,G,I,I,U,G,h),t.copy(b,G),t.copy(T,U);for(let e=0;e<s.length;e++)t.scale(V,U,s[e][0]),t.scale(F,G,s[e][2]),t.add(V,V,F),t.add(V,V,o[0]),m[A++]=V[0],m[A++]=V[1],m[A++]=V[2];y[w++]=-M[0],y[w++]=-M[1],y[w++]=-M[2];for(let e=0;e<i.length;e++)p[z++]=i[e][0]>0?i[e][0]:-i[e][0]-1+s.length,p[z++]=i[e][1]>0?i[e][1]:-i[e][1]-1+s.length,p[z++]=i[e][2]>0?i[e][2]:-i[e][2]-1+s.length,g[v++]=0,g[v++]=0,g[v++]=0;let C=s.length;const E=s.length-1;for(let e=0;e<o.length;e++){let n=!1;if(e>0){t.copy(x,M),e<o.length-1?(t.subtract(M,o[e+1],o[e]),t.normalize(M,M)):n=!0,t.add(S,x,M),t.normalize(S,S),t.add(D,o[e-1],b),r.plane.fromPositionAndNormal(o[e],S,q);r.plane.intersectRay(q,r.ray.wrap(D,x),F)?(t.subtract(F,F,o[e]),t.normalize(G,F),t.cross(U,S,G),t.normalize(U,U)):k(S,b,T,I,U,G,h),t.copy(b,G),t.copy(T,U)}c&&(t.add(F,o[e],u),t.normalize(B,F));for(let r=0;r<f;r++)if(t.scale(V,U,a[r][0]),t.scale(F,G,a[r][1]),t.add(V,V,F),t.normalize(P,V),y[w++]=P[0],y[w++]=P[1],y[w++]=P[2],t.add(V,V,o[e]),m[A++]=V[0],m[A++]=V[1],m[A++]=V[2],!n){const e=(r+1)%f;p[z++]=C+r,p[z++]=C+f+r,p[z++]=C+e,p[z++]=C+e,p[z++]=C+f+r,p[z++]=C+f+e;for(let t=0;t<6;t++)g[v++]=p[z-6+t]-E}C+=f}const O=o[o.length-1];for(let e=0;e<s.length;e++)t.scale(V,U,s[e][0]),t.scale(F,G,s[e][1]),t.add(V,V,F),t.add(V,V,O),m[A++]=V[0],m[A++]=V[1],m[A++]=V[2];const N=w/3;y[w++]=M[0],y[w++]=M[1],y[w++]=M[2];const R=C-f;for(let e=0;e<i.length;e++)p[z++]=i[e][0]>=0?C+i[e][0]:-i[e][0]-1+R,p[z++]=i[e][2]>=0?C+i[e][2]:-i[e][2]-1+R,p[z++]=i[e][1]>=0?C+i[e][1]:-i[e][1]-1+R,g[v++]=N,g[v++]=N,g[v++]=N;const j=[["position",p],["normal",g]],H=[["position",{size:3,data:m,exclusive:!0}],["normal",{size:3,data:y,exclusive:!0}]];return new l.Geometry(H,j)}function U(e,t,n){o.assert(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),o.assert(3===e[0].length,"createPolylineGeometry(): malformed vertex"),o.assert(null==t||t.length===e.length,"createPolylineGeometry: need same number of points and normals"),o.assert(null==t||3===t[0].length,"createPolylineGeometry(): malformed normal");const r=new Float64Array(3*e.length),a=new Uint32Array(2*(e.length-1));let i=0,c=0;for(let o=0;o<e.length;o++){for(let t=0;t<3;t++)r[i++]=e[o][t];o>0&&(a[c++]=o-1,a[c++]=o)}const u=[],f=[];if(u.push(["position",a]),f.push(["position",{size:3,data:r,exclusive:!0}]),t){const n=new Float32Array(3*t.length);let r=0;for(let a=0;a<e.length;a++)for(let e=0;e<3;e++)n[r++]=t[a][e];u.push(["normal",a]),f.push(["normal",{size:3,data:n,exclusive:!0}])}return n&&(f.push(["color",{size:4,data:n}]),u.push(["color",s.generateDefaultIndexArray(n.length/4)])),new l.Geometry(f,u,2)}function V(e,t,n,r){const a=new Array(18),o=[[-t,0,r/2],[n,0,r/2],[0,e,r/2],[-t,0,-r/2],[n,0,-r/2],[0,e,-r/2]],s=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let l=0;l<6;l++)a[3*l]=o[l][0],a[3*l+1]=o[l][1],a[3*l+2]=o[l][2];return new l.Geometry([["position",{size:3,data:a,exclusive:!0}]],[["position",s]])}function P(e,n){const r=e.getMutableAttribute("position").data;for(let a=0;a<r.length;a+=3){const e=r[a],o=r[a+1],s=r[a+2];t.set(y,e,o,s),t.transformMat4(y,y,n),r[a]=y[0],r[a+1]=y[1],r[a+2]=y[2]}}function F(e,t=e){const n=e.vertexAttributes,r=n.get("position").data,a=n.get("normal").data;if(a){const e=t.getMutableAttribute("normal").data;for(let t=0;t<a.length;t+=3){const n=a[t+1];e[t+1]=-a[t+2],e[t+2]=n}}if(r){const e=t.getMutableAttribute("position").data;for(let t=0;t<r.length;t+=3){const n=r[t+1];e[t+1]=-r[t+2],e[t+2]=n}}return t}function I(e,n,r,a,o){return!(Math.abs(t.dot(n,e))>o)&&(t.cross(r,e,n),t.normalize(r,r),t.cross(a,r,e),t.normalize(a,a),!0)}function k(e,t,n,r,a,o,s){return I(e,t,a,o,s)||I(e,n,a,o,s)||I(e,r,a,o,s)}a.createSquareGeometry=v,a.createConeGeometry=x,a.createCylinderGeometry=M,a.createTubeGeometry=G,a.createPathExtrusionGeometry=b,a.createPolylineGeometry=U,a.createExtrudedTriangle=V,a.transformInPlace=P,a.cgToGIS=F,a.makeOrthoBasisDirUp=I,a.makeOrthoBasisDirUpFallback=k}(m||(m={}));const h=.99619469809,y=n.create();return m}));
