/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","../../../../chunks/vec3","../../../../chunks/vec3f32","../../../../chunks/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/ray","./Attribute","./BufferVectorMath","./ContentObjectType","./DoubleArray","./FloatArray","./Geometry","./Indices","./Util","./VertexAttribute"],(function(t,e,r,n,o,u,s,a,l,c,i,A,h,b,f,V){"use strict";const p=l.Vec3Compact,O=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],y=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],m=[0,0,1,0,1,1,0,1],x=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],w=new Array(36);for(let at=0;at<6;at++)for(let t=0;t<6;t++)w[6*at+t]=at;const I=new Array(36);for(let at=0;at<6;at++)I[6*at+0]=0,I[6*at+1]=1,I[6*at+2]=2,I[6*at+3]=2,I[6*at+4]=3,I[6*at+5]=0;function g(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(24);for(let n=0;n<8;n++)r[3*n]=O[n][0]*e[0],r[3*n+1]=O[n][1]*e[1],r[3*n+2]=O[n][2]*e[2];return new h.Geometry(t,[[V.VertexAttribute.POSITION,new a.Attribute(r,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(y,3)],[V.VertexAttribute.UV0,new a.Attribute(m,2)]],[[V.VertexAttribute.POSITION,x],[V.VertexAttribute.NORMAL,w],[V.VertexAttribute.UV0,I]])}const M=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],d=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],N=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],P=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function S(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(18);for(let n=0;n<6;n++)r[3*n]=M[n][0]*e[0],r[3*n+1]=M[n][1]*e[1],r[3*n+2]=M[n][2]*e[2];return new h.Geometry(t,[[V.VertexAttribute.POSITION,new a.Attribute(r,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(d,3)]],[[V.VertexAttribute.POSITION,N],[V.VertexAttribute.NORMAL,P]])}const T=n.fromValues(-.5,0,-.5),G=n.fromValues(.5,0,-.5),L=n.fromValues(0,0,.5),R=n.fromValues(0,.5,0),F=n.create(),z=n.create(),U=n.create(),C=n.create(),v=n.create();r.subtract(F,T,R),r.subtract(z,T,G),r.cross(U,F,z),r.normalize(U,U),r.subtract(F,G,R),r.subtract(z,G,L),r.cross(C,F,z),r.normalize(C,C),r.subtract(F,L,R),r.subtract(z,L,T),r.cross(v,F,z),r.normalize(v,v);const D=[T,G,L,R],k=[0,-1,0,U[0],U[1],U[2],C[0],C[1],C[2],v[0],v[1],v[2]],E=[0,1,2,3,1,0,3,2,1,3,0,2],j=[0,0,0,1,1,1,2,2,2,3,3,3];function q(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(12);for(let n=0;n<4;n++)r[3*n]=D[n][0]*e[0],r[3*n+1]=D[n][1]*e[1],r[3*n+2]=D[n][2]*e[2];return new h.Geometry(t,[[V.VertexAttribute.POSITION,new a.Attribute(r,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(k,3)]],[[V.VertexAttribute.POSITION,E],[V.VertexAttribute.NORMAL,j]])}function B(t,e,r,n,o={uv:!0}){const u=-Math.PI,s=2*Math.PI,l=-Math.PI/2,c=Math.PI,i=Math.max(3,Math.floor(r)),b=Math.max(2,Math.floor(n)),f=(i+1)*(b+1),p=A.newFloatArray(3*f),O=A.newFloatArray(3*f),y=A.newFloatArray(2*f),m=[];let x=0;for(let a=0;a<=b;a++){const t=[],r=a/b,n=l+r*c,o=Math.cos(n);for(let a=0;a<=i;a++){const l=a/i,c=u+l*s,A=Math.cos(c)*o,h=Math.sin(n),b=-Math.sin(c)*o;p[3*x]=A*e,p[3*x+1]=h*e,p[3*x+2]=b*e,O[3*x]=A,O[3*x+1]=h,O[3*x+2]=b,y[2*x]=l,y[2*x+1]=r,t.push(x),++x}m.push(t)}const w=new Array;for(let a=0;a<b;a++)for(let t=0;t<i;t++){const e=m[a][t],r=m[a][t+1],n=m[a+1][t+1],o=m[a+1][t];0===a?(w.push(e),w.push(n),w.push(o)):a===b-1?(w.push(e),w.push(r),w.push(n)):(w.push(e),w.push(r),w.push(n),w.push(n),w.push(o),w.push(e))}const I=[[V.VertexAttribute.POSITION,w],[V.VertexAttribute.NORMAL,w]],g=[[V.VertexAttribute.POSITION,new a.Attribute(p,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(O,3,!0)]];return o.uv&&(g.push([V.VertexAttribute.UV0,new a.Attribute(y,2,!0)]),I.push([V.VertexAttribute.UV0,w])),o.offset&&(I[0][0]=V.VertexAttribute.OFFSET,g[0][0]=V.VertexAttribute.OFFSET,I.push([V.VertexAttribute.POSITION,new Array(w.length).fill(0)]),g.push([V.VertexAttribute.POSITION,new a.Attribute(Float64Array.from(o.offset),3,!0)])),new h.Geometry(t,g,I)}function X(t,e,r,n){const{vertexAttributes:o,indices:u}=Z(e,r,n);return new h.Geometry(t,o,u)}function Z(t,e,r){const n=t;let o,u;if(r)o=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],u=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const t=n*(1+Math.sqrt(5))/2;o=[-n,t,0,n,t,0,-n,-t,0,n,-t,0,0,-n,t,0,n,t,0,-n,-t,0,n,-t,t,0,-n,t,0,n,-t,0,-n,-t,0,n],u=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let a=0;a<o.length;a+=3)p.scale(o,a,t/p.length(o,a));let s={};function l(e,r){e>r&&([e,r]=[r,e]);const n=e.toString()+"."+r.toString();if(s[n])return s[n];let u=o.length;return o.length+=3,p.add(o,3*e,o,3*r,o,u),p.scale(o,u,t/p.length(o,u)),u/=3,s[n]=u,u}for(let a=0;a<e;a++){const t=u.length,e=new Array(4*t);for(let r=0;r<t;r+=3){const t=u[r],n=u[r+1],o=u[r+2],s=l(t,n),a=l(n,o),c=l(o,t),i=4*r;e[i]=t,e[i+1]=s,e[i+2]=c,e[i+3]=n,e[i+4]=a,e[i+5]=s,e[i+6]=o,e[i+7]=c,e[i+8]=a,e[i+9]=s,e[i+10]=a,e[i+11]=c}u=e,s={}}const c=A.floatArrayFrom(o);for(let a=0;a<c.length;a+=3)p.normalize(c,a);const i=[[V.VertexAttribute.POSITION,u],[V.VertexAttribute.NORMAL,u]];return{vertexAttributes:[[V.VertexAttribute.POSITION,new a.Attribute(A.floatArrayFrom(o),3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(c,3,!0)]],indices:i}}function H(t,r,n,o,u,s,l,i,A=null){const b=n?[n[0],n[1],n[2]]:[0,0,0],f=r?[r[0],r[1],r[2]]:[0,0,1];l=l||[0,0];const p=o?[255*o[0],255*o[1],255*o[2],o.length>3?255*o[3]:255]:[255,255,255,255],O=e.isSome(u)&&2===u.length?u:[1,1],y=[[V.VertexAttribute.POSITION,new a.Attribute(b,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(f,3,!0)],[V.VertexAttribute.UV0,new a.Attribute(l,l.length)],[V.VertexAttribute.COLOR,new a.Attribute(p,4,!0)],[V.VertexAttribute.SIZE,new a.Attribute(O,2)]];if(null!=s){const t=[s[0],s[1],s[2],s[3]];y.push([V.VertexAttribute.AUXPOS1,new a.Attribute(t,4)])}if(null!=i){const t=[i[0],i[1],i[2],i[3]];y.push([V.VertexAttribute.AUXPOS2,new a.Attribute(t,4)])}return new h.Geometry(t,y,null,null,c.ContentObjectType.Point,A)}const J=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function K(t,e=J){const r=new Array(12);for(let a=0;a<4;a++)for(let t=0;t<3;t++)r[3*a+t]=e[a][t];const n=[0,1,2,2,3,0],o=[0,0,1],u=[0,0,0,0,0,0],s=[0,0,1,0,1,1,0,1],l=[255,255,255,255],c=[[V.VertexAttribute.POSITION,n],[V.VertexAttribute.NORMAL,u],[V.VertexAttribute.UV0,n],[V.VertexAttribute.COLOR,u]],i=[[V.VertexAttribute.POSITION,new a.Attribute(r,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(o,3,!0)],[V.VertexAttribute.UV0,new a.Attribute(s,2,!0)],[V.VertexAttribute.COLOR,new a.Attribute(l,4,!0)]];return new h.Geometry(t,i,c)}function Q(t,e,r,o,u,s=!0,l=!0){let c=0;const i=r,b=e;let f=n.fromValues(0,c,0),p=n.fromValues(0,c+b,0),O=n.fromValues(0,-1,0),y=n.fromValues(0,1,0);u&&(c=b,p=n.fromValues(0,0,0),f=n.fromValues(0,c,0),O=n.fromValues(0,1,0),y=n.fromValues(0,-1,0));const m=[p,f],x=[O,y],w=o+2,I=Math.sqrt(b*b+i*i);if(u)for(let a=o-1;a>=0;a--){const t=a*(2*Math.PI/o),e=n.fromValues(Math.cos(t)*i,c,Math.sin(t)*i);m.push(e);const r=n.fromValues(b*Math.cos(t)/I,-i/I,b*Math.sin(t)/I);x.push(r)}else for(let a=0;a<o;a++){const t=a*(2*Math.PI/o),e=n.fromValues(Math.cos(t)*i,c,Math.sin(t)*i);m.push(e);const r=n.fromValues(b*Math.cos(t)/I,i/I,b*Math.sin(t)/I);x.push(r)}const g=new Array,M=new Array;if(s){for(let t=3;t<m.length;t++)g.push(1),g.push(t-1),g.push(t),M.push(0),M.push(0),M.push(0);g.push(m.length-1),g.push(2),g.push(1),M.push(0),M.push(0),M.push(0)}if(l){for(let t=3;t<m.length;t++)g.push(t),g.push(t-1),g.push(0),M.push(t),M.push(t-1),M.push(1);g.push(0),g.push(2),g.push(m.length-1),M.push(1),M.push(2),M.push(x.length-1)}const d=A.newFloatArray(3*w);for(let n=0;n<w;n++)d[3*n]=m[n][0],d[3*n+1]=m[n][1],d[3*n+2]=m[n][2];const N=A.newFloatArray(3*w);for(let n=0;n<w;n++)N[3*n]=x[n][0],N[3*n+1]=x[n][1],N[3*n+2]=x[n][2];const P=[[V.VertexAttribute.POSITION,g],[V.VertexAttribute.NORMAL,M]],S=[[V.VertexAttribute.POSITION,new a.Attribute(d,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(N,3,!0)]];return new h.Geometry(t,S,P)}function W(t,e,o,u,s,l,c){const i=s?n.clone(s):n.fromValues(1,0,0),b=l?n.clone(l):n.fromValues(0,0,0);c=c??!0;const f=n.create();r.normalize(f,i);const p=n.create();r.scale(p,f,Math.abs(e));const O=n.create();r.scale(O,p,-.5),r.add(O,O,b);const y=n.fromValues(0,1,0);Math.abs(1-r.dot(f,y))<.2&&r.set(y,0,0,1);const m=n.create();r.cross(m,f,y),r.normalize(m,m),r.cross(y,m,f);const x=2*u+(c?2:0),w=u+(c?2:0),I=A.newFloatArray(3*x),g=A.newFloatArray(3*w),M=A.newFloatArray(2*x),d=new Array(3*u*(c?4:2)),N=new Array(3*u*(c?4:2));c&&(I[3*(x-2)+0]=O[0],I[3*(x-2)+1]=O[1],I[3*(x-2)+2]=O[2],M[2*(x-2)]=0,M[2*(x-2)+1]=0,I[3*(x-1)+0]=I[3*(x-2)+0]+p[0],I[3*(x-1)+1]=I[3*(x-2)+1]+p[1],I[3*(x-1)+2]=I[3*(x-2)+2]+p[2],M[2*(x-1)]=1,M[2*(x-1)+1]=1,g[3*(w-2)+0]=-f[0],g[3*(w-2)+1]=-f[1],g[3*(w-2)+2]=-f[2],g[3*(w-1)+0]=f[0],g[3*(w-1)+1]=f[1],g[3*(w-1)+2]=f[2]);const P=(t,e,r)=>{d[t]=e,N[t]=r};let S=0;const T=n.create(),G=n.create();for(let n=0;n<u;n++){const t=n*(2*Math.PI/u);r.scale(T,y,Math.sin(t)),r.scale(G,m,Math.cos(t)),r.add(T,T,G),g[3*n+0]=T[0],g[3*n+1]=T[1],g[3*n+2]=T[2],r.scale(T,T,o),r.add(T,T,O),I[3*n+0]=T[0],I[3*n+1]=T[1],I[3*n+2]=T[2],M[2*n+0]=n/u,M[2*n+1]=0,I[3*(n+u)+0]=I[3*n+0]+p[0],I[3*(n+u)+1]=I[3*n+1]+p[1],I[3*(n+u)+2]=I[3*n+2]+p[2],M[2*(n+u)+0]=n/u,M[2*n+1]=1;const e=(n+1)%u;P(S++,n,n),P(S++,n+u,n),P(S++,e,e),P(S++,e,e),P(S++,n+u,n),P(S++,e+u,e)}if(c){for(let t=0;t<u;t++){const e=(t+1)%u;P(S++,x-2,w-2),P(S++,t,w-2),P(S++,e,w-2)}for(let t=0;t<u;t++){const e=(t+1)%u;P(S++,t+u,w-1),P(S++,x-1,w-1),P(S++,e+u,w-1)}}const L=[[V.VertexAttribute.POSITION,d],[V.VertexAttribute.NORMAL,N],[V.VertexAttribute.UV0,d]],R=[[V.VertexAttribute.POSITION,new a.Attribute(I,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(g,3,!0)],[V.VertexAttribute.UV0,new a.Attribute(M,2,!0)]];return new h.Geometry(t,R,L)}function Y(t,e,r,n,o,u){n=n||10,o=null==o||o,f.assert(e.length>1);const s=[[0,0,0]],a=[],l=[];for(let c=0;c<n;c++){a.push([0,-c-1,-(c+1)%n-1]);const t=c/n*2*Math.PI;l.push([Math.cos(t)*r,Math.sin(t)*r])}return $(t,l,e,s,a,o,u)}function $(t,e,l,c,i,b,f=n.fromValues(0,0,0)){const p=e.length,O=A.newFloatArray(l.length*p*3+(6*c.length||0)),y=A.newFloatArray(l.length*p*3+(c?6:0)),m=new Array,x=new Array;let w=0,I=0;const g=n.create(),M=n.create(),d=n.create(),N=n.create(),P=n.create(),S=n.create(),T=n.create(),G=o.create(),L=n.create(),R=n.create(),F=n.create(),z=n.create(),U=n.create(),C=u.create();r.set(L,0,1,0),r.subtract(M,l[1],l[0]),r.normalize(M,M),b?(r.add(G,l[0],f),r.normalize(d,G)):r.set(d,0,0,1),ot(M,d,L,L,P,d,ut),r.copy(N,d),r.copy(z,P);for(let n=0;n<c.length;n++)r.scale(S,P,c[n][0]),r.scale(G,d,c[n][2]),r.add(S,S,G),r.add(S,S,l[0]),O[w++]=S[0],O[w++]=S[1],O[w++]=S[2];y[I++]=-M[0],y[I++]=-M[1],y[I++]=-M[2];for(let r=0;r<i.length;r++)m.push(i[r][0]>0?i[r][0]:-i[r][0]-1+c.length),m.push(i[r][1]>0?i[r][1]:-i[r][1]-1+c.length),m.push(i[r][2]>0?i[r][2]:-i[r][2]-1+c.length),x.push(0),x.push(0),x.push(0);let v=c.length;const D=c.length-1;for(let n=0;n<l.length;n++){let t=!1;if(n>0){r.copy(g,M),n<l.length-1?(r.subtract(M,l[n+1],l[n]),r.normalize(M,M)):t=!0,r.add(R,g,M),r.normalize(R,R),r.add(F,l[n-1],N),u.fromPositionAndNormal(l[n],R,C);u.intersectRay(C,s.wrap(F,g),G)?(r.subtract(G,G,l[n]),r.normalize(d,G),r.cross(P,R,d),r.normalize(P,P)):ot(R,N,z,L,P,d,ut),r.copy(N,d),r.copy(z,P)}b&&(r.add(G,l[n],f),r.normalize(U,G));for(let o=0;o<p;o++)if(r.scale(S,P,e[o][0]),r.scale(G,d,e[o][1]),r.add(S,S,G),r.normalize(T,S),y[I++]=T[0],y[I++]=T[1],y[I++]=T[2],r.add(S,S,l[n]),O[w++]=S[0],O[w++]=S[1],O[w++]=S[2],!t){const t=(o+1)%p;m.push(v+o),m.push(v+p+o),m.push(v+t),m.push(v+t),m.push(v+p+o),m.push(v+p+t);for(let e=0;e<6;e++){const t=m.length-6;x.push(m[t+e]-D)}}v+=p}const k=l[l.length-1];for(let n=0;n<c.length;n++)r.scale(S,P,c[n][0]),r.scale(G,d,c[n][1]),r.add(S,S,G),r.add(S,S,k),O[w++]=S[0],O[w++]=S[1],O[w++]=S[2];const E=I/3;y[I++]=M[0],y[I++]=M[1],y[I++]=M[2];const j=v-p;for(let r=0;r<i.length;r++)m.push(i[r][0]>=0?v+i[r][0]:-i[r][0]-1+j),m.push(i[r][2]>=0?v+i[r][2]:-i[r][2]-1+j),m.push(i[r][1]>=0?v+i[r][1]:-i[r][1]-1+j),x.push(E),x.push(E),x.push(E);const q=[[V.VertexAttribute.POSITION,m],[V.VertexAttribute.NORMAL,x]],B=[[V.VertexAttribute.POSITION,new a.Attribute(O,3,!0)],[V.VertexAttribute.NORMAL,new a.Attribute(y,3,!0)]];return new h.Geometry(t,B,q)}function _(t,e,r,n){f.assert(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),f.assert(3===e[0].length,"createPolylineGeometry(): malformed vertex"),f.assert(null==r||r.length===e.length,"createPolylineGeometry: need same number of points and normals"),f.assert(null==r||3===r[0].length,"createPolylineGeometry(): malformed normal");const o=i.newDoubleArray(3*e.length),u=new Array(2*(e.length-1));let s=0,l=0;for(let a=0;a<e.length;a++){for(let t=0;t<3;t++)o[s++]=e[a][t];a>0&&(u[l++]=a-1,u[l++]=a)}const p=[],O=[];if(p.push([V.VertexAttribute.POSITION,u]),O.push([V.VertexAttribute.POSITION,new a.Attribute(o,3,!0)]),r){const t=A.newFloatArray(3*r.length);let n=0;for(let o=0;o<e.length;o++)for(let e=0;e<3;e++)t[n++]=r[o][e];p.push([V.VertexAttribute.NORMAL,u]),O.push([V.VertexAttribute.NORMAL,new a.Attribute(t,3,!0)])}return n&&(O.push([V.VertexAttribute.COLOR,new a.Attribute(n,4)]),p.push([V.VertexAttribute.COLOR,b.generateDefaultIndexArray(n.length/4)])),new h.Geometry(t,O,p,null,c.ContentObjectType.Line)}function tt(t,e,r,n,o,u=0){const s=new Array(18),l=[[-r,u,o/2],[n,u,o/2],[0,e+u,o/2],[-r,u,-o/2],[n,u,-o/2],[0,e+u,-o/2]],c=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let a=0;a<6;a++)s[3*a]=l[a][0],s[3*a+1]=l[a][1],s[3*a+2]=l[a][2];return new h.Geometry(t,[[V.VertexAttribute.POSITION,new a.Attribute(s,3,!0)]],[[V.VertexAttribute.POSITION,c]])}function et(t,e){const n=t.getMutableAttribute(V.VertexAttribute.POSITION).data;for(let o=0;o<n.length;o+=3){const t=n[o],u=n[o+1],s=n[o+2];r.set(st,t,u,s),r.transformMat4(st,st,e),n[o]=st[0],n[o+1]=st[1],n[o+2]=st[2]}}function rt(t,e=t){const r=t.vertexAttributes,n=r.get(V.VertexAttribute.POSITION).data,o=r.get(V.VertexAttribute.NORMAL).data;if(o){const t=e.getMutableAttribute(V.VertexAttribute.NORMAL).data;for(let e=0;e<o.length;e+=3){const r=o[e+1];t[e+1]=-o[e+2],t[e+2]=r}}if(n){const t=e.getMutableAttribute(V.VertexAttribute.POSITION).data;for(let e=0;e<n.length;e+=3){const r=n[e+1];t[e+1]=-n[e+2],t[e+2]=r}}}function nt(t,e,n,o,u){return!(Math.abs(r.dot(e,t))>u)&&(r.cross(n,t,e),r.normalize(n,n),r.cross(o,n,t),r.normalize(o,o),!0)}function ot(t,e,r,n,o,u,s){return nt(t,e,o,u,s)||nt(t,r,o,u,s)||nt(t,n,o,u,s)}const ut=.99619469809,st=n.create();t.cgToGIS=rt,t.createBoxGeometry=g,t.createConeGeometry=Q,t.createCylinderGeometry=W,t.createDiamondGeometry=S,t.createExtrudedTriangle=tt,t.createPathExtrusionGeometry=$,t.createPointGeometry=H,t.createPolySphereData=Z,t.createPolySphereGeometry=X,t.createPolylineGeometry=_,t.createSphereGeometry=B,t.createSquareGeometry=K,t.createTetrahedronGeometry=q,t.createTubeGeometry=Y,t.makeOrthoBasisDirUpFallback=ot,t.transformInPlace=et,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
