/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["../../../../chunks/vec3f64","../../../../chunks/vec3","../../../../chunks/vec3f32","../../support/geometryUtils","./BufferVectorMath","./Util","./GeometryData"],(function(t,e,r,n,a,o,s){"use strict";const l=a.Vec3Compact;var c,i,A,y;!function(t){const e=.5,r=[[-e,-e,e],[e,-e,e],[e,e,e],[-e,e,e],[-e,-e,-e],[e,-e,-e],[e,e,-e],[-e,e,-e]],n=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],a=[0,0,1,0,1,1,0,1],l=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],c=new Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)c[6*t+e]=t;const i=new Array(36);for(let t=0;t<6;t++)i[6*t+0]=0,i[6*t+1]=1,i[6*t+2]=2,i[6*t+3]=2,i[6*t+4]=3,i[6*t+5]=0;t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Float32Array(24);for(let n=0;n<8;n++)e[3*n]=r[n][0]*t[0],e[3*n+1]=r[n][1]*t[1],e[3*n+2]=r[n][2]*t[2];const A={};A[o.VertexAttrConstants.POSITION]=new Uint32Array(l),A[o.VertexAttrConstants.NORMAL]=new Uint32Array(c),A[o.VertexAttrConstants.UV0]=new Uint32Array(i);const y={};return y[o.VertexAttrConstants.POSITION]={size:3,data:e},y[o.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(n)},y[o.VertexAttrConstants.UV0]={size:2,data:new Float32Array(a)},new s.GeometryData(y,A)}}(c||(c={})),function(t){const e=.5,r=[[-e,0,-e],[e,0,-e],[e,0,e],[-e,0,e],[0,-e,0],[0,e,0]],n=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],a=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],l=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Float32Array(18);for(let n=0;n<6;n++)e[3*n]=r[n][0]*t[0],e[3*n+1]=r[n][1]*t[1],e[3*n+2]=r[n][2]*t[2];const c={};c[o.VertexAttrConstants.POSITION]=new Uint32Array(a),c[o.VertexAttrConstants.NORMAL]=new Uint32Array(l);const i={};return i[o.VertexAttrConstants.POSITION]={size:3,data:e},i[o.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(n)},new s.GeometryData(i,c)}}(i||(i={})),function(t){const n=.5,a=r.fromValues(-n,0,-n),l=r.fromValues(n,0,-n),c=r.fromValues(0,0,n),i=r.fromValues(0,.5,0),A=r.create(),y=r.create(),f=r.create(),u=r.create(),V=r.create();e.subtract(A,a,i),e.subtract(y,a,l),e.cross(f,A,y),e.normalize(f,f),e.subtract(A,l,i),e.subtract(y,l,c),e.cross(u,A,y),e.normalize(u,u),e.subtract(A,c,i),e.subtract(y,c,a),e.cross(V,A,y),e.normalize(V,V);const h=[a,l,c,i],d=[0,-1,0,f[0],f[1],f[2],u[0],u[1],u[2],V[0],V[1],V[2]],m=[0,1,2,3,1,0,3,2,1,3,0,2],O=[0,0,0,1,1,1,2,2,2,3,3,3];t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Float32Array(12);for(let r=0;r<4;r++)e[3*r]=h[r][0]*t[0],e[3*r+1]=h[r][1]*t[1],e[3*r+2]=h[r][2]*t[2];const r={};r[o.VertexAttrConstants.POSITION]=new Uint32Array(m),r[o.VertexAttrConstants.NORMAL]=new Uint32Array(O);const n={};return n[o.VertexAttrConstants.POSITION]={size:3,data:e},n[o.VertexAttrConstants.NORMAL]={size:3,data:new Float32Array(d)},new s.GeometryData(n,r)}}(A||(A={})),function(a){a.createBoxGeometry=c.createGeometry,a.createDiamondGeometry=i.createGeometry,a.createTetrahedronGeometry=A.createGeometry,a.createSphereGeometry=function(t,e,r,n){const{phiStart:a=-Math.PI,phiLength:l=2*Math.PI,thetaStart:c=-Math.PI/2,thetaLength:i=Math.PI}=n||{},{position:A=o.VertexAttrConstants.POSITION,normal:y=o.VertexAttrConstants.NORMAL,uv:f=o.VertexAttrConstants.UV0}=(null==n?void 0:n.attributes)||{},u=Math.max(3,Math.floor(e)),V=Math.max(2,Math.floor(r)),h=(u+1)*(V+1),d=new Float32Array(3*h),m=new Float32Array(3*h),O=new Float32Array(2*h),w=[];let x=0;for(let e=0;e<=V;e++){const r=[],n=e/V,o=c+n*i,s=Math.cos(o);for(let e=0;e<=u;e++){const c=e/u,i=a+c*l,A=Math.cos(i)*s,y=Math.sin(o),f=-Math.sin(i)*s;d[3*x]=A*t,d[3*x+1]=y*t,d[3*x+2]=f*t,m[3*x]=A,m[3*x+1]=y,m[3*x+2]=f,O[2*x]=c,O[2*x+1]=n,r.push(x),++x}w.push(r)}const C=new Uint32Array(2*u*(V-1)*3);x=0;for(let t=0;t<V;t++)for(let e=0;e<u;e++){const r=w[t][e],n=w[t][e+1],a=w[t+1][e+1],o=w[t+1][e];0===t?(C[x++]=r,C[x++]=a,C[x++]=o):t===V-1?(C[x++]=r,C[x++]=n,C[x++]=a):(C[x++]=r,C[x++]=n,C[x++]=a,C[x++]=a,C[x++]=o,C[x++]=r)}const I={};I[A]=C,I[y]=C;const g={};return g[A]={size:3,data:d},g[y]={size:3,data:m},f&&(g[f]={size:2,data:O},I[f]=C),new s.GeometryData(g,I)},a.createPolySphereGeometry=function(t,e,r){const n=t;let a,c;if(r)a=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],c=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const t=n*(1+Math.sqrt(5))/2;a=[-n,t,0,n,t,0,-n,-t,0,n,-t,0,0,-n,t,0,n,t,0,-n,-t,0,n,-t,t,0,-n,t,0,n,-t,0,-n,-t,0,n],c=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let e=0;e<a.length;e+=3)l.scale(a,e,t/l.length(a,e));let i={};function A(e,r){e>r&&([e,r]=[r,e]);const n=e.toString()+"."+r.toString();if(i[n])return i[n];let o=a.length;return a.length+=3,l.add(a,3*e,a,3*r,a,o),l.scale(a,o,t/l.length(a,o)),o/=3,i[n]=o,o}for(let t=0;t<e;t++){const t=c.length,e=new Uint32Array(4*t);for(let r=0;r<t;r+=3){const t=c[r],n=c[r+1],a=c[r+2],o=A(t,n),s=A(n,a),l=A(a,t),i=4*r;e[i]=t,e[i+1]=o,e[i+2]=l,e[i+3]=n,e[i+4]=s,e[i+5]=o,e[i+6]=a,e[i+7]=l,e[i+8]=s,e[i+9]=o,e[i+10]=s,e[i+11]=l}c=e,i={}}const y=new Float32Array(a);for(let t=0;t<y.length;t+=3)l.normalize(y,t);const f={};f[o.VertexAttrConstants.POSITION]=c,f[o.VertexAttrConstants.NORMAL]=c;const u={};return u[o.VertexAttrConstants.POSITION]={size:3,data:new Float32Array(a)},u[o.VertexAttrConstants.NORMAL]={size:3,data:y},new s.GeometryData(u,f)},a.createPointGeometry=function(t,e,r,n,a,l,c,i){const A=e?new Float64Array([e[0],e[1],e[2]]):new Float32Array([0,0,0]),y=t?new Float32Array([t[0],t[1],t[2]]):new Float32Array([0,0,1]),f=l?new Float32Array(l):new Float32Array([0,0]),u=r?new Uint8Array([255*r[0],255*r[1],255*r[2],r.length>3?255*r[3]:255]):new Uint8Array([255,255,255,255]),V=null!=n&&2===n.length?new Float32Array(n):new Float32Array([1,1]),h={};if(h[o.VertexAttrConstants.POSITION]={size:3,data:A},h[o.VertexAttrConstants.NORMAL]={size:3,data:y},h[o.VertexAttrConstants.UV0]={size:f.length,data:f},h[o.VertexAttrConstants.COLOR]={size:4,data:u},h[o.VertexAttrConstants.SIZE]={size:2,data:V},null!=a){const t=new Float32Array([a[0],a[1],a[2],a[3]]);h[o.VertexAttrConstants.AUXPOS1]={size:4,data:t}}if(null!=c){const t=new Float32Array([c[0],c[1],c[2],c[3]]);h[o.VertexAttrConstants.AUXPOS2]={size:4,data:t}}return null!=i?(i.initialize(h,s.GeometryData.DefaultIndices,"point"),i):new s.GeometryData(h,s.GeometryData.DefaultIndices,"point")},a.updatePointGeometry=function(t,e,r,n,a,s,l,c){const i=c.vertexAttributes;if(null!=t){const{data:e}=i[o.VertexAttrConstants.NORMAL];e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=e){const{data:t}=i[o.VertexAttrConstants.POSITION];t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=r){const{data:t}=i[o.VertexAttrConstants.COLOR];t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3]}if(null!=n){const{data:t}=i[o.VertexAttrConstants.SIZE];t[0]=n[0],t[1]=n[1]}if(null!=a){const{data:t}=i[o.VertexAttrConstants.AUXPOS1];t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3]}if(null!=s){const{data:t}=i[o.VertexAttrConstants.UV0];t[0]=s[0],t[1]=s[1]}if(null!=l){const{data:t}=i[o.VertexAttrConstants.AUXPOS2];t[0]=l[0],t[1]=l[1],t[2]=l[2],t[3]=l[3]}return c},a.createPointArrayGeometry=function(t,e){const r=new Float32Array(3*t.length),n=new Float32Array(e?3*t.length:3),a=new Uint32Array(t.length),l=new Uint32Array(t.length);for(let o=0;o<t.length;o++)r[3*o]=t[o][0],r[3*o+1]=t[o][1],r[3*o+2]=t[o][2],e&&(n[3*o]=e[o][0],n[3*o+1]=e[o][1],n[3*o+2]=e[o][2]),a[o]=o,l[o]=0;e||(n[0]=0,n[1]=1,n[2]=0);const c=new Float32Array(2);c[0]=0,c[1]=0;const i={};i[o.VertexAttrConstants.POSITION]=a,i[o.VertexAttrConstants.NORMAL]=e?a:l,i[o.VertexAttrConstants.UV0]=l;const A={};return A[o.VertexAttrConstants.POSITION]={size:3,data:r},A[o.VertexAttrConstants.NORMAL]={size:3,data:n},A[o.VertexAttrConstants.UV0]={size:2,data:c},new s.GeometryData(A,i,"point")},a.createTriangleGeometry=function(){const t=new Float32Array([0,0,0,0,0,100,100,0,0]),e=new Uint32Array([0,1,2]),r=new Float32Array([0,1,0]),n=new Uint32Array([0,0,0]),a=new Float32Array([0,0]),l=new Uint32Array([0,0,0]),c={};c[o.VertexAttrConstants.POSITION]=e,c[o.VertexAttrConstants.NORMAL]=n,c[o.VertexAttrConstants.UV0]=l;const i={};return i[o.VertexAttrConstants.POSITION]={size:3,data:t},i[o.VertexAttrConstants.NORMAL]={size:3,data:r},i[o.VertexAttrConstants.UV0]={size:2,data:a},new s.GeometryData(i,c)};const y=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function V(t,r,n,a,o){return!(Math.abs(e.dot(r,t))>o)&&(e.cross(n,t,r),e.normalize(n,n),e.cross(a,n,t),e.normalize(a,a),!0)}function h(t,e,r,n,a,o,s){return V(t,e,a,o,s)||V(t,r,a,o,s)||V(t,n,a,o,s)}a.createSquareGeometry=function(t=y){const e=new Float64Array(12);for(let r=0;r<4;r++)for(let n=0;n<3;n++)e[3*r+n]=t[r][n];const r=new Uint32Array([0,1,2,2,3,0]),n=new Float32Array([0,0,1]),a=new Uint32Array([0,0,0,0,0,0]),l=new Float32Array([0,0,1,0,1,1,0,1]),c=new Uint8Array([255,255,255,255]),i={[o.VertexAttrConstants.POSITION]:r,[o.VertexAttrConstants.NORMAL]:a,[o.VertexAttrConstants.UV0]:r,[o.VertexAttrConstants.COLOR]:a},A={[o.VertexAttrConstants.POSITION]:{size:3,data:e},[o.VertexAttrConstants.NORMAL]:{size:3,data:n},[o.VertexAttrConstants.UV0]:{size:2,data:l},[o.VertexAttrConstants.COLOR]:{size:4,data:c}};return new s.GeometryData(A,i)},a.createConeGeometry=function(t,e,n,a,l=!0,c=!0){let i=0;const A=e,y=t;let f=r.fromValues(0,i,0),u=r.fromValues(0,i+y,0),V=r.fromValues(0,-1,0),h=r.fromValues(0,1,0);a&&(i=y,u=r.fromValues(0,0,0),f=r.fromValues(0,i,0),V=r.fromValues(0,1,0),h=r.fromValues(0,-1,0));const d=[u,f],m=[V,h],O=n+2,w=Math.sqrt(y*y+A*A);if(a)for(let t=n-1;t>=0;t--){const e=t*(2*Math.PI/n),a=r.fromValues(Math.cos(e)*A,i,Math.sin(e)*A);d.push(a);const o=r.fromValues(y*Math.cos(e)/w,-A/w,y*Math.sin(e)/w);m.push(o)}else for(let t=0;t<n;t++){const e=t*(2*Math.PI/n),a=r.fromValues(Math.cos(e)*A,i,Math.sin(e)*A);d.push(a);const o=r.fromValues(y*Math.cos(e)/w,A/w,y*Math.sin(e)/w);m.push(o)}const x=new Uint32Array(2*(n+2)*3),C=new Uint32Array(2*(n+2)*3);let I=0,g=0;if(l){for(let t=3;t<d.length;t++)x[I++]=1,x[I++]=t-1,x[I++]=t,C[g++]=0,C[g++]=0,C[g++]=0;x[I++]=d.length-1,x[I++]=2,x[I++]=1,C[g++]=0,C[g++]=0,C[g++]=0}if(c){for(let t=3;t<d.length;t++)x[I++]=t,x[I++]=t-1,x[I++]=0,C[g++]=t,C[g++]=t-1,C[g++]=1;x[I++]=0,x[I++]=2,x[I++]=d.length-1,C[g++]=1,C[g++]=2,C[g++]=m.length-1}const M=new Float32Array(3*O);for(let t=0;t<O;t++)M[3*t]=d[t][0],M[3*t+1]=d[t][1],M[3*t+2]=d[t][2];const z=new Float32Array(3*O);for(let t=0;t<O;t++)z[3*t]=m[t][0],z[3*t+1]=m[t][1],z[3*t+2]=m[t][2];const N={};N[o.VertexAttrConstants.POSITION]=x,N[o.VertexAttrConstants.NORMAL]=C;const P={};return P[o.VertexAttrConstants.POSITION]={size:3,data:M},P[o.VertexAttrConstants.NORMAL]={size:3,data:z},new s.GeometryData(P,N)},a.createCylinderGeometry=function(t,n,a,l,c,i){const A=l?r.clone(l):r.fromValues(1,0,0),y=c?r.clone(c):r.fromValues(0,0,0),f=void 0===i||i,u=r.create();e.normalize(u,A);const V=r.create();e.scale(V,u,Math.abs(t));const h=r.create();e.scale(h,V,-.5),e.add(h,h,y);const d=r.fromValues(0,1,0);Math.abs(1-e.dot(u,d))<.2&&e.set(d,0,0,1);const m=r.create();e.cross(m,u,d),e.normalize(m,m),e.cross(d,m,u);const O=2*a+(f?2:0),w=a+(f?2:0),x=new Float32Array(3*O),C=new Float32Array(3*w),I=new Float32Array(2*O),g=new Uint32Array(3*a*(f?4:2)),M=new Uint32Array(3*a*(f?4:2));f&&(x[3*(O-2)+0]=h[0],x[3*(O-2)+1]=h[1],x[3*(O-2)+2]=h[2],I[2*(O-2)]=0,I[2*(O-2)+1]=0,x[3*(O-1)+0]=x[3*(O-2)+0]+V[0],x[3*(O-1)+1]=x[3*(O-2)+1]+V[1],x[3*(O-1)+2]=x[3*(O-2)+2]+V[2],I[2*(O-1)]=1,I[2*(O-1)+1]=1,C[3*(w-2)+0]=-u[0],C[3*(w-2)+1]=-u[1],C[3*(w-2)+2]=-u[2],C[3*(w-1)+0]=u[0],C[3*(w-1)+1]=u[1],C[3*(w-1)+2]=u[2]);const z=function(t,e,r){g[t]=e,M[t]=r};let N=0;const P=r.create(),U=r.create();for(let t=0;t<a;t++){const r=t*(2*Math.PI/a);e.scale(P,d,Math.sin(r)),e.scale(U,m,Math.cos(r)),e.add(P,P,U),C[3*t+0]=P[0],C[3*t+1]=P[1],C[3*t+2]=P[2],e.scale(P,P,n),e.add(P,P,h),x[3*t+0]=P[0],x[3*t+1]=P[1],x[3*t+2]=P[2],I[2*t+0]=t/a,I[2*t+1]=0,x[3*(t+a)+0]=x[3*t+0]+V[0],x[3*(t+a)+1]=x[3*t+1]+V[1],x[3*(t+a)+2]=x[3*t+2]+V[2],I[2*(t+a)+0]=t/a,I[2*t+1]=1;const o=(t+1)%a;z(N++,t,t),z(N++,t+a,t),z(N++,o,o),z(N++,o,o),z(N++,t+a,t),z(N++,o+a,o)}if(f){for(let t=0;t<a;t++){const e=(t+1)%a;z(N++,O-2,w-2),z(N++,t,w-2),z(N++,e,w-2)}for(let t=0;t<a;t++){const e=(t+1)%a;z(N++,t+a,w-1),z(N++,O-1,w-1),z(N++,e+a,w-1)}}const G={};G[o.VertexAttrConstants.POSITION]=g,G[o.VertexAttrConstants.NORMAL]=M,G[o.VertexAttrConstants.UV0]=g;const F={};return F[o.VertexAttrConstants.POSITION]={size:3,data:x},F[o.VertexAttrConstants.NORMAL]={size:3,data:C},F[o.VertexAttrConstants.UV0]={size:2,data:I},new s.GeometryData(F,G)},a.createTubeGeometry=function(t,e,r,n,s){r=r||10,n=null==n||n,o.assert(t.length>1);const l=[],c=[];for(let t=0;t<r;t++){l.push([0,-t-1,-(t+1)%r-1]);const n=t/r*2*Math.PI;c.push([Math.cos(n)*e,Math.sin(n)*e])}return a.createPathExtrusionGeometry(c,t,[[0,0,0]],l,n,s)},a.createPathExtrusionGeometry=function(a,l,c,i,A,y=r.fromValues(0,0,0)){const u=a.length,V=new Float32Array(l.length*u*3+(6*c.length||0)),d=new Float32Array(l.length*u+(2*c.length||0)),m=new Float32Array(l.length*u*3+(c?6:0)),O=(l.length-1)*u*6+3*i.length*2,w=new Uint32Array(O),x=new Uint32Array(O);let C=0,I=0,g=0,M=0,z=0;const N=r.create(),P=r.create(),U=r.create(),G=r.create(),F=r.create(),S=r.create(),p=r.create(),T=t.create(),L=r.create(),R=r.create(),D=r.create(),b=r.create(),v=r.create(),k=n.plane.create();e.set(L,0,1,0),e.subtract(P,l[1],l[0]),e.normalize(P,P),A?(e.add(T,l[0],y),e.normalize(U,T)):e.set(U,0,0,1),h(P,U,L,L,F,U,f),e.copy(G,U),e.copy(b,F);for(let t=0;t<c.length;t++)e.scale(S,F,c[t][0]),e.scale(T,U,c[t][2]),e.add(S,S,T),e.add(S,S,l[0]),V[C++]=S[0],V[C++]=S[1],V[C++]=S[2],d[g++]=0;m[I++]=-P[0],m[I++]=-P[1],m[I++]=-P[2];for(let t=0;t<i.length;t++)w[M++]=i[t][0]>0?i[t][0]:-i[t][0]-1+c.length,w[M++]=i[t][1]>0?i[t][1]:-i[t][1]-1+c.length,w[M++]=i[t][2]>0?i[t][2]:-i[t][2]-1+c.length,x[z++]=0,x[z++]=0,x[z++]=0;let E=c.length;const B=c.length-1;for(let t=0;t<l.length;t++){let r=!1;if(t>0){e.copy(N,P),t<l.length-1?(e.subtract(P,l[t+1],l[t]),e.normalize(P,P)):r=!0,e.add(R,N,P),e.normalize(R,R),e.add(D,l[t-1],G),n.plane.fromPositionAndNormal(l[t],R,k);n.plane.intersectRay(k,n.ray.wrap(D,N),T)?(e.subtract(T,T,l[t]),e.normalize(U,T),e.cross(F,R,U),e.normalize(F,F)):h(R,G,b,L,F,U,f),e.copy(G,U),e.copy(b,F)}A&&(e.add(T,l[t],y),e.normalize(v,T));for(let n=0;n<u;n++)if(e.scale(S,F,a[n][0]),e.scale(T,U,a[n][1]),e.add(S,S,T),e.normalize(p,S),m[I++]=p[0],m[I++]=p[1],m[I++]=p[2],d[g++]=A?e.dot(S,v):S[2],e.add(S,S,l[t]),V[C++]=S[0],V[C++]=S[1],V[C++]=S[2],!r){const t=(n+1)%u;w[M++]=E+n,w[M++]=E+u+n,w[M++]=E+t,w[M++]=E+t,w[M++]=E+u+n,w[M++]=E+u+t;for(let t=0;t<6;t++)x[z++]=w[M-6+t]-B}E+=u}const X=l[l.length-1];for(let t=0;t<c.length;t++)e.scale(S,F,c[t][0]),e.scale(T,U,c[t][1]),e.add(S,S,T),e.add(S,S,X),V[C++]=S[0],V[C++]=S[1],V[C++]=S[2],d[g++]=0;const q=I/3;m[I++]=P[0],m[I++]=P[1],m[I++]=P[2];const Z=E-u;for(let t=0;t<i.length;t++)w[M++]=i[t][0]>=0?E+i[t][0]:-i[t][0]-1+Z,w[M++]=i[t][2]>=0?E+i[t][2]:-i[t][2]-1+Z,w[M++]=i[t][1]>=0?E+i[t][1]:-i[t][1]-1+Z,x[z++]=q,x[z++]=q,x[z++]=q;const j={};j[o.VertexAttrConstants.POSITION]=w,j[o.VertexAttrConstants.NORMAL]=x;const H={};return H[o.VertexAttrConstants.POSITION]={size:3,data:V},H.zOffset={size:1,data:d},H[o.VertexAttrConstants.NORMAL]={size:3,data:m},new s.GeometryData(H,j)},a.createPolylineGeometry=function(t,e){o.assert(t.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),o.assert(3===t[0].length,"createPolylineGeometry(): malformed vertex"),o.assert(void 0===e||e.length===t.length,"createPolylineGeometry: need same number of points and normals"),o.assert(void 0===e||3===e[0].length,"createPolylineGeometry(): malformed normal");const r=new Float64Array(3*t.length),n=new Uint32Array(2*(t.length-1));let a=0,l=0;for(let e=0;e<t.length;e++){for(let n=0;n<3;n++)r[a++]=t[e][n];e>0&&(n[l++]=e-1,n[l++]=e)}const c={},i={};if(c[o.VertexAttrConstants.POSITION]=n,i[o.VertexAttrConstants.POSITION]={size:3,data:r},e){const r=new Float32Array(3*e.length);let a=0;for(let n=0;n<t.length;n++)for(let t=0;t<3;t++)r[a++]=e[n][t];c[o.VertexAttrConstants.NORMAL]=n,i[o.VertexAttrConstants.NORMAL]={size:3,data:r}}return new s.GeometryData(i,c,"line")},a.createExtrudedTriangle=function(t,e,r,n){const a=new Float32Array(18),l=[[-e,0,n/2],[r,0,n/2],[0,t,n/2],[-e,0,-n/2],[r,0,-n/2],[0,t,-n/2]];for(let t=0;t<6;t++)a[3*t]=l[t][0],a[3*t+1]=l[t][1],a[3*t+2]=l[t][2];const c={[o.VertexAttrConstants.POSITION]:new Uint32Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5])},i={[o.VertexAttrConstants.POSITION]:{size:3,data:a}};return new s.GeometryData(i,c)},a.transformInPlace=function(t,r){const n=t.vertexAttributes[o.VertexAttrConstants.POSITION].data;for(let t=0;t<n.length;t+=3){const a=n[t],o=n[t+1],s=n[t+2];e.set(u,a,o,s),e.transformMat4(u,u,r),n[t]=u[0],n[t+1]=u[1],n[t+2]=u[2]}},a.cgToGIS=function(t,e=t){const r=t.getVertexAttr(),n=r.position.data,a=r.normal.data,o=e.getVertexAttr(),s=o.position.data,l=o.normal.data;if(a)for(let t=0;t<a.length;t+=3){const e=a[t+1];l[t+1]=-a[t+2],l[t+2]=e}if(n)for(let t=0;t<n.length;t+=3){const e=n[t+1];s[t+1]=-n[t+2],s[t+2]=e}return e},a.makeOrthoBasisDirUp=V,a.makeOrthoBasisDirUpFallback=h}(y||(y={}));const f=.99619469809,u=r.create();return y}));
