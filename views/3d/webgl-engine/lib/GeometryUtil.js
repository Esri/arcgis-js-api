/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["../../../../chunks/vec3","../../../../chunks/vec3f32","../../../../chunks/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/ray","./basicInterfaces","./BufferVectorMath","./Geometry","./geometryDataUtils","./Util","./VertexAttribute"],(function(t,e,r,a,n,o,i,s,l,u,c){"use strict";const A=i.Vec3Compact;var x,f,b,V;!function(t){const e=.5,r=[[-e,-e,e],[e,-e,e],[e,e,e],[-e,e,e],[-e,-e,-e],[e,-e,-e],[e,e,-e],[-e,e,-e]],a=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],n=[0,0,1,0,1,1,0,1],o=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),i=new Uint16Array(36);for(let s=0;s<6;s++)for(let t=0;t<6;t++)i[6*s+t]=s;const l=new Uint16Array(36);for(let s=0;s<6;s++)l[6*s+0]=0,l[6*s+1]=1,l[6*s+2]=2,l[6*s+3]=2,l[6*s+4]=3,l[6*s+5]=0;function u(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(24);for(let a=0;a<8;a++)e[3*a]=r[a][0]*t[0],e[3*a+1]=r[a][1]*t[1],e[3*a+2]=r[a][2]*t[2];return new s.Geometry([[c.VertexAttribute.POSITION,{size:3,data:e,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:a}],[c.VertexAttribute.UV0,{size:2,data:n}]],[[c.VertexAttribute.POSITION,o],[c.VertexAttribute.NORMAL,i],[c.VertexAttribute.UV0,l]])}t.createGeometry=u}(x||(x={})),function(t){const e=.5,r=[[-e,0,-e],[e,0,-e],[e,0,e],[-e,0,e],[0,-e,0],[0,e,0]],a=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],n=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),o=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);function i(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(18);for(let a=0;a<6;a++)e[3*a]=r[a][0]*t[0],e[3*a+1]=r[a][1]*t[1],e[3*a+2]=r[a][2]*t[2];return new s.Geometry([[c.VertexAttribute.POSITION,{size:3,data:e,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:a}]],[[c.VertexAttribute.POSITION,n],[c.VertexAttribute.NORMAL,o]])}t.createGeometry=i}(f||(f={})),function(r){const a=.5,n=0,o=e.fromValues(-a,n,-a),i=e.fromValues(a,n,-a),l=e.fromValues(0,n,a),u=e.fromValues(0,n+a,0),A=e.create(),x=e.create(),f=e.create(),b=e.create(),V=e.create();t.subtract(A,o,u),t.subtract(x,o,i),t.cross(f,A,x),t.normalize(f,f),t.subtract(A,i,u),t.subtract(x,i,l),t.cross(b,A,x),t.normalize(b,b),t.subtract(A,l,u),t.subtract(x,l,o),t.cross(V,A,x),t.normalize(V,V);const y=[o,i,l,u],h=[0,-1,0,f[0],f[1],f[2],b[0],b[1],b[2],V[0],V[1],V[2]],O=[0,1,2,3,1,0,3,2,1,3,0,2],m=[0,0,0,1,1,1,2,2,2,3,3,3];function d(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(12);for(let r=0;r<4;r++)e[3*r]=y[r][0]*t[0],e[3*r+1]=y[r][1]*t[1],e[3*r+2]=y[r][2]*t[2];return new s.Geometry([[c.VertexAttribute.POSITION,{size:3,data:e,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:h}]],[[c.VertexAttribute.POSITION,new Uint16Array(O)],[c.VertexAttribute.NORMAL,new Uint16Array(m)]])}r.createGeometry=d}(b||(b={})),function(i){function V(t,e,r,a={uv:!0}){const n=-Math.PI,o=2*Math.PI,i=-Math.PI/2,l=Math.PI,u=Math.max(3,Math.floor(e)),A=Math.max(2,Math.floor(r)),x=(u+1)*(A+1),f=new Float32Array(3*x),b=new Float32Array(3*x),V=new Float32Array(2*x),y=[];let h=0;for(let s=0;s<=A;s++){const e=[],r=s/A,a=i+r*l,c=Math.cos(a);for(let i=0;i<=u;i++){const s=i/u,l=n+s*o,A=Math.cos(l)*c,x=Math.sin(a),y=-Math.sin(l)*c;f[3*h]=A*t,f[3*h+1]=x*t,f[3*h+2]=y*t,b[3*h]=A,b[3*h+1]=x,b[3*h+2]=y,V[2*h]=s,V[2*h+1]=r,e.push(h),++h}y.push(e)}const O=new Uint32Array(2*u*(A-1)*3);h=0;for(let s=0;s<A;s++)for(let t=0;t<u;t++){const e=y[s][t],r=y[s][t+1],a=y[s+1][t+1],n=y[s+1][t];0===s?(O[h++]=e,O[h++]=a,O[h++]=n):s===A-1?(O[h++]=e,O[h++]=r,O[h++]=a):(O[h++]=e,O[h++]=r,O[h++]=a,O[h++]=a,O[h++]=n,O[h++]=e)}const m=[[c.VertexAttribute.POSITION,O],[c.VertexAttribute.NORMAL,O]],d=[[c.VertexAttribute.POSITION,{size:3,data:f,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:b,exclusive:!0}]];return a.uv&&(d.push([c.VertexAttribute.UV0,{size:2,data:V,exclusive:!0}]),m.push([c.VertexAttribute.UV0,O])),a.offset&&(m[0][0]=c.VertexAttribute.OFFSET,d[0][0]=c.VertexAttribute.OFFSET,m.push([c.VertexAttribute.POSITION,new Uint32Array(O.length)]),d.push([c.VertexAttribute.POSITION,{size:3,data:Float64Array.from(a.offset),exclusive:!0}])),new s.Geometry(d,m)}function O(t,e,r){const a=t;let n,o;if(r)n=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const t=a*(1+Math.sqrt(5))/2;n=[-a,t,0,a,t,0,-a,-t,0,a,-t,0,0,-a,t,0,a,t,0,-a,-t,0,a,-t,t,0,-a,t,0,a,-t,0,-a,-t,0,a],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let s=0;s<n.length;s+=3)A.scale(n,s,t/A.length(n,s));let i={};function l(e,r){e>r&&([e,r]=[r,e]);const a=e.toString()+"."+r.toString();if(i[a])return i[a];let o=n.length;return n.length+=3,A.add(n,3*e,n,3*r,n,o),A.scale(n,o,t/A.length(n,o)),o/=3,i[a]=o,o}for(let s=0;s<e;s++){const t=o.length,e=new Uint32Array(4*t);for(let r=0;r<t;r+=3){const t=o[r],a=o[r+1],n=o[r+2],i=l(t,a),s=l(a,n),u=l(n,t),c=4*r;e[c]=t,e[c+1]=i,e[c+2]=u,e[c+3]=a,e[c+4]=s,e[c+5]=i,e[c+6]=n,e[c+7]=u,e[c+8]=s,e[c+9]=i,e[c+10]=s,e[c+11]=u}o=e,i={}}const u=new Float32Array(n);for(let s=0;s<u.length;s+=3)A.normalize(u,s);const x=[[c.VertexAttribute.POSITION,o],[c.VertexAttribute.NORMAL,o]],f=[[c.VertexAttribute.POSITION,{size:3,data:new Float32Array(n),exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:u,exclusive:!0}]];return new s.Geometry(f,x)}function m(t,e,r,a,n,i,l){const u=e?[e[0],e[1],e[2]]:[0,0,0],A=t?[t[0],t[1],t[2]]:[0,0,1];i=i||[0,0];const x=r?[255*r[0],255*r[1],255*r[2],r.length>3?255*r[3]:255]:[255,255,255,255],f=null!=a&&2===a.length?a:[1,1],b=[[c.VertexAttribute.POSITION,{size:3,data:u,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:A,exclusive:!0}],[c.VertexAttribute.UV0,{size:i.length,data:i}],[c.VertexAttribute.COLOR,{size:4,data:x,exclusive:!0}],[c.VertexAttribute.SIZE,{size:2,data:f}]];if(null!=n){const t=new Float32Array([n[0],n[1],n[2],n[3]]);b.push([c.VertexAttribute.AUXPOS1,{size:4,data:t}])}if(null!=l){const t=new Float32Array([l[0],l[1],l[2],l[3]]);b.push([c.VertexAttribute.AUXPOS2,{size:4,data:t}])}return new s.Geometry(b,null,o.PrimitiveType.Point)}function d(t,e,r,a,n,o,i,s){if(null!=t){const{data:e}=s.getMutableAttribute(c.VertexAttribute.NORMAL);e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=e){const{data:t}=s.getMutableAttribute(c.VertexAttribute.POSITION);t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=r){const{data:t}=s.getMutableAttribute(c.VertexAttribute.COLOR);t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3]}if(null!=a){const{data:t}=s.getMutableAttribute(c.VertexAttribute.SIZE);t[0]=a[0],t[1]=a[1]}if(null!=n){const{data:t}=s.getMutableAttribute(c.VertexAttribute.AUXPOS1);t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3]}if(null!=o){const{data:t}=s.getMutableAttribute(c.VertexAttribute.UV0);t[0]=o[0],t[1]=o[1]}if(null!=i){const{data:t}=s.getMutableAttribute(c.VertexAttribute.AUXPOS2);t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3]}}function I(t,e){const r=new Float32Array(3*t.length),a=new Float32Array(e?3*t.length:3),n=new Uint32Array(t.length),i=new Uint32Array(t.length);for(let o=0;o<t.length;o++)r[3*o]=t[o][0],r[3*o+1]=t[o][1],r[3*o+2]=t[o][2],e&&(a[3*o]=e[o][0],a[3*o+1]=e[o][1],a[3*o+2]=e[o][2]),n[o]=o,i[o]=0;e||(a[0]=0,a[1]=1,a[2]=0);const l=[0,0],u=[[c.VertexAttribute.POSITION,n],[c.VertexAttribute.NORMAL,e?n:i],[c.VertexAttribute.UV0,i]],A=[[c.VertexAttribute.POSITION,{size:3,data:r,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:a,exclusive:!0}],[c.VertexAttribute.UV0,{size:2,data:l,exclusive:!0}]];return new s.Geometry(A,u,o.PrimitiveType.Point)}function g(){const t=[0,0,0,0,0,100,100,0,0],e=new Uint16Array([0,1,2]),r=[0,1,0],a=new Uint16Array([0,0,0]),n=[0,0],o=new Uint16Array([0,0,0]),i=[[c.VertexAttribute.POSITION,e],[c.VertexAttribute.NORMAL,a],[c.VertexAttribute.UV0,o]],l=[[c.VertexAttribute.POSITION,{size:3,data:t,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:r,exclusive:!0}],[c.VertexAttribute.UV0,{size:2,data:n,exclusive:!0}]];return new s.Geometry(l,i)}i.createBoxGeometry=x.createGeometry,i.createDiamondGeometry=f.createGeometry,i.createTetrahedronGeometry=b.createGeometry,i.createSphereGeometry=V,i.createPolySphereGeometry=O,i.createPointGeometry=m,i.updatePointGeometry=d,i.createPointArrayGeometry=I,i.createTriangleGeometry=g;const M=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function w(t=M){const e=new Array(12);for(let s=0;s<4;s++)for(let r=0;r<3;r++)e[3*s+r]=t[s][r];const r=new Uint32Array([0,1,2,2,3,0]),a=[0,0,1],n=new Uint32Array([0,0,0,0,0,0]),o=[0,0,1,0,1,1,0,1],i=[255,255,255,255],l=[[c.VertexAttribute.POSITION,r],[c.VertexAttribute.NORMAL,n],[c.VertexAttribute.UV0,r],[c.VertexAttribute.COLOR,n]],u=[[c.VertexAttribute.POSITION,{size:3,data:e,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:a,exclusive:!0}],[c.VertexAttribute.UV0,{size:2,data:o,exclusive:!0}],[c.VertexAttribute.COLOR,{size:4,data:i,exclusive:!0}]];return new s.Geometry(u,l)}function P(t,r,a,n,o=!0,i=!0){let l=0;const u=r,A=t;let x=e.fromValues(0,l,0),f=e.fromValues(0,l+A,0),b=e.fromValues(0,-1,0),V=e.fromValues(0,1,0);n&&(l=A,f=e.fromValues(0,0,0),x=e.fromValues(0,l,0),b=e.fromValues(0,1,0),V=e.fromValues(0,-1,0));const y=[f,x],h=[b,V],O=a+2,m=Math.sqrt(A*A+u*u);if(n)for(let s=a-1;s>=0;s--){const t=s*(2*Math.PI/a),r=e.fromValues(Math.cos(t)*u,l,Math.sin(t)*u);y.push(r);const n=e.fromValues(A*Math.cos(t)/m,-u/m,A*Math.sin(t)/m);h.push(n)}else for(let s=0;s<a;s++){const t=s*(2*Math.PI/a),r=e.fromValues(Math.cos(t)*u,l,Math.sin(t)*u);y.push(r);const n=e.fromValues(A*Math.cos(t)/m,u/m,A*Math.sin(t)/m);h.push(n)}const d=new Uint32Array(2*(a+2)*3),I=new Uint32Array(2*(a+2)*3);let g=0,M=0;if(o){for(let t=3;t<y.length;t++)d[g++]=1,d[g++]=t-1,d[g++]=t,I[M++]=0,I[M++]=0,I[M++]=0;d[g++]=y.length-1,d[g++]=2,d[g++]=1,I[M++]=0,I[M++]=0,I[M++]=0}if(i){for(let t=3;t<y.length;t++)d[g++]=t,d[g++]=t-1,d[g++]=0,I[M++]=t,I[M++]=t-1,I[M++]=1;d[g++]=0,d[g++]=2,d[g++]=y.length-1,I[M++]=1,I[M++]=2,I[M++]=h.length-1}const w=new Float32Array(3*O);for(let e=0;e<O;e++)w[3*e]=y[e][0],w[3*e+1]=y[e][1],w[3*e+2]=y[e][2];const P=new Float32Array(3*O);for(let e=0;e<O;e++)P[3*e]=h[e][0],P[3*e+1]=h[e][1],P[3*e+2]=h[e][2];const N=[[c.VertexAttribute.POSITION,d],[c.VertexAttribute.NORMAL,I]],z=[[c.VertexAttribute.POSITION,{size:3,data:w,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:P,exclusive:!0}]];return new s.Geometry(z,N)}function N(r,a,n,o,i,l){const u=o?e.clone(o):e.fromValues(1,0,0),A=i?e.clone(i):e.fromValues(0,0,0);l=null==l||l;const x=e.create();t.normalize(x,u);const f=e.create();t.scale(f,x,Math.abs(r));const b=e.create();t.scale(b,f,-.5),t.add(b,b,A);const V=e.fromValues(0,1,0);Math.abs(1-t.dot(x,V))<.2&&t.set(V,0,0,1);const y=e.create();t.cross(y,x,V),t.normalize(y,y),t.cross(V,y,x);const h=2*n+(l?2:0),O=n+(l?2:0),m=new Float32Array(3*h),d=new Float32Array(3*O),I=new Float32Array(2*h),g=new Uint32Array(3*n*(l?4:2)),M=new Uint32Array(3*n*(l?4:2));l&&(m[3*(h-2)+0]=b[0],m[3*(h-2)+1]=b[1],m[3*(h-2)+2]=b[2],I[2*(h-2)]=0,I[2*(h-2)+1]=0,m[3*(h-1)+0]=m[3*(h-2)+0]+f[0],m[3*(h-1)+1]=m[3*(h-2)+1]+f[1],m[3*(h-1)+2]=m[3*(h-2)+2]+f[2],I[2*(h-1)]=1,I[2*(h-1)+1]=1,d[3*(O-2)+0]=-x[0],d[3*(O-2)+1]=-x[1],d[3*(O-2)+2]=-x[2],d[3*(O-1)+0]=x[0],d[3*(O-1)+1]=x[1],d[3*(O-1)+2]=x[2]);const w=function(t,e,r){g[t]=e,M[t]=r};let P=0;const N=e.create(),z=e.create();for(let e=0;e<n;e++){const r=e*(2*Math.PI/n);t.scale(N,V,Math.sin(r)),t.scale(z,y,Math.cos(r)),t.add(N,N,z),d[3*e+0]=N[0],d[3*e+1]=N[1],d[3*e+2]=N[2],t.scale(N,N,a),t.add(N,N,b),m[3*e+0]=N[0],m[3*e+1]=N[1],m[3*e+2]=N[2],I[2*e+0]=e/n,I[2*e+1]=0,m[3*(e+n)+0]=m[3*e+0]+f[0],m[3*(e+n)+1]=m[3*e+1]+f[1],m[3*(e+n)+2]=m[3*e+2]+f[2],I[2*(e+n)+0]=e/n,I[2*e+1]=1;const o=(e+1)%n;w(P++,e,e),w(P++,e+n,e),w(P++,o,o),w(P++,o,o),w(P++,e+n,e),w(P++,o+n,o)}if(l){for(let t=0;t<n;t++){const e=(t+1)%n;w(P++,h-2,O-2),w(P++,t,O-2),w(P++,e,O-2)}for(let t=0;t<n;t++){const e=(t+1)%n;w(P++,t+n,O-1),w(P++,h-1,O-1),w(P++,e+n,O-1)}}const U=[[c.VertexAttribute.POSITION,g],[c.VertexAttribute.NORMAL,M],[c.VertexAttribute.UV0,g]],S=[[c.VertexAttribute.POSITION,{size:3,data:m,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:d,exclusive:!0}],[c.VertexAttribute.UV0,{size:2,data:I,exclusive:!0}]];return new s.Geometry(S,U)}function z(t,e,r,a,n){r=r||10,a=null==a||a,u.assert(t.length>1);const o=[[0,0,0]],s=[],l=[];for(let i=0;i<r;i++){s.push([0,-i-1,-(i+1)%r-1]);const t=i/r*2*Math.PI;l.push([Math.cos(t)*e,Math.sin(t)*e])}return i.createPathExtrusionGeometry(l,t,o,s,a,n)}function U(o,i,l,u,A,x=e.fromValues(0,0,0)){const f=o.length,b=new Float32Array(i.length*f*3+(6*l.length||0)),V=new Float32Array(i.length*f*3+(l?6:0)),h=(i.length-1)*f*6+3*u.length*2,O=new Uint32Array(h),m=new Uint32Array(h);let d=0,I=0,g=0,M=0;const w=e.create(),P=e.create(),N=e.create(),z=e.create(),U=e.create(),S=e.create(),p=e.create(),v=r.create(),T=e.create(),G=e.create(),R=e.create(),F=e.create(),C=e.create(),E=a.create();t.set(T,0,1,0),t.subtract(P,i[1],i[0]),t.normalize(P,P),A?(t.add(v,i[0],x),t.normalize(N,v)):t.set(N,0,0,1),L(P,N,T,T,U,N,y),t.copy(z,N),t.copy(F,U);for(let e=0;e<l.length;e++)t.scale(S,U,l[e][0]),t.scale(v,N,l[e][2]),t.add(S,S,v),t.add(S,S,i[0]),b[d++]=S[0],b[d++]=S[1],b[d++]=S[2];V[I++]=-P[0],V[I++]=-P[1],V[I++]=-P[2];for(let t=0;t<u.length;t++)O[g++]=u[t][0]>0?u[t][0]:-u[t][0]-1+l.length,O[g++]=u[t][1]>0?u[t][1]:-u[t][1]-1+l.length,O[g++]=u[t][2]>0?u[t][2]:-u[t][2]-1+l.length,m[M++]=0,m[M++]=0,m[M++]=0;let k=l.length;const D=l.length-1;for(let e=0;e<i.length;e++){let r=!1;if(e>0){t.copy(w,P),e<i.length-1?(t.subtract(P,i[e+1],i[e]),t.normalize(P,P)):r=!0,t.add(G,w,P),t.normalize(G,G),t.add(R,i[e-1],z),a.fromPositionAndNormal(i[e],G,E);a.intersectRay(E,n.wrap(R,w),v)?(t.subtract(v,v,i[e]),t.normalize(N,v),t.cross(U,G,N),t.normalize(U,U)):L(G,z,F,T,U,N,y),t.copy(z,N),t.copy(F,U)}A&&(t.add(v,i[e],x),t.normalize(C,v));for(let a=0;a<f;a++)if(t.scale(S,U,o[a][0]),t.scale(v,N,o[a][1]),t.add(S,S,v),t.normalize(p,S),V[I++]=p[0],V[I++]=p[1],V[I++]=p[2],t.add(S,S,i[e]),b[d++]=S[0],b[d++]=S[1],b[d++]=S[2],!r){const t=(a+1)%f;O[g++]=k+a,O[g++]=k+f+a,O[g++]=k+t,O[g++]=k+t,O[g++]=k+f+a,O[g++]=k+f+t;for(let e=0;e<6;e++)m[M++]=O[g-6+e]-D}k+=f}const B=i[i.length-1];for(let e=0;e<l.length;e++)t.scale(S,U,l[e][0]),t.scale(v,N,l[e][1]),t.add(S,S,v),t.add(S,S,B),b[d++]=S[0],b[d++]=S[1],b[d++]=S[2];const X=I/3;V[I++]=P[0],V[I++]=P[1],V[I++]=P[2];const q=k-f;for(let t=0;t<u.length;t++)O[g++]=u[t][0]>=0?k+u[t][0]:-u[t][0]-1+q,O[g++]=u[t][2]>=0?k+u[t][2]:-u[t][2]-1+q,O[g++]=u[t][1]>=0?k+u[t][1]:-u[t][1]-1+q,m[M++]=X,m[M++]=X,m[M++]=X;const Z=[[c.VertexAttribute.POSITION,O],[c.VertexAttribute.NORMAL,m]],j=[[c.VertexAttribute.POSITION,{size:3,data:b,exclusive:!0}],[c.VertexAttribute.NORMAL,{size:3,data:V,exclusive:!0}]];return new s.Geometry(j,Z)}function S(t,e,r){u.assert(t.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),u.assert(3===t[0].length,"createPolylineGeometry(): malformed vertex"),u.assert(null==e||e.length===t.length,"createPolylineGeometry: need same number of points and normals"),u.assert(null==e||3===e[0].length,"createPolylineGeometry(): malformed normal");const a=new Float64Array(3*t.length),n=new Uint32Array(2*(t.length-1));let i=0,A=0;for(let o=0;o<t.length;o++){for(let e=0;e<3;e++)a[i++]=t[o][e];o>0&&(n[A++]=o-1,n[A++]=o)}const x=[],f=[];if(x.push([c.VertexAttribute.POSITION,n]),f.push([c.VertexAttribute.POSITION,{size:3,data:a,exclusive:!0}]),e){const r=new Float32Array(3*e.length);let a=0;for(let n=0;n<t.length;n++)for(let t=0;t<3;t++)r[a++]=e[n][t];x.push([c.VertexAttribute.NORMAL,n]),f.push([c.VertexAttribute.NORMAL,{size:3,data:r,exclusive:!0}])}return r&&(f.push([c.VertexAttribute.COLOR,{size:4,data:r}]),x.push([c.VertexAttribute.COLOR,l.generateDefaultIndexArray(r.length/4)])),new s.Geometry(f,x,o.PrimitiveType.Line)}function p(t,e,r,a,n=0){const o=new Array(18),i=[[-e,n,a/2],[r,n,a/2],[0,t+n,a/2],[-e,n,-a/2],[r,n,-a/2],[0,t+n,-a/2]],l=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let s=0;s<6;s++)o[3*s]=i[s][0],o[3*s+1]=i[s][1],o[3*s+2]=i[s][2];return new s.Geometry([[c.VertexAttribute.POSITION,{size:3,data:o,exclusive:!0}]],[[c.VertexAttribute.POSITION,l]])}function v(e,r){const a=e.getMutableAttribute(c.VertexAttribute.POSITION).data;for(let n=0;n<a.length;n+=3){const e=a[n],o=a[n+1],i=a[n+2];t.set(h,e,o,i),t.transformMat4(h,h,r),a[n]=h[0],a[n+1]=h[1],a[n+2]=h[2]}}function T(t,e=t){const r=t.vertexAttributes,a=r.get(c.VertexAttribute.POSITION).data,n=r.get(c.VertexAttribute.NORMAL).data;if(n){const t=e.getMutableAttribute(c.VertexAttribute.NORMAL).data;for(let e=0;e<n.length;e+=3){const r=n[e+1];t[e+1]=-n[e+2],t[e+2]=r}}if(a){const t=e.getMutableAttribute(c.VertexAttribute.POSITION).data;for(let e=0;e<a.length;e+=3){const r=a[e+1];t[e+1]=-a[e+2],t[e+2]=r}}return e}function G(e,r,a,n,o){return!(Math.abs(t.dot(r,e))>o)&&(t.cross(a,e,r),t.normalize(a,a),t.cross(n,a,e),t.normalize(n,n),!0)}function L(t,e,r,a,n,o,i){return G(t,e,n,o,i)||G(t,r,n,o,i)||G(t,a,n,o,i)}i.createSquareGeometry=w,i.createConeGeometry=P,i.createCylinderGeometry=N,i.createTubeGeometry=z,i.createPathExtrusionGeometry=U,i.createPolylineGeometry=S,i.createExtrudedTriangle=p,i.transformInPlace=v,i.cgToGIS=T,i.makeOrthoBasisDirUp=G,i.makeOrthoBasisDirUpFallback=L}(V||(V={}));const y=.99619469809,h=e.create();return V}));
