/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["../../../../chunks/vec3","../../../../chunks/vec3f32","../../../../chunks/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/ray","./BufferVectorMath","./Geometry","./geometryDataUtils","./Util"],(function(e,t,n,r,o,a,s,l,i){"use strict";const c=a.Vec3Compact;var u,f,m,h;!function(e){const t=.5,n=[[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t],[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t]],r=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],o=[0,0,1,0,1,1,0,1],a=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),l=new Uint16Array(36);for(let s=0;s<6;s++)for(let e=0;e<6;e++)l[6*s+e]=s;const i=new Uint16Array(36);for(let s=0;s<6;s++)i[6*s+0]=0,i[6*s+1]=1,i[6*s+2]=2,i[6*s+3]=2,i[6*s+4]=3,i[6*s+5]=0;function c(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(24);for(let r=0;r<8;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new s.Geometry([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}],["uv0",{size:2,data:o}]],[["position",a],["normal",l],["uv0",i]])}e.createGeometry=c}(u||(u={})),function(e){const t=.5,n=[[-t,0,-t],[t,0,-t],[t,0,t],[-t,0,t],[0,-t,0],[0,t,0]],r=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],o=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),a=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);function l(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(18);for(let r=0;r<6;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new s.Geometry([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}]],[["position",o],["normal",a]])}e.createGeometry=l}(f||(f={})),function(n){const r=.5,o=0,a=t.fromValues(-r,o,-r),l=t.fromValues(r,o,-r),i=t.fromValues(0,o,r),c=t.fromValues(0,o+r,0),u=t.create(),f=t.create(),m=t.create(),h=t.create(),y=t.create();e.subtract(u,a,c),e.subtract(f,a,l),e.cross(m,u,f),e.normalize(m,m),e.subtract(u,l,c),e.subtract(f,l,i),e.cross(h,u,f),e.normalize(h,h),e.subtract(u,i,c),e.subtract(f,i,a),e.cross(y,u,f),e.normalize(y,y);const d=[a,l,i,c],p=[0,-1,0,m[0],m[1],m[2],h[0],h[1],h[2],y[0],y[1],y[2]],g=[0,1,2,3,1,0,3,2,1,3,0,2],A=[0,0,0,1,1,1,2,2,2,3,3,3];function w(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(12);for(let n=0;n<4;n++)t[3*n]=d[n][0]*e[0],t[3*n+1]=d[n][1]*e[1],t[3*n+2]=d[n][2]*e[2];return new s.Geometry([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:p}]],[["position",new Uint16Array(g)],["normal",new Uint16Array(A)]])}n.createGeometry=w}(m||(m={})),function(a){function h(e,t,n,r={uv:!0}){const o=-Math.PI,a=2*Math.PI,l=-Math.PI/2,i=Math.PI,c=Math.max(3,Math.floor(t)),u=Math.max(2,Math.floor(n)),f=(c+1)*(u+1),m=new Float32Array(3*f),h=new Float32Array(3*f),y=new Float32Array(2*f),d=[];let p=0;for(let s=0;s<=u;s++){const t=[],n=s/u,r=l+n*i,f=Math.cos(r);for(let s=0;s<=c;s++){const l=s/c,i=o+l*a,u=Math.cos(i)*f,d=Math.sin(r),g=-Math.sin(i)*f;m[3*p]=u*e,m[3*p+1]=d*e,m[3*p+2]=g*e,h[3*p]=u,h[3*p+1]=d,h[3*p+2]=g,y[2*p]=l,y[2*p+1]=n,t.push(p),++p}d.push(t)}const g=new Uint32Array(2*c*(u-1)*3);p=0;for(let s=0;s<u;s++)for(let e=0;e<c;e++){const t=d[s][e],n=d[s][e+1],r=d[s+1][e+1],o=d[s+1][e];0===s?(g[p++]=t,g[p++]=r,g[p++]=o):s===u-1?(g[p++]=t,g[p++]=n,g[p++]=r):(g[p++]=t,g[p++]=n,g[p++]=r,g[p++]=r,g[p++]=o,g[p++]=t)}const A=[["position",g],["normal",g]],w=[["position",{size:3,data:m,exclusive:!0}],["normal",{size:3,data:h,exclusive:!0}]];return r.uv&&(w.push(["uv0",{size:2,data:y,exclusive:!0}]),A.push(["uv0",g])),r.offset&&(A[0][0]="offset",w[0][0]="offset",A.push(["position",new Uint32Array(g.length)]),w.push(["position",{size:3,data:Float64Array.from(r.offset),exclusive:!0}])),new s.Geometry(w,A)}function p(e,t,n){const r=e;let o,a;if(n)o=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],a=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const e=r*(1+Math.sqrt(5))/2;o=[-r,e,0,r,e,0,-r,-e,0,r,-e,0,0,-r,e,0,r,e,0,-r,-e,0,r,-e,e,0,-r,e,0,r,-e,0,-r,-e,0,r],a=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let s=0;s<o.length;s+=3)c.scale(o,s,e/c.length(o,s));let l={};function i(t,n){t>n&&([t,n]=[n,t]);const r=t.toString()+"."+n.toString();if(l[r])return l[r];let a=o.length;return o.length+=3,c.add(o,3*t,o,3*n,o,a),c.scale(o,a,e/c.length(o,a)),a/=3,l[r]=a,a}for(let s=0;s<t;s++){const e=a.length,t=new Uint32Array(4*e);for(let n=0;n<e;n+=3){const e=a[n],r=a[n+1],o=a[n+2],s=i(e,r),l=i(r,o),c=i(o,e),u=4*n;t[u]=e,t[u+1]=s,t[u+2]=c,t[u+3]=r,t[u+4]=l,t[u+5]=s,t[u+6]=o,t[u+7]=c,t[u+8]=l,t[u+9]=s,t[u+10]=l,t[u+11]=c}a=t,l={}}const u=new Float32Array(o);for(let s=0;s<u.length;s+=3)c.normalize(u,s);const f=[["position",a],["normal",a]],m=[["position",{size:3,data:new Float32Array(o),exclusive:!0}],["normal",{size:3,data:u,exclusive:!0}]];return new s.Geometry(m,f)}function g(e,t,n,r,o,a,l){const i=t?[t[0],t[1],t[2]]:[0,0,0],c=e?[e[0],e[1],e[2]]:[0,0,1];a=a||[0,0];const u=n?[255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]:[255,255,255,255],f=null!=r&&2===r.length?r:[1,1],m=[["position",{size:3,data:i,exclusive:!0}],["normal",{size:3,data:c,exclusive:!0}],["uv0",{size:a.length,data:a}],["color",{size:4,data:u,exclusive:!0}],["size",{size:2,data:f}]];if(null!=o){const e=new Float32Array([o[0],o[1],o[2],o[3]]);m.push(["auxpos1",{size:4,data:e}])}if(null!=l){const e=new Float32Array([l[0],l[1],l[2],l[3]]);m.push(["auxpos2",{size:4,data:e}])}return new s.Geometry(m,null,1)}function A(e,t,n,r,o,a,s,l){if(null!=e){const{data:t}=l.getMutableAttribute("normal");t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=t){const{data:e}=l.getMutableAttribute("position");e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=n){const{data:e}=l.getMutableAttribute("color");e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3]}if(null!=r){const{data:e}=l.getMutableAttribute("size");e[0]=r[0],e[1]=r[1]}if(null!=o){const{data:e}=l.getMutableAttribute("auxpos1");e[0]=o[0],e[1]=o[1],e[2]=o[2],e[3]=o[3]}if(null!=a){const{data:e}=l.getMutableAttribute("uv0");e[0]=a[0],e[1]=a[1]}if(null!=s){const{data:e}=l.getMutableAttribute("auxpos2");e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3]}}function w(e,t){const n=new Float32Array(3*e.length),r=new Float32Array(t?3*e.length:3),o=new Uint32Array(e.length),a=new Uint32Array(e.length);for(let s=0;s<e.length;s++)n[3*s]=e[s][0],n[3*s+1]=e[s][1],n[3*s+2]=e[s][2],t&&(r[3*s]=t[s][0],r[3*s+1]=t[s][1],r[3*s+2]=t[s][2]),o[s]=s,a[s]=0;t||(r[0]=0,r[1]=1,r[2]=0);const l=[["position",o],["normal",t?o:a],["uv0",a]],i=[["position",{size:3,data:n,exclusive:!0}],["normal",{size:3,data:r,exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]];return new s.Geometry(i,l,1)}function z(){const e=[0,0,0,0,0,100,100,0,0],t=[0,1,0],n=[0,0],r=[["position",new Uint16Array([0,1,2])],["normal",new Uint16Array([0,0,0])],["uv0",new Uint16Array([0,0,0])]],o=[["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:t,exclusive:!0}],["uv0",{size:2,data:n,exclusive:!0}]];return new s.Geometry(o,r)}a.createBoxGeometry=u.createGeometry,a.createDiamondGeometry=f.createGeometry,a.createTetrahedronGeometry=m.createGeometry,a.createSphereGeometry=h,a.createPolySphereGeometry=p,a.createPointGeometry=g,a.updatePointGeometry=A,a.createPointArrayGeometry=w,a.createTriangleGeometry=z;const v=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function x(e=v){const t=new Array(12);for(let s=0;s<4;s++)for(let n=0;n<3;n++)t[3*s+n]=e[s][n];const n=new Uint32Array([0,1,2,2,3,0]),r=[0,0,1],o=new Uint32Array([0,0,0,0,0,0]),a=[["position",n],["normal",o],["uv0",n],["color",o]],l=[["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r,exclusive:!0}],["uv0",{size:2,data:[0,0,1,0,1,1,0,1],exclusive:!0}],["color",{size:4,data:[255,255,255,255],exclusive:!0}]];return new s.Geometry(l,a)}function M(e,n,r,o,a=!0,l=!0){let i=0;const c=n,u=e;let f=t.fromValues(0,i,0),m=t.fromValues(0,i+u,0),h=t.fromValues(0,-1,0),y=t.fromValues(0,1,0);o&&(i=u,m=t.fromValues(0,0,0),f=t.fromValues(0,i,0),h=t.fromValues(0,1,0),y=t.fromValues(0,-1,0));const d=[m,f],p=[h,y],g=r+2,A=Math.sqrt(u*u+c*c);if(o)for(let s=r-1;s>=0;s--){const e=s*(2*Math.PI/r),n=t.fromValues(Math.cos(e)*c,i,Math.sin(e)*c);d.push(n);const o=t.fromValues(u*Math.cos(e)/A,-c/A,u*Math.sin(e)/A);p.push(o)}else for(let s=0;s<r;s++){const e=s*(2*Math.PI/r),n=t.fromValues(Math.cos(e)*c,i,Math.sin(e)*c);d.push(n);const o=t.fromValues(u*Math.cos(e)/A,c/A,u*Math.sin(e)/A);p.push(o)}const w=new Uint32Array(2*(r+2)*3),z=new Uint32Array(2*(r+2)*3);let v=0,x=0;if(a){for(let e=3;e<d.length;e++)w[v++]=1,w[v++]=e-1,w[v++]=e,z[x++]=0,z[x++]=0,z[x++]=0;w[v++]=d.length-1,w[v++]=2,w[v++]=1,z[x++]=0,z[x++]=0,z[x++]=0}if(l){for(let e=3;e<d.length;e++)w[v++]=e,w[v++]=e-1,w[v++]=0,z[x++]=e,z[x++]=e-1,z[x++]=1;w[v++]=0,w[v++]=2,w[v++]=d.length-1,z[x++]=1,z[x++]=2,z[x++]=p.length-1}const M=new Float32Array(3*g);for(let t=0;t<g;t++)M[3*t]=d[t][0],M[3*t+1]=d[t][1],M[3*t+2]=d[t][2];const G=new Float32Array(3*g);for(let t=0;t<g;t++)G[3*t]=p[t][0],G[3*t+1]=p[t][1],G[3*t+2]=p[t][2];const b=[["position",w],["normal",z]],U=[["position",{size:3,data:M,exclusive:!0}],["normal",{size:3,data:G,exclusive:!0}]];return new s.Geometry(U,b)}function G(n,r,o,a,l,i){const c=a?t.clone(a):t.fromValues(1,0,0),u=l?t.clone(l):t.fromValues(0,0,0);i=null==i||i;const f=t.create();e.normalize(f,c);const m=t.create();e.scale(m,f,Math.abs(n));const h=t.create();e.scale(h,m,-.5),e.add(h,h,u);const y=t.fromValues(0,1,0);Math.abs(1-e.dot(f,y))<.2&&e.set(y,0,0,1);const d=t.create();e.cross(d,f,y),e.normalize(d,d),e.cross(y,d,f);const p=2*o+(i?2:0),g=o+(i?2:0),A=new Float32Array(3*p),w=new Float32Array(3*g),z=new Float32Array(2*p),v=new Uint32Array(3*o*(i?4:2)),x=new Uint32Array(3*o*(i?4:2));i&&(A[3*(p-2)+0]=h[0],A[3*(p-2)+1]=h[1],A[3*(p-2)+2]=h[2],z[2*(p-2)]=0,z[2*(p-2)+1]=0,A[3*(p-1)+0]=A[3*(p-2)+0]+m[0],A[3*(p-1)+1]=A[3*(p-2)+1]+m[1],A[3*(p-1)+2]=A[3*(p-2)+2]+m[2],z[2*(p-1)]=1,z[2*(p-1)+1]=1,w[3*(g-2)+0]=-f[0],w[3*(g-2)+1]=-f[1],w[3*(g-2)+2]=-f[2],w[3*(g-1)+0]=f[0],w[3*(g-1)+1]=f[1],w[3*(g-1)+2]=f[2]);const M=function(e,t,n){v[e]=t,x[e]=n};let G=0;const b=t.create(),U=t.create();for(let t=0;t<o;t++){const n=t*(2*Math.PI/o);e.scale(b,y,Math.sin(n)),e.scale(U,d,Math.cos(n)),e.add(b,b,U),w[3*t+0]=b[0],w[3*t+1]=b[1],w[3*t+2]=b[2],e.scale(b,b,r),e.add(b,b,h),A[3*t+0]=b[0],A[3*t+1]=b[1],A[3*t+2]=b[2],z[2*t+0]=t/o,z[2*t+1]=0,A[3*(t+o)+0]=A[3*t+0]+m[0],A[3*(t+o)+1]=A[3*t+1]+m[1],A[3*(t+o)+2]=A[3*t+2]+m[2],z[2*(t+o)+0]=t/o,z[2*t+1]=1;const a=(t+1)%o;M(G++,t,t),M(G++,t+o,t),M(G++,a,a),M(G++,a,a),M(G++,t+o,t),M(G++,a+o,a)}if(i){for(let e=0;e<o;e++){const t=(e+1)%o;M(G++,p-2,g-2),M(G++,e,g-2),M(G++,t,g-2)}for(let e=0;e<o;e++){const t=(e+1)%o;M(G++,e+o,g-1),M(G++,p-1,g-1),M(G++,t+o,g-1)}}const V=[["position",v],["normal",x],["uv0",v]],P=[["position",{size:3,data:A,exclusive:!0}],["normal",{size:3,data:w,exclusive:!0}],["uv0",{size:2,data:z,exclusive:!0}]];return new s.Geometry(P,V)}function b(e,t,n,r,o){n=n||10,r=null==r||r,i.assert(e.length>1);const s=[[0,0,0]],l=[],c=[];for(let a=0;a<n;a++){l.push([0,-a-1,-(a+1)%n-1]);const e=a/n*2*Math.PI;c.push([Math.cos(e)*t,Math.sin(e)*t])}return a.createPathExtrusionGeometry(c,e,s,l,r,o)}function U(a,l,i,c,u,f=t.fromValues(0,0,0)){const m=a.length,h=new Float32Array(l.length*m*3+(6*i.length||0)),d=new Float32Array(l.length*m*3+(i?6:0)),p=(l.length-1)*m*6+3*c.length*2,g=new Uint32Array(p),A=new Uint32Array(p);let w=0,z=0,v=0,x=0;const M=t.create(),G=t.create(),b=t.create(),U=t.create(),V=t.create(),P=t.create(),F=t.create(),I=n.create(),k=t.create(),D=t.create(),T=t.create(),B=t.create(),q=t.create(),C=r.create();e.set(k,0,1,0),e.subtract(G,l[1],l[0]),e.normalize(G,G),u?(e.add(I,l[0],f),e.normalize(b,I)):e.set(b,0,0,1),S(G,b,k,k,V,b,y),e.copy(U,b),e.copy(B,V);for(let t=0;t<i.length;t++)e.scale(P,V,i[t][0]),e.scale(I,b,i[t][2]),e.add(P,P,I),e.add(P,P,l[0]),h[w++]=P[0],h[w++]=P[1],h[w++]=P[2];d[z++]=-G[0],d[z++]=-G[1],d[z++]=-G[2];for(let e=0;e<c.length;e++)g[v++]=c[e][0]>0?c[e][0]:-c[e][0]-1+i.length,g[v++]=c[e][1]>0?c[e][1]:-c[e][1]-1+i.length,g[v++]=c[e][2]>0?c[e][2]:-c[e][2]-1+i.length,A[x++]=0,A[x++]=0,A[x++]=0;let E=i.length;const O=i.length-1;for(let t=0;t<l.length;t++){let n=!1;if(t>0){e.copy(M,G),t<l.length-1?(e.subtract(G,l[t+1],l[t]),e.normalize(G,G)):n=!0,e.add(D,M,G),e.normalize(D,D),e.add(T,l[t-1],U),r.fromPositionAndNormal(l[t],D,C);r.intersectRay(C,o.wrap(T,M),I)?(e.subtract(I,I,l[t]),e.normalize(b,I),e.cross(V,D,b),e.normalize(V,V)):S(D,U,B,k,V,b,y),e.copy(U,b),e.copy(B,V)}u&&(e.add(I,l[t],f),e.normalize(q,I));for(let r=0;r<m;r++)if(e.scale(P,V,a[r][0]),e.scale(I,b,a[r][1]),e.add(P,P,I),e.normalize(F,P),d[z++]=F[0],d[z++]=F[1],d[z++]=F[2],e.add(P,P,l[t]),h[w++]=P[0],h[w++]=P[1],h[w++]=P[2],!n){const e=(r+1)%m;g[v++]=E+r,g[v++]=E+m+r,g[v++]=E+e,g[v++]=E+e,g[v++]=E+m+r,g[v++]=E+m+e;for(let t=0;t<6;t++)A[x++]=g[v-6+t]-O}E+=m}const N=l[l.length-1];for(let t=0;t<i.length;t++)e.scale(P,V,i[t][0]),e.scale(I,b,i[t][1]),e.add(P,P,I),e.add(P,P,N),h[w++]=P[0],h[w++]=P[1],h[w++]=P[2];const R=z/3;d[z++]=G[0],d[z++]=G[1],d[z++]=G[2];const j=E-m;for(let e=0;e<c.length;e++)g[v++]=c[e][0]>=0?E+c[e][0]:-c[e][0]-1+j,g[v++]=c[e][2]>=0?E+c[e][2]:-c[e][2]-1+j,g[v++]=c[e][1]>=0?E+c[e][1]:-c[e][1]-1+j,A[x++]=R,A[x++]=R,A[x++]=R;const H=[["position",g],["normal",A]],J=[["position",{size:3,data:h,exclusive:!0}],["normal",{size:3,data:d,exclusive:!0}]];return new s.Geometry(J,H)}function V(e,t,n){i.assert(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),i.assert(3===e[0].length,"createPolylineGeometry(): malformed vertex"),i.assert(null==t||t.length===e.length,"createPolylineGeometry: need same number of points and normals"),i.assert(null==t||3===t[0].length,"createPolylineGeometry(): malformed normal");const r=new Float64Array(3*e.length),o=new Uint32Array(2*(e.length-1));let a=0,c=0;for(let s=0;s<e.length;s++){for(let t=0;t<3;t++)r[a++]=e[s][t];s>0&&(o[c++]=s-1,o[c++]=s)}const u=[],f=[];if(u.push(["position",o]),f.push(["position",{size:3,data:r,exclusive:!0}]),t){const n=new Float32Array(3*t.length);let r=0;for(let o=0;o<e.length;o++)for(let e=0;e<3;e++)n[r++]=t[o][e];u.push(["normal",o]),f.push(["normal",{size:3,data:n,exclusive:!0}])}return n&&(f.push(["color",{size:4,data:n}]),u.push(["color",l.generateDefaultIndexArray(n.length/4)])),new s.Geometry(f,u,2)}function P(e,t,n,r,o=0){const a=new Array(18),l=[[-t,o,r/2],[n,o,r/2],[0,e+o,r/2],[-t,o,-r/2],[n,o,-r/2],[0,e+o,-r/2]],i=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let s=0;s<6;s++)a[3*s]=l[s][0],a[3*s+1]=l[s][1],a[3*s+2]=l[s][2];return new s.Geometry([["position",{size:3,data:a,exclusive:!0}]],[["position",i]])}function F(t,n){const r=t.getMutableAttribute("position").data;for(let o=0;o<r.length;o+=3){const t=r[o],a=r[o+1],s=r[o+2];e.set(d,t,a,s),e.transformMat4(d,d,n),r[o]=d[0],r[o+1]=d[1],r[o+2]=d[2]}}function I(e,t=e){const n=e.vertexAttributes,r=n.get("position").data,o=n.get("normal").data;if(o){const e=t.getMutableAttribute("normal").data;for(let t=0;t<o.length;t+=3){const n=o[t+1];e[t+1]=-o[t+2],e[t+2]=n}}if(r){const e=t.getMutableAttribute("position").data;for(let t=0;t<r.length;t+=3){const n=r[t+1];e[t+1]=-r[t+2],e[t+2]=n}}return t}function k(t,n,r,o,a){return!(Math.abs(e.dot(n,t))>a)&&(e.cross(r,t,n),e.normalize(r,r),e.cross(o,r,t),e.normalize(o,o),!0)}function S(e,t,n,r,o,a,s){return k(e,t,o,a,s)||k(e,n,o,a,s)||k(e,r,o,a,s)}a.createSquareGeometry=x,a.createConeGeometry=M,a.createCylinderGeometry=G,a.createTubeGeometry=b,a.createPathExtrusionGeometry=U,a.createPolylineGeometry=V,a.createExtrudedTriangle=P,a.transformInPlace=F,a.cgToGIS=I,a.makeOrthoBasisDirUp=k,a.makeOrthoBasisDirUpFallback=S}(h||(h={}));const y=.99619469809,d=t.create();return h}));
