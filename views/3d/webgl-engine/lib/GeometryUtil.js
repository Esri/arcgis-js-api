/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/vec3","../../../../chunks/vec3f32","../../../../chunks/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/ray","./basicInterfaces","./BufferVectorMath","./Geometry","./Indices","./Util","./VertexAttribute"],(function(t,e,r,a,s,n,o,u,i,l,c,A){"use strict";const h=u.Vec3Compact;var x,f,b;!function(t){const e=.5,r=[[-e,-e,e],[e,-e,e],[e,e,e],[-e,e,e],[-e,-e,-e],[e,-e,-e],[e,e,-e],[-e,e,-e]],a=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],s=[0,0,1,0,1,1,0,1],n=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],o=new Array(36);for(let i=0;i<6;i++)for(let t=0;t<6;t++)o[6*i+t]=i;const u=new Array(36);for(let i=0;i<6;i++)u[6*i+0]=0,u[6*i+1]=1,u[6*i+2]=2,u[6*i+3]=2,u[6*i+4]=3,u[6*i+5]=0;function l(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(24);for(let a=0;a<8;a++)e[3*a]=r[a][0]*t[0],e[3*a+1]=r[a][1]*t[1],e[3*a+2]=r[a][2]*t[2];return new i.Geometry([[A.VertexAttribute.POSITION,{size:3,data:e,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:a}],[A.VertexAttribute.UV0,{size:2,data:s}]],[[A.VertexAttribute.POSITION,n],[A.VertexAttribute.NORMAL,o],[A.VertexAttribute.UV0,u]])}t.createGeometry=l}(x||(x={})),function(t){const e=.5,r=[[-e,0,-e],[e,0,-e],[e,0,e],[-e,0,e],[0,-e,0],[0,e,0]],a=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],s=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],n=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function o(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(18);for(let a=0;a<6;a++)e[3*a]=r[a][0]*t[0],e[3*a+1]=r[a][1]*t[1],e[3*a+2]=r[a][2]*t[2];return new i.Geometry([[A.VertexAttribute.POSITION,{size:3,data:e,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:a}]],[[A.VertexAttribute.POSITION,s],[A.VertexAttribute.NORMAL,n]])}t.createGeometry=o}(f||(f={})),function(t){const a=.5,s=0,n=r.fromValues(-a,s,-a),o=r.fromValues(a,s,-a),u=r.fromValues(0,s,a),l=r.fromValues(0,s+a,0),c=r.create(),h=r.create(),x=r.create(),f=r.create(),b=r.create();e.subtract(c,n,l),e.subtract(h,n,o),e.cross(x,c,h),e.normalize(x,x),e.subtract(c,o,l),e.subtract(h,o,u),e.cross(f,c,h),e.normalize(f,f),e.subtract(c,u,l),e.subtract(h,u,n),e.cross(b,c,h),e.normalize(b,b);const V=[n,o,u,l],O=[0,-1,0,x[0],x[1],x[2],f[0],f[1],f[2],b[0],b[1],b[2]],y=[0,1,2,3,1,0,3,2,1,3,0,2],d=[0,0,0,1,1,1,2,2,2,3,3,3];function m(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(12);for(let r=0;r<4;r++)e[3*r]=V[r][0]*t[0],e[3*r+1]=V[r][1]*t[1],e[3*r+2]=V[r][2]*t[2];return new i.Geometry([[A.VertexAttribute.POSITION,{size:3,data:e,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:O}]],[[A.VertexAttribute.POSITION,y],[A.VertexAttribute.NORMAL,d]])}t.createGeometry=m}(b||(b={}));const V=x.createGeometry,O=f.createGeometry,y=b.createGeometry;function d(t,e,r,a={uv:!0}){const s=-Math.PI,n=2*Math.PI,o=-Math.PI/2,u=Math.PI,l=Math.max(3,Math.floor(e)),c=Math.max(2,Math.floor(r)),h=(l+1)*(c+1),x=new Float32Array(3*h),f=new Float32Array(3*h),b=new Float32Array(2*h),V=[];let O=0;for(let i=0;i<=c;i++){const e=[],r=i/c,a=o+r*u,A=Math.cos(a);for(let o=0;o<=l;o++){const u=o/l,i=s+u*n,c=Math.cos(i)*A,h=Math.sin(a),V=-Math.sin(i)*A;x[3*O]=c*t,x[3*O+1]=h*t,x[3*O+2]=V*t,f[3*O]=c,f[3*O+1]=h,f[3*O+2]=V,b[2*O]=u,b[2*O+1]=r,e.push(O),++O}V.push(e)}const y=new Array;for(let i=0;i<c;i++)for(let t=0;t<l;t++){const e=V[i][t],r=V[i][t+1],a=V[i+1][t+1],s=V[i+1][t];0===i?(y.push(e),y.push(a),y.push(s)):i===c-1?(y.push(e),y.push(r),y.push(a)):(y.push(e),y.push(r),y.push(a),y.push(a),y.push(s),y.push(e))}const d=[[A.VertexAttribute.POSITION,y],[A.VertexAttribute.NORMAL,y]],m=[[A.VertexAttribute.POSITION,{size:3,data:x,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:f,exclusive:!0}]];return a.uv&&(m.push([A.VertexAttribute.UV0,{size:2,data:b,exclusive:!0}]),d.push([A.VertexAttribute.UV0,y])),a.offset&&(d[0][0]=A.VertexAttribute.OFFSET,m[0][0]=A.VertexAttribute.OFFSET,d.push([A.VertexAttribute.POSITION,new Array(y.length).fill(0)]),m.push([A.VertexAttribute.POSITION,{size:3,data:Float64Array.from(a.offset),exclusive:!0}])),new i.Geometry(m,d)}function m(t,e,r){const a=t;let s,n;if(r)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],n=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const t=a*(1+Math.sqrt(5))/2;s=[-a,t,0,a,t,0,-a,-t,0,a,-t,0,0,-a,t,0,a,t,0,-a,-t,0,a,-t,t,0,-a,t,0,a,-t,0,-a,-t,0,a],n=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let i=0;i<s.length;i+=3)h.scale(s,i,t/h.length(s,i));let o={};function u(e,r){e>r&&([e,r]=[r,e]);const a=e.toString()+"."+r.toString();if(o[a])return o[a];let n=s.length;return s.length+=3,h.add(s,3*e,s,3*r,s,n),h.scale(s,n,t/h.length(s,n)),n/=3,o[a]=n,n}for(let i=0;i<e;i++){const t=n.length,e=new Array(4*t);for(let r=0;r<t;r+=3){const t=n[r],a=n[r+1],s=n[r+2],o=u(t,a),i=u(a,s),l=u(s,t),c=4*r;e[c]=t,e[c+1]=o,e[c+2]=l,e[c+3]=a,e[c+4]=i,e[c+5]=o,e[c+6]=s,e[c+7]=l,e[c+8]=i,e[c+9]=o,e[c+10]=i,e[c+11]=l}n=e,o={}}const l=new Float32Array(s);for(let i=0;i<l.length;i+=3)h.normalize(l,i);const c=[[A.VertexAttribute.POSITION,n],[A.VertexAttribute.NORMAL,n]],x=[[A.VertexAttribute.POSITION,{size:3,data:new Float32Array(s),exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:l,exclusive:!0}]];return new i.Geometry(x,c)}function p(t,e,r,a,s,n,u,l){const c=e?[e[0],e[1],e[2]]:[0,0,0],h=t?[t[0],t[1],t[2]]:[0,0,1];n=n||[0,0];const x=r?[255*r[0],255*r[1],255*r[2],r.length>3?255*r[3]:255]:[255,255,255,255],f=null!=a&&2===a.length?a:[1,1],b=[[A.VertexAttribute.POSITION,{size:3,data:c,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:h,exclusive:!0}],[A.VertexAttribute.UV0,{size:n.length,data:n}],[A.VertexAttribute.COLOR,{size:4,data:x,exclusive:!0}],[A.VertexAttribute.SIZE,{size:2,data:f}]];if(null!=s){const t=new Float32Array([s[0],s[1],s[2],s[3]]);b.push([A.VertexAttribute.AUXPOS1,{size:4,data:t}])}if(null!=u){const t=new Float32Array([u[0],u[1],u[2],u[3]]);b.push([A.VertexAttribute.AUXPOS2,{size:4,data:t}])}return new i.Geometry(b,null,o.PrimitiveType.Point,l)}function I(t,e,r,a,s,n,o,u){if(null!=t){const{data:e}=u.getMutableAttribute(A.VertexAttribute.NORMAL);e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=e){const{data:t}=u.getMutableAttribute(A.VertexAttribute.POSITION);t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=r){const{data:t}=u.getMutableAttribute(A.VertexAttribute.COLOR);t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3]}if(null!=a){const{data:t}=u.getMutableAttribute(A.VertexAttribute.SIZE);t[0]=a[0],t[1]=a[1]}if(null!=s){const{data:t}=u.getMutableAttribute(A.VertexAttribute.AUXPOS1);t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3]}if(null!=n){const{data:t}=u.getMutableAttribute(A.VertexAttribute.UV0);t[0]=n[0],t[1]=n[1]}if(null!=o){const{data:t}=u.getMutableAttribute(A.VertexAttribute.AUXPOS2);t[0]=o[0],t[1]=o[1],t[2]=o[2],t[3]=o[3]}}function g(t,e){const r=new Float32Array(3*t.length),a=new Float32Array(e?3*t.length:3),s=new Array(t.length),n=new Array(t.length).fill(0);for(let o=0;o<t.length;o++)r[3*o]=t[o][0],r[3*o+1]=t[o][1],r[3*o+2]=t[o][2],e&&(a[3*o]=e[o][0],a[3*o+1]=e[o][1],a[3*o+2]=e[o][2]),s[o]=o;e||(a[0]=0,a[1]=1,a[2]=0);const u=[0,0],l=[[A.VertexAttribute.POSITION,s],[A.VertexAttribute.NORMAL,e?s:n],[A.VertexAttribute.UV0,n]],c=[[A.VertexAttribute.POSITION,{size:3,data:r,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:a,exclusive:!0}],[A.VertexAttribute.UV0,{size:2,data:u,exclusive:!0}]];return new i.Geometry(c,l,o.PrimitiveType.Point)}function M(){const t=[0,0,0,0,0,100,100,0,0],e=[0,1,2],r=[0,1,0],a=[0,0,0],s=[0,0],n=[0,0,0],o=[[A.VertexAttribute.POSITION,e],[A.VertexAttribute.NORMAL,a],[A.VertexAttribute.UV0,n]],u=[[A.VertexAttribute.POSITION,{size:3,data:t,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:r,exclusive:!0}],[A.VertexAttribute.UV0,{size:2,data:s,exclusive:!0}]];return new i.Geometry(u,o)}const P=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function N(t=P){const e=new Array(12);for(let i=0;i<4;i++)for(let r=0;r<3;r++)e[3*i+r]=t[i][r];const r=[0,1,2,2,3,0],a=[0,0,1],s=[0,0,0,0,0,0],n=[0,0,1,0,1,1,0,1],o=[255,255,255,255],u=[[A.VertexAttribute.POSITION,r],[A.VertexAttribute.NORMAL,s],[A.VertexAttribute.UV0,r],[A.VertexAttribute.COLOR,s]],l=[[A.VertexAttribute.POSITION,{size:3,data:e,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:a,exclusive:!0}],[A.VertexAttribute.UV0,{size:2,data:n,exclusive:!0}],[A.VertexAttribute.COLOR,{size:4,data:o,exclusive:!0}]];return new i.Geometry(l,u)}function z(t,e,a,s,n=!0,o=!0){let u=0;const l=e,c=t;let h=r.fromValues(0,u,0),x=r.fromValues(0,u+c,0),f=r.fromValues(0,-1,0),b=r.fromValues(0,1,0);s&&(u=c,x=r.fromValues(0,0,0),h=r.fromValues(0,u,0),f=r.fromValues(0,1,0),b=r.fromValues(0,-1,0));const V=[x,h],O=[f,b],y=a+2,d=Math.sqrt(c*c+l*l);if(s)for(let i=a-1;i>=0;i--){const t=i*(2*Math.PI/a),e=r.fromValues(Math.cos(t)*l,u,Math.sin(t)*l);V.push(e);const s=r.fromValues(c*Math.cos(t)/d,-l/d,c*Math.sin(t)/d);O.push(s)}else for(let i=0;i<a;i++){const t=i*(2*Math.PI/a),e=r.fromValues(Math.cos(t)*l,u,Math.sin(t)*l);V.push(e);const s=r.fromValues(c*Math.cos(t)/d,l/d,c*Math.sin(t)/d);O.push(s)}const m=new Array,p=new Array;if(n){for(let t=3;t<V.length;t++)m.push(1),m.push(t-1),m.push(t),p.push(0),p.push(0),p.push(0);m.push(V.length-1),m.push(2),m.push(1),p.push(0),p.push(0),p.push(0)}if(o){for(let t=3;t<V.length;t++)m.push(t),m.push(t-1),m.push(0),p.push(t),p.push(t-1),p.push(1);m.push(0),m.push(2),m.push(V.length-1),p.push(1),p.push(2),p.push(O.length-1)}const I=new Float32Array(3*y);for(let r=0;r<y;r++)I[3*r]=V[r][0],I[3*r+1]=V[r][1],I[3*r+2]=V[r][2];const g=new Float32Array(3*y);for(let r=0;r<y;r++)g[3*r]=O[r][0],g[3*r+1]=O[r][1],g[3*r+2]=O[r][2];const M=[[A.VertexAttribute.POSITION,m],[A.VertexAttribute.NORMAL,p]],P=[[A.VertexAttribute.POSITION,{size:3,data:I,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:g,exclusive:!0}]];return new i.Geometry(P,M)}function w(t,a,s,n,o,u){const l=n?r.clone(n):r.fromValues(1,0,0),c=o?r.clone(o):r.fromValues(0,0,0);u=u??!0;const h=r.create();e.normalize(h,l);const x=r.create();e.scale(x,h,Math.abs(t));const f=r.create();e.scale(f,x,-.5),e.add(f,f,c);const b=r.fromValues(0,1,0);Math.abs(1-e.dot(h,b))<.2&&e.set(b,0,0,1);const V=r.create();e.cross(V,h,b),e.normalize(V,V),e.cross(b,V,h);const O=2*s+(u?2:0),y=s+(u?2:0),d=new Float32Array(3*O),m=new Float32Array(3*y),p=new Float32Array(2*O),I=new Array(3*s*(u?4:2)),g=new Array(3*s*(u?4:2));u&&(d[3*(O-2)+0]=f[0],d[3*(O-2)+1]=f[1],d[3*(O-2)+2]=f[2],p[2*(O-2)]=0,p[2*(O-2)+1]=0,d[3*(O-1)+0]=d[3*(O-2)+0]+x[0],d[3*(O-1)+1]=d[3*(O-2)+1]+x[1],d[3*(O-1)+2]=d[3*(O-2)+2]+x[2],p[2*(O-1)]=1,p[2*(O-1)+1]=1,m[3*(y-2)+0]=-h[0],m[3*(y-2)+1]=-h[1],m[3*(y-2)+2]=-h[2],m[3*(y-1)+0]=h[0],m[3*(y-1)+1]=h[1],m[3*(y-1)+2]=h[2]);const M=(t,e,r)=>{I[t]=e,g[t]=r};let P=0;const N=r.create(),z=r.create();for(let r=0;r<s;r++){const t=r*(2*Math.PI/s);e.scale(N,b,Math.sin(t)),e.scale(z,V,Math.cos(t)),e.add(N,N,z),m[3*r+0]=N[0],m[3*r+1]=N[1],m[3*r+2]=N[2],e.scale(N,N,a),e.add(N,N,f),d[3*r+0]=N[0],d[3*r+1]=N[1],d[3*r+2]=N[2],p[2*r+0]=r/s,p[2*r+1]=0,d[3*(r+s)+0]=d[3*r+0]+x[0],d[3*(r+s)+1]=d[3*r+1]+x[1],d[3*(r+s)+2]=d[3*r+2]+x[2],p[2*(r+s)+0]=r/s,p[2*r+1]=1;const n=(r+1)%s;M(P++,r,r),M(P++,r+s,r),M(P++,n,n),M(P++,n,n),M(P++,r+s,r),M(P++,n+s,n)}if(u){for(let t=0;t<s;t++){const e=(t+1)%s;M(P++,O-2,y-2),M(P++,t,y-2),M(P++,e,y-2)}for(let t=0;t<s;t++){const e=(t+1)%s;M(P++,t+s,y-1),M(P++,O-1,y-1),M(P++,e+s,y-1)}}const w=[[A.VertexAttribute.POSITION,I],[A.VertexAttribute.NORMAL,g],[A.VertexAttribute.UV0,I]],S=[[A.VertexAttribute.POSITION,{size:3,data:d,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:m,exclusive:!0}],[A.VertexAttribute.UV0,{size:2,data:p,exclusive:!0}]];return new i.Geometry(S,w)}function S(t,e,r,a,s){r=r||10,a=null==a||a,c.assert(t.length>1);const n=[[0,0,0]],o=[],u=[];for(let i=0;i<r;i++){o.push([0,-i-1,-(i+1)%r-1]);const t=i/r*2*Math.PI;u.push([Math.cos(t)*e,Math.sin(t)*e])}return v(u,t,n,o,a,s)}function v(t,o,u,l,c,h=r.fromValues(0,0,0)){const x=t.length,f=new Float32Array(o.length*x*3+(6*u.length||0)),b=new Float32Array(o.length*x*3+(u?6:0)),V=new Array,O=new Array;let y=0,d=0;const m=r.create(),p=r.create(),I=r.create(),g=r.create(),M=r.create(),P=r.create(),N=r.create(),z=a.create(),w=r.create(),S=r.create(),v=r.create(),T=r.create(),G=r.create(),L=s.create();e.set(w,0,1,0),e.subtract(p,o[1],o[0]),e.normalize(p,p),c?(e.add(z,o[0],h),e.normalize(I,z)):e.set(I,0,0,1),U(p,I,w,w,M,I,C),e.copy(g,I),e.copy(T,M);for(let r=0;r<u.length;r++)e.scale(P,M,u[r][0]),e.scale(z,I,u[r][2]),e.add(P,P,z),e.add(P,P,o[0]),f[y++]=P[0],f[y++]=P[1],f[y++]=P[2];b[d++]=-p[0],b[d++]=-p[1],b[d++]=-p[2];for(let e=0;e<l.length;e++)V.push(l[e][0]>0?l[e][0]:-l[e][0]-1+u.length),V.push(l[e][1]>0?l[e][1]:-l[e][1]-1+u.length),V.push(l[e][2]>0?l[e][2]:-l[e][2]-1+u.length),O.push(0),O.push(0),O.push(0);let R=u.length;const F=u.length-1;for(let r=0;r<o.length;r++){let a=!1;if(r>0){e.copy(m,p),r<o.length-1?(e.subtract(p,o[r+1],o[r]),e.normalize(p,p)):a=!0,e.add(S,m,p),e.normalize(S,S),e.add(v,o[r-1],g),s.fromPositionAndNormal(o[r],S,L);s.intersectRay(L,n.wrap(v,m),z)?(e.subtract(z,z,o[r]),e.normalize(I,z),e.cross(M,S,I),e.normalize(M,M)):U(S,g,T,w,M,I,C),e.copy(g,I),e.copy(T,M)}c&&(e.add(z,o[r],h),e.normalize(G,z));for(let s=0;s<x;s++)if(e.scale(P,M,t[s][0]),e.scale(z,I,t[s][1]),e.add(P,P,z),e.normalize(N,P),b[d++]=N[0],b[d++]=N[1],b[d++]=N[2],e.add(P,P,o[r]),f[y++]=P[0],f[y++]=P[1],f[y++]=P[2],!a){const t=(s+1)%x;V.push(R+s),V.push(R+x+s),V.push(R+t),V.push(R+t),V.push(R+x+s),V.push(R+x+t);for(let e=0;e<6;e++){const t=V.length-6;O.push(V[t+e]-F)}}R+=x}const k=o[o.length-1];for(let r=0;r<u.length;r++)e.scale(P,M,u[r][0]),e.scale(z,I,u[r][1]),e.add(P,P,z),e.add(P,P,k),f[y++]=P[0],f[y++]=P[1],f[y++]=P[2];const E=d/3;b[d++]=p[0],b[d++]=p[1],b[d++]=p[2];const B=R-x;for(let e=0;e<l.length;e++)V.push(l[e][0]>=0?R+l[e][0]:-l[e][0]-1+B),V.push(l[e][2]>=0?R+l[e][2]:-l[e][2]-1+B),V.push(l[e][1]>=0?R+l[e][1]:-l[e][1]-1+B),O.push(E),O.push(E),O.push(E);const D=[[A.VertexAttribute.POSITION,V],[A.VertexAttribute.NORMAL,O]],X=[[A.VertexAttribute.POSITION,{size:3,data:f,exclusive:!0}],[A.VertexAttribute.NORMAL,{size:3,data:b,exclusive:!0}]];return new i.Geometry(X,D)}function T(t,e,r){c.assert(t.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),c.assert(3===t[0].length,"createPolylineGeometry(): malformed vertex"),c.assert(null==e||e.length===t.length,"createPolylineGeometry: need same number of points and normals"),c.assert(null==e||3===e[0].length,"createPolylineGeometry(): malformed normal");const a=new Float64Array(3*t.length),s=new Array(2*(t.length-1));let n=0,u=0;for(let o=0;o<t.length;o++){for(let e=0;e<3;e++)a[n++]=t[o][e];o>0&&(s[u++]=o-1,s[u++]=o)}const h=[],x=[];if(h.push([A.VertexAttribute.POSITION,s]),x.push([A.VertexAttribute.POSITION,{size:3,data:a,exclusive:!0}]),e){const r=new Float32Array(3*e.length);let a=0;for(let s=0;s<t.length;s++)for(let t=0;t<3;t++)r[a++]=e[s][t];h.push([A.VertexAttribute.NORMAL,s]),x.push([A.VertexAttribute.NORMAL,{size:3,data:r,exclusive:!0}])}return r&&(x.push([A.VertexAttribute.COLOR,{size:4,data:r}]),h.push([A.VertexAttribute.COLOR,l.generateDefaultIndexArray(r.length/4)])),new i.Geometry(x,h,o.PrimitiveType.Line)}function G(t,e,r,a,s=0){const n=new Array(18),o=[[-e,s,a/2],[r,s,a/2],[0,t+s,a/2],[-e,s,-a/2],[r,s,-a/2],[0,t+s,-a/2]],u=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let i=0;i<6;i++)n[3*i]=o[i][0],n[3*i+1]=o[i][1],n[3*i+2]=o[i][2];return new i.Geometry([[A.VertexAttribute.POSITION,{size:3,data:n,exclusive:!0}]],[[A.VertexAttribute.POSITION,u]])}function L(t,r){const a=t.getMutableAttribute(A.VertexAttribute.POSITION).data;for(let s=0;s<a.length;s+=3){const t=a[s],n=a[s+1],o=a[s+2];e.set(k,t,n,o),e.transformMat4(k,k,r),a[s]=k[0],a[s+1]=k[1],a[s+2]=k[2]}}function R(t,e=t){const r=t.vertexAttributes,a=r.get(A.VertexAttribute.POSITION).data,s=r.get(A.VertexAttribute.NORMAL).data;if(s){const t=e.getMutableAttribute(A.VertexAttribute.NORMAL).data;for(let e=0;e<s.length;e+=3){const r=s[e+1];t[e+1]=-s[e+2],t[e+2]=r}}if(a){const t=e.getMutableAttribute(A.VertexAttribute.POSITION).data;for(let e=0;e<a.length;e+=3){const r=a[e+1];t[e+1]=-a[e+2],t[e+2]=r}}return e}function F(t,r,a,s,n){return!(Math.abs(e.dot(r,t))>n)&&(e.cross(a,t,r),e.normalize(a,a),e.cross(s,a,t),e.normalize(s,s),!0)}function U(t,e,r,a,s,n,o){return F(t,e,s,n,o)||F(t,r,s,n,o)||F(t,a,s,n,o)}const C=.99619469809,k=r.create();t.cgToGIS=R,t.createBoxGeometry=V,t.createConeGeometry=z,t.createCylinderGeometry=w,t.createDiamondGeometry=O,t.createExtrudedTriangle=G,t.createPathExtrusionGeometry=v,t.createPointArrayGeometry=g,t.createPointGeometry=p,t.createPolySphereGeometry=m,t.createPolylineGeometry=T,t.createSphereGeometry=d,t.createSquareGeometry=N,t.createTetrahedronGeometry=y,t.createTriangleGeometry=M,t.createTubeGeometry=S,t.makeOrthoBasisDirUp=F,t.makeOrthoBasisDirUpFallback=U,t.transformInPlace=L,t.updatePointGeometry=I,Object.defineProperties(t,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
