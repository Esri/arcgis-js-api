/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/mat2f64","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/ray","./Attribute","./FloatArray","./GeometryUtil","./Indices","./VertexAttribute","../materials/internal/MaterialUtil"],(function(t,e,i,r,s,o,n,a,h,l,u,c,f,p,x,d,m){"use strict";function v(){return{up:h.create(),right:h.create()}}function g(t,e,i){a.transformMat4(t.up,e.up,i),a.transformMat4(t.right,e.right,i)}function b(t,e,i){t[0]=i[0]*e.right[0]+i[1]*e.up[0],t[1]=i[0]*e.right[1]+i[1]*e.up[1],t[2]=i[0]*e.right[2]+i[1]*e.up[2]}function A(t,e,i){o.set(t,a.dot(i,e.right),a.dot(i,e.up))}let V=function(){function t(){this.pos=h.create(),this.posES=h.create(),this.vLeft=h.create(),this.vRight=h.create(),this.vMinSiblingLength=0,this.frame=v(),this.rotationFrameUp=h.create(),this.rotationRight=n.create(),this.rotationAngle=0,this.miterStretch=i.create(),this.maxStretchDistance=0}return t.prototype.setFrameFromUpVector=function(t){a.copy(this.frame.up,t),a.add(H,this.vLeft,this.vRight),a.normalize(H,H),a.scale(z,this.frame.up,a.dot(H,this.frame.up)),a.subtract(j,H,z),a.normalize(j,j),a.cross(this.frame.right,j,this.frame.up)},t}(),C=function(){function t(){this.vertices=[],this.vertexIndices=[],this.vertexNormals=[],this.poles=[],this.poleIndices=[]}var i=t.prototype;return i.addVertex=function(t,e){return this.vertices.push(n.clone(t)),this.vertexNormals.push(n.clone(e)),this.vertices.length-1},i.addPole=function(t,e=null){return this.poles.push({position:n.clone(t),normal:e?n.clone(e):null}),this.poles.length-1},i.addSegment=function(t,e=null){this.vertexIndices.push(t.v0),this.vertexIndices.push(t.v1),e&&(this.poleIndices.push(e.v0),this.poleIndices.push(e.v1))},i.translate=function(t,e){for(const i of this.vertices)i[0]+=t,i[1]+=e;for(const i of this.poles)i.position[0]+=t,i.position[1]+=e},e._createClass(t,[{key:"numSegments",get:function(){return this.vertexIndices.length/2}}]),t}();function D(t=20){const e=.5,i=new C,r={v0:0,v1:0};i.addPole(n.fromValues(0,0));for(let o=0;o<t;++o){const r=2*o*Math.PI/t,s=Math.cos(r),a=Math.sin(r),h=n.fromValues(s*e,a*e),l=n.fromValues(s,a);i.addVertex(h,l)}for(let o=0;o<t-1;++o){const t={v0:o,v1:o+1};i.addSegment(t,r)}const s={v0:t-1,v1:0};return i.addSegment(s,r),i}function y(){const t=1,e=1,i=new C,r=n.fromValues(.5*-t,.5*-e),s=n.fromValues(.5*t,.5*-e),o=n.fromValues(.5*t,.5*e),a=n.fromValues(.5*-t,.5*e),h=n.fromValues(0,-1),l=n.fromValues(1,0),u=n.fromValues(0,1),c=n.fromValues(-1,0);return i.addPole(n.fromValues(0,.5*e),u),i.addPole(n.fromValues(0,.5*e)),i.addPole(n.fromValues(0,.5*-e)),i.addPole(n.fromValues(0,.5*-e),h),i.addVertex(r,h),i.addVertex(s,h),i.addSegment({v0:0,v1:1},{v0:3,v1:3}),i.addVertex(s,l),i.addVertex(o,l),i.addSegment({v0:2,v1:3},{v0:2,v1:1}),i.addVertex(o,u),i.addVertex(a,u),i.addSegment({v0:4,v1:5},{v0:0,v1:0}),i.addVertex(a,c),i.addVertex(r,c),i.addSegment({v0:6,v1:7},{v0:1,v1:2}),i}let P=function(){function t(t){this.vertices=t,this.offset=h.create(),this.xform=s.create();const e=Math.floor((t.length-1)/2);a.copy(this.offset,this.vertices[e].pos);for(const i of this.vertices)a.subtract(i.pos,i.pos,this.offset);r.translate(this.xform,this.xform,this.offset),this.updatePathVertexInformation()}return t.prototype.updatePathVertexInformation=function(){const t=this.vertices.length,e=this.vertices[0];e.index=0,e.vLeft=h.create(),a.subtract(e.vRight,this.vertices[1].pos,e.pos);let i=a.length(e.vRight);e.vMinSiblingLength=i,a.normalize(e.vRight,e.vRight);let r=e;for(let s=1;s<t;++s){const e=this.vertices[s];if(e.index=s,e.vLeft=r.vRight,s<t-1){a.subtract(e.vRight,this.vertices[s+1].pos,e.pos);const t=a.length(e.vRight);e.vMinSiblingLength=Math.min(i,t),i=t,a.normalize(e.vRight,e.vRight)}else a.copy(e.vRight,e.vLeft),e.vMinSiblingLength=i;r=e}},t}();function I(t,e){let i=null;const r=t.vertices.length,s=.99619469809,o=h.create(),n=h.create(),c=h.create(),f=h.create(),x=h.create(),d=h.create(),m=l.create();let v=t.vertices[0];a.copy(n,e),a.set(o,0,1,0),p.makeOrthoBasisDirUpFallback(v.vRight,n,o,o,c,n,s),a.copy(v.frame.up,n),a.copy(v.frame.right,c),i=v;for(let h=1;h<r;++h){v=t.vertices[h],a.add(x,v.vLeft,v.vRight);let e=a.length(x);e>0?(e=1/Math.sqrt(e),x[0]=x[0]*e,x[1]=x[1]*e,x[2]=x[2]*e):(x[0]=v.vRight[0],x[1]=v.vRight[1],x[2]=v.vRight[2]),a.add(d,i.pos,i.frame.up),l.fromPositionAndNormal(v.pos,x,m);l.intersectRay(m,u.wrap(d,v.vLeft),f)?(a.subtract(f,f,v.pos),a.normalize(n,f),a.cross(c,x,n),a.normalize(c,c)):p.makeOrthoBasisDirUpFallback(x,i.frame.up,i.frame.right,o,c,n,s),a.copy(v.frame.up,n),a.copy(v.frame.right,c),i=v}}let N=function(){},S=function(){function t(){}var e=t.prototype;return e.numProfilesPerJoin=function(){return 1},e.extrude=function(t,e,i){for(let r=0;r<e.vertices.length;++r)i(t.index,t.frame,e.vertices[r],e.vertexNormals[r],!1)},t}(),R=function(){function t(t=.8*Math.PI,e=1){this.cutoffAngle=t,this.numBendSubdivisions=e}var e=t.prototype;return e.numProfilesPerJoin=function(){return this.numBendSubdivisions+1},e.extrude=function(t,e,i){const s=q;if(Math.abs(t.rotationAngle)>=this.cutoffAngle)for(let n=0;n<this.numBendSubdivisions+1;++n){r.fromRotation(Q,.5*-t.rotationAngle+n*t.rotationAngle/this.numBendSubdivisions,t.rotationFrameUp),g(s,t.frame,Q);for(let r=0;r<e.vertices.length;++r){o.dot(e.vertices[r],t.rotationRight)*t.rotationAngle>=0?i(t.index,s,e.vertices[r],e.vertexNormals[r],!1):(o.transformMat2(B,e.vertices[r],t.miterStretch),i(t.index,t.frame,B,e.vertexNormals[r],!0))}}else for(let r=0;r<this.numBendSubdivisions+1;++r)for(let s=0;s<e.vertices.length;++s){const r=o.dot(e.vertices[s],t.rotationRight)*t.rotationAngle>=0;o.transformMat2(B,e.vertices[s],t.miterStretch),i(t.index,t.frame,B,e.vertexNormals[s],!r)}},t}(),_=function(){function t(){}return t.prototype.rebuildConnectingProfileGeometry=function(t,e,i){for(let r=0;r<e.vertices.length;++r)i(t.index,t.frame,e.vertices[r],e.vertexNormals[r],0,0)},t}(),T=function(t){function i(){return t.call(this)||this}e._inheritsLoose(i,t);var r=i.prototype;return r.getNumVertices=function(){return 0},r.getNumIndices=function(){return 0},r.rebuildCapGeometry=function(){},r.buildTopology=function(){},i}(_),U=function(t){function i(e,i=0,r=!1){var s;return(s=t.call(this)||this).profile=e,s.profilePlaneOffset=i,s.flip=r,s}e._inheritsLoose(i,t);var r=i.prototype;return r.getNumVertices=function(){return this.profile.vertices.length},r.getNumIndices=function(){return 3*this.profile.numSegments},r.rebuildConnectingProfileGeometry=function(t,e,i){for(let r=0;r<e.vertices.length;++r)i(t.index,t.frame,e.vertices[r],e.vertexNormals[r],this.profilePlaneOffset,0)},r.rebuildCapGeometry=function(t,e){const i=E;o.set(i,0,0);const r=this.flip?1:-1;for(let s=0;s<this.profile.vertices.length;++s)e(t.index,t.frame,this.profile.vertices[s],i,this.profilePlaneOffset,r)},r.buildTopology=function(t,e){const i=this.vertexBufferStart+this.profile.vertexIndices[0];for(let r=1;r<this.profile.numSegments;++r){const t=this.profile.vertexIndices[2*r+0],s=this.profile.vertexIndices[2*r+1],o=this.vertexBufferStart+t,n=this.vertexBufferStart+s;this.flip?e(n,o,i):e(i,o,n)}},i}(_),L=function(t){function i(e){var i;return(i=t.call(this)||this).flip=!1,i.sign=0,i.breakNormals=!1,i.numSegments=3,i.profile=e.profile,i.flip=e.flip,i.sign=i.flip?1:-1,i.breakNormals=e.breakNormals,i.numSegments=e.subdivisions,i}e._inheritsLoose(i,t);var r=i.prototype;return r.getNumVertices=function(){let t=0;return t=this.profile.vertices.length*(this.numSegments-1),this.breakNormals&&(t+=this.profile.vertices.length),t+=this.profile.poles.length,t},r.getNumIndices=function(){let t=0;t+=2*this.profile.numSegments*(this.numSegments-1);for(let e=0;e<this.profile.numSegments;++e){const i=this.profile.vertexIndices[2*e+0],r=this.profile.vertexIndices[2*e+1];this.profile.poleIndices[i]===this.profile.poleIndices[r]?t+=1:t+=2}return 3*t},r.rebuildCapGeometry=function(t,e){const i=t.frame,r=.5*this.sign,s=B,n=E;o.set(n,0,0);for(let o=0;o<this.profile.poles.length;++o){const s=this.profile.poles[o];s.normal?e(t.index,i,s.position,s.normal,r,0):e(t.index,i,s.position,n,r,this.sign)}if(this.breakNormals)for(let o=0;o<this.profile.vertices.length;++o)e(t.index,i,this.profile.vertices[o],this.profile.vertexNormals[o],0,0);for(let a=0;a<this.numSegments-1;++a){const h=(1-(a+1)/this.numSegments)*Math.PI*.5,l=Math.sin(h),u=Math.cos(h);for(let a=0;a<this.profile.vertices.length;++a){const h=this.profile.poles[this.profile.poleIndices[a]];o.subtract(s,this.profile.vertices[a],h.position),o.scale(s,s,l),h.normal?(o.add(s,s,h.position),e(t.index,i,s,h.normal,r*u,0)):(o.normalize(n,s),o.scale(n,n,l),o.add(s,s,h.position),e(t.index,i,s,n,r*u,this.sign*u))}}},r.buildTopology=function(t,e){const i=this.breakNormals?this.vertexBufferStart+this.profile.poles.length:this.firstProfileVertexIndex,r=this.breakNormals?this.vertexBufferStart+this.profile.poles.length+this.profile.vertices.length:this.vertexBufferStart+this.profile.poles.length;for(let s=0;s<this.profile.numSegments;++s){const t=this.profile.vertexIndices[2*s+0],o=this.profile.vertexIndices[2*s+1],n=this.vertexBufferStart+this.profile.poleIndices[t],a=this.vertexBufferStart+this.profile.poleIndices[o];let h=i+t,l=i+o;for(let i=0;i<this.numSegments-1;++i){const s=r+i*this.profile.vertices.length+t,n=r+i*this.profile.vertices.length+o;this.flip?(e(s,l,h),e(l,s,n)):(e(h,l,s),e(n,s,l)),h=s,l=n}this.flip?(e(n,l,h),n!==a&&e(n,a,l)):(e(h,l,n),n!==a&&e(l,a,n))}},i}(_),M=function(){function t(t,e,i,r,s,o={}){this.options=o,this._extrusionVertexCount=0,this.numExtrusionProfiles=0,this.numVerticesTotal=0,this.numNormalsTotal=0,this.profile=e,this.path=t,this.extruder=i,this.startCap=r,this.endCap=s;const n=this.path.vertices.length-2;this.numExtrusionProfiles=i.numProfilesPerJoin()*n+2,this.numVerticesTotal=e.vertices.length*this.numExtrusionProfiles,this.numNormalsTotal=this.numVerticesTotal,this.startCap.vertexBufferStart=this.numVerticesTotal;const a=this.startCap.getNumVertices();this.numVerticesTotal+=a,this.numNormalsTotal+=a,this.endCap.vertexBufferStart=this.numVerticesTotal;const h=this.endCap.getNumVertices();this.numVerticesTotal+=h,this.numNormalsTotal+=h,this.pathVertexData=f.newFloatArray(1*this.numVerticesTotal),this.profileRightAxisData=f.newFloatArray(4*this.numVerticesTotal),this.profileUpAxisData=f.newFloatArray(4*this.numVerticesTotal),this.profileVertexAndNormalData=f.newFloatArray(4*this.numVerticesTotal),this.originData=f.newFloatArray(3*this.path.vertices.length),this._rebuildGeometry(),this.buildTopology()}var e=t.prototype;return e.emitVertex=function(t,e,i,r,s){if(this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=r[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=r[1],this.pathVertexData[this._extrusionVertexCount]=t,s){const e=this.path.vertices[t];this.profileRightAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[0]*e.maxStretchDistance,this.profileUpAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[1]*e.maxStretchDistance}else this.profileRightAxisData[4*this._extrusionVertexCount+3]=0,this.profileUpAxisData[4*this._extrusionVertexCount+3]=0;++this._extrusionVertexCount},e.emitCapVertex=function(t,e,i,r,s,o){this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=r[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=r[1],this.pathVertexData[this._extrusionVertexCount]=t,this.profileRightAxisData[4*this._extrusionVertexCount+3]=s,this.profileUpAxisData[4*this._extrusionVertexCount+3]=o,++this._extrusionVertexCount},e._rebuildGeometry=function(){const t=(t,e,i,r,s)=>this.emitVertex(t,e,i,r,s),e=(t,e,i,r,s,o)=>this.emitCapVertex(t,e,i,r,s,o);this._extrusionVertexCount=0;for(const i of this.path.vertices)this.originData[3*i.index+0]=i.pos[0],this.originData[3*i.index+1]=i.pos[1],this.originData[3*i.index+2]=i.pos[2];this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0],this.profile,e);for(let i=1;i<this.path.vertices.length-1;++i)this.extruder.extrude(this.path.vertices[i],this.profile,t);this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length-1],this.profile,e),this.startCap.rebuildCapGeometry(this.path.vertices[0],e),this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length-1],e)},e.buildTopology=function(){const t=this.profile.vertices.length,e=this.profile.numSegments,i=this.numExtrusionProfiles-1;let r=3*(2*(e*i));this.startCap.indexBufferStart=r,this.startCap.firstProfileVertexIndex=0,r+=this.startCap.getNumIndices(),this.endCap.indexBufferStart=r,this.endCap.firstProfileVertexIndex=t*(this.numExtrusionProfiles-1);const s=new Array,o=new Array,n=new Array,a=(t,e,i)=>{s.push(t),s.push(e),s.push(i),o.push(t),o.push(e),o.push(i),n.push(this.pathVertexData[t]),n.push(this.pathVertexData[e]),n.push(this.pathVertexData[i])};for(let h=0;h<e;++h){const e=this.profile.vertexIndices[2*h],r=this.profile.vertexIndices[2*h+1];for(let s=0;s<i;++s){const i=s*t+e,o=(s+1)*t+r,n=s*t+r;a(i,(s+1)*t+e,o),a(i,o,n)}}this.startCap.buildTopology(this.path.vertices[0],a),this.endCap.buildTopology(this.path.vertices[this.path.vertices.length-1],a),this.vertexIndices=x.compactIndices(s),this.normalIndices=x.compactIndices(o),this.pathVertexIndices=x.compactIndices(n)},e.onPathChanged=function(){this._rebuildGeometry()},t}(),O=function(){function t(t){this.builder=t}return t.prototype.onPathChanged=function(){this.builder.onPathChanged()},e._createClass(t,[{key:"xform",get:function(){return this.builder.path.xform}}]),t}(),k=function(t){function i(e){var i;return(i=t.call(this,e)||this).vertexAttributePosition=null,i.vertexAttributeNormal=null,i.vertexAttributeColor=null,i.vertexAttributePosition=f.newFloatArray(3*i.builder.numVerticesTotal),i.vertexAttributeNormal=f.newFloatArray(3*i.builder.numNormalsTotal),i.vertexAttributeColor=new Uint8Array(4),i.vertexAttributeColor[0]=255,i.vertexAttributeColor[1]=255,i.vertexAttributeColor[2]=255,i.vertexAttributeColor[3]=255,i}e._inheritsLoose(i,t);var r=i.prototype;return r.bakeVertexColors=function(t){this.vertexAttributeColor[0]=255*t[0],this.vertexAttributeColor[1]=255*t[1],this.vertexAttributeColor[2]=255*t[2],this.vertexAttributeColor[3]=255*(t.length>3?t[3]:1)},r.bake=function(t){this.size=t;for(let e=0;e<this.builder.numVerticesTotal;++e){let i=this.builder.pathVertexData[e];const r=0===i||i===this.builder.path.vertices.length-1;i*=3;const s=F;a.set(s,this.builder.originData[i++],this.builder.originData[i++],this.builder.originData[i]);const n=4*e,h=z,l=B,u=H,c=J,f=X;let p=0,x=0;if(a.set(c,this.builder.profileRightAxisData[n],this.builder.profileRightAxisData[n+1],this.builder.profileRightAxisData[n+2]),a.set(f,this.builder.profileUpAxisData[n],this.builder.profileUpAxisData[n+1],this.builder.profileUpAxisData[n+2]),o.set(l,this.builder.profileVertexAndNormalData[n]*t[0],this.builder.profileVertexAndNormalData[n+1]*t[1]),r)a.cross(u,f,c),p=this.builder.profileRightAxisData[n+3]*t[0],x=this.builder.profileUpAxisData[n+3];else{const t=E,e=G;o.set(t,this.builder.profileRightAxisData[n+3],this.builder.profileUpAxisData[n+3]);const i=o.length(t);o.normalize(t,t);const r=o.dot(l,t);if(Math.abs(r)>i){o.set(e,-t[1],t[0]);const s=o.dot(l,e);o.scale(t,t,i*Math.sign(r)),o.scale(e,e,s),o.add(l,t,e)}a.set(u,0,0,0)}a.set(h,c[0]*l[0]+f[0]*l[1],c[1]*l[0]+f[1]*l[1],c[2]*l[0]+f[2]*l[1]),this.vertexAttributePosition[3*e+0]=s[0]+h[0]+u[0]*p,this.vertexAttributePosition[3*e+1]=s[1]+h[1]+u[1]*p,this.vertexAttributePosition[3*e+2]=s[2]+h[2]+u[2]*p;const d=B;o.set(d,this.builder.profileVertexAndNormalData[n+2],this.builder.profileVertexAndNormalData[n+3]),this.vertexAttributeNormal[3*e+0]=c[0]*d[0]+f[0]*d[1]+u[0]*x,this.vertexAttributeNormal[3*e+1]=c[1]*d[0]+f[1]*d[1]+u[1]*x,this.vertexAttributeNormal[3*e+2]=c[2]*d[0]+f[2]*d[1]+u[2]*x}},r.createGeometryData=function(){const t=[[d.VertexAttribute.POSITION,this.builder.vertexIndices],[d.VertexAttribute.NORMAL,this.builder.normalIndices]],e=[[d.VertexAttribute.POSITION,new c.Attribute(this.vertexAttributePosition,3,!0)],[d.VertexAttribute.NORMAL,new c.Attribute(this.vertexAttributeNormal,3,!0)]];if(this.vertexAttributeColor){const i=this.builder.vertexIndices.length;t.push([d.VertexAttribute.COLOR,new Array(i).fill(0)]),e.push([d.VertexAttribute.COLOR,new c.Attribute(this.vertexAttributeColor,4)])}return{vertexAttributes:e,indices:t}},r.onPathChanged=function(){t.prototype.onPathChanged.call(this),this.bake(this.size)},r.intersect=function(t,e,i){const r=this.builder.vertexIndices,s=new c.Attribute(this.vertexAttributePosition,3),o=r.length/3;m.intersectTriangles(t,e,0,o,r,s,void 0,void 0,i)},i}(O),w=function(t){function i(e,i,r,s){var o;(o=t.call(this,e)||this).sizeAttributeValue=i,o.colorAttributeValue=r,o.opacityAttributeValue=s,o.vvData=null,o.baked=new k(e),o.vvData=f.newFloatArray(4*o.builder.path.vertices.length);for(let t=0;t<o.builder.path.vertices.length;++t){o.vvData[4*t+0]=i,o.vvData[4*t+1]=r,o.vvData[4*t+2]=s;const e=0===t||t===o.builder.path.vertices.length-1;o.vvData[4*t+3]=e?1:0}return o}return e._inheritsLoose(i,t),i.prototype.createGeometryData=function(){return{vertexAttributes:[[d.VertexAttribute.POSITION,new c.Attribute(this.builder.originData,3,!0)],[d.VertexAttribute.PROFILERIGHT,new c.Attribute(this.builder.profileRightAxisData,4,!0)],[d.VertexAttribute.PROFILEUP,new c.Attribute(this.builder.profileUpAxisData,4,!0)],[d.VertexAttribute.PROFILEVERTEXANDNORMAL,new c.Attribute(this.builder.profileVertexAndNormalData,4,!0)],[d.VertexAttribute.FEATUREVALUE,new c.Attribute(this.vvData,4,!0)]],indices:[[d.VertexAttribute.POSITION,this.builder.pathVertexIndices],[d.VertexAttribute.PROFILERIGHT,this.builder.vertexIndices],[d.VertexAttribute.PROFILEUP,this.builder.vertexIndices],[d.VertexAttribute.PROFILEVERTEXANDNORMAL,this.builder.vertexIndices],[d.VertexAttribute.FEATUREVALUE,this.builder.pathVertexIndices]]}},i}(O);const F=h.create(),B=n.create(),E=n.create(),G=n.create(),z=h.create(),H=h.create(),J=h.create(),X=h.create(),j=h.create(),q=v(),Q=s.create();t.Builder=M,t.CapBuilder=_,t.Extruder=N,t.FastUpdatePathGeometry=w,t.MiterExtruder=R,t.NoCapBuilder=T,t.Path=P,t.PathGeometryData=O,t.PathVertex=V,t.Profile=C,t.RoundCapBuilder=L,t.SimpleExtruder=S,t.StaticPathGeometry=k,t.TriangulationCapBuilder=U,t.computeMinimumRotationTangentFrame=I,t.creatQuadProfile=y,t.createCircleProfile=D,t.makeFrame=v,t.profileSpaceToVertexSpace=b,t.vertexSpaceToProfileSpace=A,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
