/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["../../../../chunks/_rollupPluginBabelHelpers","../../../../core/mathUtils","../../../../chunks/vec3f64","../../../../chunks/vec3","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec2f64","../../../../chunks/vec2","../../support/geometryUtils","./Util","./GeometryData","./GeometryUtil","../materials/internal/MaterialUtil","../../../../chunks/mat2","../../../../chunks/mat2f64","../materials/PathTechnique"],(function(t,e,i,r,s,o,n,a,h,l,u,c,f,p,d,x){"use strict";var m;!function(m){function N(){return{up:i.create(),right:i.create()}}m.makeFrame=N,m.profileSpaceToVertexSpace=function(t,e,i){t[0]=i[0]*e.right[0]+i[1]*e.up[0],t[1]=i[0]*e.right[1]+i[1]*e.up[1],t[2]=i[0]*e.right[2]+i[1]*e.up[2]},m.vertexSpaceToProfileSpace=function(t,e,i){a.set(t,r.dot(i,e.right),r.dot(i,e.up))};let S=function(){function t(){this.pos=i.create(),this.posES=i.create(),this.posGS=i.create(),this.vRight=i.create(),this.vLeft=i.create(),this.frame=N(),this.rotationFrame=N(),this.rotationRight=n.create(),this.rotationAngle=0,this.miterStretch=d.create()}var s=t.prototype;return s.setFrameFromUpVector=function(t){r.copy(this.frame.up,t),r.add(C,this.vLeft,this.vRight),r.normalize(C,C),r.scale(b,this.frame.up,r.dot(C,this.frame.up)),r.subtract(P,C,b),r.normalize(P,P),r.cross(this.frame.right,P,this.frame.up)},s.computeRotationAxisAndAngleFromUpVector=function(){r.copy(this.rotationFrame.up,this.frame.up),r.copy(this.rotationFrame.right,this.frame.right),a.set(this.rotationRight,1,0),r.scale(b,this.frame.up,r.dot(this.frame.up,this.vLeft)),r.subtract(b,this.vLeft,b),r.negate(b,b),r.normalize(b,b),r.scale(C,this.frame.up,r.dot(this.frame.up,this.vRight)),r.subtract(C,this.vRight,C),r.normalize(C,C),r.cross(D,this.rotationFrame.up,this.vLeft);const t=e.sign(r.dot(D,this.vRight));if(this.rotationAngle=t*(Math.PI-e.acosClamped(r.dot(b,C))),Math.abs(this.rotationAngle)>0){const t=e.reciprocalClamped(Math.cos(.5*this.rotationAngle));p.set(this.miterStretch,t-1+1,0,0,1)}const i=Math.PI-this.rotationAngle;this.maxStretchDistance=Math.abs(Math.min(this.vLeftLength,this.vRightLength)/Math.cos(.5*i))},t}();m.PathVertex=S;let U=function(){function e(){this.vertices=[],this.vertexIndices=[],this.vertexNormals=[],this.poles=[],this.poleIndices=[],this.uvs=null,this.uvIndices=null}var i=e.prototype;return i.addVertex=function(t,e){return this.vertices.push(n.clone(t)),this.vertexNormals.push(n.clone(e)),this.vertices.length-1},i.addUV=function(t){return this.uvs||(this.uvs=[],this.uvIndices=[]),this.uvs.push(t),this.uvs.length-1},i.addPole=function(t,e=null){return this.poles.push({position:n.clone(t),normal:e?n.clone(e):null}),this.poles.length-1},i.addSegment=function(t,e=null,i=null){this.vertexIndices.push(t.v0),this.vertexIndices.push(t.v1),e&&(this.uvIndices.push(e.v0),this.uvIndices.push(e.v1)),i&&(this.poleIndices.push(i.v0),this.poleIndices.push(i.v1))},i.hasUV=function(){return null!=this.uvs},i.translate=function(t,e){for(const i of this.vertices)i[0]+=t,i[1]+=e;for(const i of this.poles)i.position[0]+=t,i.position[1]+=e},e.circle=function(t=20){const i=new e,r={v0:0,v1:0};i.addPole(n.fromValues(0,0));for(let e=0;e<t;++e){const r=2*e*Math.PI/t,s=Math.cos(r),o=Math.sin(r),a=n.fromValues(.5*s,.5*o),h=n.fromValues(s,o);i.addVertex(a,h),i.addUV(e/t)}i.addUV(1);for(let e=0;e<t-1;++e){const t={v0:e,v1:e+1},s=t;i.addSegment(t,s,r)}const s={v0:t-1,v1:0},o={v0:t-1,v1:t};return i.addSegment(s,o,r),i},e.rect=function(){const t=new e,i=n.fromValues(-.5,-.5),r=n.fromValues(.5,-.5),s=n.fromValues(.5,.5),o=n.fromValues(-.5,.5),a=n.fromValues(0,-1),h=n.fromValues(1,0),l=n.fromValues(0,1),u=n.fromValues(-1,0);t.addUV(0),t.addUV(1),t.addPole(n.fromValues(0,.5),l),t.addPole(n.fromValues(0,.5)),t.addPole(n.fromValues(0,-.5)),t.addPole(n.fromValues(0,-.5),a);const c={v0:0,v1:1};return t.addVertex(i,a),t.addVertex(r,a),t.addSegment({v0:0,v1:1},c,{v0:3,v1:3}),t.addVertex(r,h),t.addVertex(s,h),t.addSegment({v0:2,v1:3},c,{v0:2,v1:1}),t.addVertex(s,l),t.addVertex(o,l),t.addSegment({v0:4,v1:5},c,{v0:0,v1:0}),t.addVertex(o,u),t.addVertex(i,u),t.addSegment({v0:6,v1:7},c,{v0:1,v1:2}),t},t._createClass(e,[{key:"numSegments",get:function(){return this.vertexIndices.length/2}}]),e}();m.Profile=U;let _=function(){function t(t){this.vertices=[],this.offset=i.create(),this.xform=o.create(),this.vertices=t;const e=Math.floor((t.length-1)/2);r.copy(this.offset,this.vertices[e].pos);for(const t of this.vertices)r.subtract(t.pos,t.pos,this.offset);s.translate(this.xform,this.xform,this.offset),this.updatePathVertexInformation()}return t.prototype.updatePathVertexInformation=function(){const t=this.vertices.length;let e=this.vertices[0];e.index=0,r.set(e.vLeft,0,0,0),e.vLeftLength=0,r.subtract(e.vRight,this.vertices[1].pos,e.pos),e.vRightLength=r.length(e.vRight),r.normalize(e.vRight,e.vRight);let i=e;for(let s=1;s<t;++s)e=this.vertices[s],e.index=s,r.copy(e.vLeft,i.vRight),e.vLeftLength=i.vRightLength,s<t-1?(r.subtract(e.vRight,this.vertices[s+1].pos,e.pos),e.vRightLength=r.length(e.vRight),r.normalize(e.vRight,e.vRight)):(r.copy(e.vRight,e.vLeft),e.vRightLength=e.vLeftLength),i=e},t}();m.Path=_,m.computeMinimumRotationTangentFrame=function(t,e){let s=null;const o=t.vertices.length,n=.99619469809,a=i.create(),l=i.create(),u=i.create(),f=i.create(),p=i.create(),d=i.create(),x=h.plane.create();let m=t.vertices[0];r.copy(l,e),r.set(a,0,1,0),c.makeOrthoBasisDirUpFallback(m.vRight,l,a,a,u,l,n),r.copy(m.frame.up,l),r.copy(m.frame.right,u),s=m;for(let e=1;e<o;++e){m=t.vertices[e],r.add(p,m.vLeft,m.vRight);let i=r.length(p);i>0?(i=1/Math.sqrt(i),p[0]=p[0]*i,p[1]=p[1]*i,p[2]=p[2]*i):(p[0]=m.vRight[0],p[1]=m.vRight[1],p[2]=m.vRight[2]),r.add(d,s.pos,s.frame.up),h.plane.fromPositionAndNormal(m.pos,p,x);h.plane.intersectRay(x,h.ray.wrap(d,m.vLeft),f)?(r.subtract(f,f,m.pos),r.normalize(l,f),r.cross(u,p,l),r.normalize(u,u)):c.makeOrthoBasisDirUpFallback(p,s.frame.up,s.frame.right,a,u,l,n),r.copy(m.frame.up,l),r.copy(m.frame.right,u),s=m}};m.Extruder=function(){};let T=function(){function t(){}var e=t.prototype;return e.numProfilesPerJoin=function(){return 1},e.extrude=function(t,e,i){for(let r=0;r<e.vertices.length;++r)i(t.index,t.frame,e.vertices[r],e.vertexNormals[r],!1)},t}();m.SimpleExtruder=T;let L=function(){function t(t=.8*Math.PI,e=1){this.cutoffAngle=t,this.numBendSubdivisions=e}var e=t.prototype;return e.numProfilesPerJoin=function(){return this.numBendSubdivisions+1},e.extrude=function(t,e,i){const o=y;if(Math.abs(t.rotationAngle)>=this.cutoffAngle)for(let u=0;u<this.numBendSubdivisions+1;++u){s.identity(R),s.rotate(R,R,.5*-t.rotationAngle+u*t.rotationAngle/this.numBendSubdivisions,t.rotationFrame.up),n=o,h=t.frame,l=R,r.transformMat4(n.up,h.up,l),r.transformMat4(n.right,h.right,l);for(let r=0;r<e.vertices.length;++r){a.dot(e.vertices[r],t.rotationRight)*t.rotationAngle>=0?i(t.index,o,e.vertices[r],e.vertexNormals[r],!1):(a.transformMat2(g,e.vertices[r],t.miterStretch),i(t.index,t.frame,g,e.vertexNormals[r],!0))}}else for(let r=0;r<this.numBendSubdivisions+1;++r)for(let r=0;r<e.vertices.length;++r){const s=a.dot(e.vertices[r],t.rotationRight)*t.rotationAngle>=0;a.transformMat2(g,e.vertices[r],t.miterStretch),i(t.index,t.frame,g,e.vertexNormals[r],!s)}var n,h,l},t}();m.MiterExtruder=L;const F={generateUV:!1};let M=function(){function t(){}return t.prototype.rebuildConnectingProfileGeometry=function(t,e,i){for(let r=0;r<e.vertices.length;++r)i(t.index,t.frame,e.vertices[r],e.vertexNormals[r],0,0)},t}();m.CapBuilder=M;let O=function(e){function i(){return e.call(this)||this}t._inheritsLoose(i,e);var r=i.prototype;return r.getNumVertices=function(){return 0},r.getNumIndices=function(){return 0},r.rebuildCapGeometry=function(){},r.buildTopology=function(){},i}(M);m.NoCapBuilder=O;let k=function(e){function i(t,i=0,r=!1){var s;return(s=e.call(this)||this).profile=t,s.profilePlaneOffset=i,s.flip=r,s}t._inheritsLoose(i,e);var r=i.prototype;return r.getNumVertices=function(){return this.profile.vertices.length},r.getNumIndices=function(){return 3*this.profile.numSegments},r.rebuildConnectingProfileGeometry=function(t,e,i){for(let r=0;r<e.vertices.length;++r)i(t.index,t.frame,e.vertices[r],e.vertexNormals[r],this.profilePlaneOffset,0)},r.rebuildCapGeometry=function(t,e){const i=V;a.set(i,0,0);const r=this.flip?1:-1;for(let s=0;s<this.profile.vertices.length;++s)e(t.index,t.frame,this.profile.vertices[s],i,this.profilePlaneOffset,r)},r.buildTopology=function(t,e){const i=this.vertexBufferStart+this.profile.vertexIndices[0];for(let t=1;t<this.profile.numSegments;++t){const r=this.profile.vertexIndices[2*t+0],s=this.profile.vertexIndices[2*t+1],o=this.vertexBufferStart+r,n=this.vertexBufferStart+s;this.flip?e(n,o,i):e(i,o,n)}},i}(M);m.TriangulationCapBuilder=k;let B=function(e){function i(t){var i;return(i=e.call(this)||this).flip=!1,i.sign=0,i.breakNormals=!1,i.numSegments=3,i.profile=t.profile,i.flip=t.flip,i.sign=i.flip?1:-1,i.breakNormals=t.breakNormals,i.numSegments=t.subdivisions,i}t._inheritsLoose(i,e);var r=i.prototype;return r.getNumVertices=function(){let t=0;return t=this.profile.vertices.length*(this.numSegments-1),this.breakNormals&&(t+=this.profile.vertices.length),t+=this.profile.poles.length,t},r.getNumIndices=function(){let t=0;t+=2*this.profile.numSegments*(this.numSegments-1);for(let e=0;e<this.profile.numSegments;++e){const i=this.profile.vertexIndices[2*e+0],r=this.profile.vertexIndices[2*e+1];this.profile.poleIndices[i]===this.profile.poleIndices[r]?t+=1:t+=2}return 3*t},r.rebuildCapGeometry=function(t,e){const i=t.frame,r=.5*this.sign,s=g,o=V;a.set(o,0,0);for(let s=0;s<this.profile.poles.length;++s){const n=this.profile.poles[s];n.normal?e(t.index,i,n.position,n.normal,r,0):e(t.index,i,n.position,o,r,this.sign)}if(this.breakNormals)for(let r=0;r<this.profile.vertices.length;++r)e(t.index,i,this.profile.vertices[r],this.profile.vertexNormals[r],0,0);for(let n=0;n<this.numSegments-1;++n){const h=(1-(n+1)/this.numSegments)*Math.PI*.5,l=Math.sin(h),u=Math.cos(h);for(let n=0;n<this.profile.vertices.length;++n){const h=this.profile.poles[this.profile.poleIndices[n]];a.subtract(s,this.profile.vertices[n],h.position),a.scale(s,s,l),h.normal?(a.add(s,s,h.position),e(t.index,i,s,h.normal,r*u,0)):(a.normalize(o,s),a.scale(o,o,l),a.add(s,s,h.position),e(t.index,i,s,o,r*u,this.sign*u))}}},r.buildTopology=function(t,e){const i=this.breakNormals?this.vertexBufferStart+this.profile.poles.length:this.firstProfileVertexIndex,r=this.breakNormals?this.vertexBufferStart+this.profile.poles.length+this.profile.vertices.length:this.vertexBufferStart+this.profile.poles.length;for(let t=0;t<this.profile.numSegments;++t){const s=this.profile.vertexIndices[2*t+0],o=this.profile.vertexIndices[2*t+1],n=this.vertexBufferStart+this.profile.poleIndices[s],a=this.vertexBufferStart+this.profile.poleIndices[o];let h=i+s,l=i+o;for(let t=0;t<this.numSegments-1;++t){const i=r+t*this.profile.vertices.length+s,n=r+t*this.profile.vertices.length+o;this.flip?(e(i,l,h),e(l,i,n)):(e(h,l,i),e(n,i,l)),h=i,l=n}this.flip?(e(n,l,h),n!==a&&e(n,a,l)):(e(h,l,n),n!==a&&e(l,a,n))}},i}(M);m.RoundCapBuilder=B;let E=function(){function t(t,e,i,r,s,o=F){this.options=o,this._extrusionVertexCount=0,this._triangleCount=0,this.numExtrusionProfiles=0,this.numVerticesTotal=0,this.numNormalsTotal=0,this.numUVTotal=0,this.profile=e,this.path=t,this.extruder=i,this.startCap=r,this.endCap=s;const n=this.path.vertices.length-2;this.numExtrusionProfiles=i.numProfilesPerJoin()*n+2,this.numVerticesTotal=e.vertices.length*this.numExtrusionProfiles,this.numNormalsTotal=this.numVerticesTotal,this.startCap.vertexBufferStart=this.numVerticesTotal;const a=this.startCap.getNumVertices();this.numVerticesTotal+=a,this.numNormalsTotal+=a,this.endCap.vertexBufferStart=this.numVerticesTotal;const h=this.endCap.getNumVertices();this.numVerticesTotal+=h,this.numNormalsTotal+=h,this.pathVertexData=new Float32Array(1*this.numVerticesTotal),this.profileRightAxisData=new Float32Array(4*this.numVerticesTotal),this.profileUpAxisData=new Float32Array(4*this.numVerticesTotal),this.profileVertexAndNormalData=new Float32Array(4*this.numVerticesTotal),this.profile.hasUV()&&this.options.generateUV&&(this.numUVTotal=this.profile.uvs.length,this.uvData=new Float32Array(2*this.numUVTotal)),this.originData=new Float32Array(3*this.path.vertices.length),this.rebuildGeometry(),this.buildTopology()}var e=t.prototype;return e.emitVertex=function(t,e,i,r,s){if(this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=r[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=r[1],this.pathVertexData[this._extrusionVertexCount]=t,s){const e=this.path.vertices[t];this.profileRightAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[0]*e.maxStretchDistance,this.profileUpAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[1]*e.maxStretchDistance}else this.profileRightAxisData[4*this._extrusionVertexCount+3]=0,this.profileUpAxisData[4*this._extrusionVertexCount+3]=0;++this._extrusionVertexCount},e.emitCapVertex=function(t,e,i,r,s,o){this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=r[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=r[1],this.pathVertexData[this._extrusionVertexCount]=t,this.profileRightAxisData[4*this._extrusionVertexCount+3]=s,this.profileUpAxisData[4*this._extrusionVertexCount+3]=o,++this._extrusionVertexCount},e.emitTriangle=function(t,e,i){this.vertexIndices[3*this._triangleCount+0]=t,this.vertexIndices[3*this._triangleCount+1]=e,this.vertexIndices[3*this._triangleCount+2]=i,this.pathVertexIndices[3*this._triangleCount+0]=this.pathVertexData[t],this.pathVertexIndices[3*this._triangleCount+1]=this.pathVertexData[e],this.pathVertexIndices[3*this._triangleCount+2]=this.pathVertexData[i],this.normalIndices[3*this._triangleCount+0]=t,this.normalIndices[3*this._triangleCount+1]=e,this.normalIndices[3*this._triangleCount+2]=i,++this._triangleCount},e.rebuildGeometry=function(){const t=(t,e,i,r,s)=>this.emitVertex(t,e,i,r,s),e=(t,e,i,r,s,o)=>this.emitCapVertex(t,e,i,r,s,o);this._extrusionVertexCount=0;for(const t of this.path.vertices)this.originData[3*t.index+0]=t.pos[0],this.originData[3*t.index+1]=t.pos[1],this.originData[3*t.index+2]=t.pos[2];this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0],this.profile,e);for(let e=1;e<this.path.vertices.length-1;++e)this.extruder.extrude(this.path.vertices[e],this.profile,t);if(this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length-1],this.profile,e),this.startCap.rebuildCapGeometry(this.path.vertices[0],e),this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length-1],e),this.profile.hasUV()&&this.options.generateUV)for(let t=0;t<this.profile.uvs.length;++t)this.uvData[2*t+0]=this.profile.uvs[t],this.uvData[2*t+1]=0},e.buildTopology=function(){const t=(t,e,i)=>this.emitTriangle(t,e,i);this._triangleCount=0;const e=this.profile.vertices.length,i=this.profile.numSegments,r=this.numExtrusionProfiles-1;let s=3*(2*(i*r));this.startCap.indexBufferStart=s,this.startCap.firstProfileVertexIndex=0,s+=this.startCap.getNumIndices(),this.endCap.indexBufferStart=s,this.endCap.firstProfileVertexIndex=e*(this.numExtrusionProfiles-1),s+=this.endCap.getNumIndices(),this.vertexIndices=new Uint32Array(s),this.normalIndices=new Uint32Array(s),this.pathVertexIndices=new Uint32Array(s),this.profile.hasUV()&&this.options.generateUV&&(this.uvIndices=new Uint32Array(s));for(let s=0;s<i;++s){const i=this.profile.vertexIndices[2*s],o=this.profile.vertexIndices[2*s+1];for(let s=0;s<r;++s){const r=s*e+i,n=(s+1)*e+o,a=s*e+o;t(r,(s+1)*e+i,n),t(r,n,a)}}this.startCap.buildTopology(this.path.vertices[0],t),this.endCap.buildTopology(this.path.vertices[this.path.vertices.length-1],t)},e.onPathChanged=function(){this.rebuildGeometry()},t}();m.Builder=E;let G=function(){function e(t){this.builder=t}return e.prototype.onPathChanged=function(){this.builder.onPathChanged()},t._createClass(e,[{key:"xform",get:function(){return this.builder.path.xform}}]),e}();m.PathGeometry=G;let z=function(i){function s(t){var e;return(e=i.call(this,t)||this).vertexAttributePosition=null,e.vertexAttributeNormal=null,e.vertexAttributeColor=null,e.vertexAttributePosition=new Float32Array(3*e.builder.numVerticesTotal),e.vertexAttributeNormal=new Float32Array(3*e.builder.numNormalsTotal),e.vertexAttributeColor=new Uint8Array(4),e.vertexAttributeColor[0]=255,e.vertexAttributeColor[1]=255,e.vertexAttributeColor[2]=255,e.vertexAttributeColor[3]=255,e}t._inheritsLoose(s,i);var o=s.prototype;return o.bakeVertexColors=function(t){this.vertexAttributeColor[0]=255*t[0],this.vertexAttributeColor[1]=255*t[1],this.vertexAttributeColor[2]=255*t[2],this.vertexAttributeColor[3]=255*(t.length>3?t[3]:1)},o.bake=function(t){this.size=t;for(let i=0;i<this.builder.numVerticesTotal;++i){const s=this.builder.pathVertexData[i],o=0===s||s===this.builder.path.vertices.length-1,n=v;r.set(n,this.builder.originData[3*s+0],this.builder.originData[3*s+1],this.builder.originData[3*s+2]);const h=b,l=g,u=C,c=D,f=I;let p=0,d=0;if(r.set(c,this.builder.profileRightAxisData[4*i+0],this.builder.profileRightAxisData[4*i+1],this.builder.profileRightAxisData[4*i+2]),r.set(f,this.builder.profileUpAxisData[4*i+0],this.builder.profileUpAxisData[4*i+1],this.builder.profileUpAxisData[4*i+2]),a.set(l,this.builder.profileVertexAndNormalData[4*i+0]*t[0],this.builder.profileVertexAndNormalData[4*i+1]*t[1]),o)r.cross(u,f,c),p=this.builder.profileRightAxisData[4*i+3]*t[0],d=this.builder.profileUpAxisData[4*i+3];else{const t=V,s=A;a.set(t,this.builder.profileRightAxisData[4*i+3],this.builder.profileUpAxisData[4*i+3]);const o=a.length(t);a.normalize(t,t);const n=a.dot(l,t);if(Math.abs(n)>o){a.set(s,-t[1],t[0]);const i=a.dot(l,s);a.scale(t,t,o*e.sign(n)),a.scale(s,s,i),a.add(l,t,s)}r.set(u,0,0,0)}r.set(h,c[0]*l[0]+f[0]*l[1],c[1]*l[0]+f[1]*l[1],c[2]*l[0]+f[2]*l[1]),this.vertexAttributePosition[3*i+0]=n[0]+h[0]+u[0]*p,this.vertexAttributePosition[3*i+1]=n[1]+h[1]+u[1]*p,this.vertexAttributePosition[3*i+2]=n[2]+h[2]+u[2]*p;const x=g;a.set(x,this.builder.profileVertexAndNormalData[4*i+2],this.builder.profileVertexAndNormalData[4*i+3]),this.vertexAttributeNormal[3*i+0]=c[0]*x[0]+f[0]*x[1]+u[0]*d,this.vertexAttributeNormal[3*i+1]=c[1]*x[0]+f[1]*x[1]+u[1]*d,this.vertexAttributeNormal[3*i+2]=c[2]*x[0]+f[2]*x[1]+u[2]*d}},o.createGeometryData=function(){const t={};if(t[l.VertexAttrConstants.POSITION]=this.builder.vertexIndices,t[l.VertexAttrConstants.NORMAL]=this.builder.normalIndices,this.vertexAttributeColor){const e=t[l.VertexAttrConstants.POSITION].length;t[l.VertexAttrConstants.COLOR]=new Uint32Array(e)}const e={};return e[l.VertexAttrConstants.POSITION]={size:3,data:this.vertexAttributePosition},e[l.VertexAttrConstants.NORMAL]={size:3,data:this.vertexAttributeNormal},this.vertexAttributeColor&&(e[l.VertexAttrConstants.COLOR]={size:4,data:this.vertexAttributeColor}),new u.GeometryData(e,t,"triangle")},o.onPathChanged=function(){i.prototype.onPathChanged.call(this),this.bake(this.size)},o.intersect=function(t,e,i){const r=this.builder.vertexIndices,s={size:3,offsetIdx:0,strideIdx:3,data:this.vertexAttributePosition},o=r.length/3;f.intersectTriangles(t,e,0,o,r,s,void 0,void 0,i)},s}(G);m.StaticPathGeometry=z;let w=function(e){function i(t,i,r,s){var o;(o=e.call(this,t)||this).sizeAttributeValue=i,o.colorAttributeValue=r,o.opacityAttributeValue=s,o.vvData=null,o.baked=new z(t),o.vvData=new Float32Array(4*o.builder.path.vertices.length);for(let t=0;t<o.builder.path.vertices.length;++t){o.vvData[4*t+0]=i,o.vvData[4*t+1]=r,o.vvData[4*t+2]=s;const e=0===t||t===o.builder.path.vertices.length-1;o.vvData[4*t+3]=e?1:0}return o}return t._inheritsLoose(i,e),i.prototype.createGeometryData=function(){const t={};t[x.PathVertexAttrConstants.POSITION]=this.builder.pathVertexIndices,t[x.PathVertexAttrConstants.PROFILERIGHT]=this.builder.vertexIndices,t[x.PathVertexAttrConstants.PROFILEUP]=this.builder.vertexIndices,t[x.PathVertexAttrConstants.PROFILEVERTEXANDNORMAL]=this.builder.vertexIndices,t[x.PathVertexAttrConstants.FEATUREVALUE]=this.builder.pathVertexIndices;const e={};return e[x.PathVertexAttrConstants.POSITION]={size:3,data:this.builder.originData},e[x.PathVertexAttrConstants.PROFILERIGHT]={size:4,data:this.builder.profileRightAxisData},e[x.PathVertexAttrConstants.PROFILEUP]={size:4,data:this.builder.profileUpAxisData},e[x.PathVertexAttrConstants.PROFILEVERTEXANDNORMAL]={size:4,data:this.builder.profileVertexAndNormalData},e[x.PathVertexAttrConstants.FEATUREVALUE]={size:4,data:this.vvData},new u.GeometryData(e,t,"triangle")},i}(G);m.FastUpdatePathGeometry=w}(m||(m={}));const v=i.create(),g=n.create(),V=n.create(),A=n.create(),b=i.create(),C=i.create(),D=i.create(),I=i.create(),P=i.create(),y=m.makeFrame(),R=o.create();return m}));
