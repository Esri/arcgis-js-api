/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import t from"../../../../../core/Accessor.js";import{equals as r}from"../../../../../core/arrayUtils.js";import s from"../../../../../core/Logger.js";import{clamp as o}from"../../../../../core/mathUtils.js";import{disposeMaybe as n,destroyMaybe as i,isNone as a,isSome as c}from"../../../../../core/maybe.js";import{createAbortError as d}from"../../../../../core/promiseUtils.js";import{property as l}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as m}from"../../../../../core/accessorSupport/decorators/subclass.js";import{f as g,t as u,e as h}from"../../../../../chunks/mat3.js";import{c as p}from"../../../../../chunks/mat3f64.js";import{I as f,c as b}from"../../../../../chunks/mat4f64.js";import{s as y,c as j,v as O,e as v}from"../../../../../chunks/vec3.js";import{c as w}from"../../../../../chunks/vec3f64.js";import{WatchUpdatingTracking as E}from"../../../../../core/support/WatchUpdatingTracking.js";import{g as R,d as x}from"../../../../../chunks/sphere.js";import{c as T}from"../../../../../chunks/vec33.js";import{ViewingMode as _}from"../../../../ViewingMode.js";import{encodeElevationOffset as M}from"../../collections/Component/Material/shader/ComponentData.glsl.js";import{TwoVectorPosition as C}from"../../core/util/TwoVectorPosition.js";import{GridLocalOriginFactory as D}from"../GridLocalOriginFactory.js";import{applyToModelMatrix as P}from"../localOriginHelper.js";import{LocalOriginManager as S}from"../LocalOriginManager.js";import{Object3D as A}from"../Object3D.js";import{VertexAttribute as k}from"../VertexAttribute.js";import{VertexLayout as B,EdgeShaderAttributeLocations as I,glVertexLayout as U,EdgeInputBufferLayout as L}from"./bufferLayouts.js";import{RegularEdgeBufferWriter as V,SilhouetteEdgeBufferWriter as N}from"./edgeBufferWriters.js";import{EdgeType as H}from"./edgePreprocessing.js";import{EdgeRenderer as z,LINE_WIDTH_FRACTION_FACTOR as W,EXTENSION_LENGTH_OFFSET as q}from"./EdgeRenderer.js";import{EdgePassParameters as G}from"./EdgeShaderParameters.js";import K from"./EdgeWorkerHandle.js";import{Transparency as F}from"./interfaces.js";import{generateStrokesTexture as Q}from"./strokes.js";import{determineRendererType as J,determineEdgeTransparency as X,determineObjectTransparency as Y,fillComponenBufferIndices as Z,computeEdgeCount as $}from"./util.js";import{BufferManager as ee}from"../TextureBackedBuffer/BufferManager.js";import{BufferObject as te}from"../../../../webgl/BufferObject.js";import{Usage as re}from"../../../../webgl/enums.js";import{VertexArrayObject as se}from"../../../../webgl/VertexArrayObject.js";const oe=s.getLogger("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView");let ne=class extends t{constructor(e){super(e),this.updatingHandles=new E,this.perObjectData=new Map,this.perObjectDataEvictionCache=new Set,this.renderers=new Map,this.numberOfRenderedEdges={[F.TRANSPARENT]:0,[F.OPAQUE]:0},this.gpuMemoryUsage=0,this.workerAbort=new AbortController,this.tmpModelPosition=w(),this.localOrigins=new S(new D(e.renderSR))}initialize(){this.worker=new K(this.schedule),this.componentColorManager=new ee(this.rctx,3);const e=B.createBuffer(4);for(let t=0;t<4;t++)e.sideness.set(t,0,0===t||3===t?0:1),e.sideness.set(t,1,0===t||1===t?0:1);this.verticesBufferObject=te.createVertex(this.rctx,re.STATIC_DRAW,e.buffer)}destroy(){this.destroyed||(this.perObjectData.forEach((e=>this._discardObjectEntry(e))),this.perObjectData.clear(),this.strokesTexture=n(this.strokesTexture),this.componentColorManager=i(this.componentColorManager),this.workerAbort.abort(),this.worker.destroy(),this.verticesBufferObject=n(this.verticesBufferObject),this.renderers.clear(),this.updatingHandles.destroy())}get updating(){return this.updatingHandles.updating}get usedMemory(){return this.gpuMemoryUsage}get numberOfRenderedPrimitives(){return this.numberOfRenderedEdges[F.TRANSPARENT]+this.numberOfRenderedEdges[F.OPAQUE]}shouldRender(){return this.renderers.size>0}async addComponentObject(e,t,r,s,o,n,i,a){if(this.hasObject(e))return this.getObjectMemoryUsage(e);let c;const d=new ce(new Promise((e=>c=e)),r.center,r.radius);this.perObjectData.set(e,d);const l=await this.updatingHandles.addPromise(this._addComponentGeometry(t,d,s,o,n,i,a));return this.setNeedsRender(),c(),l}async addOrUpdateObject3D(e,t,r,s){if(this.destroyed)return void oe.warn("Attempt to add an object to a destroyed instance");const o=this.perObjectData.get(e);let n;o?.renderables.length>0&&this.perObjectDataEvictionCache.add(o);const i=e.boundingVolumeWorldSpace.bounds,a=new ce(new Promise((e=>n=e)),R(i),x(i));this.perObjectData.set(e,a);const c=new Array;if(r.mergeGeometries&&e.geometries.length>1&&ae(e))c.push(this._addObjectMergedGeometries(e,a,t,r,s));else for(let d=0;d<e.geometries.length;d++){const o=e.geometryRecords[d];if(!o.material.supportsEdges)continue;const n=e.geometries[d];c.push(this._addGeometry(e,a,n,o,t[0],r,s))}await this.updatingHandles.addPromise(Promise.all(c)),this.perObjectDataEvictionCache.delete(a),this._discardObjectEntry(o),this.setNeedsRender(),n()}_discardObjectEntry(e){e&&(e.renderables.length&&(e.renderables.forEach((e=>this._removeRenderable(e))),this.setNeedsRender()),e.loaded=null)}hasObject(e){return this.perObjectData.has(e)}async updateAllComponentOpacities(e,t){const r=t instanceof Array?e=>t[e]:()=>t;(await this.updatingHandles.addPromise(this._getObjectEntry(e))).renderables.forEach((e=>{const t=e.components.meta.length;for(let s=0;s<t;s++){const t=r(s),o=e.components.meta[s],n=o.index;o.material.opacity=t,e.components.buffer.textureBuffer.setDataElement(n,1,3,255*t)}this._updateTransparency(e)})),this.setNeedsRender()}async getObjectMemoryUsage(e){return(await this._getObjectEntry(e)).renderables.reduce(((e,t)=>e+t.statistics.gpuMemoryUsage),0)}async updateAllComponentMaterials(e,t,r,s){const o=e instanceof A,n=!!r.hasSlicePlane,i=J(t),a=z.getKey(i,n,o);(await this.updatingHandles.addPromise(this._getObjectEntry(e))).renderables.forEach((e=>{if(a!==e.rendererKey){const t=this.renderers.get(e.rendererKey),r=this._acquireRenderer(i,n,o);t.removeRenderable(e),t.refCount.decrement(),e.rendererKey=a,r.addRenderable(e)}for(let r=0;r<t.length;r++)e.components.meta[r].material=t[r];s&&this._updateComponentBuffer(e.components),this._updateTransparency(e)})),this.setNeedsRender()}async updateAllVerticalOffsets(e,t){(await this.updatingHandles.addPromise(this._getObjectEntry(e))).renderables.forEach((e=>{const r=e.components.meta;for(let s=0;s<r.length;s++)e.components.meta[s].verticalOffset=t?.[s]??0;this._updateComponentBuffer(e.components)})),this.setNeedsRender()}async updateObjectVisibility(e,t){(await this.updatingHandles.addPromise(this._getObjectEntry(e))).renderables.forEach((e=>e.visible=t)),this.setNeedsRender()}removeObject(e){const t=this.perObjectData.get(e);t&&(this.perObjectData.delete(e),this._discardObjectEntry(t))}async _getObjectEntry(e){const t=this.perObjectData.get(e);if(!t)throw"no object";if(await t.loaded,null==t.loaded)throw d();return t}removeAll(){this.perObjectData.forEach(((e,t)=>this.removeObject(t)))}render(e,t){if(this.numberOfRenderedEdges[t]=0,a(this.componentColorManager))return;this.localOrigins.updateViewMatrices(e.camera.viewMatrix);const r=e.camera.viewInverseTransposeMatrix,s=w(),o=new C;let n=0,i=0;if(this.renderers.forEach((r=>{0===r.refCount.value?(this.renderers.delete(r.key),r.dispose()):r.forEachRenderable((t=>{t.visible&&(n+=t.statistics.averageEdgeLength,i++,t.regular&&r.updateTechnique(e,!1),t.silhouette&&r.updateTechnique(e,!0))}),t)})),this.componentColorManager.garbageCollect(),this.componentColorManager.updateTextures(),0===i)return;const c=40*n/i,d=e.camera.perScreenPixelRatio,l=new G(c,d,t);y(s,r[3],r[7],r[11]),o.set(s),j(l.transformWorldFromViewTH,o.high),j(l.transformWorldFromViewTL,o.low),g(l.transformViewFromCameraRelativeRS,e.camera.viewMatrix),u(de,l.transformViewFromCameraRelativeRS),h(l.transformNormalViewFromGlobal,de),l.transformProjFromView=e.camera.projectionMatrix,this._updateObjectCameraDistances(e),this.renderers.forEach((t=>{this._renderRegularEdges(t,e,l),this._renderSilhouetteEdges(t,e,l)}))}_updateTransparency(e){const t=X(e.components.meta),r=Y(e.components.meta);t===e.edgeTransparency&&r===e.objectTransparency||(e.edgeTransparency=t,e.objectTransparency=r,this.renderers.get(e.rendererKey).setRenderablesDirty())}_computeModelTransformWithLocalOrigin(e,t,r){if(e.getCombinedStaticTransformation(t,r),c(t.origin))this.localOrigins.register(t.origin);else{const e=y(this.tmpModelPosition,r[12],r[13],r[14]);t.origin=this.localOrigins.acquire(e)}return P(t.origin.vec3,r),t.origin}_updateComponentBuffer(e){const{meta:t,buffer:r}=e,s=new Uint8Array(4);for(let n=0;n<t.length;n++){const e=t[n].material,i=t[n].index,a=o(Math.round(e.size*W),0,255),c=o(e.extensionLength,-q,255-q)+q,d="solid"===e.type?H.SOLID:H.SKETCH,l=255*e.opacity,m=e.color,g=255*m[0],u=255*m[1],h=255*m[2],p=255*m[3];r.textureBuffer.setData(i,0,g,u,h,p),r.textureBuffer.setData(i,1,a,c,d,l),M(t[n].verticalOffset,s),r.textureBuffer.setData(i,2,s[0],s[1],s[2],s[3])}}_createComponentBuffers(e){if(a(this.componentColorManager))return null;const t=new Array,r=this.componentColorManager.getBuffer(e.length);for(let o=0;o<e.length;o++){const s=e[o],n=r.acquireIndex();t.push({index:n,verticalOffset:0,material:s})}const s={meta:t,buffer:r};return this._updateComponentBuffer(s),s}_extractEdges(e,t,r,s,o,n=o.length){return this.worker.process({data:t,indices:o,indicesLength:n,writerSettings:e,skipDeduplicate:r},this.workerAbort.signal,s)}_createEdgeResources(e){const t={};if(a(this.verticesBufferObject))return t;if(e.regular.lodInfo.lengths.length>0){const r=new se(this.rctx,I,{vertices:U,instances:V.glLayout},{vertices:this.verticesBufferObject,instances:te.createVertex(this.rctx,re.STATIC_DRAW,e.regular.instancesData.buffer)});t.regular={vao:r,lod:e.regular.lodInfo}}if(e.silhouette.lodInfo.lengths.length>0){const r=new se(this.rctx,I,{vertices:U,instances:N.glLayout},{vertices:this.verticesBufferObject,instances:te.createVertex(this.rctx,re.STATIC_DRAW,e.silhouette.instancesData.buffer)});t.silhouette={vao:r,lod:e.silhouette.lodInfo}}return t}async _addGeometry(e,t,r,s,o,n,i){const a=r.vertexAttributes.get(k.POSITION),c=r.indices.get(k.POSITION),d=b(),l={position:a,indices:c,modelTransform:d,origin:this._computeModelTransformWithLocalOrigin(e,s,d)};return this._addPositionData(t,l,r.edgeIndicesLength,o,n,i)}async _addPositionData(e,t,r,s,o,n=!1){if(null==e.loaded)return;const i=this._createComponentBuffers([s]);if(a(i)||r<=0)return;const c=this._acquireRenderer(s.type,!!o.hasSlicePlane,!0),{modelTransform:d,origin:l}=t,m=t.indices,g=t.position,u=g.data.length/g.size,h=L.createBuffer(u);for(let a=0;a<u;a++)h.position.set(a,0,g.data[a*g.size+0]),h.position.set(a,1,g.data[a*g.size+1]),h.position.set(a,2,g.data[a*g.size+2]);Z(i.meta,[0,h.componentIndex.count],h.componentIndex);const p=await this.updatingHandles.addPromise(this._extractEdges(c.writerSettings,h,!1,n,m,r));if(null==e.loaded)return;const{regular:f,silhouette:b}=this._createEdgeResources(p),y=(f?f.vao.size:0)+(b?b.vao.size:0),j={regular:f,silhouette:b,transform:{modelMatrix:d,origin:l},statistics:{gpuMemoryUsage:y,externalMemoryUsage:!1,averageEdgeLength:p.averageEdgeLength},components:i,visible:!0,edgeTransparency:X(i.meta),objectTransparency:Y(i.meta),distanceToCamera:0,rendererKey:c.key};e.renderables.push(j),c.addRenderable(j),this.gpuMemoryUsage+=y}async _addComponentGeometry(e,t,r,s,o,n,i){if(null==t.loaded)return 0;const c=this._createComponentBuffers(n);if(a(c))return 0;const d=J(n),l=this._acquireRenderer(d,i.hasSlicePlane||!1,!1),m=L.createBuffer(r.count);T(m.position,r),Z(c.meta,o,m.componentIndex,s);const g=!0,u=l.writerSettings,h=await this.updatingHandles.addPromise(this._extractEdges(u,m,g,!1,s));if(null==t.loaded)return 0;const{regular:p,silhouette:f}=this._createEdgeResources(h),b=(p?p.vao.size:0)+(f?f.vao.size:0),y={regular:p,silhouette:f,transform:e,statistics:{gpuMemoryUsage:b,externalMemoryUsage:!0,averageEdgeLength:h.averageEdgeLength},components:c,visible:!0,edgeTransparency:X(c.meta),objectTransparency:Y(c.meta),distanceToCamera:0,rendererKey:l.key};return t.renderables.push(y),l.addRenderable(y),b}async _addObjectMergedGeometries(e,t,r,s,o){const n=new Map;let i=0,a=null,c=0;for(let b=0;b<e.geometries.length;b++){const t=e.geometries[b],r=e.geometryRecords[b];if(!r.material.supportsEdges)continue;!a&&r.origin&&(a=r);const s=t.vertexAttributes.get(k.POSITION);c+=s.data.length/s.size,i+=t.edgeIndicesLength}const d=c>=65536?Uint32Array:Uint16Array,l=i?new d(i):null,m=[];let g=0;for(let b=0;b<e.geometries.length;b++){const t=e.geometries[b];if(!e.geometryRecords[b].material.supportsEdges)continue;const r=t.vertexAttributes.get(k.POSITION),s=t.indices.get(k.POSITION);let o=n.get(r.data);if(null==o){o=m.length/3;for(let e=0;e<r.data.length;e+=r.size)m.push(r.data[e+0]),m.push(r.data[e+1]),m.push(r.data[e+2]);n.set(r.data,o)}if(s)for(let e=0;e<t.edgeIndicesLength;e++)l[g++]=o+s[e]}const u=a||e.geometryRecords[0],h=b(),p=this._computeModelTransformWithLocalOrigin(e,u,h);for(let b=0;b<e.geometryRecords.length;b++)e.geometryRecords[b].origin=p;const f={position:{data:m,size:3},indices:l,modelTransform:h,origin:p};await this.updatingHandles.addPromise(this._addPositionData(t,f,l.length,r[0],s,o))}_acquireRenderer(e,t,r){const s=z.getKey(e,t,r);let o=this.renderers.get(s);return a(this.strokesTexture)&&(this.strokesTexture=Q(this.rctx)),o||(o=new z(this.rctx,this.techniqueRepository,{type:e,hasSlicePlane:t,strokesTexture:this.strokesTexture,legacy:r,spherical:this.viewingMode===_.Global}),this.renderers.set(s,o)),o.refCount.increment(),o}_removeRenderable(e){ie(e);const t=this.renderers.get(e.rendererKey);if(t){t.removeRenderable(e),t.refCount.decrement(),"origin"in e.transform&&this.localOrigins.release(e.transform.origin),this.gpuMemoryUsage-=e.statistics.externalMemoryUsage?0:e.statistics.gpuMemoryUsage;for(const t of e.components.meta)e.components.buffer.releaseIndex(t.index)}}_updateObjectCameraDistances(e){const t=e.camera.eye,r=e.camera.viewForward,s=w(),o=e=>{const{center:o,radius:n}=e;O(s,o,t);const i=v(s,r),a=i<-n?1/0:i<n?0:i-n;e.renderables.forEach((e=>e.distanceToCamera=a))};this.perObjectData.forEach(o),this.perObjectDataEvictionCache.forEach(o)}_renderRegularEdges(e,t,r){const s=e.bindRegularEdges(r,t),o=r.transparency;e.forEachRenderable((n=>{if(!n.visible||!n.regular)return;const i=$(n.regular.lod.lengths,n.distanceToCamera,r),a="origin"in n.transform?this.localOrigins.getViewMatrix(n.transform.origin):f;e.renderRegularEdges(s,n,t,i,a),this.numberOfRenderedEdges[o]+=i}),o)}_renderSilhouetteEdges(e,t,r){const s=e.bindSilhouetteEdges(r,t),o=r.transparency;e.forEachRenderable((n=>{if(!n.visible||!n.silhouette)return;const i=$(n.silhouette.lod.lengths,n.distanceToCamera,r),a="origin"in n.transform?this.localOrigins.getViewMatrix(n.transform.origin):f;e.renderSilhouetteEdges(s,n,t,i,a),this.numberOfRenderedEdges[o]+=i}),o)}};function ie(e){e.regular&&(e.regular.vao.vertexBuffers.instances.dispose(),e.regular.vao.dispose(!1),e.regular.vao=null),e.silhouette&&(e.silhouette.vao.vertexBuffers.instances.dispose(),e.silhouette.vao.dispose(!1),e.silhouette.vao=null)}function ae(e){let t=null,s=null;for(let o=0;o<e.geometries.length;o++){const n=e.geometryRecords[o];if(n.material.supportsEdges){if(t){if(!r(t,n.transformation))return!1}else t=n.transformation;if(!s&&c(n.origin))s=n;else if(c(s?.origin)&&c(n.origin)&&s.origin.id!==n.origin.id)return!1}}return!0}e([l({constructOnly:!0})],ne.prototype,"rctx",void 0),e([l({constructOnly:!0})],ne.prototype,"renderSR",void 0),e([l({constructOnly:!0})],ne.prototype,"viewingMode",void 0),e([l({constructOnly:!0})],ne.prototype,"techniqueRepository",void 0),e([l({constructOnly:!0})],ne.prototype,"setNeedsRender",void 0),e([l({constructOnly:!0})],ne.prototype,"schedule",void 0),e([l({readOnly:!0})],ne.prototype,"updatingHandles",void 0),e([l({readOnly:!0})],ne.prototype,"updating",null),ne=e([m("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView")],ne);class ce{constructor(e,t,r){this.center=t,this.radius=r,this.renderables=new Array,this.loaded=e,this.loaded.then((()=>{null!=this.loaded&&(this.loaded=!0)}))}}const de=p();export{ne as EdgeView};
