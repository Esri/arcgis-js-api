/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/maybe","../../../../chunks/vec3f64","../../../webgl/BufferObject","../../../webgl/FramebufferObject","../../../webgl/Program","../../../webgl/enums","../../../webgl/checkWebGLError","../../../webgl/renderState","../../../webgl/Texture","../../../webgl/VertexArrayObject","./doublePrecisionUtils","./Util","../../../webgl/testFloatBufferBlend","../../../webgl/testSVGPremultipliedAlpha"],(function(e,n,t,o,i,r,s,l,a,c,u,f,d,h,v,p){"use strict";let b=function(){function e(e){this.context=e,this.svgAlwaysPremultipliesAlpha=!1,this.floatBufferBlendWorking=!1,this._doublePrecisionRequiresObfuscation=null,this.floatBufferBlendWorking=v.testFloatBufferBlend(e),p.testSVGPremultipliedAlpha(e).then((e=>this.svgAlwaysPremultipliesAlpha=!e))}return n._createClass(e,[{key:"doublePrecisionRequiresObfuscation",get:function(){if(t.isNone(this._doublePrecisionRequiresObfuscation)){const e=_(this.context,!1),n=_(this.context,!0);this._doublePrecisionRequiresObfuscation=0!==e&&(0===n||e/n>5)}return this._doublePrecisionRequiresObfuscation}}]),e}(),A=null;function g(e){return(t.isNone(A)||A.context!==e)&&(A=new b(e)),A}function m(e){t.isSome(A)&&A.context===e&&(A=null)}function _(e,n){const t=new r(e,{colorTarget:0,depthStencilTarget:0},{target:3553,wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1});function l(t,o){const i=`\n\n  precision highp float;\n\n  attribute vec2 position;\n\n  uniform vec3 u_highA;\n  uniform vec3 u_lowA;\n  uniform vec3 u_highB;\n  uniform vec3 u_lowB;\n\n  varying vec4 v_color;\n\n  ${n?"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION":""}\n\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\n\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n  }\n\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n  }\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = dpPlusFrc(hiA, hiB);\n    vec3 e = dpMinusFrc(t1, hiA);\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n    return t1 + t2;\n  }\n\n  #else\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = hiA + hiB;\n    vec3 e = t1 - hiA;\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n    return t1 + t2;\n  }\n\n  #endif\n\n  const float MAX_RGBA_FLOAT =\n    255.0 / 256.0 +\n    255.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n  vec4 float2rgba(const float value) {\n    // Make sure value is in the domain we can represent\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n    // Decompose value in 32bit fixed point parts represented as\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\n    // by a power of 256 (this removes the bits that are represented in the previous\n    // component) and then converts the fractional part to 8bits.\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n    // Convert uint8 values (from 0 to 255) to floating point representation for\n    // the shader\n    const float toU8AsFloat = 1.0 / 255.0;\n\n    return fixedPointU8 * toU8AsFloat;\n  }\n\n  void main() {\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\n\n    v_color = float2rgba(val.z / 25.0);\n\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\n  }\n  `,r="\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ",l=new s.Program(e,i,r,new Map([["position",0]])),a=new Float32Array(6);d.encodeDoubleArray(t,a,3);const c=new Float32Array(6);return d.encodeDoubleArray(o,c,3),e.useProgram(l),l.setUniform3f("u_highA",a[0],a[2],a[4]),l.setUniform3f("u_lowA",a[1],a[3],a[5]),l.setUniform3f("u_highB",c[0],c[2],c[4]),l.setUniform3f("u_lowB",c[1],c[3],c[5]),l}const a=i.createVertex(e,35044,new Uint16Array([0,0,1,0,0,1,1,1])),c=new f(e,new Map([["position",0]]),{geometry:[{name:"position",count:2,type:5123,offset:0,stride:4,normalized:!1}]},{geometry:a}),u=o.fromValues(5633261.287538229,2626832.878767164,1434988.0495278358),v=o.fromValues(5633271.46742708,2626873.6381334523,1434963.231608387),p=l(u,v),b=e.getBoundFramebufferObject(),{x:A,y:g,width:m,height:_}=e.getViewport();e.bindFramebuffer(t),e.setViewport(0,0,1,1),e.bindVAO(c),e.drawArrays(5,0,4);const w=new Uint8Array(4);t.readPixels(0,0,1,1,6408,5121,w),p.dispose(),c.dispose(!1),a.dispose(),t.dispose(),e.setViewport(A,g,m,_),e.bindFramebuffer(b);const B=(u[2]-v[2])/25,F=h.unpackFloatRGBA(w);return Math.abs(B-F)}e.clearTestWebGLDriver=m,e.testWebGLDriver=g,Object.defineProperty(e,"__esModule",{value:!0})}));
