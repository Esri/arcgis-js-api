/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/vec3f64","./Octree"],(function(e,n,t){"use strict";function r(e,n,t,r,s){for(let n=0;n<3;n++)if(e[n]<t[n]||e[n]>r[n])throw new Error("[Octree Validation] Object is not within node bounds");const i=.25*(r[0]-t[0]);if(s&&n<i)throw new Error("[Octree Validation] Object is too small to be a terminal");if(!s&&n>i)throw new Error("[Octree Validation] Object is too large to be a resident")}function s(e,n,t){return(t=t||e)[0]=e[0]+n,t[1]=e[1]+n,t[2]=e[2]+n,t}e.assert=function(e,t){return e.forEachNode(((i,m,a)=>{const o=s(m,-a/2,n.create()),l=s(m,a/2,n.create());if(i.terminals.forAll((e=>r(t.getCenter(e),t.getRadius(e),o,l,!0))),null!==i.residents){if(i.residents.length>e.maximumObjectsPerNode)throw new Error("[Octree Validation] Number of objects "+i.residents.length+" exceeds maximum allowed ("+e.maximumObjectsPerNode+")");i.residents.forAll((e=>r(t.getCenter(e),t.getRadius(e),o,l,!1)))}let d=!1;if(i.children.forEach((e=>{if(e&&(d=!0,null!==i.residents))throw new Error("[Octree Validation] Node has residents and children")})),!d&&(null===i.residents||0===i.residents.length)&&0===i.terminals.length)throw new Error("[Octree Validation] dangling empty node");return!0})),!0},e.debugDump=function e(r,s=!1){const i=r instanceof t?r.root:r;let m;return m={},r instanceof t&&s&&(m.center=n.clone(r.center),m.size=r.size),i.terminals.length>0&&(m.terminals=i.terminals.map((e=>e.id))),null!==i.residents&&i.residents.length>0&&(m.residents=i.residents.map((e=>e.id))),null===i.residents&&i.children.forEach((function(n,t){n&&(m["child"+t]=e(n))})),m},e.stats=function(e){const n={numNodes:0,numObjects:0,numTerminals:0,numResidents:0,numOutsiders:0,numInnerNodes:0,numTerminalNodes:0,maximumDepth:0,maxNumTerminals:0,maxNumResidents:0,maxNumObjects:0};return e.forEachNode(((t,r,s)=>{null===t.residents?n.numInnerNodes++:n.numTerminalNodes++,n.numTerminals+=t.terminals.length,n.maxNumTerminals=Math.max(t.terminals.length,n.maxNumTerminals);let i=t.terminals.length;null!==t.residents&&(n.numResidents+=t.residents.length,n.maxNumResidents=Math.max(t.residents.length,n.maxNumResidents),i+=t.residents.length),n.maxNumObjects=Math.max(i,n.maxNumObjects);const m=Math.round(Math.log(e.size/s)*Math.LOG2E);return n.maximumDepth=Math.max(n.maximumDepth,m),!0})),n.numObjects=n.numOutsiders+n.numTerminals+n.numResidents,n.numNodes=n.numInnerNodes+n.numTerminalNodes,n},Object.defineProperty(e,"__esModule",{value:!0})}));
