/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["../../../../chunks/_rollupPluginBabelHelpers","../../../../core/pbf","../../../../core/promiseUtils","../../../../geometry/libtess","./Feature","./IndexMemoryBuffer","./SourceLayerData","./VertexMemoryBuffer","./buckets/CircleBucket","./buckets/FillBucket","./buckets/LineBucket","./buckets/SymbolBucket","../webgl/TileClipper","../../tiling/enums"],(function(e,t,r,s,i,n,o,l,c,a,u,f,h,p){"use strict";const _=8,y=14,d=5;let m=function(){function m(e,r,s,i,n){if(this._pbfTiles={},this._tileClippers={},this._client=s,this._tile=r,n){this._styleLayerUIDs=new Set;for(const e of n)this._styleLayerUIDs.add(e)}this._styleRepository=i,this._layers=this._styleRepository.layers;const[o,l,c]=r.tileKey.split("/").map(parseFloat);this._level=o;const a=_+Math.max((this._level-y)*d,0);for(const u of Object.keys(e)){const r=e[u];this._pbfTiles[u]=new t(new Uint8Array(r.protobuff),new DataView(r.protobuff));if(r.refKey){const[e]=r.refKey.split("/").map(parseFloat),t=o-e;if(t>0){const e=(1<<t)-1,r=l&e,s=c&e;this._tileClippers[u]=new h.TileClipper(t,r,s,8,a)}}this._tileClippers[u]||(this._tileClippers[u]=new h.SimpleBuilder)}}var T=m.prototype;return T._canParseStyleLayer=function(e){return!this._styleLayerUIDs||this._styleLayerUIDs.has(e)},T.parse=function(){var t=e._asyncToGenerator((function*(e){const t=s.loadLibtess(),r=this._initialize(e),{returnedBuckets:i}=r;this._processLayers(r),this._linkReferences(r),this._filterFeatures(r);const n=[],o=new Set,l=(e,t)=>{o.has(e)||(n.push({name:e,repeat:t}),o.add(e))},c={};for(const s of i)s.getResources(s.tileClipper,l,c);if(this._tile.status===p.TileStatus.INVALID)return Promise.resolve([]);const a=this._fetchResources(n,c,e);return Promise.all([...a,t]).then((()=>this._processFeatures(r.returnedBuckets)))}));function r(e){return t.apply(this,arguments)}return r}(),T._initialize=function(e){return{signal:e&&e.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}},T._processLayers=function(e){const{sourceNameToTileData:t,layers:r,zoom:s,sourceNameToTileClipper:i,sourceNameToUniqueSourceLayerBuckets:n,sourceNameToUniqueSourceLayers:o,returnedBuckets:l,layerIdToBucket:c,referencerUIDToReferencedId:a}=e;for(let u=r.length-1;u>=0;u--){const e=r[u];if(!this._canParseStyleLayer(e.uid)||e.minzoom&&s<Math.floor(e.minzoom)||e.maxzoom&&s>=e.maxzoom||0===e.type)continue;if(!t[e.source]||!i[e.source])continue;const f=t[e.source],h=i[e.source],p=e.sourceLayer,_=f[p];if(_){let t=o[e.source];if(t||(t=o[e.source]=new Set),t.add(e.sourceLayer),e.refLayerId)a.set(e.uid,e.refLayerId);else{const t=this._createBucket(e);if(t){t.layerUIDs=[e.uid],t.layerExtent=_.extent,t.tileClipper=h;let r=n[e.source];r||(r=n[e.source]={});let s=r[p];s||(s=r[p]=[]),s.push(t),l.push(t),c[e.id]=t}}}}},T._linkReferences=function(e){const{layerIdToBucket:t,referencerUIDToReferencedId:r}=e;r.forEach(((e,r)=>{t[e=e]&&t[e].layerUIDs.push(r)}))},T._filterFeatures=function(e){const{signal:t,sourceNameToTileData:s,sourceNameToUniqueSourceLayerBuckets:n,sourceNameToUniqueSourceLayers:o}=e,l=10*this._level,c=10*(this._level+1),a=[],u=[];for(const r of Object.keys(o)){o[r].forEach((e=>{a.push(e),u.push(r)}))}for(let f=0;f<a.length;f++){const e=u[f],o=a[f];if(!s[e]||!n[e])continue;const h=s[e][o],p=n[e][o];if(!p||0===p.length)continue;if(r.isAborted(t))return;const _=h.getData();for(;_.nextTag(2);){const e=_.getMessage(),t=new i(e,h);e.release();const r=t.values;if(r){const e=r._minzoom;if(e&&e>=c)continue;const t=r._maxzoom;if(t&&t<=l)continue}for(const s of p)s.pushFeature(t)}}},T._fetchResources=function(e,t,r){const s=[],i=this._tile.getWorkerTileHandler();let n,o;e.length>0&&(n=i.fetchSprites(e,this._client,r),s.push(n));for(const l in t){const e=t[l];e.size>0&&(o=i.fetchGlyphs(this._tile.tileKey,l,e,this._client,r),s.push(o))}return s},T._processFeatures=function(e){const t=e.filter((e=>e.hasFeatures()||this._canParseStyleLayer(e.layer.uid)));for(const r of t)r.processFeatures(r.tileClipper);return t},T._parseTileData=function(e){const t={};for(const r of Object.keys(e)){const s=e[r],i={};for(;s.next();)switch(s.tag()){case 3:{const e=s.getMessage(),t=new o(e);e.release(),i[t.name]=t;break}default:s.skip()}t[r]=i}return t},T._createBucket=function(e){switch(e.type){case 0:return null;case 1:return this._createFillBucket(e);case 2:return this._createLineBucket(e);case 4:return this._createCircleBucket(e);case 3:return this._createSymbolBucket(e)}},T._createFillBucket=function(e){return new a(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new l.FillVertexBuffer(e.fillMaterial.getStride()),new n.TriangleIndexBuffer,new l.OutlineVertexBuffer(e.outlineMaterial.getStride()),new n.TriangleIndexBuffer)},T._createLineBucket=function(e){return new u(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new l.LineVertexBuffer(e.lineMaterial.getStride()),new n.TriangleIndexBuffer)},T._createCircleBucket=function(e){return new c(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new l.CircleVertexBuffer(e.circleMaterial.getStride()),new n.TriangleIndexBuffer)},T._createSymbolBucket=function(e){const t=this._tile;return new f(e,this._level,new l.SymbolVertexBuffer(e.iconMaterial.getStride()),new n.TriangleIndexBuffer,new l.SymbolVertexBuffer(e.textMaterial.getStride()),new n.TriangleIndexBuffer,t.placementEngine,t.getWorkerTileHandler())},m}();return m}));
