/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/has","../../../../core/maybe","../../../../core/promiseUtils","../../../../request","../../../../geometry/support/aaBoundingRect","../../../../core/MemCache","../../../../core/ItemCache","../../../../core/workers/workers","../../tiling/TileKey","./TileIndex","./VectorTile","./GlyphMosaic","./GlyphSource","./SpriteMosaic","./decluttering/debugging"],(function(e,t,i,s,o,r,n,a,l,c,u,h,f,p,_,y,g){"use strict";const d=new l(10),m=new Map;let T=function(){function e(e,t,i,s){this._vectorTileLayer=e,this._styleRepository=t,this.devicePixelRatio=i,this._memCache=s,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map}var l=e.prototype;return l.destroy=function(){this._ongoingTileRequests&&this.abortAll(),this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)},l.start=async function(e){const t=this._vectorTileLayer,s=t.sourceNameToSource,r=[];for(const t in s)r.push(this._fetchTileMap(s[t],e));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,e),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new y(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const n=this._styleRepository,a=new _(n.glyphs);return this._glyphMosaic=new p(1024,1024,a),this._broadcastPromise=c.open("WorkerTileHandler",{client:this,scheduler:e.scheduler,signal:e.signal}).then((s=>(this._connection=s,o.all(this._connection.broadcast("setStyle",{style:t.currentStyleInfo.style,vectorTileLayerMaxBuffers:i("vectortilelayer-max-buffers")},e))))),o.all(r)},l.updateStyle=async function(e){return await this._broadcastPromise,this._broadcastPromise=o.create(((t,i)=>{o.all(this._connection.broadcast("updateStyle",e)).then(t,i)})),this._broadcastPromise},l.setStyle=async function(e,t){await this._broadcastPromise,this._styleRepository=e;const s=this._vectorTileLayer.sourceNameToSource,r=[];for(const e in s)r.push(this._fetchTileMap(s[e],null));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new y(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const n=new _(e.glyphs);return this._glyphMosaic=new p(1024,1024,n),this._broadcastPromise=o.create(((e,s)=>{o.all(this._connection.broadcast("setStyle",{style:t,vectorTileLayerMaxBuffers:i("vectortilelayer-max-buffers")})).then(e,s)})),r.push(this._broadcastPromise),o.all(r)},l.getVectorTile=function(e,t,i,r){const l=new u(e,t,i,0);if(s.isSome(this._memCache)){const e=this._memCache.get(l.id);if(s.isSome(e))return e.reference(),o.resolve(e)}return this._getVectorTileData(l).then((e=>{if(o.throwIfAborted(r),s.isSome(this._memCache)){const e=this._memCache.get(l.id);if(s.isSome(e))return e.reference(),e}if(!this._vectorTileLayer)return null;const t=this._vectorTileLayer.tileInfo.getTileBounds(n.create(),l),i=new f.VectorTile(l,this._styleRepository,t,[512,512]);if(e&&e.tileData){if(i.setData(e.tileData),s.isSome(this._memCache)){i.reference();const e=i.getMemoryUsage();e>0&&this._memCache.put(i.key.id,i,e*i.referenced,a.MIN_PRIORITY)}}else i.setData(null);return i}))},l.releaseVectorTile=function(e){s.isNone(this._memCache)||e.release()||this._memCache.updateSize(e.key.id,e,e.getMemoryUsage()*e.referenced)},l.fetchTileData=function(e,t){return this._getRefKeys(e,t).then((e=>{const i=this._vectorTileLayer.sourceNameToSource,s=[];for(const e in i)s.push(e);return this._getSourcesData(s,e,t)}))},l.parseTileData=function(e,t){const s=e&&e.data;if(!s)return o.resolve(null);const{sourceName2DataAndRefKey:r,transferList:n}=s;return 0===Object.keys(r).length?o.resolve(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((s=>s.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:r,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:n}).then((e=>{if(i("esri-vector-tiles-debug")){const t={};for(const e in r)t[e]=r[e].refKey;return{tileData:e,refKeys:t}}return{tileData:e}}))))))},l.abortAll=function(){this._ongoingRequestToController.forEach((e=>e.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()},l.getSprites=async function(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)},l.getGlyphs=function(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)},l.perfReport=function({key:e,milliseconds:t}){g.perfAdd(e,t,"ms")},l._getTilePayload=async function(e,t,i){const s=u.pool.acquire(e.id),n=this._vectorTileLayer.sourceNameToSource[t].getSourceTileUrl(s.level,s.row,s.col);u.pool.release(s);try{return{protobuff:(await r(n,{responseType:"array-buffer",...i})).data,sourceName:t}}catch(e){if(o.isAbortError(e))throw e;return{protobuff:null,sourceName:t}}},l._fetchTileMap=async function(e,t){if(e.capabilities.operations.supportsTileMap&&e.tileIndex)return o.resolve();if(!e.tileMapURL)return;const i=d.get(e.tileMapURL);if(i)return void(e.tileIndex=i);let s;if(m.has(e.tileMapURL)){try{s=await m.get(e.tileMapURL),e.tileIndex=new h(s.data)}catch(e){if(o.isAbortError(e))throw e}return}const n=r(e.tileMapURL,t);m.set(e.tileMapURL,n);try{s=await n,m.delete(e.tileMapURL),d.put(e.tileMapURL,e.tileIndex),e.tileIndex=new h(s.data)}catch(t){if(m.delete(e.tileMapURL),o.isAbortError(t))throw t}},l._getRefKeys=function(e,t){const i=this._vectorTileLayer.sourceNameToSource,s=new Array;for(const o in i){const r=i[o].getRefKey(e,t);s.push(r)}return o.eachAlways(s)},l._getSourcesData=function(e,t,i){const s=[];for(let o=0;o<t.length;o++)if(null==t[o].value||null==e[o])s.push(null);else{const r=this._getTilePayload(t[o].value,e[o],i);s.push(r)}return o.eachAlways(s).then((e=>{const i={},s=[];for(let o=0;o<e.length;o++)if(e[o].value&&e[o].value&&e[o].value.protobuff&&e[o].value.protobuff.byteLength>0){const r=t[o].value.id;i[e[o].value.sourceName]={refKey:r,protobuff:e[o].value.protobuff},s.push(e[o].value.protobuff)}return{sourceName2DataAndRefKey:i,transferList:s}}))},l._getVectorTileData=function(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,s={signal:i.signal},o=this._getParsedVectorTileData(e,s).then((e=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),e))).catch((()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null)));return this._ongoingTileRequests.set(t,o),this._ongoingRequestToController.set(t,i),o},l._getParsedVectorTileData=function(e,t){return this.fetchTileData(e,t).then((i=>this.parseTileData({key:e,data:i},t)))},t._createClass(e,[{key:"spriteMosaic",get:function(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}},{key:"glyphMosaic",get:function(){return this._glyphMosaic}},{key:"updating",get:function(){return this._ongoingTileRequests.size>0}}]),e}();e.TileHandler=T,Object.defineProperty(e,"__esModule",{value:!0})}));
