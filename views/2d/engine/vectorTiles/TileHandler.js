/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/promiseUtils","../../../../core/urlUtils","../../../../core/workers/workers","./GlyphMosaic","./GlyphSource","./SpriteMosaic","./decluttering/debugging","../../tiling/TileKey"],(function(e,t,r,s,i,o,n,l,a,c){"use strict";let u=function(){function e(e,t,r){this._layer=e,this._styleRepository=t,this.devicePixelRatio=r,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}var u=e.prototype;return u.destroy=function(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._layer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)},u.start=function(){var e=t._asyncToGenerator((function*(e){this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,e),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new l(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const t=new n(this._layer.currentStyleInfo.glyphsUrl?s.addQueryParameters(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new o(1024,1024,t),this._broadcastPromise=i.open("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then((t=>(this._connection=t,Promise.all(this._connection.broadcast("setStyle",this._layer.currentStyleInfo.style,e)))))}));function r(t){return e.apply(this,arguments)}return r}(),u.updateStyle=function(){var e=t._asyncToGenerator((function*(e){return yield this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}));function r(t){return e.apply(this,arguments)}return r}(),u.setSpriteSource=function(e){const t=new l(1024,1024,250);return t.setSpriteSource(e),this._spriteMosaic=t,this._spriteSourcePromise=Promise.resolve(e),t},u.setStyle=function(){var e=t._asyncToGenerator((function*(e,t){yield this._broadcastPromise,this._styleRepository=e,this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new l(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const r=new n(this._layer.currentStyleInfo.glyphsUrl?s.addQueryParameters(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new o(1024,1024,r),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",t)),this._broadcastPromise}));function r(t,r){return e.apply(this,arguments)}return r}(),u.fetchTileData=function(e,t){return this._getRefKeys(e,t).then((e=>{const r=this._layer.sourceNameToSource,s=[];for(const t in r)s.push(t);return this._getSourcesData(s,e,t)}))},u.parseTileData=function(e,t){const r=e&&e.data;if(!r)return Promise.resolve(null);const{sourceName2DataAndRefKey:s,transferList:i}=r;return 0===Object.keys(s).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((r=>r.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:s,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:i})))))},u.getSprites=function(){var e=t._asyncToGenerator((function*(e){return yield this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}));function r(t){return e.apply(this,arguments)}return r}(),u.getGlyphs=function(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)},u.perfReport=function({key:e,milliseconds:t}){a.perfAdd(e,t,"ms")},u._getTilePayload=function(){var e=t._asyncToGenerator((function*(e,t,s){const i=c.pool.acquire(e.id),o=this._layer.sourceNameToSource[t],{level:n,row:l,col:a}=i;c.pool.release(i);try{return{protobuff:yield o.requestTile(n,l,a,s),sourceName:t}}catch(u){if(r.isAbortError(u))throw u;return{protobuff:null,sourceName:t}}}));function s(t,r,s){return e.apply(this,arguments)}return s}(),u._getRefKeys=function(e,t){const s=this._layer.sourceNameToSource,i=new Array;for(const r in s){const o=s[r].getRefKey(e,t);i.push(o)}return r.eachAlways(i)},u._getSourcesData=function(e,t,s){const i=[];for(let r=0;r<t.length;r++)if(null==t[r].value||null==e[r])i.push(null);else{const o=this._getTilePayload(t[r].value,e[r],s);i.push(o)}return r.eachAlways(i).then((e=>{const r={},s=[];for(let i=0;i<e.length;i++)if(e[i].value&&e[i].value&&e[i].value.protobuff&&e[i].value.protobuff.byteLength>0){const o=t[i].value.id;r[e[i].value.sourceName]={refKey:o,protobuff:e[i].value.protobuff},s.push(e[i].value.protobuff)}return{sourceName2DataAndRefKey:r,transferList:s}}))},t._createClass(e,[{key:"spriteMosaic",get:function(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}},{key:"glyphMosaic",get:function(){return this._glyphMosaic}}]),e}();e.TileHandler=u,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
