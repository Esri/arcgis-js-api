/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/has","../../../../core/promiseUtils","../../../../request","../../../../core/ItemCache","../../../../core/workers/workers","../../tiling/TileKey","./TileIndex","./GlyphMosaic","./GlyphSource","./SpriteMosaic","./decluttering/debugging"],(function(e,t,s,i,r,o,n,a,l,c,u,h,p){"use strict";const y=new o(10),f=new Map;let _=function(){function e(e,t,s){this._vectorTileLayer=e,this._styleRepository=t,this.devicePixelRatio=s,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}var o=e.prototype;return o.destroy=function(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)},o.start=async function(e){const t=this._vectorTileLayer,i=t.sourceNameToSource,r=[];for(const s in i)r.push(this._fetchTileMap(i[s],e));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,e),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new h(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const o=this._styleRepository,a=new u(o.glyphs);return this._glyphMosaic=new c(1024,1024,a),this._broadcastPromise=n.open("WorkerTileHandler",{client:this,scheduler:e.scheduler,signal:e.signal}).then((i=>(this._connection=i,Promise.all(this._connection.broadcast("setStyle",{style:t.currentStyleInfo.style,vectorTileLayerMaxBuffers:s("vectortilelayer-max-buffers")},e))))),Promise.all(r)},o.updateStyle=async function(e){return await this._broadcastPromise,this._broadcastPromise=new Promise(((t,s)=>{Promise.all(this._connection.broadcast("updateStyle",e)).then(t,s)})),this._broadcastPromise},o.setStyle=async function(e,t){await this._broadcastPromise,this._styleRepository=e;const i=this._vectorTileLayer.sourceNameToSource,r=[];for(const s in i)r.push(this._fetchTileMap(i[s],null));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new h(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const o=new u(e.glyphs);return this._glyphMosaic=new c(1024,1024,o),this._broadcastPromise=new Promise(((e,i)=>{Promise.all(this._connection.broadcast("setStyle",{style:t,vectorTileLayerMaxBuffers:s("vectortilelayer-max-buffers")})).then(e,i)})),r.push(this._broadcastPromise),Promise.all(r)},o.fetchTileData=function(e,t){return this._getRefKeys(e,t).then((e=>{const s=this._vectorTileLayer.sourceNameToSource,i=[];for(const t in s)i.push(t);return this._getSourcesData(i,e,t)}))},o.parseTileData=function(e,t){const s=e&&e.data;if(!s)return Promise.resolve(null);const{sourceName2DataAndRefKey:i,transferList:r}=s;return 0===Object.keys(i).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((s=>s.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:i,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:r}).then((e=>({tileData:e})))))))},o.getSprites=async function(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)},o.getGlyphs=function(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)},o.perfReport=function({key:e,milliseconds:t}){p.perfAdd(e,t,"ms")},o._getTilePayload=async function(e,t,s){const r=a.pool.acquire(e.id),o=this._vectorTileLayer.sourceNameToSource[t].getSourceTileUrl(r.level,r.row,r.col);a.pool.release(r);try{return{protobuff:await this.request(o,s),sourceName:t}}catch(n){if(i.isAbortError(n))throw n;return{protobuff:null,sourceName:t}}},o.request=function(e,t){return r(e,{responseType:"array-buffer",...t}).then((({data:e})=>e))},o._fetchTileMap=async function(e,t){if(e.capabilities.operations.supportsTileMap&&e.tileIndex)return Promise.resolve();if(!e.tileMapURL)return;const s=y.get(e.tileMapURL);if(s)return void(e.tileIndex=s);let o;if(f.has(e.tileMapURL)){try{o=await f.get(e.tileMapURL),e.tileIndex=new l(o.data)}catch(a){if(i.isAbortError(a))throw a}return}const n=r(e.tileMapURL,t);f.set(e.tileMapURL,n);try{o=await n,f.delete(e.tileMapURL),y.put(e.tileMapURL,e.tileIndex),e.tileIndex=new l(o.data)}catch(a){if(f.delete(e.tileMapURL),i.isAbortError(a))throw a}},o._getRefKeys=function(e,t){const s=this._vectorTileLayer.sourceNameToSource,r=new Array;for(const i in s){const o=s[i].getRefKey(e,t);r.push(o)}return i.eachAlways(r)},o._getSourcesData=function(e,t,s){const r=[];for(let i=0;i<t.length;i++)if(null==t[i].value||null==e[i])r.push(null);else{const o=this._getTilePayload(t[i].value,e[i],s);r.push(o)}return i.eachAlways(r).then((e=>{const s={},i=[];for(let r=0;r<e.length;r++)if(e[r].value&&e[r].value&&e[r].value.protobuff&&e[r].value.protobuff.byteLength>0){const o=t[r].value.id;s[e[r].value.sourceName]={refKey:o,protobuff:e[r].value.protobuff},i.push(e[r].value.protobuff)}return{sourceName2DataAndRefKey:s,transferList:i}}))},t._createClass(e,[{key:"spriteMosaic",get:function(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}},{key:"glyphMosaic",get:function(){return this._glyphMosaic}}]),e}();e.TileHandler=_,Object.defineProperty(e,"__esModule",{value:!0})}));
