/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../request","../../../../core/has","../../../../core/promiseUtils","../../../../core/urlUtils","../../../../core/workers/workers","./GlyphMosaic","./GlyphSource","./SpriteMosaic","./decluttering/debugging","../../tiling/TileKey"],(function(e,t,r,s,i,o,n,a,l,c,u,h){"use strict";let y=function(){function e(e,t,r){this._layer=e,this._styleRepository=t,this.devicePixelRatio=r,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}var y=e.prototype;return y.destroy=function(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._layer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)},y.start=function(){var e=t._asyncToGenerator((function*(e){this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,e),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new c(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const t=new l(this._layer.currentStyleInfo.glyphsUrl?o.addQueryParameters(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new a(1024,1024,t),this._broadcastPromise=n.open("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then((t=>(this._connection=t,Promise.all(this._connection.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,vectorTileLayerMaxBuffers:s("vectortilelayer-max-buffers")},e)))))}));function r(t){return e.apply(this,arguments)}return r}(),y.updateStyle=function(){var e=t._asyncToGenerator((function*(e){return yield this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}));function r(t){return e.apply(this,arguments)}return r}(),y.setStyle=function(){var e=t._asyncToGenerator((function*(e,t){yield this._broadcastPromise,this._styleRepository=e,this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new c(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const r=new l(this._layer.currentStyleInfo.glyphsUrl?o.addQueryParameters(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new a(1024,1024,r),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:t,vectorTileLayerMaxBuffers:s("vectortilelayer-max-buffers")})),this._broadcastPromise}));function r(t,r){return e.apply(this,arguments)}return r}(),y.fetchTileData=function(e,t){return this._getRefKeys(e,t).then((e=>{const r=this._layer.sourceNameToSource,s=[];for(const t in r)s.push(t);return this._getSourcesData(s,e,t)}))},y.parseTileData=function(e,t){const r=e&&e.data;if(!r)return Promise.resolve(null);const{sourceName2DataAndRefKey:s,transferList:i}=r;return 0===Object.keys(s).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((r=>r.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:s,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:i})))))},y.getSprites=function(){var e=t._asyncToGenerator((function*(e){return yield this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}));function r(t){return e.apply(this,arguments)}return r}(),y.getGlyphs=function(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)},y.perfReport=function({key:e,milliseconds:t}){u.perfAdd(e,t,"ms")},y._getTilePayload=function(){var e=t._asyncToGenerator((function*(e,t,r){const s=h.pool.acquire(e.id),o=this._layer.sourceNameToSource[t].getSourceTileUrl(s.level,s.row,s.col);h.pool.release(s);try{return{protobuff:yield this.request(o,r),sourceName:t}}catch(n){if(i.isAbortError(n))throw n;return{protobuff:null,sourceName:t}}}));function r(t,r,s){return e.apply(this,arguments)}return r}(),y.request=function(e,t){return r(e,{responseType:"array-buffer",...t}).then((({data:e})=>e))},y._getRefKeys=function(e,t){const r=this._layer.sourceNameToSource,s=new Array;for(const i in r){const o=r[i].getRefKey(e,t);s.push(o)}return i.eachAlways(s)},y._getSourcesData=function(e,t,r){const s=[];for(let i=0;i<t.length;i++)if(null==t[i].value||null==e[i])s.push(null);else{const o=this._getTilePayload(t[i].value,e[i],r);s.push(o)}return i.eachAlways(s).then((e=>{const r={},s=[];for(let i=0;i<e.length;i++)if(e[i].value&&e[i].value&&e[i].value.protobuff&&e[i].value.protobuff.byteLength>0){const o=t[i].value.id;r[e[i].value.sourceName]={refKey:o,protobuff:e[i].value.protobuff},s.push(e[i].value.protobuff)}return{sourceName2DataAndRefKey:r,transferList:s}}))},t._createClass(e,[{key:"spriteMosaic",get:function(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}},{key:"glyphMosaic",get:function(){return this._glyphMosaic}}]),e}();e.TileHandler=y,Object.defineProperty(e,"__esModule",{value:!0})}));
