/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["../../../../../chunks/_rollupPluginBabelHelpers","../../../../../core/ArrayPool","../../../../../chunks/earcut","../../../../../geometry/libtess","../../../../../geometry/support/TileClipper","../enums","./BaseBucket"],(function(t,e,i,n,r,l,s){"use strict";return function(s){function o(t,e,i,n,r,o,a){var f;return(f=s.call(this,t,e,i)||this).type=l.BucketType.FILL,f._patternMap=new Map,f._fillVertexBuffer=n,f._fillIndexBuffer=r,f._outlineVertexBuffer=o,f._outlineIndexBuffer=a,f}t._inheritsLoose(o,s);var a=o.prototype;return a.getResources=function(t,e,i){const n=this.layer,r=this.zoom,l=n.getPaintProperty("fill-pattern");if(l)if(l.isDataDriven)for(const s of this._features)e(l.getValue(r,s),!0);else e(l.getValue(r),!0)},a.processFeatures=function(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const e=this.layer,i=this.zoom,{fillMaterial:n,outlineMaterial:r,hasDataDrivenFill:l,hasDataDrivenOutline:s}=e;t&&t.setExtent(this.layerExtent);const o=e.getPaintProperty("fill-pattern"),a=o?.isDataDriven;let f=!o&&e.getPaintValue("fill-antialias",i);if(e.outlineUsesFillColor){if(f&&!e.hasDataDrivenOpacity){const t=e.getPaintValue("fill-opacity",i),n=e.getPaintValue("fill-opacity",i+1);t<1&&n<1&&(f=!1)}if(f&&!e.hasDataDrivenColor){const t=e.getPaintValue("fill-color",i),n=e.getPaintValue("fill-color",i+1);t[3]<1&&n[3]<1&&(f=!1)}}const u=this._features,d=t?.validateTessellation;if(a){const l=[];for(const a of u){const u=o.getValue(i,a),h=this._spriteInfo[u];if(!h||!h.rect)continue;const x=n.encodeAttributes(a,i,e,h),c=f&&s?r.encodeAttributes(a,i,e):[],y=a.getGeometry(t);l.push({ddFillAttributes:x,ddOutlineAttributes:c,page:h.page,geometry:y}),l.sort(((t,e)=>t.page-e.page));for(const{ddFillAttributes:t,ddOutlineAttributes:i,page:n,geometry:r}of l)this._processFeature(r,f,e.outlineUsesFillColor,t,i,d,n)}}else for(const h of u){const o=l?n.encodeAttributes(h,i,e):null,a=f&&s?r.encodeAttributes(h,i,e):null,u=h.getGeometry(t);this._processFeature(u,f,e.outlineUsesFillColor,o,a,d)}},a.serialize=function(){let t=10;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const e=new Uint32Array(t),i=new Int32Array(e.buffer);let n=0;e[n++]=this.type,e[n++]=this.layerUIDs.length;for(let s=0;s<this.layerUIDs.length;s++)e[n++]=this.layerUIDs[s];e[n++]=this._fillIndexStart,e[n++]=this._fillIndexCount,e[n++]=this._outlineIndexStart,e[n++]=this._outlineIndexCount;const r=this._patternMap,l=r.size;if(e[n++]=l,l>0)for(const[s,[o,a]]of r)e[n++]=s,e[n++]=o,e[n++]=a;e[n++]=this._fillVertexBuffer.array.length;for(let s=0;s<this._fillVertexBuffer.array.length;s++)i[n++]=this._fillVertexBuffer.array[s];e[n++]=this._fillIndexBuffer.array.length;for(let s=0;s<this._fillIndexBuffer.array.length;s++)e[n++]=this._fillIndexBuffer.array[s];e[n++]=this._outlineVertexBuffer.array.length;for(let s=0;s<this._outlineVertexBuffer.array.length;s++)i[n++]=this._outlineVertexBuffer.array[s];e[n++]=this._outlineIndexBuffer.array.length;for(let s=0;s<this._outlineIndexBuffer.array.length;s++)e[n++]=this._outlineIndexBuffer.array[s];return e.buffer},a._processFeature=function(t,e,i,n,r,l,s){if(!t)return;const a=t.length,f=!r||0===r.length;if(e&&(!i||f))for(let o=0;o<a;o++)this._processOutline(t[o],r);const u=32;let d;for(let h=0;h<a;h++){const e=o._area(t[h]);e>u?(void 0!==d&&this._processFill(t,d,n,l,s),d=[h]):e<-u&&void 0!==d&&d.push(h)}void 0!==d&&this._processFill(t,d,n,l,s)},a._processOutline=function(t,e){const i=this._outlineVertexBuffer,n=this._outlineIndexBuffer,l=n.index;let s,o,a;const f=new r.Point(0,0),u=new r.Point(0,0),d=new r.Point(0,0);let h=-1,x=-1,c=-1,y=-1,_=-1,g=!1;const p=0;let I=t.length;if(I<2)return;const B=t[p];let V=t[I-1];for(;I&&V.isEqual(B);)--I,V=t[I-1];if(!(I-p<2)){for(let r=p;r<I;++r){r===p?(s=t[I-1],o=t[p],a=t[p+1],f.assignSub(o,s),f.normalize(),f.rightPerpendicular()):(s=o,o=a,a=r!==I-1?t[r+1]:t[p],f.assign(u));const l=this._isClipEdge(s,o);-1===y&&(g=l),u.assignSub(a,o),u.normalize(),u.rightPerpendicular();const B=f.x*u.y-f.y*u.x;d.assignAdd(f,u),d.normalize();const V=-d.x*-f.x+-d.y*-f.y;let C=Math.abs(0!==V?1/V:1);C>8&&(C=8),B>=0?(c=i.add(o.x,o.y,f.x,f.y,0,1,e),-1===y&&(y=c),h>=0&&x>=0&&c>=0&&!l&&n.add(h,x,c),x=i.add(o.x,o.y,C*-d.x,C*-d.y,0,-1,e),-1===_&&(_=x),h>=0&&x>=0&&c>=0&&!l&&n.add(h,x,c),h=x,x=c,c=i.add(o.x,o.y,d.x,d.y,0,1,e),h>=0&&x>=0&&c>=0&&!l&&n.add(h,x,c),x=i.add(o.x,o.y,u.x,u.y,0,1,e),h>=0&&x>=0&&c>=0&&!l&&n.add(h,x,c)):(c=i.add(o.x,o.y,C*d.x,C*d.y,0,1,e),-1===y&&(y=c),h>=0&&x>=0&&c>=0&&!l&&n.add(h,x,c),x=i.add(o.x,o.y,-f.x,-f.y,0,-1,e),-1===_&&(_=x),h>=0&&x>=0&&c>=0&&!l&&n.add(h,x,c),h=x,x=c,c=i.add(o.x,o.y,-d.x,-d.y,0,-1,e),h>=0&&x>=0&&c>=0&&!l&&n.add(h,x,c),h=i.add(o.x,o.y,-u.x,-u.y,0,-1,e),h>=0&&x>=0&&c>=0&&!l&&n.add(h,x,c))}h>=0&&x>=0&&y>=0&&!g&&n.add(h,x,y),h>=0&&y>=0&&_>=0&&!g&&n.add(h,_,y),this._outlineIndexCount+=3*(n.index-l)}},a._processFill=function(t,r,l,s,o){s=!0;let a;r.length>1&&(a=[]);let f=0;for(const e of r)0!==f&&a.push(f),f+=t[e].length;const u=2*f,d=e.acquire();for(const e of r){const i=t[e],n=i.length;for(let t=0;t<n;++t)d.push(i[t].x,i[t].y)}const h=i.earcut(d,a,2);if(s&&i.earcut.deviation(d,a,2,h)>0){const e=r.map((e=>t[e].length)),{buffer:i,vertexCount:s}=n.triangulate(d,e);if(s>0){const t=this._fillVertexBuffer.index;for(let e=0;e<s;e++)this._fillVertexBuffer.add(i[2*e],i[2*e+1],l);for(let e=0;e<s;e+=3){const i=t+e;this._fillIndexBuffer.add(i,i+1,i+2)}if(void 0!==o){const t=this._patternMap,e=t.get(o);e?e[1]+=s:t.set(o,[this._fillIndexStart+this._fillIndexCount,s])}this._fillIndexCount+=s}}else{const t=h.length;if(t>0){const e=this._fillVertexBuffer.index;let i=0;for(;i<u;)this._fillVertexBuffer.add(d[i++],d[i++],l);let n=0;for(;n<t;)this._fillIndexBuffer.add(e+h[n++],e+h[n++],e+h[n++]);if(void 0!==o){const e=this._patternMap,i=e.get(o);i?i[1]+=t:e.set(o,[this._fillIndexStart+this._fillIndexCount,t])}this._fillIndexCount+=t}}e.release(d)},a._isClipEdge=function(t,e){return t.x===e.x?t.x<=-64||t.x>=4160:t.y===e.y&&(t.y<=-64||t.y>=4160)},o._area=function(t){let e=0;const i=t.length-1;for(let n=0;n<i;n++)e+=(t[n].x-t[n+1].x)*(t[n].y+t[n+1].y);return e+=(t[i].x-t[0].x)*(t[i].y+t[0].y),.5*e},t._createClass(o,[{key:"fillIndexStart",get:function(){return this._fillIndexStart}},{key:"fillIndexCount",get:function(){return this._fillIndexCount}},{key:"outlineIndexStart",get:function(){return this._outlineIndexStart}},{key:"outlineIndexCount",get:function(){return this._outlineIndexCount}}]),o}(s)}));
