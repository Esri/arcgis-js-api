/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["../../../../../chunks/_rollupPluginBabelHelpers","../../../../../core/ArrayPool","../../../../../chunks/earcut","./BaseBucket","../../webgl/Geometry","../../webgl/mesh/Tesselator"],(function(t,e,n,i,l,r){"use strict";const o=new r;function s(t,e,n,i){let l,r;o.beginPolygon(t,e);for(const s of i){const t=n[s];if(!(t.length<3)){o.beginContour();for(let e=0;e<t.length;++e){l=t[e].x,r=t[e].y;const n=[l,r,0];o.addVertex(n,n)}o.endContour()}}o.endPolygon()}return function(i){function r(t,e,n,l,r,o,s){var a;return(a=i.call(this,t,e,n)||this).type=1,a._patternMap=new Map,a._fillVertexBuffer=l,a._fillIndexBuffer=r,a._outlineVertexBuffer=o,a._outlineIndexBuffer=s,a}t._inheritsLoose(r,i);var o=r.prototype;return o.getResources=function(t,e,n){const i=this.layer,l=this.zoom,r=i.getPaintProperty("fill-pattern");if(r)if(r.isDataDriven)for(const o of this._features)e.add({name:r.getValue(l,o),repeat:!0});else e.add({name:r.getValue(l),repeat:!0})},o.processFeatures=function(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const e=this.layer,n=this.zoom,{fillMaterial:i,outlineMaterial:l,hasDataDrivenFill:r,hasDataDrivenOutline:o}=e;t&&t.setExtent(this.layerExtent);const s=e.getPaintProperty("fill-pattern"),a=null==s?void 0:s.isDataDriven;let f=!s&&e.getPaintValue("fill-antialias",n);if(e.outlineUsesFillColor){if(f&&!e.hasDataDrivenOpacity){const t=e.getPaintValue("fill-opacity",n),i=e.getPaintValue("fill-opacity",n+1);t<1&&i<1&&(f=!1)}if(f&&!e.hasDataDrivenColor){const t=e.getPaintValue("fill-color",n),i=e.getPaintValue("fill-color",n+1);t[3]<1&&i[3]<1&&(f=!1)}}const u=this._features,d=null==t?void 0:t.validateTessellation;if(a){const r=[];for(const a of u){const u=s.getValue(n,a),h=this._spriteInfo[u];if(!h||!h.rect)continue;const c=i.encodeAttributes(a,n,e,h),x=f&&o?l.encodeAttributes(a,n,e):[],y=a.getGeometry(t);r.push({ddFillAttributes:c,ddOutlineAttributes:x,page:h.page,geometry:y}),r.sort(((t,e)=>t.page-e.page));for(const{ddFillAttributes:t,ddOutlineAttributes:n,page:i,geometry:l}of r)this._processFeature(l,f,e.outlineUsesFillColor,t,n,d,i)}}else for(const h of u){const s=r?i.encodeAttributes(h,n,e):null,a=f&&o?l.encodeAttributes(h,n,e):null,u=h.getGeometry(t);this._processFeature(u,f,e.outlineUsesFillColor,s,a,d)}},o.serialize=function(){let t=10;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const e=new Uint32Array(t),n=new Int32Array(e.buffer);let i=0;e[i++]=this.type,e[i++]=this.layerUIDs.length;for(let o=0;o<this.layerUIDs.length;o++)e[i++]=this.layerUIDs[o];e[i++]=this._fillIndexStart,e[i++]=this._fillIndexCount,e[i++]=this._outlineIndexStart,e[i++]=this._outlineIndexCount;const l=this._patternMap,r=l.size;if(e[i++]=r,r>0)for(const[o,[s,a]]of l)e[i++]=o,e[i++]=s,e[i++]=a;e[i++]=this._fillVertexBuffer.array.length;for(let o=0;o<this._fillVertexBuffer.array.length;o++)n[i++]=this._fillVertexBuffer.array[o];e[i++]=this._fillIndexBuffer.array.length;for(let o=0;o<this._fillIndexBuffer.array.length;o++)e[i++]=this._fillIndexBuffer.array[o];e[i++]=this._outlineVertexBuffer.array.length;for(let o=0;o<this._outlineVertexBuffer.array.length;o++)n[i++]=this._outlineVertexBuffer.array[o];e[i++]=this._outlineIndexBuffer.array.length;for(let o=0;o<this._outlineIndexBuffer.array.length;o++)e[i++]=this._outlineIndexBuffer.array[o];return e.buffer},o._processFeature=function(t,e,n,i,l,o,s){if(!t)return;const a=t.length,f=!l||0===l.length;if(e&&(!n||f))for(let r=0;r<a;r++)this._processOutline(t[r],l);const u=32;let d;for(let h=0;h<a;h++){const e=r._area(t[h]);e>u?(void 0!==d&&this._processFill(t,d,i,o,s),d=[h]):e<-u&&void 0!==d&&d.push(h)}void 0!==d&&this._processFill(t,d,i,o,s)},o._processOutline=function(t,e){const n=this._outlineVertexBuffer,i=this._outlineIndexBuffer,r=i.index;let o,s,a;const f=new l.Point(0,0),u=new l.Point(0,0),d=new l.Point(0,0);let h=-1,c=-1,x=-1,y=-1,g=-1,_=!1;const p=0;let I=t.length;if(I<2)return;const B=t[p];let V=t[I-1];for(;I&&V.isEqual(B);)--I,V=t[I-1];if(!(I-p<2)){for(let l=p;l<I;++l){l===p?(o=t[I-1],s=t[p],a=t[p+1],f.assignSub(s,o),f.normalize(),f.rightPerpendicular()):(o=s,s=a,a=l!==I-1?t[l+1]:t[p],f.assign(u));const r=this._isClipEdge(o,s);-1===y&&(_=r),u.assignSub(a,s),u.normalize(),u.rightPerpendicular();const B=f.x*u.y-f.y*u.x;d.assignAdd(f,u),d.normalize();const V=-d.x*-f.x+-d.y*-f.y;let C=Math.abs(0!==V?1/V:1);C>8&&(C=8),B>=0?(x=n.add(s.x,s.y,f.x,f.y,0,1,e),-1===y&&(y=x),h>=0&&c>=0&&x>=0&&!r&&i.add(h,c,x),c=n.add(s.x,s.y,C*-d.x,C*-d.y,0,-1,e),-1===g&&(g=c),h>=0&&c>=0&&x>=0&&!r&&i.add(h,c,x),h=c,c=x,x=n.add(s.x,s.y,d.x,d.y,0,1,e),h>=0&&c>=0&&x>=0&&!r&&i.add(h,c,x),c=n.add(s.x,s.y,u.x,u.y,0,1,e),h>=0&&c>=0&&x>=0&&!r&&i.add(h,c,x)):(x=n.add(s.x,s.y,C*d.x,C*d.y,0,1,e),-1===y&&(y=x),h>=0&&c>=0&&x>=0&&!r&&i.add(h,c,x),c=n.add(s.x,s.y,-f.x,-f.y,0,-1,e),-1===g&&(g=c),h>=0&&c>=0&&x>=0&&!r&&i.add(h,c,x),h=c,c=x,x=n.add(s.x,s.y,-d.x,-d.y,0,-1,e),h>=0&&c>=0&&x>=0&&!r&&i.add(h,c,x),h=n.add(s.x,s.y,-u.x,-u.y,0,-1,e),h>=0&&c>=0&&x>=0&&!r&&i.add(h,c,x))}h>=0&&c>=0&&y>=0&&!_&&i.add(h,c,y),h>=0&&y>=0&&g>=0&&!_&&i.add(h,g,y),this._outlineIndexCount+=3*(i.index-r)}},o._processFill=function(t,i,l,r,o){r=!0;let a;i.length>1&&(a=[]);let f=0;for(const e of i)0!==f&&a.push(f),f+=t[e].length;const u=2*f,d=e.acquire();for(const e of i){const n=t[e],i=n.length;for(let t=0;t<i;++t)d.push(n[t].x,n[t].y)}const h=n.earcut(d,a,2);if(r&&n.earcut.deviation(d,a,2,h)>0){const e=[],n=[];if(s(e,n,t,i),n.length>0){const t=this._fillVertexBuffer.index;let i=0;for(;i<e.length;)this._fillVertexBuffer.add(e[i++],e[i++],l);let r=0;for(;r<n.length;)this._fillIndexBuffer.add(t+n[r+0],t+n[r+1],t+n[r+2]),r+=3;if(void 0!==o){const t=this._patternMap,e=t.get(o);e?e[1]+=n.length:t.set(o,[this._fillIndexStart+this._fillIndexCount,n.length])}this._fillIndexCount+=n.length}}else{const t=h.length;if(t>0){const e=this._fillVertexBuffer.index;let n=0;for(;n<u;)this._fillVertexBuffer.add(d[n++],d[n++],l);let i=0;for(;i<t;)this._fillIndexBuffer.add(e+h[i++],e+h[i++],e+h[i++]);if(void 0!==o){const e=this._patternMap,n=e.get(o);n?n[1]+=t:e.set(o,[this._fillIndexStart+this._fillIndexCount,t])}this._fillIndexCount+=t}}e.release(d)},o._isClipEdge=function(t,e){return t.x===e.x?t.x<=-64||t.x>=4160:t.y===e.y&&(t.y<=-64||t.y>=4160)},r._area=function(t){let e=0;const n=t.length-1;for(let i=0;i<n;i++)e+=(t[i].x-t[i+1].x)*(t[i].y+t[i+1].y);return e+=(t[n].x-t[0].x)*(t[n].y+t[0].y),.5*e},t._createClass(r,[{key:"fillIndexStart",get:function(){return this._fillIndexStart}},{key:"fillIndexCount",get:function(){return this._fillIndexCount}},{key:"outlineIndexStart",get:function(){return this._outlineIndexStart}},{key:"outlineIndexCount",get:function(){return this._outlineIndexCount}}]),r}(i)}));
