/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["../../../../../chunks/_rollupPluginBabelHelpers","../../../../../core/ArrayPool","../../../../../core/libs/earcut/earcut","../../webgl/Geometry","../../webgl/mesh/Tesselator","./BaseBucket"],(function(e,t,n,l,i,r){"use strict";const o=new i;function s(e,t,n,l){let i,r;o.beginPolygon(e,t);for(const s of l){const e=n[s];if(!(e.length<3)){o.beginContour();for(let t=0;t<e.length;++t){i=e[t].x,r=e[t].y;const n=[i,r,0];o.addVertex(n,n)}o.endContour()}}o.endPolygon()}return function(i){function r(e,t,n,l,r,o){var s;return(s=i.call(this,e,t)||this).type=1,s._fillVertexBuffer=n,s._fillIndexBuffer=l,s._outlineVertexBuffer=r,s._outlineIndexBuffer=o,s}e._inheritsLoose(r,i);var o=r.prototype;return o.processFeatures=function(e){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const t=this.layer,n=this.zoom;e&&e.setExtent(this.layerExtent);let l=void 0===t.getPaintValue("fill-pattern",n)&&t.getPaintValue("fill-antialias",n);if(t.outlineUsesFillColor){if(l&&!t.hasDataDrivenOpacity){const e=t.getPaintValue("fill-opacity",n),i=t.getPaintValue("fill-opacity",n+1);e<1&&i<1&&(l=!1)}if(l&&!t.hasDataDrivenColor){const e=t.getPaintValue("fill-color",n),i=t.getPaintValue("fill-color",n+1);e[3]<1&&i[3]<1&&(l=!1)}}const{fillMaterial:i,outlineMaterial:r,hasDataDrivenFill:o,hasDataDrivenOutline:s}=t;for(const f of this._features){const a=o?i.encodeAttributes(f,n,t):null,u=l&&s?r.encodeAttributes(f,n,t):null,d=f.getGeometry(e),h=null==e?void 0:e.validateTessellation;this._processFeature(d,l,t.outlineUsesFillColor,a,u,h)}},o.serialize=function(){let e=10;e+=this.layerUIDs.length,e+=this._fillVertexBuffer.array.length,e+=this._fillIndexBuffer.array.length,e+=this._outlineVertexBuffer.array.length,e+=this._outlineIndexBuffer.array.length;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let l=0;t[l++]=this.type,t[l++]=this.layerUIDs.length;for(let i=0;i<this.layerUIDs.length;i++)t[l++]=this.layerUIDs[i];t[l++]=this._fillIndexStart,t[l++]=this._fillIndexCount,t[l++]=this._outlineIndexStart,t[l++]=this._outlineIndexCount,t[l++]=this._fillVertexBuffer.array.length;for(let i=0;i<this._fillVertexBuffer.array.length;i++)n[l++]=this._fillVertexBuffer.array[i];t[l++]=this._fillIndexBuffer.array.length;for(let i=0;i<this._fillIndexBuffer.array.length;i++)t[l++]=this._fillIndexBuffer.array[i];t[l++]=this._outlineVertexBuffer.array.length;for(let i=0;i<this._outlineVertexBuffer.array.length;i++)n[l++]=this._outlineVertexBuffer.array[i];t[l++]=this._outlineIndexBuffer.array.length;for(let i=0;i<this._outlineIndexBuffer.array.length;i++)t[l++]=this._outlineIndexBuffer.array[i];return t.buffer},o._processFeature=function(e,t,n,l,i,o){if(!e)return;const s=e.length,f=!i||0===i.length;if(t&&(!n||f))for(let r=0;r<s;r++)this._processOutline(e[r],i);const a=128;let u;for(let d=0;d<s;d++){const t=r._area(e[d]);t>a?(void 0!==u&&this._processFill(e,u,l,o),u=[d]):t<-a&&void 0!==u&&u.push(d)}void 0!==u&&this._processFill(e,u,l,o)},o._processOutline=function(e,t){const n=this._outlineVertexBuffer,i=this._outlineIndexBuffer,r=i.index;let o,s,f;const a=new l.Point(0,0),u=new l.Point(0,0),d=new l.Point(0,0);let h=-1,x=-1,c=-1,y=-1,_=-1,g=!1;const I=0;let B=e.length;if(B<2)return;const p=e[I];let V=e[B-1];for(;B&&V.isEqual(p);)--B,V=e[B-1];if(!(B-I<2)){for(let l=I;l<B;++l){l===I?(o=e[B-1],s=e[I],f=e[I+1],a.assignSub(s,o),a.normalize(),a.rightPerpendicular()):(o=s,s=f,f=l!==B-1?e[l+1]:e[I],a.assign(u));const r=this._isClipEdge(o,s);-1===y&&(g=r),u.assignSub(f,s),u.normalize(),u.rightPerpendicular();const p=a.x*u.y-a.y*u.x;d.assignAdd(a,u),d.normalize();const V=-d.x*-a.x+-d.y*-a.y;let C=Math.abs(0!==V?1/V:1);C>8&&(C=8),p>=0?(c=n.add(s.x,s.y,a.x,a.y,0,1,t),-1===y&&(y=c),h>=0&&x>=0&&c>=0&&!r&&i.add(h,x,c),x=n.add(s.x,s.y,C*-d.x,C*-d.y,0,-1,t),-1===_&&(_=x),h>=0&&x>=0&&c>=0&&!r&&i.add(h,x,c),h=x,x=c,c=n.add(s.x,s.y,d.x,d.y,0,1,t),h>=0&&x>=0&&c>=0&&!r&&i.add(h,x,c),x=n.add(s.x,s.y,u.x,u.y,0,1,t),h>=0&&x>=0&&c>=0&&!r&&i.add(h,x,c)):(c=n.add(s.x,s.y,C*d.x,C*d.y,0,1,t),-1===y&&(y=c),h>=0&&x>=0&&c>=0&&!r&&i.add(h,x,c),x=n.add(s.x,s.y,-a.x,-a.y,0,-1,t),-1===_&&(_=x),h>=0&&x>=0&&c>=0&&!r&&i.add(h,x,c),h=x,x=c,c=n.add(s.x,s.y,-d.x,-d.y,0,-1,t),h>=0&&x>=0&&c>=0&&!r&&i.add(h,x,c),h=n.add(s.x,s.y,-u.x,-u.y,0,-1,t),h>=0&&x>=0&&c>=0&&!r&&i.add(h,x,c))}h>=0&&x>=0&&y>=0&&!g&&i.add(h,x,y),h>=0&&y>=0&&_>=0&&!g&&i.add(h,_,y),this._outlineIndexCount+=3*(i.index-r)}},o._processFill=function(e,l,i,r){let o;l.length>1&&(o=[]);let f=0;for(const t of l)0!==f&&o.push(f),f+=e[t].length;const a=2*f,u=t.acquire();for(const t of l){const n=e[t],l=n.length;for(let e=0;e<l;++e)u.push(n[e].x,n[e].y)}const d=n.earcut(u,o,2);if(r&&n.deviation(u,o,2,d)>0){const t=[],n=[];if(s(t,n,e,l),n.length>0){const e=this._fillVertexBuffer.index;let l=0;for(;l<t.length;)this._fillVertexBuffer.add(t[l++],t[l++],i);let r=0;for(;r<n.length;)this._fillIndexBuffer.add(e+n[r+0],e+n[r+1],e+n[r+2]),r+=3;this._fillIndexCount+=n.length}}else{const e=d.length;if(e>0){const t=this._fillVertexBuffer.index;let n=0;for(;n<a;)this._fillVertexBuffer.add(u[n++],u[n++],i);let l=0;for(;l<e;)this._fillIndexBuffer.add(t+d[l++],t+d[l++],t+d[l++]);this._fillIndexCount+=e}}t.release(u)},o._isClipEdge=function(e,t){return e.x===t.x?e.x<=-64||e.x>=4160:e.y===t.y&&(e.y<=-64||e.y>=4160)},r._area=function(e){let t=0;const n=e.length-1;for(let l=0;l<n;l++)t+=(e[l].x-e[l+1].x)*(e[l].y+e[l+1].y);return t+=(e[n].x-e[0].x)*(e[n].y+e[0].y),.5*t},e._createClass(r,[{key:"fillIndexStart",get:function(){return this._fillIndexStart}},{key:"fillIndexCount",get:function(){return this._fillIndexCount}},{key:"outlineIndexStart",get:function(){return this._outlineIndexStart}},{key:"outlineIndexCount",get:function(){return this._outlineIndexCount}}]),r}(r)}));
