/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["../../../../../chunks/_rollupPluginBabelHelpers","../../../../../core/ArrayPool","../../../../../chunks/earcut","../../../../../geometry/libtess","../enums","./BaseBucket","../../webgl/Geometry"],(function(t,e,i,n,l,r,s){"use strict";return function(r){function o(t,e,i,n,s,o,a){var f;return(f=r.call(this,t,e,i)||this).type=l.BucketType.FILL,f._patternMap=new Map,f._fillVertexBuffer=n,f._fillIndexBuffer=s,f._outlineVertexBuffer=o,f._outlineIndexBuffer=a,f}t._inheritsLoose(o,r);var a=o.prototype;return a.getResources=function(t,e,i){const n=this.layer,l=this.zoom,r=n.getPaintProperty("fill-pattern");if(r)if(r.isDataDriven)for(const s of this._features)e(r.getValue(l,s),!0);else e(r.getValue(l),!0)},a.processFeatures=function(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const e=this.layer,i=this.zoom,{fillMaterial:n,outlineMaterial:l,hasDataDrivenFill:r,hasDataDrivenOutline:s}=e;t&&t.setExtent(this.layerExtent);const o=e.getPaintProperty("fill-pattern"),a=null==o?void 0:o.isDataDriven;let f=!o&&e.getPaintValue("fill-antialias",i);if(e.outlineUsesFillColor){if(f&&!e.hasDataDrivenOpacity){const t=e.getPaintValue("fill-opacity",i),n=e.getPaintValue("fill-opacity",i+1);t<1&&n<1&&(f=!1)}if(f&&!e.hasDataDrivenColor){const t=e.getPaintValue("fill-color",i),n=e.getPaintValue("fill-color",i+1);t[3]<1&&n[3]<1&&(f=!1)}}const u=this._features,d=null==t?void 0:t.validateTessellation;if(a){const r=[];for(const a of u){const u=o.getValue(i,a),h=this._spriteInfo[u];if(!h||!h.rect)continue;const x=n.encodeAttributes(a,i,e,h),c=f&&s?l.encodeAttributes(a,i,e):[],y=a.getGeometry(t);r.push({ddFillAttributes:x,ddOutlineAttributes:c,page:h.page,geometry:y}),r.sort(((t,e)=>t.page-e.page));for(const{ddFillAttributes:t,ddOutlineAttributes:i,page:n,geometry:l}of r)this._processFeature(l,f,e.outlineUsesFillColor,t,i,d,n)}}else for(const h of u){const o=r?n.encodeAttributes(h,i,e):null,a=f&&s?l.encodeAttributes(h,i,e):null,u=h.getGeometry(t);this._processFeature(u,f,e.outlineUsesFillColor,o,a,d)}},a.serialize=function(){let t=10;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const e=new Uint32Array(t),i=new Int32Array(e.buffer);let n=0;e[n++]=this.type,e[n++]=this.layerUIDs.length;for(let s=0;s<this.layerUIDs.length;s++)e[n++]=this.layerUIDs[s];e[n++]=this._fillIndexStart,e[n++]=this._fillIndexCount,e[n++]=this._outlineIndexStart,e[n++]=this._outlineIndexCount;const l=this._patternMap,r=l.size;if(e[n++]=r,r>0)for(const[s,[o,a]]of l)e[n++]=s,e[n++]=o,e[n++]=a;e[n++]=this._fillVertexBuffer.array.length;for(let s=0;s<this._fillVertexBuffer.array.length;s++)i[n++]=this._fillVertexBuffer.array[s];e[n++]=this._fillIndexBuffer.array.length;for(let s=0;s<this._fillIndexBuffer.array.length;s++)e[n++]=this._fillIndexBuffer.array[s];e[n++]=this._outlineVertexBuffer.array.length;for(let s=0;s<this._outlineVertexBuffer.array.length;s++)i[n++]=this._outlineVertexBuffer.array[s];e[n++]=this._outlineIndexBuffer.array.length;for(let s=0;s<this._outlineIndexBuffer.array.length;s++)e[n++]=this._outlineIndexBuffer.array[s];return e.buffer},a._processFeature=function(t,e,i,n,l,r,s){if(!t)return;const a=t.length,f=!l||0===l.length;if(e&&(!i||f))for(let o=0;o<a;o++)this._processOutline(t[o],l);const u=32;let d;for(let h=0;h<a;h++){const e=o._area(t[h]);e>u?(void 0!==d&&this._processFill(t,d,n,r,s),d=[h]):e<-u&&void 0!==d&&d.push(h)}void 0!==d&&this._processFill(t,d,n,r,s)},a._processOutline=function(t,e){const i=this._outlineVertexBuffer,n=this._outlineIndexBuffer,l=n.index;let r,o,a;const f=new s.Point(0,0),u=new s.Point(0,0),d=new s.Point(0,0);let h=-1,x=-1,c=-1,y=-1,_=-1,g=!1;const p=0;let I=t.length;if(I<2)return;const B=t[p];let V=t[I-1];for(;I&&V.isEqual(B);)--I,V=t[I-1];if(!(I-p<2)){for(let l=p;l<I;++l){l===p?(r=t[I-1],o=t[p],a=t[p+1],f.assignSub(o,r),f.normalize(),f.rightPerpendicular()):(r=o,o=a,a=l!==I-1?t[l+1]:t[p],f.assign(u));const s=this._isClipEdge(r,o);-1===y&&(g=s),u.assignSub(a,o),u.normalize(),u.rightPerpendicular();const B=f.x*u.y-f.y*u.x;d.assignAdd(f,u),d.normalize();const V=-d.x*-f.x+-d.y*-f.y;let C=Math.abs(0!==V?1/V:1);C>8&&(C=8),B>=0?(c=i.add(o.x,o.y,f.x,f.y,0,1,e),-1===y&&(y=c),h>=0&&x>=0&&c>=0&&!s&&n.add(h,x,c),x=i.add(o.x,o.y,C*-d.x,C*-d.y,0,-1,e),-1===_&&(_=x),h>=0&&x>=0&&c>=0&&!s&&n.add(h,x,c),h=x,x=c,c=i.add(o.x,o.y,d.x,d.y,0,1,e),h>=0&&x>=0&&c>=0&&!s&&n.add(h,x,c),x=i.add(o.x,o.y,u.x,u.y,0,1,e),h>=0&&x>=0&&c>=0&&!s&&n.add(h,x,c)):(c=i.add(o.x,o.y,C*d.x,C*d.y,0,1,e),-1===y&&(y=c),h>=0&&x>=0&&c>=0&&!s&&n.add(h,x,c),x=i.add(o.x,o.y,-f.x,-f.y,0,-1,e),-1===_&&(_=x),h>=0&&x>=0&&c>=0&&!s&&n.add(h,x,c),h=x,x=c,c=i.add(o.x,o.y,-d.x,-d.y,0,-1,e),h>=0&&x>=0&&c>=0&&!s&&n.add(h,x,c),h=i.add(o.x,o.y,-u.x,-u.y,0,-1,e),h>=0&&x>=0&&c>=0&&!s&&n.add(h,x,c))}h>=0&&x>=0&&y>=0&&!g&&n.add(h,x,y),h>=0&&y>=0&&_>=0&&!g&&n.add(h,_,y),this._outlineIndexCount+=3*(n.index-l)}},a._processFill=function(t,l,r,s,o){s=!0;let a;l.length>1&&(a=[]);let f=0;for(const e of l)0!==f&&a.push(f),f+=t[e].length;const u=2*f,d=e.acquire();for(const e of l){const i=t[e],n=i.length;for(let t=0;t<n;++t)d.push(i[t].x,i[t].y)}const h=i.earcut(d,a,2);if(s&&i.earcut.deviation(d,a,2,h)>0){const e=l.map((e=>t[e].length)),{buffer:i,vertexCount:s}=n.triangulate(d,e);if(s>0){const t=this._fillVertexBuffer.index;for(let e=0;e<s;e++)this._fillVertexBuffer.add(i[2*e],i[2*e+1],r);for(let e=0;e<s;e+=3){const i=t+e;this._fillIndexBuffer.add(i,i+1,i+2)}if(void 0!==o){const t=this._patternMap,e=t.get(o);e?e[1]+=s:t.set(o,[this._fillIndexStart+this._fillIndexCount,s])}this._fillIndexCount+=s}}else{const t=h.length;if(t>0){const e=this._fillVertexBuffer.index;let i=0;for(;i<u;)this._fillVertexBuffer.add(d[i++],d[i++],r);let n=0;for(;n<t;)this._fillIndexBuffer.add(e+h[n++],e+h[n++],e+h[n++]);if(void 0!==o){const e=this._patternMap,i=e.get(o);i?i[1]+=t:e.set(o,[this._fillIndexStart+this._fillIndexCount,t])}this._fillIndexCount+=t}}e.release(d)},a._isClipEdge=function(t,e){return t.x===e.x?t.x<=-64||t.x>=4160:t.y===e.y&&(t.y<=-64||t.y>=4160)},o._area=function(t){let e=0;const i=t.length-1;for(let n=0;n<i;n++)e+=(t[n].x-t[n+1].x)*(t[n].y+t[n+1].y);return e+=(t[i].x-t[0].x)*(t[i].y+t[0].y),.5*e},t._createClass(o,[{key:"fillIndexStart",get:function(){return this._fillIndexStart}},{key:"fillIndexCount",get:function(){return this._fillIndexCount}},{key:"outlineIndexStart",get:function(){return this._outlineIndexStart}},{key:"outlineIndexCount",get:function(){return this._outlineIndexCount}}]),o}(r)}));
