/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t,unwrap as r}from"../../../../core/maybe.js";import{BucketType as i}from"./enums.js";import{deserializeSymbols as s}from"./decluttering/util.js";import{BufferObject as n}from"../../../webgl/BufferObject.js";import{Usage as f}from"../../../webgl/enums.js";import{VertexArrayObject as o}from"../../../webgl/VertexArrayObject.js";class a{constructor(e,t){this.layerUIDs=[],this.isDestroyed=!1,this.data=e,this.memoryUsed=e.byteLength;let r=1;const i=new Uint32Array(e);this.layerUIDs=[];const s=i[r++];for(let n=0;n<s;n++)this.layerUIDs[n]=i[r++];this.bufferDataOffset=r,t&&(this.layer=t.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return e(this.data)}get offset(){return this.bufferDataOffset}destroy(){this.isDestroyed||(this.doDestroy(),this.isDestroyed=!0)}prepareForRendering(t){e(this.data)||(this.doPrepareForRendering(t,this.data,this.bufferDataOffset),this.data=null)}}class l extends a{constructor(e,t){super(e,t),this.type=i.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const r=new Uint32Array(e);let s=this.bufferDataOffset;this.lineIndexStart=r[s++],this.lineIndexCount=r[s++];const n=r[s++];if(n>0){const e=new Map;for(let t=0;t<n;t++){const t=r[s++],i=r[s++],n=r[s++];e.set(t,[i,n])}this.patternMap=e}this.bufferDataOffset=s}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){t(this.lineVertexArrayObject)&&this.lineVertexArrayObject.dispose(),t(this.lineVertexBuffer)&&this.lineVertexBuffer.dispose(),t(this.lineIndexBuffer)&&this.lineIndexBuffer.dispose(),this.lineVertexArrayObject=null,this.lineVertexBuffer=null,this.lineIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(e,t,r){const i=new Uint32Array(t),s=new Int32Array(i.buffer),a=i[r++];this.lineVertexBuffer=n.createVertex(e,f.STATIC_DRAW,new Int32Array(s.buffer,4*r,a)),r+=a;const l=i[r++];this.lineIndexBuffer=n.createIndex(e,f.STATIC_DRAW,new Uint32Array(i.buffer,4*r,l)),r+=l;const u=this.layer.lineMaterial;this.lineVertexArrayObject=new o(e,u.getAttributeLocations(),u.getLayoutInfo(),{geometry:this.lineVertexBuffer},this.lineIndexBuffer)}}class u extends a{constructor(e,t){super(e,t),this.type=i.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const r=new Uint32Array(e);let s=this.bufferDataOffset;this.fillIndexStart=r[s++],this.fillIndexCount=r[s++],this.outlineIndexStart=r[s++],this.outlineIndexCount=r[s++];const n=r[s++];if(n>0){const e=new Map;for(let t=0;t<n;t++){const t=r[s++],i=r[s++],n=r[s++];e.set(t,[i,n])}this.patternMap=e}this.bufferDataOffset=s}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){t(this.fillVertexArrayObject)&&this.fillVertexArrayObject.dispose(),t(this.fillVertexBuffer)&&this.fillVertexBuffer.dispose(),t(this.fillIndexBuffer)&&this.fillIndexBuffer.dispose(),this.fillVertexArrayObject=null,this.fillVertexBuffer=null,this.fillIndexBuffer=null,t(this.outlineVertexArrayObject)&&this.outlineVertexArrayObject.dispose(),t(this.outlineVertexBuffer)&&this.outlineVertexBuffer.dispose(),t(this.outlineIndexBuffer)&&this.outlineIndexBuffer.dispose(),this.outlineVertexArrayObject=null,this.outlineVertexBuffer=null,this.outlineIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(e,t,r){const i=new Uint32Array(t),s=new Int32Array(i.buffer),a=i[r++];this.fillVertexBuffer=n.createVertex(e,f.STATIC_DRAW,new Int32Array(s.buffer,4*r,a)),r+=a;const l=i[r++];this.fillIndexBuffer=n.createIndex(e,f.STATIC_DRAW,new Uint32Array(i.buffer,4*r,l)),r+=l;const u=i[r++];this.outlineVertexBuffer=n.createVertex(e,f.STATIC_DRAW,new Int32Array(s.buffer,4*r,u)),r+=u;const h=i[r++];this.outlineIndexBuffer=n.createIndex(e,f.STATIC_DRAW,new Uint32Array(i.buffer,4*r,h)),r+=h;const c=this.layer,x=c.fillMaterial,y=c.outlineMaterial;this.fillVertexArrayObject=new o(e,x.getAttributeLocations(),x.getLayoutInfo(),{geometry:this.fillVertexBuffer},this.fillIndexBuffer),this.outlineVertexArrayObject=new o(e,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:this.outlineVertexBuffer},this.outlineIndexBuffer)}}class h extends a{constructor(e,t,r){super(e,t),this.type=i.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const n=new Uint32Array(e),f=new Int32Array(e),o=new Float32Array(e);let a=this.bufferDataOffset;this.isIconSDF=!!n[a++];const l=n[a++];for(let i=0;i<l;i++){const e=n[a++],t=n[a++],r=n[a++];this.iconPerPageElementsMap.set(e,[t,r])}const u=n[a++];for(let i=0;i<u;i++){const e=n[a++],t=n[a++],r=n[a++];this.glyphPerPageElementsMap.set(e,[t,r])}const h=n[a++],c=n[a++];this.iconOpacity=new Int32Array(h),this.textOpacity=new Int32Array(c),a=s(n,f,o,a,this.symbols,r),this.bufferDataOffset=a}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const[t,r]of this.iconPerPageElementsMap)e+=r[1];for(const[t,r]of this.glyphPerPageElementsMap)e+=r[1];return e/3}doDestroy(){t(this.iconVertexArrayObject)&&this.iconVertexArrayObject.dispose(),t(this.iconVertexBuffer)&&this.iconVertexBuffer.dispose(),t(this.iconOpacityBuffer)&&this.iconOpacityBuffer.dispose(),t(this.iconIndexBuffer)&&this.iconIndexBuffer.dispose(),this.iconVertexArrayObject=null,this.iconVertexBuffer=null,this.iconOpacityBuffer=null,this.iconIndexBuffer=null,t(this.textVertexArrayObject)&&this.textVertexArrayObject.dispose(),t(this.textVertexBuffer)&&this.textVertexBuffer.dispose(),t(this.textOpacityBuffer)&&this.textOpacityBuffer.dispose(),t(this.textIndexBuffer)&&this.textIndexBuffer.dispose(),this.textVertexArrayObject=null,this.textVertexBuffer=null,this.textOpacityBuffer=null,this.textIndexBuffer=null,this.memoryUsed=0}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=r(this.iconOpacity),t=r(this.iconOpacityBuffer);e.length>0&&e.byteLength===t.size&&t.setSubData(e);const i=r(this.textOpacity),s=r(this.textOpacityBuffer);i.length>0&&i.byteLength===s.size&&s.setSubData(i)}doPrepareForRendering(e,t,i){const s=new Uint32Array(t),a=new Int32Array(s.buffer),l=s[i++];this.iconVertexBuffer=n.createVertex(e,f.STATIC_DRAW,new Int32Array(a.buffer,4*i,l)),i+=l;const u=s[i++];this.iconIndexBuffer=n.createIndex(e,f.STATIC_DRAW,new Uint32Array(s.buffer,4*i,u)),i+=u;const h=s[i++];this.textVertexBuffer=n.createVertex(e,f.STATIC_DRAW,new Int32Array(a.buffer,4*i,h)),i+=h;const c=s[i++];this.textIndexBuffer=n.createIndex(e,f.STATIC_DRAW,new Uint32Array(s.buffer,4*i,c)),i+=c,this.iconOpacityBuffer=n.createVertex(e,f.STATIC_DRAW,r(this.iconOpacity).buffer),this.textOpacityBuffer=n.createVertex(e,f.STATIC_DRAW,r(this.textOpacity).buffer);const x=this.layer,y=x.iconMaterial,d=x.textMaterial;this.iconVertexArrayObject=new o(e,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:this.iconVertexBuffer,opacity:this.iconOpacityBuffer},this.iconIndexBuffer),this.textVertexArrayObject=new o(e,d.getAttributeLocations(),d.getLayoutInfo(),{geometry:this.textVertexBuffer,opacity:this.textOpacityBuffer},this.textIndexBuffer)}}class c extends a{constructor(e,t){super(e,t),this.type=i.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const r=new Uint32Array(e);let s=this.bufferDataOffset;this.circleIndexStart=r[s++],this.circleIndexCount=r[s++],this.bufferDataOffset=s}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){t(this.circleVertexArrayObject)&&this.circleVertexArrayObject.dispose(),t(this.circleVertexBuffer)&&this.circleVertexBuffer.dispose(),t(this.circleIndexBuffer)&&this.circleIndexBuffer.dispose(),this.circleVertexArrayObject=null,this.circleVertexBuffer=null,this.circleIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(e,t,r){const i=new Uint32Array(t),s=new Int32Array(i.buffer),a=i[r++];this.circleVertexBuffer=n.createVertex(e,f.STATIC_DRAW,new Int32Array(s.buffer,4*r,a)),r+=a;const l=i[r++];this.circleIndexBuffer=n.createIndex(e,f.STATIC_DRAW,new Uint32Array(i.buffer,4*r,l)),r+=l;const u=this.layer.circleMaterial;this.circleVertexArrayObject=new o(e,u.getAttributeLocations(),u.getLayoutInfo(),{geometry:this.circleVertexBuffer},this.circleIndexBuffer)}}export{c as CircleRenderBucket,u as FillRenderBucket,l as LineRenderBucket,a as RenderBucketBase,h as SymbolRenderBucket};
