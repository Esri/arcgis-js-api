/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/maybe","./enums","./decluttering/util","../../../webgl/BufferObject","../../../webgl/enums","../../../webgl/VertexArrayObject"],(function(e,t,r,n,i,s,f,o){"use strict";let a=function(){function e(e,t){this.layerUIDs=[],this.isDestroyed=!1,this._data=e,this.memoryUsed=e.byteLength;let r=1;const n=new Uint32Array(e);this.layerUIDs=[];const i=n[r++];for(let s=0;s<i;s++)this.layerUIDs[s]=n[r++];this.bufferDataOffset=r,t&&(this.layer=t.getStyleLayerByUID(this.layerUIDs[0]))}var n=e.prototype;return n.destroy=function(){this.isDestroyed||(this.doDestroy(),this.isDestroyed=!0)},n.prepareForRendering=function(e){r.isNone(this._data)||(this.doPrepareForRendering(e,this._data,this.bufferDataOffset),this._data=null)},t._createClass(e,[{key:"isPreparedForRendering",get:function(){return r.isNone(this._data)}},{key:"offset",get:function(){return this.bufferDataOffset}}]),e}(),u=function(e){function i(t,r){var i;(i=e.call(this,t,r)||this).type=n.BucketType.LINE,i.lineIndexStart=0,i.lineIndexCount=0;const s=new Uint32Array(t);let f=i.bufferDataOffset;i.lineIndexStart=s[f++],i.lineIndexCount=s[f++];const o=s[f++];if(o>0){const e=new Map;for(let t=0;t<o;t++){const t=s[f++],r=s[f++],n=s[f++];e.set(t,[r,n])}i.patternMap=e}return i.bufferDataOffset=f,i}t._inheritsLoose(i,e);var a=i.prototype;return a.hasData=function(){return this.lineIndexCount>0},a.triangleCount=function(){return this.lineIndexCount/3},a.doDestroy=function(){r.isSome(this.lineVertexArrayObject)&&this.lineVertexArrayObject.dispose(),r.isSome(this.lineVertexBuffer)&&this.lineVertexBuffer.dispose(),r.isSome(this.lineIndexBuffer)&&this.lineIndexBuffer.dispose(),this.lineVertexArrayObject=null,this.lineVertexBuffer=null,this.lineIndexBuffer=null,this.memoryUsed=0},a.doPrepareForRendering=function(e,t,r){const n=new Uint32Array(t),i=new Int32Array(n.buffer),a=n[r++];this.lineVertexBuffer=s.BufferObject.createVertex(e,f.Usage.STATIC_DRAW,new Int32Array(i.buffer,4*r,a)),r+=a;const u=n[r++];this.lineIndexBuffer=s.BufferObject.createIndex(e,f.Usage.STATIC_DRAW,new Uint32Array(n.buffer,4*r,u)),r+=u;const c=this.layer.lineMaterial;this.lineVertexArrayObject=new o.VertexArrayObject(e,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:this.lineVertexBuffer},this.lineIndexBuffer)},i}(a),c=function(e){function i(t,r){var i;(i=e.call(this,t,r)||this).type=n.BucketType.FILL,i.fillIndexStart=0,i.fillIndexCount=0,i.outlineIndexStart=0,i.outlineIndexCount=0;const s=new Uint32Array(t);let f=i.bufferDataOffset;i.fillIndexStart=s[f++],i.fillIndexCount=s[f++],i.outlineIndexStart=s[f++],i.outlineIndexCount=s[f++];const o=s[f++];if(o>0){const e=new Map;for(let t=0;t<o;t++){const t=s[f++],r=s[f++],n=s[f++];e.set(t,[r,n])}i.patternMap=e}return i.bufferDataOffset=f,i}t._inheritsLoose(i,e);var a=i.prototype;return a.hasData=function(){return this.fillIndexCount>0||this.outlineIndexCount>0},a.triangleCount=function(){return(this.fillIndexCount+this.outlineIndexCount)/3},a.doDestroy=function(){r.isSome(this.fillVertexArrayObject)&&this.fillVertexArrayObject.dispose(),r.isSome(this.fillVertexBuffer)&&this.fillVertexBuffer.dispose(),r.isSome(this.fillIndexBuffer)&&this.fillIndexBuffer.dispose(),this.fillVertexArrayObject=null,this.fillVertexBuffer=null,this.fillIndexBuffer=null,r.isSome(this.outlineVertexArrayObject)&&this.outlineVertexArrayObject.dispose(),r.isSome(this.outlineVertexBuffer)&&this.outlineVertexBuffer.dispose(),r.isSome(this.outlineIndexBuffer)&&this.outlineIndexBuffer.dispose(),this.outlineVertexArrayObject=null,this.outlineVertexBuffer=null,this.outlineIndexBuffer=null,this.memoryUsed=0},a.doPrepareForRendering=function(e,t,r){const n=new Uint32Array(t),i=new Int32Array(n.buffer),a=n[r++];this.fillVertexBuffer=s.BufferObject.createVertex(e,f.Usage.STATIC_DRAW,new Int32Array(i.buffer,4*r,a)),r+=a;const u=n[r++];this.fillIndexBuffer=s.BufferObject.createIndex(e,f.Usage.STATIC_DRAW,new Uint32Array(n.buffer,4*r,u)),r+=u;const c=n[r++];this.outlineVertexBuffer=s.BufferObject.createVertex(e,f.Usage.STATIC_DRAW,new Int32Array(i.buffer,4*r,c)),r+=c;const l=n[r++];this.outlineIndexBuffer=s.BufferObject.createIndex(e,f.Usage.STATIC_DRAW,new Uint32Array(n.buffer,4*r,l)),r+=l;const h=this.layer,x=h.fillMaterial,y=h.outlineMaterial;this.fillVertexArrayObject=new o.VertexArrayObject(e,x.getAttributeLocations(),x.getLayoutInfo(),{geometry:this.fillVertexBuffer},this.fillIndexBuffer),this.outlineVertexArrayObject=new o.VertexArrayObject(e,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:this.outlineVertexBuffer},this.outlineIndexBuffer)},i}(a),l=function(e){function a(t,r,s){var f;(f=e.call(this,t,r)||this).type=n.BucketType.SYMBOL,f.iconPerPageElementsMap=new Map,f.glyphPerPageElementsMap=new Map,f.symbolInstances=[],f.isIconSDF=!1,f.opacityChanged=!1,f.lastOpacityUpdate=0,f.symbols=[];const o=new Uint32Array(t),a=new Int32Array(t),u=new Float32Array(t);let c=f.bufferDataOffset;f.isIconSDF=!!o[c++];const l=o[c++];for(let e=0;e<l;e++){const e=o[c++],t=o[c++],r=o[c++];f.iconPerPageElementsMap.set(e,[t,r])}const h=o[c++];for(let e=0;e<h;e++){const e=o[c++],t=o[c++],r=o[c++];f.glyphPerPageElementsMap.set(e,[t,r])}const x=o[c++],y=o[c++];return f.iconOpacity=new Int32Array(x),f.textOpacity=new Int32Array(y),c=i.deserializeSymbols(o,a,u,c,f.symbols,s),f.bufferDataOffset=c,f}t._inheritsLoose(a,e);var u=a.prototype;return u.hasData=function(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0},u.triangleCount=function(){let e=0;for(const[t,r]of this.iconPerPageElementsMap)e+=r[1];for(const[t,r]of this.glyphPerPageElementsMap)e+=r[1];return e/3},u.doDestroy=function(){r.isSome(this.iconVertexArrayObject)&&this.iconVertexArrayObject.dispose(),r.isSome(this.iconVertexBuffer)&&this.iconVertexBuffer.dispose(),r.isSome(this.iconOpacityBuffer)&&this.iconOpacityBuffer.dispose(),r.isSome(this.iconIndexBuffer)&&this.iconIndexBuffer.dispose(),this.iconVertexArrayObject=null,this.iconVertexBuffer=null,this.iconOpacityBuffer=null,this.iconIndexBuffer=null,r.isSome(this.textVertexArrayObject)&&this.textVertexArrayObject.dispose(),r.isSome(this.textVertexBuffer)&&this.textVertexBuffer.dispose(),r.isSome(this.textOpacityBuffer)&&this.textOpacityBuffer.dispose(),r.isSome(this.textIndexBuffer)&&this.textIndexBuffer.dispose(),this.textVertexArrayObject=null,this.textVertexBuffer=null,this.textOpacityBuffer=null,this.textIndexBuffer=null,this.memoryUsed=0},u.updateOpacityInfo=function(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=r.unwrap(this.iconOpacity),t=r.unwrap(this.iconOpacityBuffer);e.length>0&&e.byteLength===t.size&&t.setSubData(e,0,0,e.length);const n=r.unwrap(this.textOpacity),i=r.unwrap(this.textOpacityBuffer);n.length>0&&n.byteLength===i.size&&i.setSubData(n,0,0,n.length)},u.doPrepareForRendering=function(e,t,n){const i=new Uint32Array(t),a=new Int32Array(i.buffer),u=i[n++];this.iconVertexBuffer=s.BufferObject.createVertex(e,f.Usage.STATIC_DRAW,new Int32Array(a.buffer,4*n,u)),n+=u;const c=i[n++];this.iconIndexBuffer=s.BufferObject.createIndex(e,f.Usage.STATIC_DRAW,new Uint32Array(i.buffer,4*n,c)),n+=c;const l=i[n++];this.textVertexBuffer=s.BufferObject.createVertex(e,f.Usage.STATIC_DRAW,new Int32Array(a.buffer,4*n,l)),n+=l;const h=i[n++];this.textIndexBuffer=s.BufferObject.createIndex(e,f.Usage.STATIC_DRAW,new Uint32Array(i.buffer,4*n,h)),n+=h,this.iconOpacityBuffer=s.BufferObject.createVertex(e,f.Usage.STATIC_DRAW,r.unwrap(this.iconOpacity).buffer),this.textOpacityBuffer=s.BufferObject.createVertex(e,f.Usage.STATIC_DRAW,r.unwrap(this.textOpacity).buffer);const x=this.layer,y=x.iconMaterial,d=x.textMaterial;this.iconVertexArrayObject=new o.VertexArrayObject(e,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:this.iconVertexBuffer,opacity:this.iconOpacityBuffer},this.iconIndexBuffer),this.textVertexArrayObject=new o.VertexArrayObject(e,d.getAttributeLocations(),d.getLayoutInfo(),{geometry:this.textVertexBuffer,opacity:this.textOpacityBuffer},this.textIndexBuffer)},a}(a),h=function(e){function i(t,r){var i;(i=e.call(this,t,r)||this).type=n.BucketType.CIRCLE,i.circleIndexStart=0,i.circleIndexCount=0;const s=new Uint32Array(t);let f=i.bufferDataOffset;return i.circleIndexStart=s[f++],i.circleIndexCount=s[f++],i.bufferDataOffset=f,i}t._inheritsLoose(i,e);var a=i.prototype;return a.hasData=function(){return this.circleIndexCount>0},a.triangleCount=function(){return this.circleIndexCount/3},a.doDestroy=function(){r.isSome(this.circleVertexArrayObject)&&this.circleVertexArrayObject.dispose(),r.isSome(this.circleVertexBuffer)&&this.circleVertexBuffer.dispose(),r.isSome(this.circleIndexBuffer)&&this.circleIndexBuffer.dispose(),this.circleVertexArrayObject=null,this.circleVertexBuffer=null,this.circleIndexBuffer=null,this.memoryUsed=0},a.doPrepareForRendering=function(e,t,r){const n=new Uint32Array(t),i=new Int32Array(n.buffer),a=n[r++];this.circleVertexBuffer=s.BufferObject.createVertex(e,f.Usage.STATIC_DRAW,new Int32Array(i.buffer,4*r,a)),r+=a;const u=n[r++];this.circleIndexBuffer=s.BufferObject.createIndex(e,f.Usage.STATIC_DRAW,new Uint32Array(n.buffer,4*r,u)),r+=u;const c=this.layer.circleMaterial;this.circleVertexArrayObject=new o.VertexArrayObject(e,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:this.circleVertexBuffer},this.circleIndexBuffer)},i}(a);e.CircleRenderBucket=h,e.FillRenderBucket=c,e.LineRenderBucket=u,e.RenderBucketBase=a,e.SymbolRenderBucket=l,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
