/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["../../../../chunks/_rollupPluginBabelHelpers","../../../../core/ArrayPool","../../../../core/libs/earcut/earcut","../webgl/Geometry","../webgl/mesh/Tesselator","./BaseBucket"],(function(e,t,i,n,l,r){"use strict";const o=new l;return function(l){function r(e,t,i,n,r,o){var a;if((a=l.call(this,e,t)||this).type=1,e.hasDataDrivenFill!==i.isDataDriven())throw new Error("incompatible fill buffer");if(e.hasDataDrivenOutline!==r.isDataDriven())throw new Error("incompatible outline buffer");return a._fillVertexBuffer=i,a._fillIndexBuffer=n,a._outlineVertexBuffer=r,a._outlineIndexBuffer=o,a}e._inheritsLoose(r,l);var a=r.prototype;return a.processFeatures=function(e){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const t=this.layer,i=this.zoom,n=t.hasDataDrivenFill,l=t.hasDataDrivenOutline;e&&e.setExtent(this.layerExtent);const r=t.getPaintValue("fill-pattern",i);let o=t.getPaintValue("fill-antialias",i)&&void 0===r,a=[1,1,1,1],f=[1,1,1,1],s=1;if(t.outlineUsesFillColor){if(o&&!t.hasDataDrivenOpacity){const e=t.getPaintValue("fill-opacity",i),n=t.getPaintValue("fill-opacity",i+1);e<1&&n<1&&(o=!1)}if(o&&!t.hasDataDrivenColor){const e=t.getPaintValue("fill-color",i),n=t.getPaintValue("fill-color",i+1);e[3]<1&&n[3]<1&&(o=!1)}}for(const u of this._features){let h,d;!r&&t.hasDataDrivenColor&&(a=t.getPaintValue("fill-color",i,u)),t.hasDataDrivenOpacity&&(s=t.getPaintValue("fill-opacity",i,u)),!r&&t.hasDataDrivenOutlineColor&&(f=t.getPaintValue("fill-outline-color",i,u)),n&&(h={color:a,opacity:s}),l&&(d={color:t.outlineUsesFillColor?a:f,opacity:s});const x=u.getGeometry(e),c=null==e?void 0:e.validateTessellation;this._processFeature(x,o,t.outlineUsesFillColor,h,d,c)}},a.serialize=function(){let e=12;e+=this.layerUIDs.length,e+=this._fillVertexBuffer.array.length,e+=this._fillIndexBuffer.array.length,e+=this._outlineVertexBuffer.array.length,e+=this._outlineIndexBuffer.array.length;let t=0;const i=new Uint32Array(e),n=new Int32Array(i.buffer);i[t++]=this.type,i[t++]=this.layerUIDs.length;for(let e=0;e<this.layerUIDs.length;e++)i[t++]=this.layerUIDs[e];i[t++]=this._fillIndexStart,i[t++]=this._fillIndexCount,i[t++]=this._outlineIndexStart,i[t++]=this._outlineIndexCount,i[t++]=this._fillVertexBuffer.isDataDriven()?1:0,i[t++]=this._outlineVertexBuffer.isDataDriven()?1:0,i[t++]=this._fillVertexBuffer.array.length;for(let e=0;e<this._fillVertexBuffer.array.length;e++)n[t++]=this._fillVertexBuffer.array[e];i[t++]=this._fillIndexBuffer.array.length;for(let e=0;e<this._fillIndexBuffer.array.length;e++)i[t++]=this._fillIndexBuffer.array[e];i[t++]=this._outlineVertexBuffer.array.length;for(let e=0;e<this._outlineVertexBuffer.array.length;e++)n[t++]=this._outlineVertexBuffer.array[e];i[t++]=this._outlineIndexBuffer.array.length;for(let e=0;e<this._outlineIndexBuffer.array.length;e++)i[t++]=this._outlineIndexBuffer.array[e];return i.buffer},a._processFeature=function(e,t,i,n,l,o){if(!e)return;const a=e.length;if(t&&(!i||!l||l.color[3]*l.opacity==1))for(let t=0;t<a;t++)this._processOutline(e[t],l);let f;for(let t=0;t<a;t++){const i=r._area(e[t]);i>128?(void 0!==f&&this._processFill(e,f,n,o),f=[t]):i<-128&&void 0!==f&&f.push(t)}void 0!==f&&this._processFill(e,f,n,o)},a._processOutline=function(e,t){const i=this._outlineVertexBuffer,l=this._outlineIndexBuffer,r=l.index;let o,a,f;const s=new n.Point(0,0),u=new n.Point(0,0),h=new n.Point(0,0);let d=-1,x=-1,c=-1,y=-1,_=-1,g=!1;let I=e.length;if(I<2)return;const B=e[0];let p=e[I-1];for(;I&&p.isEqual(B);)--I,p=e[I-1];if(!(I-0<2)){for(let n=0;n<I;++n){0===n?(o=e[I-1],a=e[0],f=e[1],s.assignSub(a,o),s.normalize(),s.rightPerpendicular()):(o=a,a=f,f=n!==I-1?e[n+1]:e[0],s.assign(u));const r=this._isClipEdge(o,a);-1===y&&(g=r),u.assignSub(f,a),u.normalize(),u.rightPerpendicular();const B=s.x*u.y-s.y*u.x;h.assignAdd(s,u),h.normalize();const p=-h.x*-s.x+-h.y*-s.y;let D=Math.abs(0!==p?1/p:1);D>8&&(D=8),B>=0?(c=i.add(a.x,a.y,s.x,s.y,0,1,t),-1===y&&(y=c),d>=0&&x>=0&&c>=0&&!r&&l.add(d,x,c),x=i.add(a.x,a.y,D*-h.x,D*-h.y,0,-1,t),-1===_&&(_=x),d>=0&&x>=0&&c>=0&&!r&&l.add(d,x,c),d=x,x=c,c=i.add(a.x,a.y,h.x,h.y,0,1,t),d>=0&&x>=0&&c>=0&&!r&&l.add(d,x,c),x=i.add(a.x,a.y,u.x,u.y,0,1,t),d>=0&&x>=0&&c>=0&&!r&&l.add(d,x,c)):(c=i.add(a.x,a.y,D*h.x,D*h.y,0,1,t),-1===y&&(y=c),d>=0&&x>=0&&c>=0&&!r&&l.add(d,x,c),x=i.add(a.x,a.y,-s.x,-s.y,0,-1,t),-1===_&&(_=x),d>=0&&x>=0&&c>=0&&!r&&l.add(d,x,c),d=x,x=c,c=i.add(a.x,a.y,-h.x,-h.y,0,-1,t),d>=0&&x>=0&&c>=0&&!r&&l.add(d,x,c),d=i.add(a.x,a.y,-u.x,-u.y,0,-1,t),d>=0&&x>=0&&c>=0&&!r&&l.add(d,x,c))}d>=0&&x>=0&&y>=0&&!g&&l.add(d,x,y),d>=0&&y>=0&&_>=0&&!g&&l.add(d,_,y),this._outlineIndexCount+=3*(l.index-r)}},a._processFill=function(e,n,l,r){let a;n.length>1&&(a=[]);let f=0;for(const t of n)0!==f&&a.push(f),f+=e[t].length;const s=2*f,u=t.acquire();for(const t of n){const i=e[t],n=i.length;for(let e=0;e<n;++e)u.push(i[e].x,i[e].y)}const h=i.earcut(u,a,2);if(r&&i.deviation(u,a,2,h)>0){const t=[],i=[];if(function(e,t,i,n){let l,r;o.beginPolygon(e,t);for(const e of n){const t=i[e];if(!(t.length<3)){o.beginContour();for(let e=0;e<t.length;++e){l=t[e].x,r=t[e].y;const i=[l,r,0];o.addVertex(i,i)}o.endContour()}}o.endPolygon()}(t,i,e,n),i.length>0){const e=this._fillVertexBuffer.index;let n=0;for(;n<t.length;)this._fillVertexBuffer.add(t[n++],t[n++],l);let r=0;for(;r<i.length;)this._fillIndexBuffer.add(e+i[r+0],e+i[r+1],e+i[r+2]),r+=3;this._fillIndexCount+=i.length}}else{const e=h.length;if(e>0){const t=this._fillVertexBuffer.index;let i=0;for(;i<s;)this._fillVertexBuffer.add(u[i++],u[i++],l);let n=0;for(;n<e;)this._fillIndexBuffer.add(t+h[n++],t+h[n++],t+h[n++]);this._fillIndexCount+=e}}t.release(u)},a._isClipEdge=function(e,t){return e.x===t.x?e.x<=-64||e.x>=4160:e.y===t.y&&(e.y<=-64||e.y>=4160)},r._area=function(e){let t=0;const i=e.length-1;for(let n=0;n<i;n++)t+=(e[n].x-e[n+1].x)*(e[n].y+e[n+1].y);return t+=(e[i].x-e[0].x)*(e[i].y+e[0].y),.5*t},e._createClass(r,[{key:"fillIndexStart",get:function(){return this._fillIndexStart}},{key:"fillIndexCount",get:function(){return this._fillIndexCount}},{key:"outlineIndexStart",get:function(){return this._outlineIndexStart}},{key:"outlineIndexCount",get:function(){return this._outlineIndexCount}}]),r}(r)}));
