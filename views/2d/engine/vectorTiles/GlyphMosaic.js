/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
define(["../../../webgl/BufferObject","../../../webgl/FramebufferObject","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/has","../../../webgl/checkWebGLError","../../../webgl/enums","../../../../chunks/builtins","../../../webgl/Texture","../../../webgl/VertexArrayObject","./RectangleBinPack","../webgl/Rect"],(function(t,e,i,s,h,r,n,c,a,o,l){"use strict";return function(){function t(t,e,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=e,this._glyphSource=i,this._binPack=new o(t-4,e-4),this._glyphData.push(new Uint8Array(t*e)),this._dirties.push(!0),this._textures.push(void 0)}var e=t.prototype;return e.getGlyphItems=function(t,e){const i=[],s=this._glyphSource,h=new Set,r=1/256;for(const c of e){const t=Math.floor(c*r);h.add(t)}const n=[];return h.forEach((e=>{if(e<=256){const i=t+e;if(this._rangePromises.has(i))n.push(this._rangePromises.get(i));else{const h=s.getRange(t,e).then((()=>{this._rangePromises.delete(i)}),(()=>{this._rangePromises.delete(i)}));this._rangePromises.set(i,h),n.push(h)}}})),Promise.all(n).then((()=>{let h=this._glyphIndex[t];h||(h={},this._glyphIndex[t]=h);for(const r of e){const e=h[r];if(e){i[r]={sdf:!0,rect:e.rect,metrics:e.metrics,page:e.page,code:r};continue}const n=s.getGlyph(t,r);if(!n||!n.metrics)continue;const c=n.metrics;let a;if(0===c.width)a=new l(0,0,0,0);else{const t=3,e=c.width+2*t,i=c.height+2*t;let s=e%4?4-e%4:4,h=i%4?4-i%4:4;1===s&&(s=5),1===h&&(h=5),a=this._binPack.allocate(e+s,i+h),a.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new o(this.width-4,this.height-4),a=this._binPack.allocate(e+s,i+h));const r=this._glyphData[this._currentPage],l=n.bitmap;let g,u;if(l)for(let n=0;n<i;n++){g=e*n,u=this.width*(a.y+n+1)+a.x;for(let t=0;t<e;t++)r[u+t+1]=l[g+t]}}h[r]={rect:a,metrics:c,tileIDs:null,page:this._currentPage},i[r]={sdf:!0,rect:a,metrics:c,page:this._currentPage,code:r},this._dirties[this._currentPage]=!0}return i}))},e.removeGlyphs=function(t){for(const e in this._glyphIndex){const i=this._glyphIndex[e];if(!i)continue;let s;for(const e in i)if(s=i[e],s.tileIDs.delete(t),0===s.tileIDs.size){const t=this._glyphData[s.page],h=s.rect;let r,n;for(let e=0;e<h.height;e++)for(r=this.width*(h.y+e)+h.x,n=0;n<h.width;n++)t[r+n]=0;delete i[e],this._dirties[s.page]=!0}}},e.bind=function(t,e,i,s=0){this._textures[i]||(this._textures[i]=new c(t,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const h=this._textures[i];h.setSamplingMode(e),this._dirties[i]&&h.setData(this._glyphData[i]),t.bindTexture(h,s),this._dirties[i]=!1},e.dispose=function(){this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0},t}()}));
