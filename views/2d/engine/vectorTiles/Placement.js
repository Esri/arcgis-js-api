/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../geometry/support/TileClipper","./GeometryUtils","./TextShaping","./decluttering/config","./style/StyleDefinition"],(function(e,t,n,i,o,l){"use strict";const h=4096,a=512,s=8,c=.5,r=2;let m=function(e,t,n=0,i=-1,o=c){this.x=e,this.y=t,this.angle=n,this.segment=i,this.minzoom=o},g=function(e,t,i,o,l,h=c,a=n.C_INFINITY){this.anchor=e,this.labelAngle=t,this.glyphAngle=i,this.page=o,this.alternateVerticalGlyph=l,this.minzoom=h,this.maxzoom=a},I=function(e,t,n,i,o,l,h,a,s,c,r,m){this.tl=e,this.tr=t,this.bl=n,this.br=i,this.mosaicRect=o,this.labelAngle=l,this.minAngle=h,this.maxAngle=a,this.anchor=s,this.minzoom=c,this.maxzoom=r,this.page=m},y=function(e){this.shapes=e},T=function(){function e(){}var h=e.prototype;return h.getIconPlacement=function(e,i,h){const a=new t.Point(e.x,e.y),s=h.rotationAlignment===l.RotationAlignment.MAP,c=h.keepUpright;let r=h.rotate*n.C_DEG_TO_RAD;s&&(r+=e.angle);const m=new y([]);return h.allowOverlap&&h.ignorePlacement||!o.DECLUTTER_TILES||(m.iconColliders=[]),this._addIconPlacement(m,a,i,h,r),s&&c&&this._addIconPlacement(m,a,i,h,r+n.C_PI),m},h._addIconPlacement=function(e,i,h,a,s){const r=h.pixelRatio,m=h.width/r,g=h.height/r,y=a.offset;let T=y[0],d=y[1];switch(a.anchor){case l.SymbolAnchor.CENTER:T-=m/2,d-=g/2;break;case l.SymbolAnchor.LEFT:d-=g/2;break;case l.SymbolAnchor.RIGHT:T-=m,d-=g/2;break;case l.SymbolAnchor.TOP:T-=m/2;break;case l.SymbolAnchor.BOTTOM:T-=m/2,d-=g;break;case l.SymbolAnchor.TOP_LEFT:break;case l.SymbolAnchor.BOTTOM_LEFT:d-=g;break;case l.SymbolAnchor.TOP_RIGHT:T-=m;break;case l.SymbolAnchor.BOTTOM_RIGHT:T-=m,d-=g}const P=h.rect,x=2/r,p=T-x,w=d-x,_=p+P.width/r,f=w+P.height/r,b=new t.Point(p,w),u=new t.Point(_,f),S=new t.Point(p,f),A=new t.Point(_,w);if(0!==s){const e=Math.cos(s),t=Math.sin(s);b.rotate(e,t),u.rotate(e,t),S.rotate(e,t),A.rotate(e,t)}const E=new I(b,A,S,u,P,s,0,256,i,c,n.C_INFINITY,0);if(e.shapes.push(E),(!a.allowOverlap||!a.ignorePlacement)&&o.DECLUTTER_TILES){const t=a.size,o=a.padding,l={xTile:i.x,yTile:i.y,dxPixels:T*t-o,dyPixels:d*t-o,hard:!a.optional,partIndex:0,width:m*t+2*o,height:g*t+2*o,angle:s,minLod:c,maxLod:n.C_INFINITY};e.iconColliders.push(l)}},h.getTextPlacement=function(e,o,h,a){const m=new t.Point(e.x,e.y),T=a.rotate*n.C_DEG_TO_RAD,d=a.rotationAlignment===l.RotationAlignment.MAP,P=a.keepUpright,x=a.padding;let p=c;const w=!d?0:e.angle,_=e.segment>=0&&d,f=a.allowOverlap&&a.ignorePlacement?null:[],b=[],u=4,S=!_;let A=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY,L=A,O=E;const N=(_||d)&&P,C=a.size/i.SDF_GLYPH_SIZE;let G=!1;for(const t of o)if(t.vertical){G=!0;break}let F,M=0,k=0;if(!_&&G){const e=i.TextShaping.getTextBox(o,a.lineHeight*i.SDF_GLYPH_SIZE);switch(a.anchor){case l.SymbolAnchor.LEFT:M=e.height/2,k=-e.width/2;break;case l.SymbolAnchor.RIGHT:M=-e.height/2,k=e.width/2;break;case l.SymbolAnchor.TOP:M=e.height/2,k=e.width/2;break;case l.SymbolAnchor.BOTTOM:M=-e.height/2,k=-e.width/2;break;case l.SymbolAnchor.TOP_LEFT:M=e.height;break;case l.SymbolAnchor.BOTTOM_LEFT:k=-e.width;break;case l.SymbolAnchor.TOP_RIGHT:k=e.width;break;case l.SymbolAnchor.BOTTOM_RIGHT:M=-e.height}}M+=a.offset[0]*i.SDF_GLYPH_SIZE,k+=a.offset[1]*i.SDF_GLYPH_SIZE;for(const l of o){const o=l.glyphMosaicItem;if(!o||o.rect.isEmpty)continue;const y=o.rect,R=o.metrics,Y=o.page;if(f&&S){if(void 0!==F&&F!==l.y){let t,i,o,l;G?(t=-O+M,i=A+k,o=O-L,l=E-A):(t=A+M,i=L+k,o=E-A,l=O-L);const h={xTile:e.x,yTile:e.y,dxPixels:t*C-x,dyPixels:i*C-x,hard:!a.optional,partIndex:1,width:o*C+2*x,height:l*C+2*x,angle:T,minLod:c,maxLod:n.C_INFINITY};f.push(h),A=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY,L=A,O=E}F=l.y}const v=[];if(_){const t=.5*o.metrics.width,n=(l.x+R.left-u+t)*C*s;if(p=this._placeGlyph(e,p,n,h,e.segment,1,l.vertical,Y,v),P&&(p=this._placeGlyph(e,p,n,h,e.segment,-1,l.vertical,Y,v)),p>=r)break}else v.push(new g(m,w,w,Y,!1)),d&&P&&v.push(new g(m,w+n.C_PI,w+n.C_PI,Y,!1));const D=l.x+R.left,z=l.y-i.SDF_GLYPH_BASELINE-R.top,H=D+R.width,B=z+R.height;let V,Z,U,q,X,j,J,K;if(!_&&G)if(l.vertical){const e=(D+H)/2-R.height/2,n=(z+B)/2+R.width/2;V=new t.Point(-n-u+M,e-u+k),Z=new t.Point(V.x+y.width,V.y+y.height),U=new t.Point(V.x,Z.y),q=new t.Point(Z.x,V.y)}else V=new t.Point(-z+u+M,D-u+k),Z=new t.Point(V.x-y.height,V.y+y.width),U=new t.Point(Z.x,V.y),q=new t.Point(V.x,Z.y);else V=new t.Point(D-u+M,z-u+k),Z=new t.Point(V.x+y.width,V.y+y.height),U=new t.Point(V.x,Z.y),q=new t.Point(Z.x,V.y);for(const n of v){let i,o,h,s;if(n.alternateVerticalGlyph){if(!X){const e=(D+H)/2+M,n=(z+B)/2+k;X=new t.Point(e-R.height/2-u,n+R.width/2+u),j=new t.Point(X.x+y.height,X.y-y.width),J=new t.Point(j.x,X.y),K=new t.Point(X.x,j.y)}i=X,o=J,h=K,s=j}else i=V,o=U,h=q,s=Z;const c=z,m=B,g=n.glyphAngle+T;if(0!==g){const e=Math.cos(g),t=Math.sin(g);i=i.clone(),o=o?.clone(),h=h?.clone(),s=s?.clone(),i.rotate(e,t),s?.rotate(e,t),o?.rotate(e,t),h?.rotate(e,t)}let d=0,P=256;if(_&&G?l.vertical?n.alternateVerticalGlyph?(d=32,P=96):(d=224,P=32):(d=224,P=96):(d=192,P=64),b.push(new I(i,h,o,s,y,n.labelAngle,d,P,n.anchor,n.minzoom,n.maxzoom,n.page)),f&&(!N||this._legible(n.labelAngle)))if(S)D<A&&(A=D),c<L&&(L=c),H>E&&(E=H),m>O&&(O=m);else if(n.minzoom<r){const t={xTile:e.x,yTile:e.y,dxPixels:(D+M)*C-x,dyPixels:(c+M)*C-x,hard:!a.optional,partIndex:1,width:(H-D)*C+2*x,height:(m-c)*C+2*x,angle:g,minLod:n.minzoom,maxLod:n.maxzoom};f.push(t)}}}if(p>=r)return null;if(f&&S){let t,i,o,l;G?(t=-O+M,i=A+k,o=O-L,l=E-A):(t=A+M,i=L+k,o=E-A,l=O-L);const h={xTile:e.x,yTile:e.y,dxPixels:t*C-x,dyPixels:i*C-x,hard:!a.optional,partIndex:1,width:o*C+2*x,height:l*C+2*x,angle:T,minLod:c,maxLod:n.C_INFINITY};f.push(h)}const R=new y(b);return f&&f.length>0&&(R.textColliders=f),R},h._legible=function(e){const t=n.radToByte(e);return t<65||t>=193},h._placeGlyph=function(e,i,o,l,h,a,s,c,r){let m=a;const I=m<0?n.positiveMod(e.angle+n.C_PI,n.C_2PI):e.angle;let y=0;o<0&&(m*=-1,o*=-1,y=n.C_PI),m>0&&++h;let T=new t.Point(e.x,e.y),d=l[h],P=n.C_INFINITY;if(l.length<=h)return P;for(;;){const e=d.x-T.x,t=d.y-T.y,a=Math.sqrt(e*e+t*t),x=Math.max(o/a,i),p=e/a,w=t/a,_=n.positiveMod(Math.atan2(w,p)+y,n.C_2PI);if(r.push(new g(T,I,_,c,!1,x,P)),s&&r.push(new g(T,I,_,c,!0,x,P)),x<=i)return x;T=d.clone();do{if(h+=m,l.length<=h||h<0)return x;d=l[h]}while(T.isEqual(d));let f=d.x-T.x,b=d.y-T.y;const u=Math.sqrt(f*f+b*b);f*=a/u,b*=a/u,T.x-=f,T.y-=b,P=x}},e}();e.Anchor=m,e.PlacedSymbol=I,e.Placement=y,e.PlacementEngine=T,e.TILE_COORD_SIZE=h,e.TILE_PIXEL_RATIO=s,e.TILE_PIXEL_SIZE=a,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
