/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","./GeometryUtils","./TextShaping","./decluttering/config","./style/StyleDefinition","../webgl/Geometry"],(function(e,t,n,i,o,l){"use strict";const h=4096,a=512,s=8,c=.5,r=2;let m=function(e,t,n=0,i=-1,o=c){this.x=e,this.y=t,this.angle=n,this.segment=i,this.minzoom=o},g=function(e,n,i,o,l,h=c,a=t.C_INFINITY){this.anchor=e,this.labelAngle=n,this.glyphAngle=i,this.page=o,this.alternateVerticalGlyph=l,this.minzoom=h,this.maxzoom=a},I=function(e,t,n,i,o,l,h,a,s,c,r,m){this.tl=e,this.tr=t,this.bl=n,this.br=i,this.mosaicRect=o,this.labelAngle=l,this.minAngle=h,this.maxAngle=a,this.anchor=s,this.minzoom=c,this.maxzoom=r,this.page=m},y=function(e){this.shapes=e},T=function(){function e(){}var h=e.prototype;return h.getIconPlacement=function(e,n,h){const a=new l.Point(e.x,e.y),s=h.rotationAlignment===o.RotationAlignment.MAP,c=h.keepUpright;let r=h.rotate*t.C_DEG_TO_RAD;s&&(r+=e.angle);const m=new y([]);return h.allowOverlap&&h.ignorePlacement||!i.DECLUTTER_TILES||(m.iconColliders=[]),this._addIconPlacement(m,a,n,h,r),s&&c&&this._addIconPlacement(m,a,n,h,r+t.C_PI),m},h._addIconPlacement=function(e,n,h,a,s){const r=h.pixelRatio,m=h.width/r,g=h.height/r,y=a.offset;let T=y[0],d=y[1];switch(a.anchor){case o.SymbolAnchor.CENTER:T-=m/2,d-=g/2;break;case o.SymbolAnchor.LEFT:d-=g/2;break;case o.SymbolAnchor.RIGHT:T-=m,d-=g/2;break;case o.SymbolAnchor.TOP:T-=m/2;break;case o.SymbolAnchor.BOTTOM:T-=m/2,d-=g;break;case o.SymbolAnchor.TOP_LEFT:break;case o.SymbolAnchor.BOTTOM_LEFT:d-=g;break;case o.SymbolAnchor.TOP_RIGHT:T-=m;break;case o.SymbolAnchor.BOTTOM_RIGHT:T-=m,d-=g}const P=h.rect,x=2/r,_=T-x,w=d-x,p=_+P.width/r,f=w+P.height/r,b=new l.Point(_,w),u=new l.Point(p,f),S=new l.Point(_,f),A=new l.Point(p,w);if(0!==s){const e=Math.cos(s),t=Math.sin(s);b.rotate(e,t),u.rotate(e,t),S.rotate(e,t),A.rotate(e,t)}const E=new I(b,A,S,u,P,s,0,256,n,c,t.C_INFINITY,0);if(e.shapes.push(E),(!a.allowOverlap||!a.ignorePlacement)&&i.DECLUTTER_TILES){const i=a.size,o=a.padding,l={xTile:n.x,yTile:n.y,dxPixels:T*i-o,dyPixels:d*i-o,hard:!a.optional,partIndex:0,width:m*i+2*o,height:g*i+2*o,angle:s,minLod:c,maxLod:t.C_INFINITY};e.iconColliders.push(l)}},h.getTextPlacement=function(e,i,h,a){const m=new l.Point(e.x,e.y),T=a.rotate*t.C_DEG_TO_RAD,d=a.rotationAlignment===o.RotationAlignment.MAP,P=a.keepUpright,x=a.padding;let _=c;const w=!d?0:e.angle,p=e.segment>=0&&d,f=a.allowOverlap&&a.ignorePlacement?null:[],b=[],u=4,S=!p;let A=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY,L=A,O=E;const N=(p||d)&&P,G=a.size/n.SDF_GLYPH_SIZE;let C=!1;for(const t of i)if(t.vertical){C=!0;break}let F,M=0,k=0;if(!p&&C){const e=n.TextShaping.getTextBox(i,a.lineHeight*n.SDF_GLYPH_SIZE);switch(a.anchor){case o.SymbolAnchor.LEFT:M=e.height/2,k=-e.width/2;break;case o.SymbolAnchor.RIGHT:M=-e.height/2,k=e.width/2;break;case o.SymbolAnchor.TOP:M=e.height/2,k=e.width/2;break;case o.SymbolAnchor.BOTTOM:M=-e.height/2,k=-e.width/2;break;case o.SymbolAnchor.TOP_LEFT:M=e.height;break;case o.SymbolAnchor.BOTTOM_LEFT:k=-e.width;break;case o.SymbolAnchor.TOP_RIGHT:k=e.width;break;case o.SymbolAnchor.BOTTOM_RIGHT:M=-e.height}}M+=a.offset[0]*n.SDF_GLYPH_SIZE,k+=a.offset[1]*n.SDF_GLYPH_SIZE;for(const o of i){const i=o.glyphMosaicItem;if(!i||i.rect.isEmpty)continue;const y=i.rect,R=i.metrics,Y=i.page;if(f&&S){if(void 0!==F&&F!==o.y){let n,i,o,l;C?(n=-O+M,i=A+k,o=O-L,l=E-A):(n=A+M,i=L+k,o=E-A,l=O-L);const h={xTile:e.x,yTile:e.y,dxPixels:n*G-x,dyPixels:i*G-x,hard:!a.optional,partIndex:1,width:o*G+2*x,height:l*G+2*x,angle:T,minLod:c,maxLod:t.C_INFINITY};f.push(h),A=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY,L=A,O=E}F=o.y}const v=[];if(p){const t=.5*i.metrics.width,n=(o.x+R.left-u+t)*G*s;if(_=this._placeGlyph(e,_,n,h,e.segment,1,o.vertical,Y,v),P&&(_=this._placeGlyph(e,_,n,h,e.segment,-1,o.vertical,Y,v)),_>=r)break}else v.push(new g(m,w,w,Y,!1)),d&&P&&v.push(new g(m,w+t.C_PI,w+t.C_PI,Y,!1));const D=o.x+R.left,z=o.y-n.SDF_GLYPH_BASELINE-R.top,H=D+R.width,B=z+R.height;let V,Z,U,q,X,j,J,K;if(!p&&C)if(o.vertical){const e=(D+H)/2-R.height/2,t=(z+B)/2+R.width/2;V=new l.Point(-t-u+M,e-u+k),Z=new l.Point(V.x+y.width,V.y+y.height),U=new l.Point(V.x,Z.y),q=new l.Point(Z.x,V.y)}else V=new l.Point(-z+u+M,D-u+k),Z=new l.Point(V.x-y.height,V.y+y.width),U=new l.Point(Z.x,V.y),q=new l.Point(V.x,Z.y);else V=new l.Point(D-u+M,z-u+k),Z=new l.Point(V.x+y.width,V.y+y.height),U=new l.Point(V.x,Z.y),q=new l.Point(Z.x,V.y);for(const t of v){let n,i,h,s;if(t.alternateVerticalGlyph){if(!X){const e=(D+H)/2+M,t=(z+B)/2+k;X=new l.Point(e-R.height/2-u,t+R.width/2+u),j=new l.Point(X.x+y.height,X.y-y.width),J=new l.Point(j.x,X.y),K=new l.Point(X.x,j.y)}n=X,i=J,h=K,s=j}else n=V,i=U,h=q,s=Z;const c=z,m=B,g=t.glyphAngle+T;if(0!==g){const e=Math.cos(g),t=Math.sin(g);n=n.clone(),i=i.clone(),h=h.clone(),s=s.clone(),n.rotate(e,t),s.rotate(e,t),i.rotate(e,t),h.rotate(e,t)}let d=0,P=256;if(p&&C?o.vertical?t.alternateVerticalGlyph?(d=32,P=96):(d=224,P=32):(d=224,P=96):(d=192,P=64),b.push(new I(n,h,i,s,y,t.labelAngle,d,P,t.anchor,t.minzoom,t.maxzoom,t.page)),f&&(!N||this._legible(t.labelAngle)))if(S)D<A&&(A=D),c<L&&(L=c),H>E&&(E=H),m>O&&(O=m);else if(t.minzoom<r){const n={xTile:e.x,yTile:e.y,dxPixels:(D+M)*G-x,dyPixels:(c+M)*G-x,hard:!a.optional,partIndex:1,width:(H-D)*G+2*x,height:(m-c)*G+2*x,angle:g,minLod:t.minzoom,maxLod:t.maxzoom};f.push(n)}}}if(_>=r)return null;if(f&&S){let n,i,o,l;C?(n=-O+M,i=A+k,o=O-L,l=E-A):(n=A+M,i=L+k,o=E-A,l=O-L);const h={xTile:e.x,yTile:e.y,dxPixels:n*G-x,dyPixels:i*G-x,hard:!a.optional,partIndex:1,width:o*G+2*x,height:l*G+2*x,angle:T,minLod:c,maxLod:t.C_INFINITY};f.push(h)}const R=new y(b);return f&&f.length>0&&(R.textColliders=f),R},h._legible=function(e){const n=t.radToByte(e);return n<65||n>=193},h._placeGlyph=function(e,n,i,o,h,a,s,c,r){let m=a;const I=m<0?t.positiveMod(e.angle+t.C_PI,t.C_2PI):e.angle;let y=0;i<0&&(m*=-1,i*=-1,y=t.C_PI),m>0&&++h;let T=new l.Point(e.x,e.y),d=o[h],P=t.C_INFINITY;if(o.length<=h)return P;for(;;){const e=d.x-T.x,l=d.y-T.y,a=Math.sqrt(e*e+l*l),x=Math.max(i/a,n),_=e/a,w=l/a,p=t.positiveMod(Math.atan2(w,_)+y,t.C_2PI);if(r.push(new g(T,I,p,c,!1,x,P)),s&&r.push(new g(T,I,p,c,!0,x,P)),x<=n)return x;T=d.clone();do{if(h+=m,o.length<=h||h<0)return x;d=o[h]}while(T.isEqual(d));let f=d.x-T.x,b=d.y-T.y;const u=Math.sqrt(f*f+b*b);f*=a/u,b*=a/u,T.x-=f,T.y-=b,P=x}},e}();e.Anchor=m,e.PlacedSymbol=I,e.Placement=y,e.PlacementEngine=T,e.TILE_COORD_SIZE=h,e.TILE_PIXEL_RATIO=s,e.TILE_PIXEL_SIZE=a,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
