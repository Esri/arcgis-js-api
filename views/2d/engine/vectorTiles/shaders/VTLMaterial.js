/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/_rollupPluginBabelHelpers","../../../../../chunks/vec4f32","../MemoryBuffer"],(function(t,e,n,o){"use strict";let s=function(){function t(t){this._color=n.create(),this._key=t}var s=t.prototype;return s.defines=function(){return[]},s.getStride=function(){return this._layoutInfo||this._buildAttributesInfo(),this._stride},s.getAttributeLocations=function(){return this._locations||this._buildAttributesInfo(),this._locations},s.getLayoutInfo=function(){return this._layoutInfo||this._buildAttributesInfo(),this._layoutInfo},s.getEncodingInfos=function(){return this._propertyEncodingInfo||this._buildAttributesInfo(),this._propertyEncodingInfo},s.getUniforms=function(){return this._uniforms||this._buildAttributesInfo(),this._uniforms},s.getShaderHeader=function(){return this._shaderHeader||this._buildAttributesInfo(),this._shaderHeader},s.getShaderMain=function(){return this._shaderMain||this._buildAttributesInfo(),this._shaderMain},s.setDataUniforms=function(t,e,n,o){const s=this.getUniforms();for(const i in s){const r=s[i];switch(r.type){case"float":t.setUniform1f(r.name,r.getValue(n,e,o));break;case"vec2":t.setUniform2fv(r.name,r.getValue(n,e,o));break;case"vec4":{const s=r.getValue(n,e,o),i=s[3];this._color[0]=i*s[0],this._color[1]=i*s[1],this._color[2]=i*s[2],this._color[3]=i,t.setUniform4fv(r.name,this._color)}}}},s.encodeAttributes=function(t,e,n){const o=this.attributesInfo(),s=this.getEncodingInfos(),i=[];for(const a of Object.keys(s)){var r;const c=s[a],{type:u,precisionFactor:f,isLayout:h}=o[a],l=h?n.getLayoutProperty(a):n.getPaintProperty(a),d=null==(r=l.interpolator)?void 0:r.getInterpolationRange(e);let _=0;for(const n of c){n.dataIndex>=i.length&&i.push(0);const o=l.getValue(d?d[_]:e,t);switch(u){case 0:i[n.dataIndex]|=this._encodeByte(o*(f||1),8*n.offset);break;case 1:i[n.dataIndex]|=this._encodeByte(o*(f||1)+128,8*n.offset);break;case 2:i[n.dataIndex]=this._encodeColor(o);break;default:throw new Error("Unsupported encoding type")}++_}}return i},s.getAtributeState=function(t){let e=0;const n=3+2*t;return e|=this._bit(n),e|=this._bit(n+1)<<1,e},s._buildAttributesInfo=function(){const e=[],n={},o={};let s=-1;const i=this.attributesInfo(),r=this.attributes();let a=-1;for(const l of r){++a;const r=this.getAtributeState(a);if(0===r)continue;const c=i[l],u=[];n[l]=u;const f=c.type;for(let n=0;n<r;++n){const{dataType:n,bytesPerElement:i,count:r,normalized:a}=t._encodingInfo[f],c=n<<2|r;let h=o[c];h&&4!==h.offset||(++s,o[c]=h={dataIndex:s,offset:0},e.push({location:-1,name:"a_data_"+s,count:4/i,type:n,normalized:a})),u.push({dataIndex:h.dataIndex,offset:h.offset}),h.offset+=i*r}}this._buildVertexBufferLayout(e);const c={};let u=0;const f=this._layoutInfo.geometry;for(const t of f)c[t.name]=u++;const h=this._layoutInfo.opacity;if(h)for(const t of h)c[t.name]=u++;this._buildShaderInfo(e,n),this._propertyEncodingInfo=n,this._locations=c},s._buildVertexBufferLayout=function(t){const e={},n=this.geometryInfo();let o=n[0].stride;if(0===t.length)e.geometry=n;else{const s=[];let r=o;o+=4*t.length;for(const t of n){const e={...t};e.stride=o,s.push(e)}for(const e of t)s.push({name:e.name,count:e.count,type:e.type,offset:r,stride:o,normalized:e.normalized||!1,divisor:0}),r+=i(e.type)*e.count;e.geometry=s}this.opacityInfo()&&(e.opacity=this.opacityInfo()),this._layoutInfo=e,this._stride=o},s._buildShaderInfo=function(e,n){let o="\n",s="\n";const i=[];for(const t of e)o+=`attribute ${this._getType(t.count)} ${t.name};\n`;const r=this.attributes(),a=this.attributesInfo();let c=-1;for(const u of r){++c;const{name:e,type:r,precisionFactor:f,isLayout:h}=a[u],l=f&&1!==f?" * "+1/f:"",{bytesPerElement:d,count:_}=t._encodingInfo[r],y=t=>{const e=2===r?"":`[${t.offset/d}]`;return`a_data_${t.dataIndex}${e}`};switch(this.getAtributeState(c)){case 0:{const t=this._getType(_),n=`u_${e}`;i.push({name:n,type:t,getValue:(t,e)=>h?t.getLayoutValue(u,e):t.getPaintValue(u,e)}),o+=`uniform ${t} ${n};\n`,s+=`${t} ${e} = ${n};\n`}break;case 1:{const t=y(n[u][0]);s+=`${this._getType(_)} ${e} = ${t}${l};\n`}break;case 2:{const t=`u_t_${e}`;i.push({name:t,type:"float",getValue:(t,e,n)=>(h?t.getLayoutProperty(u):t.getPaintProperty(u)).interpolator.interpolationUniformValue(n,e)}),o+=`uniform float ${t};\n`;const r=y(n[u][0]),a=y(n[u][1]);s+=`${this._getType(_)} ${e} = mix(${r}${l}, ${a}${l}, ${t});\n`}}}this._shaderHeader=o,this._shaderMain=s,this._uniforms=i},s._bit=function(t){return(this._key&1<<t)>>t},s._getType=function(t){switch(t){case 1:return"float";case 2:return"vec2";case 4:return"vec4"}throw new Error("Invalid count")},s._encodeColor=function(t){const e=255*t[3];return o.i8888to32(t[0]*e,t[1]*e,t[2]*e,e)},s._encodeByte=function(t,e){return(255&t)<<e},e._createClass(t,[{key:"key",get:function(){return this._key}},{key:"type",get:function(){return 7&this._key}}]),t}();s._encodingInfo=[{dataType:5121,bytesPerElement:1,count:1,normalized:!1},{dataType:5121,bytesPerElement:1,count:1,normalized:!1},{dataType:5121,bytesPerElement:1,count:4,normalized:!0}];const i=t=>{switch(t){case 5126:case 5124:case 5125:return 4;case 5122:case 5123:return 2;case 5120:case 5121:return 1}};t.VTLMaterial=s,Object.defineProperty(t,"__esModule",{value:!0})}));
