/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{clone as t}from"../../../../../core/lang.js";import{urlToObject as e,isAbsolute as i,join as r,addQueryParameters as l}from"../../../../../core/urlUtils.js";import s from"../../../../../geometry/Extent.js";import{readServiceTileInfo as o}from"../../../../../layers/support/serviceTileInfoProperty.js";import{TilemapCache as n}from"../../../../../layers/support/TilemapCache.js";import a from"../TilemapIndex.js";import p from"../TilemapRequest.js";import{request as u}from"./VectorTilesRequestManager.js";class h{constructor(u,h,m){this.tilemap=null,this.tileInfo=null,this.capabilities=null,this.fullExtent=null,this.name=u,this.sourceUrl=h;const f=e(this.sourceUrl),c=t(m),x=c.tiles;if(f)for(let t=0;t<x.length;t++){const s=e(x[t]);s&&(i(s.path)||(s.path=r(f.path,s.path)),x[t]=l(s.path,{...f.query,...s.query}))}this.tileServers=x;const d=m.capabilities&&m.capabilities.split(",").map((t=>t.toLowerCase().trim())),y=!0===m?.exportTilesAllowed,T=!0===d?.includes("tilemap"),g=y&&m.hasOwnProperty("maxExportTilesCount")?m.maxExportTilesCount:0;this.capabilities={operations:{supportsExportTiles:y,supportsTileMap:T},exportTiles:y?{maxExportTilesCount:+g}:null},this.tileInfo=o(c.tileInfo,c,null,{ignoreMinMaxLOD:!0});const M=m.tileMap?l(r(f.path,m.tileMap),f.query):null;T?(this.type="vector-tile",this.tilemap=new p(new n({layer:{parsedUrl:f,tileInfo:this.tileInfo,type:"vector-tile",tileServers:this.tileServers}}),M)):M&&(this.tilemap=new a(M)),this.fullExtent=s.fromJSON(m.fullExtent)}destroy(){}async getRefKey(t,e){return this.tilemap?.dataKey(t,e)??t}requestTile(t,e,i,r){const l=this.tileServers[e%this.tileServers.length];return u(l,t,e,i,r)}isCompatibleWith(t){const e=this.tileInfo,i=t.tileInfo;if(!e.spatialReference.equals(i.spatialReference))return!1;if(!e.origin.equals(i.origin))return!1;if(Math.round(e.dpi)!==Math.round(i.dpi))return!1;const r=e.lods,l=i.lods,s=Math.min(r.length,l.length);for(let o=0;o<s;o++){const t=r[o],e=l[o];if(t.level!==e.level||Math.round(t.scale)!==Math.round(e.scale))return!1}return!0}}export{h as default};
