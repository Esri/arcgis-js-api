/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["../../../../../core/lang","../../../../../core/urlUtils","../../../../../core/promiseUtils","../../../../../geometry/Extent","../../../../../layers/support/serviceTileInfoProperty","../../../../../layers/support/TilemapCache","../TileIndex"],(function(e,t,i,l,r,s,n){"use strict";return function(){function o(i,o,a){this.tileMapURL="",this.tilemapCache=null,this.parsedUrl=null,this.tileInfo=null,this.capabilities=null,this.tileIndex=null,this.fullExtent=null,this.name=i,this.sourceUrl=o,o&&(this.parsedUrl=t.urlToObject(this.sourceUrl));const p=this.parsedUrl.path,u=this.parsedUrl.query?"?"+t.objectToQuery(this.parsedUrl.query):"",h=e.clone(a),c=h.tiles;o&&c.forEach(((e,i)=>{t.isAbsolute(e)||(c[i]=t.join(p,e)+u)})),this.tileServers=c,a.tileMap&&(this.tileMapURL=t.join(o,a.tileMap));const f=a.capabilities&&a.capabilities.split(",").map((e=>e.toLowerCase().trim())),d=!!a.exportTilesAllowed,x=!!f&&-1!==f.indexOf("tilemap"),m=d&&a.hasOwnProperty("maxExportTilesCount")?a.maxExportTilesCount:0;this.capabilities={operations:{supportsExportTiles:d,supportsTileMap:x},exportTiles:d?{maxExportTilesCount:+m}:null},this.tileInfo=r.readServiceTileInfo(h.tileInfo,h,null,{ignoreMinMaxLOD:!0}),x&&(this.type="vector-tile",this.tilemapCache=new s.TilemapCache({layer:this}),this.tilemapCache&&(this.tileIndex=new n(this.tilemapCache))),this.fullExtent=l.fromJSON(a.fullExtent)}var a=o.prototype;return a.getRefKey=function(e,t){return this.tileIndex?this.tileIndex.dataKey(e,t):i.resolve(e)},a.getSourceTileUrl=function(e,t,i){let l=this.tileServers[t%this.tileServers.length];return l=l.replace(/\{z\}/gi,e.toString()).replace(/\{y\}/gi,t.toString()).replace(/\{x\}/gi,i.toString()),l},a.isCompatibleWith=function(e){const t=this.tileInfo,i=e.tileInfo;if(!t.spatialReference.equals(i.spatialReference))return!1;if(!t.origin.equals(i.origin))return!1;if(Math.round(t.dpi)!==Math.round(i.dpi))return!1;const l=t.lods,r=i.lods,s=Math.min(l.length,r.length);for(let e=0;e<s;e++){const t=l[e],i=r[e];if(t.level!==i.level||Math.round(t.scale)!==Math.round(i.scale))return!1}return!0},o}()}));
