/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isSome as e,destroyMaybe as t,unwrapOrThrow as r,isNone as i,applySome as s}from"../../../../../core/maybe.js";import{FeatureDisplayList as f}from"../FeatureDisplayList.js";import{Buffer as n}from"./Buffer.js";import{DisplayRecordReader as o}from"./DisplayRecordReader.js";import{VertexArrayObject as d}from"../../../../webgl/VertexArrayObject.js";const h=0,u=1;class c{constructor(e,t){this._vaos=new Map,this._indicesInvalid=!1,this.geometryType=e}destroy(){for(const[t,r]of this._vaos)e(r)&&r.dispose(!1);this._indexBuffer=t(this._indexBuffer),this._vertexBuffer=t(this._vertexBuffer)}insert(e,t,i){if(!e.records.byteLength)return;const s=e.stride;if(this._vertexBuffer&&this._indexBuffer){const i=e.indices.byteLength/4,f=e.vertices.byteLength/s;this._indexBuffer.ensure(i),this._vertexBuffer.ensure(f);const{vertices:n,indices:d}=e,h=o.from(e.records),u=this._vertexBuffer.insert(n,0,n.byteLength/s,0),c=this._indexBuffer.insert(d,0,d.byteLength/4,u);if(h.forEach((e=>{e.indexFrom+=c,e.vertexFrom+=u})),r(this._records,"Expected records to be defined").link(h),t)this._indicesInvalid=!0;else if(this._displayList){const e=h.getCursor();for(;e.next();)this._displayList.addRecord(e)}}else{const r=e.indices.byteLength/4,i=e.vertices.byteLength/s,f=s/Uint32Array.BYTES_PER_ELEMENT;this._records=o.from(e.records),this._indexBuffer=new n("index",r,1),this._vertexBuffer=new n("vertex",i,f),this._indexBuffer.insert(e.indices,0,e.indices.byteLength/4,0),this._vertexBuffer.insert(e.vertices,0,e.vertices.byteLength/s,0),t&&(this._indicesInvalid=!0)}}remove(e){if(!i(this._records))for(const t of e){const e=this._records.getCursor();if(!e.lookup(t))continue;const r=e.indexFrom,i=e.vertexFrom;let s=e.indexCount,f=e.vertexCount;for(;e.next()&&e.id===t;)s+=e.indexCount,f+=e.vertexCount;this._indexBuffer.free(r,s),this._vertexBuffer.free(i,f,!0),this._records.delete(t)}}getVAO(e,t,r,f){if(!this._vertexBuffer||!this._indexBuffer||i(this._records)||!this._vertexBuffer.bufferSize)return null;const n=f?u:h;let o=this._vaos.get(n);(this._vertexBuffer.invalidated||this._indexBuffer.invalidated||f&&this._indexBuffer.invalidatedComputeBuffer)&&(s(o,(e=>e.dispose(!1))),o=null),this._vertexBuffer.upload(),this._indexBuffer.upload();const c=this._indexBuffer.getGPUBuffer(e,1===n),_=this._vertexBuffer.getGPUBuffer(e);return o||(o=new d(e,r,t,{geometry:_},c),this._vaos.set(n,o)),o}forEachCommand(e){if(!i(this._records)){if(this._sortIndices(this._records),!this._displayList){const e=this._cursorIndexOrder;this._displayList=f.from(this,this.geometryType,this._records.getCursor(),e)}this._displayList.forEach(e)}}_sortIndices(e){const t=!!this._indexBuffer.bufferSize;if(!this._indicesInvalid)return;this._indicesInvalid=!1;let r=0;const i=e.getCursor(),s=[],f=[],n=[];for(;i.next();)f.push(i.index),n.push(i.sortKey),s.push(i.id);f.sort(((e,t)=>{const r=n[t],i=n[e];return i===r?s[t]-s[e]:r-i}));const o=e.getCursor(),d=t?this._indexBuffer.getCPUBuffer():this._vertexBuffer.getCPUBuffer();for(const h of f){if(!o.seekIndex(h))throw new Error("Expected to find index");if(t){const{indexFrom:e,indexCount:t}=o;o.indexFrom=r;for(let i=0;i<t;i++)this._indexBuffer.set(r++,d.array[e+i])}else{const{vertexFrom:e,vertexCount:t}=o,i=this._vertexBuffer.strideInt,s=e*i,f=s+t*i;o.vertexFrom=r/i;for(let n=s;n<f;n++)this._vertexBuffer.set(r++,d.array[n])}}this._cursorIndexOrder=f,this._displayList=null}}export{c as Geometry};
