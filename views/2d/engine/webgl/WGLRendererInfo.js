/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{unwrapOr as e,unwrap as t,isSome as i}from"../../../../core/maybe.js";import{pt2px as s}from"../../../../core/screenUtils.js";import{getMetersPerUnitForSR as a}from"../../../../core/unitUtils.js";import{meterIn as r}from"../../../../renderers/support/lengthUtils.js";import{isDefined as o,isNumber as l}from"./Utils.js";import{Technique as n}from"./techniques/Technique.js";import{getTechniqueFromRenderer as v}from"./techniques/utils.js";import{getWebGLCapabilities as u}from"../../../webgl/capabilities.js";function c(e,t){const i=t.length;if(e<t[0].value||1===i)return t[0].size;for(let s=1;s<i;s++)if(e<t[s].value){const i=(e-t[s-1].value)/(t[s].value-t[s-1].value);return t[s-1].size+i*(t[s].size-t[s-1].size)}return t[i-1].size}class h{constructor(){this.symbolLevels=[],this.vvColorValues=new Float32Array(8),this.vvColors=new Float32Array(32),this.vvOpacityValues=new Float32Array(8),this.vvOpacities=new Float32Array(8),this.vvSizeMinMaxValue=new Float32Array(4),this._vvMaterialParameters={vvSizeEnabled:!1,vvColorEnabled:!1,vvRotationEnabled:!1,vvRotationType:"geographic",vvOpacityEnabled:!1},this._technique=n}getSizeVVFieldStops(i){const s=this._vvSizeFieldStops;switch(s.type){case"static":return s;case"level-dependent":return e(s.levels[i],(()=>{let e=1/0,a=0;for(const t in s.levels){const s=parseFloat(t),r=Math.abs(i-s);r<e&&(e=r,a=s)}if(e===1/0)return{sizes:new Float32Array([0,0,0,0,0,0]),values:new Float32Array([0,0,0,0,0,0])};const r=2**((i-a)/2),o=t(s.levels[a]),l=new Float32Array(o.values);return l[2]*=r,l[3]*=r,{sizes:t(o.sizes),values:l}}))}}get vvMaterialParameters(){return this._vvMaterialParameters}update(e){i(this._vvInfo)&&this._updateVisualVariables(this._vvInfo.vvRanges,e)}setInfo(e,t,i){this._updateEffects(i),this._vvInfo=t,this._technique=v(e),this.rendererSchema=this._technique.createOrUpdateRendererSchema(this.rendererSchema,e)}getVariation(){return{...this._technique.getVariation(this.rendererSchema),outsideLabelsVisible:this.outsideLabelsVisible,supportsTextureFloat:u("2d").supportsTextureFloat}}getVariationHash(){return this._technique.getVariationHash(this.rendererSchema)<<1|(this.outsideLabelsVisible?1:0)}_updateEffects(e){i(e)?this.outsideLabelsVisible=e.excludedLabelsVisible:this.outsideLabelsVisible=!1}_updateVisualVariables(e,t){const i=this._vvMaterialParameters;if(i.vvOpacityEnabled=!1,i.vvSizeEnabled=!1,i.vvColorEnabled=!1,i.vvRotationEnabled=!1,!e)return;const n=e.size;if(n){if(i.vvSizeEnabled=!0,n.minMaxValue){const e=n.minMaxValue;let i,a;if(o(e.minSize)&&o(e.maxSize))if(l(e.minSize)&&l(e.maxSize))i=s(e.minSize),a=s(e.maxSize);else{const r=t.scale;i=s(c(r,e.minSize.stops)),a=s(c(r,e.maxSize.stops))}this.vvSizeMinMaxValue.set([e.minDataValue,e.maxDataValue,i,a])}if(n.scaleStops&&(this.vvSizeScaleStopsValue=s(c(t.scale,n.scaleStops.stops))),n.unitValue){const e=a(t.spatialReference)/r[n.unitValue.unit];this.vvSizeUnitValueToPixelsRatio=e/t.resolution}n.fieldStops&&(this._vvSizeFieldStops=n.fieldStops)}const v=e.color;v&&(i.vvColorEnabled=!0,this.vvColorValues.set(v.values),this.vvColors.set(v.colors));const u=e.opacity;u&&(i.vvOpacityEnabled=!0,this.vvOpacityValues.set(u.values),this.vvOpacities.set(u.opacities));const h=e.rotation;h&&(i.vvRotationEnabled=!0,i.vvRotationType=h.type)}}export{h as WGLRendererInfo};
