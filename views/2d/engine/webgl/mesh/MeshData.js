/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import"../../../tiling/PagedTileQueue.js";import"../../../tiling/TileInfoView.js";import e from"../../../tiling/TileKey.js";import"../../../tiling/TileQueue.js";import"../../../tiling/TileStrategy.js";import{PATCH_PIXEL_BUFFER_ALLOC_SIZE as t,TILE_SIZE as r}from"../definitions.js";import{getDisplayIdTexel as i}from"../DisplayId.js";import{WGLGeometryType as s}from"../enums.js";import{getStrides as n}from"../Utils.js";import{VertexDataWriter as a}from"./VertexDataWriter.js";import{getPow2NeighborKey as h}from"../../../layers/features/support/tileUtils.js";const u=1,c=2,o=4,_=8,l=16,d=32,g=64,p=128;function x(e){switch(e){case u:case _:case d:return-1;case c:case g:return 0;case o:case l:case p:return 1}}function m(e){switch(e){case u:case c:case o:return-1;case _:case l:return 0;case d:case g:case p:return 1}}const f=u|_|d,y=o|l|p,w=u|c|o,v=d|g|p;class E{constructor(e,t,r,i,s,n=0){this._hasAggregate=!1,this.hasRecords=!1,this._data={self:new Map,neighbors:new Array},this._version=0,this._current={geometryType:0,writer:null,overlaps:0,start:0,insertAfter:0,sortKey:0,id:0,materialKey:0,indexStart:0,vertStart:0,isDotDensity:!1,bufferingEnabled:!1,metricBoxLenPointer:0},this.hint=t,this.tileKey=e,this._hasAggregate=i,this._pixelBufferEnabled=s,this._version=n,this._symbologyType=r}get hasAggregates(){return this._hasAggregate}get hasPixelBufferEnabled(){return this._pixelBufferEnabled}serialize(t){const r=[];return r.push(this._serializeTileVertexData(this.tileKey,this.tileKey,this._data.self)),this._data.neighbors.forEach(((i,s)=>{const n=1<<s,a=x(n),u=m(n),c=h(new e(this.tileKey),a,u,t),o=this._serializeTileVertexData(this.tileKey,c.id,i.vertexData);o.message.bufferIds=i.displayIds,r.push(o)})),r}_serializeTileVertexData(e,t,r){const i=new Array;return{message:{tileKeyOrigin:e,tileKey:t,data:{[s.MARKER]:r.get(s.MARKER)?.serialize(i),[s.FILL]:r.get(s.FILL)?.serialize(i),[s.LINE]:r.get(s.LINE)?.serialize(i),[s.TEXT]:r.get(s.TEXT)?.serialize(i),[s.LABEL]:r.get(s.LABEL)?.serialize(i)},version:this._version},transferList:i}}featureStart(e,t){this._current.insertAfter=e,this._current.sortKey=t}featureEnd(){}recordStart(e,t,r,i){this._current.writer=this._getVertexWriter(r),this._current.overlaps=0,this._current.indexStart=this._current.writer.indexCount,this._current.vertStart=this._current.writer.vertexCount,this._current.bufferingEnabled=i,this._current.id=e,this._current.materialKey=t,this._current.geometryType=r,this._current.isDotDensity=!1,this._current.writer.recordStart()}recordCount(){return this._current.writer.recordCount}vertexCount(){return this._current.writer.vertexCount}indexCount(){return this._current.writer.indexCount}vertexEnsureSize(e){this._current.writer.vertexEnsureSize(e)}indexEnsureSize(e){this._current.writer.indexEnsureSize(e)}vertexBounds(e,t,r,i){this._current.bufferingEnabled&&this._addOverlap(e,t,r,i)}vertexWrite(e){this._current.writer.writeVertex(e)}vertexWriteF32(e){this._current.writer.writeVertexF32(e)}vertexEnd(){}vertexWriter(){return this._current.writer.vertexWriter}indexWrite(e){this._current.writer.writeIndex(e)}indexWriter(){return this._current.writer.indexWriter}metricWriter(){return this._current.writer.metricWriter}metricStart(e,t,r,n,a,h,u,c){this._current.writer=this._getVertexWriter(s.LABEL);const o=this._current.writer.metricWriter;o.push(i(e)),o.push(t),o.push(r),o.push(n),o.push(a),o.push(h),o.push(u),o.push(c),o.push(255),this._current.metricBoxLenPointer=o.push(0)}metricEnd(){const e=this._current.writer.metricWriter;0===e.getValue(this._current.metricBoxLenPointer)&&e.seek(e.length-10)}metricBoxWrite(e,t,r,i){const s=this._current.writer.metricWriter;s.incr(this._current.metricBoxLenPointer),s.push(0),s.push(0),s.push(e),s.push(t),s.push(r),s.push(i)}recordEnd(){const e=this._current.vertStart,r=this._current.writer.vertexCount-e;if(!r)return!1;this.hasRecords=!0;const i=this._current.indexStart,h=this._current.writer.indexCount-i;if(this._current.writer.recordEnd(this._current.id,this._current.materialKey,this._current.insertAfter,i,h,e,r,this._current.sortKey),!this._pixelBufferEnabled||this._hasAggregate||0===this._current.overlaps||this._current.geometryType===s.LABEL)return!0;const u=this._current.writer;for(let s=0;s<8;s++){const e=1<<s;if(!!(this._current.overlaps&e)){this._data.neighbors[s]||(this._data.neighbors[s]={vertexData:new Map,displayIds:new Set});const r=this._data.neighbors[s],i=this._current.geometryType;if(!r.vertexData.has(i)){const e=n(i,this._symbologyType).geometry,s=new a(i,e,t);r.vertexData.set(i,s)}const h=r.vertexData.get(this._current.geometryType),c=8,o=512*-x(e)*c,_=512*-m(e)*c;h.copyLastFrom(u,o,_),r.displayIds.add(this._current.id)}}return!0}_addOverlap(e,t,i,s){const n=255^((e<0+i?y:e>=r-i?f:y|f)|(t<0+s?v:t>=r-s?w:v|w));this._current.overlaps|=n}_getVertexWriter(e){if(!this._data.self.has(e)){const t=this._data.self,r=n(e,this._symbologyType).geometry;t.set(e,new a(e,r,this.hint.records))}return this._data.self.get(e)}}export{E as MeshData};
