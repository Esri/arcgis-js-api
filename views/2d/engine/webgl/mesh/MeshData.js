/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/_rollupPluginBabelHelpers","../../../tiling/TileKey","../definitions","../../../tiling/PagedTileQueue","../../../tiling/TileInfoView","../../../tiling/TileQueue","../../../tiling/TileStrategy","../enums","../Utils","./VertexDataWriter","../../../layers/features/support/AttributeStore","../../../layers/features/support/tileUtils"],(function(e,t,r,i,n,s,u,c,a,o,h,_,l){"use strict";const f=1,d=2,y=4,p=8,g=16,x=32,m=64,L=128;function w(e){switch(e){case f:case p:case x:return-1;case d:case m:return 0;case y:case g:case L:return 1}}function T(e){switch(e){case f:case d:case y:return-1;case p:case g:return 0;case x:case m:case L:return 1}}const W=f|p|x,E=y|g|L,v=f|d|y,G=x|m|L;let D=function(){function e(e,t,r,i,n){this._hasDotDensity=!1,this._hasAggregate=!1,this.hasRecords=!1,this._data={self:new Map,neighbors:new Array},this._current={geometryType:0,writer:null,overlaps:0,start:0,insertAfter:0,id:0,materialKey:0,indexStart:0,vertStart:0,isDotDensity:!1,bufferingEnabled:!1,metricBoxLenPointer:0},this.hint=t,this.tileKey=e,this._hasDotDensity=r,this._hasAggregate=i,this._pixelBufferEnabled=n}var n=e.prototype;return n.serialize=function(e){const t=[];return t.push(this._serializeTileVertexData(this.tileKey,this._data.self)),this._data.neighbors.forEach(((i,n)=>{const s=1<<n,u=w(s),c=T(s),a=l.getPow2NeighborKey(new r(this.tileKey),u,c,e);t.push(this._serializeTileVertexData(a.id,i))})),t},n._serializeTileVertexData=function(e,t){var r,i,n,s,u;const c=new Array;return{message:{tileKey:e,data:{[a.WGLGeometryType.MARKER]:null==(r=t.get(a.WGLGeometryType.MARKER))?void 0:r.serialize(c),[a.WGLGeometryType.FILL]:null==(i=t.get(a.WGLGeometryType.FILL))?void 0:i.serialize(c),[a.WGLGeometryType.LINE]:null==(n=t.get(a.WGLGeometryType.LINE))?void 0:n.serialize(c),[a.WGLGeometryType.TEXT]:null==(s=t.get(a.WGLGeometryType.TEXT))?void 0:s.serialize(c),[a.WGLGeometryType.LABEL]:null==(u=t.get(a.WGLGeometryType.LABEL))?void 0:u.serialize(c)}},transferList:c}},n.featureStart=function(e=0){this._current.insertAfter=e},n.featureEnd=function(){},n.recordStart=function(e,t,r,i,n){this._current.writer=this._getVertexWriter(r,i),this._current.overlaps=0,this._current.indexStart=this._current.writer.indexCount,this._current.vertStart=this._current.writer.vertexCount,this._current.bufferingEnabled=n,this._current.id=e,this._current.materialKey=t,this._current.geometryType=r,this._current.isDotDensity=!1,this._current.writer.recordStart()},n.recordCount=function(){return this._current.writer.recordCount},n.vertexCount=function(){return this._current.writer.vertexCount},n.indexCount=function(){return this._current.writer.indexCount},n.vertexBounds=function(e,t,r,i){this._current.bufferingEnabled&&this._addOverlap(e,t,r,i)},n.vertexWrite=function(e){this._current.writer.writeVertex(e)},n.vertexWriteF32=function(e){this._current.writer.writeVertexF32(e)},n.vertexEnd=function(){},n.vertexWriter=function(){return this._current.writer.vertexWriter},n.indexWrite=function(e){this._current.writer.writeIndex(e)},n.indexWriter=function(){return this._current.writer.indexWriter},n.metricWriter=function(){return this._current.writer.metricWriter},n.metricStart=function(e,t,r,i,n,s,u,c){this._current.writer=this._getVertexWriter(a.WGLGeometryType.LABEL,!1);const o=this._current.writer.metricWriter;o.push(_.getDisplayIdTexel(e)),o.push(t),o.push(r),o.push(i),o.push(n),o.push(s),o.push(u),o.push(c),o.push(255),this._current.metricBoxLenPointer=o.push(0)},n.metricEnd=function(){const e=this._current.writer.metricWriter;0===e.getValue(this._current.metricBoxLenPointer)&&e.seek(e.length-10)},n.metricBoxWrite=function(e,t,r,i){const n=this._current.writer.metricWriter;n.incr(this._current.metricBoxLenPointer),n.push(0),n.push(0),n.push(e),n.push(t),n.push(r),n.push(i)},n.recordEnd=function(){const e=this._current.indexStart,t=this._current.writer.indexCount;if(e===t)return!1;this.hasRecords=!0;const r=t-e,n=this._current.vertStart,s=this._current.writer.vertexCount-n;if(this._current.writer.recordEnd(this._current.id,this._current.materialKey,this._current.insertAfter,e,r,n,s),!this._pixelBufferEnabled||this._hasAggregate||0===this._current.overlaps||this._current.geometryType===a.WGLGeometryType.LABEL)return!0;const u=this._current.writer;for(let c=0;c<8;c++){const e=1<<c;if(!!(this._current.overlaps&e)){if(!this._data.neighbors[c]){const e=new Map;this._data.neighbors[c]=e}const t=this._data.neighbors[c],r=this._current.geometryType;if(!t.has(r)){const e=o.getStrides(r,this._current.isDotDensity).geometry;t.set(r,new h.VertexDataWriter(r,e,i.PATCH_PIXEL_BUFFER_ALLOC_SIZE))}const n=t.get(this._current.geometryType),s=8,a=512*-w(e)*s,_=512*-T(e)*s;n.copyLastFrom(u,a,_)}}return!0},n._addOverlap=function(e,t,r,n){const s=255^((e<0+r?E:e>=i.TILE_SIZE-r?W:E|W)|(t<0+n?G:t>=i.TILE_SIZE-n?v:G|v));this._current.overlaps|=s},n._getVertexWriter=function(e,t){if(!this._data.self.has(e)){const t=this._data.self,r=o.getStrides(e,this._hasDotDensity).geometry;t.set(e,new h.VertexDataWriter(e,r,8e3))}return this._data.self.get(e)},t._createClass(e,[{key:"hasAggregates",get:function(){return this._hasAggregate}},{key:"hasPixelBufferEnabled",get:function(){return this._pixelBufferEnabled}}]),e}();e.MeshData=D,Object.defineProperty(e,"__esModule",{value:!0})}));
