/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isSome as e,isNone as t}from"../../../../../../core/maybe.js";import{deltaDecodeGeometry as r,convertFromGeometry as i}from"../../../../../../layers/graphics/featureConversionUtils.js";import{WGLGeometryType as s,WGLSymbologyType as o}from"../../enums.js";import{i1616to32 as m}from"../../number.js";import{getStrides as l}from"../../Utils.js";import{FillMaterialKey as n,hasOutlineFillSymbology as a,hasSimpleSymbology as h}from"../../materialKey/MaterialKey.js";import{triangulate as y,triangulateLibtess as p,clipMarshall as c}from"./templateUtils.js";import x from"./WGLLineTemplate.js";const _=100,f=1,u=u=>class extends u{constructor(...e){super(...e),this.forceLibtess=!1,this._bitset=0,this._lineTemplate=null,this.geometryType=s.FILL}_maybeAddLineTemplate(e){this._lineTemplate=x.fromFillOutline(e)}_write(t,r,i,s){const o="esriGeometryPoint"===r.geometryType,m=n.load(this._materialKey);t.recordStart(r.getDisplayId(),this._materialKey,this.geometryType,o),this._writeGeometry(t,r,m,s,o),a(m)&&e(this._lineTemplate)&&this._lineTemplate.writeGeometry(t,r,s,o),t.recordEnd()}_writeGeometry(e,r,i,s,o){const m=this._getGeometry(r,s,o);if(t(m))return;const l=[];if(!(m.maxLength>_)&&!this.forceLibtess&&y(l,m))return void(l.length&&this._writeVertices(e,r,m.coords,m.lengths,i,l));const n=p(m);this._writeVertices(e,r,n,[n.length/2],i)}_writeVertex(e,t,r,i,s,l){const n=m(f*i,f*s);if(e.vertexBounds(i,s,0,0),e.vertexWrite(n),e.vertexWrite(t),r.symbologyType===o.DOT_DENSITY)e.vertexWriteF32(1/Math.abs(l.readGeometryArea()));else{e.vertexWrite(this.fillColor);const t=h(r);t||(e.vertexWrite(this.tl),e.vertexWrite(this.br)),e.vertexWrite(this.aux2_1),e.vertexWrite(this.aux2_2),e.vertexWrite(this.aux3),t||e.vertexWrite(this._minMaxZoom)}}_writeVertices(e,t,r,i,s,o){const m=t.getDisplayId(),n=this._bitset<<24|m,a=i.reduce(((e,t)=>e+t)),h=l(s.geometryType,s.symbologyType).geometry/4,y=e.vertexCount();e.vertexEnsureSize(h*a);let p=0;if(o)for(const l of o){const i=r[2*l],o=r[2*l+1];this._writeVertex(e,n,s,i,o,t),p++}else for(let l=0;l<r.length;l+=2){const i=Math.round(r[l]),o=Math.round(r[l+1]);this._writeVertex(e,n,s,i,o,t),p++}e.indexEnsureSize(p);for(let l=0;l<p;l++)e.indexWrite(l+y)}_getGeometry(e,t,s){const o=t?r(i(t),2):e.readGeometryForDisplay();if(!o)return null;return c(o,s?256:8)}};export{u as default};
