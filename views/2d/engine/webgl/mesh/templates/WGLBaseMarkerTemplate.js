/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isSome as t,isNone as e,unwrap as i}from"../../../../../../core/maybe.js";import{pt2px as r}from"../../../../../../core/screenUtils.js";import{a as s,r as o}from"../../../../../../chunks/mat2d.js";import{c as h}from"../../../../../../chunks/mat2df32.js";import{a as f,t as n}from"../../../../../../chunks/vec2.js";import{f as x,c as a}from"../../../../../../chunks/vec2f32.js";import{deltaDecodeGeometry as m,convertFromGeometry as _}from"../../../../../../layers/graphics/featureConversionUtils.js";import{CIMMarkerPlacementHelper as p}from"../../../../../../symbols/cim/placements/CIMMarkerPlacementHelper.js";import{TILE_SIZE as c}from"../../definitions.js";import{WGLGeometryType as v,WGLSymbologyType as l}from"../../enums.js";import{i1616to32 as d}from"../../number.js";import{MarkerMaterialKey as W}from"../../materialKey/MaterialKey.js";const g=3.14159265359/180,y=8,u=u=>class extends u{constructor(...t){super(...t),this.angle=0,this.xOffset=0,this.yOffset=0,this.width=0,this.height=0,this.boundsType="square",this._anchorX=0,this._anchorY=0,this._computedWidth=0,this._computedHeight=0,this._vertexBoundsScaleX=1,this._vertexBoundsScaleY=1,this._offsets={xUpperLeft:0,yUpperLeft:0,xUpperRight:0,yUpperRight:0,xBottomLeft:0,yBottomLeft:0,xBottomRight:0,yBottomRight:0},this.geometryType=v.MARKER}_write(t,e,i,r){const s=e.getDisplayId();t.recordStart(s,this._materialKey,this.geometryType,!0),this._writeGeometry(t,e,s,i,r),t.recordEnd()}_writeGeometry(i,r,s,o,h){if(t(this._markerPlacement))return this._writePlacedMarkers(i,r,o,h);if(!h&&"esriGeometryPoint"===r.geometryType){const t=r.getX(),e=r.getY();if(!i.hasAggregates&&i.hasPixelBufferEnabled&&(t<0||t>=513||e<0||e>=513))return;return this._writeVertices(i,s,this._getPos(t,e),t,e)}const f=h?m(_(h),2):"esriGeometryPolygon"===r.geometryType?r.readCentroid():r.readGeometryForDisplay();if(!e(f)){if(f.isPoint){const[t,e]=f.coords;if(!i.hasAggregates&&i.hasPixelBufferEnabled&&(t<0||t>=512||e<0||e>=512))return;return this._writeVertices(i,s,this._getPos(t,e),t,e)}f.forEachVertex(((t,e)=>{const r=2*c;t<-r||t>=r||e<-r||e>=r||this._writeVertices(i,s,this._getPos(t,e),t,e)}))}}_writePlacedMarkers(t,e,s,o){const f=o??e.readLegacyGeometryForDisplay(),n=p.getPlacement(f,i(this._markerPlacement),r(1),s.geometryEngine);if(!n)return;const x=e.getDisplayId(),m=a(),_=h(),c=-128,v=640;let l=n.next();for(;null!=l;){const e=l.tx,i=-l.ty;e>=c&&e<=v&&i>=c&&i<=v&&(this._applyTransformation(_,m,-l.getAngle()/g),this._writeVertices(t,x,this._getPos(e,i),e,i)),l=n.next()}}_writeVertices(t,e,i,r,s){const o=W.load(this._materialKey);return o.symbologyType===l.HEATMAP?this._writeHeatmapVertices(t,e,i,r,s):this._writeMarkerVertices(t,e,o,i,r,s)}_writeMarkerVertices(t,e,i,r,s,o){const h=i.vvRotation,f=t.vertexCount();let n=this._computedWidth*this._vertexBoundsScaleX,x=this._computedHeight*this._vertexBoundsScaleY;if(this.angle){const t=Math.max(n,x);n=t,x=t}if(h){const t=Math.max(this.xOffset,this.yOffset);n+=t,x+=t}t.vertexBounds(s+this.xOffset,o-this.yOffset,n,x),t.vertexWrite(r),t.vertexWrite(this._offsetUpperLeft),t.vertexWrite(this._texUpperLeft),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(r),t.vertexWrite(this._offsetUpperRight),t.vertexWrite(this._texUpperRight),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(r),t.vertexWrite(this._offsetBottomLeft),t.vertexWrite(this._texBottomLeft),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(r),t.vertexWrite(this._offsetBottomRight),t.vertexWrite(this._texBottomRight),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),this._writeIndices(t,f)}_writeHeatmapVertices(t,e,i,r,s){const o=t.vertexCount();t.vertexBounds(r+this.xOffset,s-this.yOffset,this.width,this.height),t.vertexWrite(i),t.vertexWrite(this._offsetUpperLeft),t.vertexWrite(e),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetUpperRight),t.vertexWrite(e),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetBottomLeft),t.vertexWrite(e),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetBottomRight),t.vertexWrite(e),t.vertexEnd(),this._writeIndices(t,o)}_writeIndices(t,e){t.indexWrite(e+0),t.indexWrite(e+1),t.indexWrite(e+2),t.indexWrite(e+1),t.indexWrite(e+3),t.indexWrite(e+2)}_applyTransformation(t,e,i=0){s(t,x(this.xOffset,-this.yOffset)),this.angle+i!==0&&o(t,t,g*(this.angle+i));const r=this._computedWidth,h=this._computedHeight,a=(this._anchorX-.5)*r,m=(this._anchorY-.5)*h;f(e,a,m),n(e,e,t),this._offsetUpperLeft=d(16*e[0],16*e[1]),this._offsets.xUpperLeft=e[0],this._offsets.yUpperLeft=e[1],f(e,a+r,m),n(e,e,t),this._offsetUpperRight=d(16*e[0],16*e[1]),this._offsets.xUpperRight=e[0],this._offsets.yUpperRight=e[1],f(e,a,m+h),n(e,e,t),this._offsetBottomLeft=d(16*e[0],16*e[1]),this._offsets.xBottomLeft=e[0],this._offsets.yBottomLeft=e[1],f(e,a+r,m+h),n(e,e,t),this._offsetBottomRight=d(16*e[0],16*e[1]),this._offsets.xBottomRight=e[0],this._offsets.yBottomRight=e[1]}_getPos(t,e){return d(Math.round(y*t),Math.round(y*e))}};export{u as default};
