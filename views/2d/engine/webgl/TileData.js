/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","./enums","./MemoryRequirements","./TileBufferData","./TileDisplayData","./Utils","./WGLDisplayRecord","./cpuMapped/DisplayRecordReader","./mesh/VertexBuffer","./mesh/VertexVector","./util/Writer"],(function(e,t,r,i,s,o,a,n,f,l,u,c){"use strict";const d=new i,D=new i,p=1.5,y=5;function m(e,t){const r={};for(const i in e){const s={data:a.allocateTypedArrayBuffer(t,e[i]),stride:e[i]};r[i]=s}return r}function h(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}function x(e){const t=[[],[],[],[],[]],r=e;for(const i of r)for(const e of i.displayRecords)t[e.geometryType].push(e);return t}let B=function(){function e(){this.tileDisplayData=null,this.tileBufferData=null}var i=e.prototype;return i.reshuffle=function(){d.reset();const t=x(this.tileDisplayData.displayObjects);for(const e of t)for(const t of e)t&&d.needMore(t.geometryType,t.meshData?t.meshData.vertexCount:t.vertexCount,t.meshData?t.meshData.indexData.length:t.indexCount);const r=t.length,i=new s;for(let s=0;s<r;++s){i.geometries[s].indexBuffer=new Uint32Array(Math.round(p*d.indicesFor(s)));const t=[];for(const e in this.tileBufferData.geometries[s].vertexBuffer)t.push(this.tileBufferData.geometries[s].vertexBuffer[e].stride);const r=e._computeVertexAlignment(t),o=Math.round(p*d.verticesFor(s)),n=e._align(o,r);for(const e in this.tileBufferData.geometries[s].vertexBuffer){const t=this.tileBufferData.geometries[s].vertexBuffer[e].stride;i.geometries[s].vertexBuffer[e]={stride:t,data:a.allocateTypedArrayBuffer(n,t)}}}D.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<r;++e){const r=t[e];for(const t of r){if(t.meshData)t.writeMeshDataToBuffers(D.verticesFor(e),i.geometries[e].vertexBuffer,D.indicesFor(e),i.geometries[e].indexBuffer),t.meshData=null;else{const r=this.tileBufferData.geometries[e].vertexBuffer,s=this.tileBufferData.geometries[e].indexBuffer,o=i.geometries[e].vertexBuffer,n=i.geometries[e].indexBuffer,f=D.verticesFor(e),l=D.indicesFor(e);a.copyMeshData(f,l,o,n,t,r,s),t.vertexFrom=f,t.indexFrom=l}D.needMore(e,t.vertexCount,t.indexCount)}}for(const e of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(e.displayRecords);this.tileBufferData=i},i.getStrides=function(){const e=[];for(let t=0;t<this.tileBufferData.geometries.length;++t){const r=this.tileBufferData.geometries[t];e[t]={};for(const i in r.vertexBuffer)e[t][i]=r.vertexBuffer[i].stride}return e},i.clone=function(){const t=new e;return t.tileBufferData=this.tileBufferData.clone(),t.tileDisplayData=this.tileDisplayData.clone(),t},i._guessSize=function(){const{displayObjects:e}=this.tileDisplayData,t=Math.min(e.length,4),r=12,i=40;let s=0;for(let o=0;o<t;o++)s=Math.max(s,e[o].displayRecords.length);return 2*(e.length*r+e.length*s*i)},i.serialize=function(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),r=this.tileDisplayData.serialize(new c(Int32Array,this._guessSize())).buffer();return t.push(r),{result:{displayData:r,bufferData:e},transferList:t}},e.fromVertexData=function(i,s){const o={},c=new Map;for(const e of s)c.set(e.id,e);return a.forEachGeometryType((e=>{const s=i.data[e];if(t.isSome(s)){const t=f.DisplayRecordReader.from(s.records).getCursor();for(;t.next();){const r=t.id,i=t.materialKey,s=t.indexFrom,o=t.indexCount,a=t.vertexFrom,f=t.vertexCount,l=c.get(r),u=new n(r,e,i);u.indexFrom=s,u.indexCount=o,u.vertexFrom=a,u.vertexCount=f,l.displayRecords.push(u)}o[e]=l.VertexBuffers.fromVertexData(s,e)}else o[e]=new u.VertexVectors(e,0,r.WGLSymbologyType.DEFAULT).intoBuffers()})),e.fromMeshData({displayObjects:s,vertexBuffersMap:o})},e.fromMeshData=function(t){const r=new e,i=new o,a=new s;i.displayObjects=t.displayObjects;for(const e in t.vertexBuffersMap){const r=t.vertexBuffersMap[e];a.geometries[e].indexBuffer=r.indexBuffer,a.geometries[e].vertexBuffer=r.namedBuffers}return r.tileDisplayData=i,r.tileBufferData=a,r},e.bind=function(t,r){const i=new e;return i.tileDisplayData=t,i.tileBufferData=r,i},e.create=function(t,r){const i=new e;i.tileDisplayData=new o,i.tileDisplayData.displayObjects=t;const a=[0,0,0,0,0],f=[0,0,0,0,0],l=[[],[],[],[],[]];for(const e of t)for(const t of e.displayRecords)l[t.geometryType].push(t),a[t.geometryType]+=t.meshData.vertexCount,f[t.geometryType]+=t.meshData.indexData.length;const u=new s,c=h(r);for(let e=0;e<y;e++){const t=new Uint32Array(f[e]),r=m(c[e],a[e]);n.writeAllMeshDataToBuffers(l[e],r,t),u.geometries[e]={indexBuffer:t,vertexBuffer:r}}return i.tileBufferData=u,i},e._align=function(e,t){const r=e%t;return 0===r?e:e+(t-r)},e._computeVertexAlignment=function(e){let t=!1,r=!1;for(const i of e)i%4==2?t=!0:i%4!=0&&(r=!0);return r?4:t?2:1},e}();e.TileData=B,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
