/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","./enums","./Utils","./MemoryRequirements","./TileBufferData","./WGLDisplayRecord","./TileDisplayData","./util/Writer","./mesh/MeshData","./mesh/VertexBuffer"],(function(e,t,r,i,s,a,o,n,f,l){"use strict";const u=new i,d=new i,c=1.5;function y(e,t){const i={};for(const s in e){const a={data:r.allocateTypedArrayBuffer(t,e[s]),stride:e[s]};i[s]=a}return i}let p=function(){function e(){this.tileDisplayData=null,this.tileBufferData=null}var i=e.prototype;return i.reshuffle=function(){u.reset();const t=o.groupRecordsByGeometryType(this.tileDisplayData.displayObjects);for(const e of t)for(const t of e)t&&u.needMore(t.geometryType,t.meshData?t.meshData.vertexCount:t.vertexCount,t.meshData?t.meshData.indexData.length:t.indexCount);const i=t.length,a=new s;for(let t=0;t<i;++t){a.geometries[t].indexBuffer=new Uint32Array(Math.round(c*u.indicesFor(t)));const i=[];for(const e in this.tileBufferData.geometries[t].vertexBuffer)i.push(this.tileBufferData.geometries[t].vertexBuffer[e].stride);const s=e._computeVertexAlignment(i),o=Math.round(c*u.verticesFor(t)),n=e._align(o,s);for(const e in this.tileBufferData.geometries[t].vertexBuffer){const i=this.tileBufferData.geometries[t].vertexBuffer[e].stride;a.geometries[t].vertexBuffer[e]={stride:i,data:r.allocateTypedArrayBuffer(n,i)}}}d.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<i;++e){const i=t[e];for(const t of i){if(t.meshData)t.writeMeshDataToBuffers(d.verticesFor(e),a.geometries[e].vertexBuffer,d.indicesFor(e),a.geometries[e].indexBuffer),t.meshData=null;else{const i=this.tileBufferData.geometries[e].vertexBuffer,s=this.tileBufferData.geometries[e].indexBuffer,o=a.geometries[e].vertexBuffer,n=a.geometries[e].indexBuffer,f=d.verticesFor(e),l=d.indicesFor(e);r.copyMeshData(f,l,o,n,t,i,s),t.vertexFrom=f,t.indexFrom=l}d.needMore(e,t.vertexCount,t.indexCount)}this.tileDisplayData.displayList.unified||this.tileDisplayData.displayList.addToList(i)}if(this.tileDisplayData.displayList.unified)for(const e of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(e.displayRecords);this.tileBufferData=a},i.reshuffleBulkAdd=function(i,a,o){const n=i.addOrUpdate.tileDisplayData.displayObjects,f=this.tileDisplayData.displayObjects;u.reset();for(let e=0;e<f.length;e++){const t=f[e];for(let e=0;e<t.displayRecords.length;e++){const r=t.displayRecords[e];u.needMore(r.geometryType,r.vertexCount,r.indexCount)}}for(let e=a;e<n.length;e++){const t=n[e];for(let r=e===a?o:0;r<t.displayRecords.length;r++){const e=t.displayRecords[r];u.needMore(e.geometryType,e.vertexCount,e.indexCount)}}const l=new s;for(let t=0;t<5;t++){l.geometries[t].indexBuffer=new Uint32Array(Math.round(c*u.indicesFor(t)));const i=[],s=this.tileBufferData.geometries[t].vertexBuffer;for(const e in s)i.push(s[e].stride);const a=e._computeVertexAlignment(i),o=Math.round(c*u.verticesFor(t)),n=e._align(o,a);for(const e in s){const i=s[e].stride,a=r.allocateTypedArrayBuffer(n,i);l.geometries[t].vertexBuffer[e]={stride:i,data:a}}}d.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<f.length;e++){const t=f[e];for(let e=0;e<t.displayRecords.length;e++){const i=t.displayRecords[e],s=i.geometryType,a=this.tileBufferData.geometries[s].vertexBuffer,o=this.tileBufferData.geometries[s].indexBuffer,n=l.geometries[s].vertexBuffer,f=l.geometries[s].indexBuffer,u=d.verticesFor(s),c=d.indicesFor(s);r.copyMeshData(u,c,n,f,i,a,o),i.vertexFrom=u,i.indexFrom=c,d.needMore(s,i.vertexCount,i.indexCount),this.tileDisplayData.displayList.addToList(i)}}const y=this.tileDisplayData.displayObjectRegistry;if(0!==o){const e=n[a];for(let i=0;i<o;i++){const s=e.displayRecords[i];if(y.get(e.id)){if(s.geometryType!==t.WGLGeometryType.FILL&&s.geometryType!==t.WGLGeometryType.LINE)continue}const a=s.geometryType,o=this.tileBufferData.geometries[a].vertexBuffer,n=this.tileBufferData.geometries[a].indexBuffer,f=l.geometries[a].vertexBuffer,u=l.geometries[a].indexBuffer,c=d.verticesFor(a),p=d.indicesFor(a);r.copyMeshData(c,p,f,u,s,o,n),s.vertexFrom=c,s.indexFrom=p,d.needMore(a,s.vertexCount,s.indexCount),this.tileDisplayData.displayList.addToList(s)}}for(let e=a;e<n.length;e++){const s=n[e],f=e===a?o:0,u=y.get(s.id);for(let e=f;e<s.displayRecords.length;e++){const a=s.displayRecords[e];if(u){if(a.geometryType!==t.WGLGeometryType.FILL&&a.geometryType!==t.WGLGeometryType.LINE)continue;u.displayRecords.push(a)}const o=a.geometryType,n=i.addOrUpdate.tileBufferData.geometries[o],f=n.vertexBuffer,c=n.indexBuffer,y=l.geometries[o].vertexBuffer,p=l.geometries[o].indexBuffer,D=d.verticesFor(o),h=d.indicesFor(o);r.copyMeshData(D,h,y,p,a,f,c),a.vertexFrom=D,a.indexFrom=h,d.needMore(o,a.vertexCount,a.indexCount),this.tileDisplayData.displayList.addToList(a)}u||(y.set(s.id,s),this.tileDisplayData.displayObjects.push(s))}this.tileBufferData=l},i.getStrides=function(){const e=[];for(let t=0;t<this.tileBufferData.geometries.length;++t){const r=this.tileBufferData.geometries[t];e[t]={};for(const i in r.vertexBuffer)e[t][i]=r.vertexBuffer[i].stride}return e},i.clone=function(){const t=new e;return t.tileBufferData=this.tileBufferData.clone(),t.tileDisplayData=this.tileDisplayData.clone(),t},i._guessSize=function(){const{displayObjects:e}=this.tileDisplayData,t=Math.min(e.length,4);let r=0;for(let i=0;i<t;i++)r=Math.max(r,e[i].displayRecords.length);return 2*(12*e.length+e.length*r*40)},i.serialize=function(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),r=this.tileDisplayData.serialize(new n(Int32Array,this._guessSize())).buffer();return t.push(r),{result:{displayData:r,bufferData:e},transferList:t}},e.decode=function(t){const r=f.MeshData.deserializeDisplayObjects(t),i={};for(const e in t.vertexBuffersMap)i[e]=l.VertexBuffers.decode(t.vertexBuffersMap[e]);return e.fromMeshData({displayObjects:r,vertexBuffersMap:i})},e.fromMeshData=function(t){const r=new e,i=new o.default,a=new s;i.displayObjects=t.displayObjects;for(const e in t.vertexBuffersMap){const r=t.vertexBuffersMap[e];a.geometries[e].indexBuffer=r.indexBuffer,a.geometries[e].vertexBuffer=r.namedBuffers}return r.tileDisplayData=i,r.tileBufferData=a,r},e.bind=function(t,r){const i=new e;return i.tileDisplayData=t,i.tileBufferData=r,i},e.create=function(t,r){const i=new e;i.tileDisplayData=new o.default,i.tileDisplayData.displayObjects=t;const n=[0,0,0,0,0],f=[0,0,0,0,0],l=[[],[],[],[],[]];for(const e of t)for(const t of e.displayRecords)l[t.geometryType].push(t),n[t.geometryType]+=t.meshData.vertexCount,f[t.geometryType]+=t.meshData.indexData.length;const u=new s,d=function(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}(r);for(let e=0;e<5;e++){const t=new Uint32Array(f[e]),r=y(d[e],n[e]);a.writeAllMeshDataToBuffers(l[e],r,t),u.geometries[e]={indexBuffer:t,vertexBuffer:r}}return i.tileBufferData=u,i},e._align=function(e,t){const r=e%t;return 0===r?e:e+(t-r)},e._computeVertexAlignment=function(e){let t=!1,r=!1;for(const i of e)i%4==2?t=!0:i%4!=0&&(r=!0);return r?4:t?2:1},e}();e.TileData=p,Object.defineProperty(e,"__esModule",{value:!0})}));
