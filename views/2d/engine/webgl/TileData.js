// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.17/esri/copyright.txt for details.

define(["require","exports","./MemoryRequirements","./TileBufferData","./TileDisplayData","./Utils","./Utils","./WGLDisplayRecord","./mesh/MeshData","./mesh/VertexBuffer","./util/Writer"],(function(e,t,r,i,a,s,f,o,l,n,u){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TileData=void 0;var d=new r.default,p=new r.default;function y(e,t){var r={};for(var i in e){var a={data:f.allocateTypedArrayBuffer(t,e[i]),stride:e[i]};r[i]=a}return r}var D=function(){function e(){this.tileDisplayData=null,this.tileBufferData=null}return e.prototype.reshuffle=function(){d.reset();for(var t=a.groupRecordsByGeometryType(this.tileDisplayData.displayObjects),r=0,o=t;r<o.length;r++)for(var l=0,n=M=o[r];l<n.length;l++){(w=n[l])&&d.needMore(w.geometryType,w.meshData?w.meshData.vertexCount:w.vertexCount,w.meshData?w.meshData.indexData.length:w.indexCount)}for(var u=t.length,y=new i,D=0;D<u;++D){y.geometries[D].indexBuffer=new Uint32Array(Math.round(1.5*d.indicesFor(D)));var v=[];for(var h in this.tileBufferData.geometries[D].vertexBuffer)v.push(this.tileBufferData.geometries[D].vertexBuffer[h].stride);var c=e._computeVertexAlignment(v),g=Math.round(1.5*d.verticesFor(D)),B=e._align(g,c);for(var x in this.tileBufferData.geometries[D].vertexBuffer){var m=this.tileBufferData.geometries[D].vertexBuffer[x].stride;y.geometries[D].vertexBuffer[x]={stride:m,data:f.allocateTypedArrayBuffer(B,m)}}}p.reset(),this.tileDisplayData.displayList.clear();for(D=0;D<u;++D){for(var M,T=0,F=M=t[D];T<F.length;T++){var w;if((w=F[T]).meshData)w.writeMeshDataToBuffers(p.verticesFor(D),y.geometries[D].vertexBuffer,p.indicesFor(D),y.geometries[D].indexBuffer),w.meshData=null;else{var b=this.tileBufferData.geometries[D].vertexBuffer,R=this.tileBufferData.geometries[D].indexBuffer,C=y.geometries[D].vertexBuffer,L=y.geometries[D].indexBuffer,O=p.verticesFor(D),j=p.indicesFor(D);s.copyMeshData(O,j,C,L,w,b,R),w.vertexFrom=O,w.indexFrom=j}p.needMore(D,w.vertexCount,w.indexCount)}this.tileDisplayData.displayList.unified||this.tileDisplayData.displayList.addToList(M)}if(this.tileDisplayData.displayList.unified)for(var A=0,_=this.tileDisplayData.displayObjects;A<_.length;A++){var U=_[A];this.tileDisplayData.displayList.addToList(U.displayRecords)}this.tileBufferData=y},e.prototype.reshuffleV2=function(t,r,a){var o=t.addOrUpdate.tileDisplayData.displayObjects,l=this.tileDisplayData.displayObjects;d.reset();for(var n=0;n<l.length;n++)for(var u=l[n],y=0;y<u.displayRecords.length;y++){var D=u.displayRecords[y];d.needMore(D.geometryType,D.vertexCount,D.indexCount)}for(n=r;n<o.length;n++)for(u=o[n],y=n===r?a:0;y<u.displayRecords.length;y++){D=u.displayRecords[y];d.needMore(D.geometryType,D.vertexCount,D.indexCount)}var v=new i;for(n=0;n<5;n++){v.geometries[n].indexBuffer=new Uint32Array(Math.round(1.5*d.indicesFor(n)));var h=[],c=this.tileBufferData.geometries[n].vertexBuffer;for(var g in c)h.push(c[g].stride);var B=e._computeVertexAlignment(h),x=Math.round(1.5*d.verticesFor(n)),m=e._align(x,B);for(var M in c){var T=c[M].stride,F=f.allocateTypedArrayBuffer(m,T);v.geometries[n].vertexBuffer[M]={stride:T,data:F}}}p.reset(),this.tileDisplayData.displayList.clear();for(n=0;n<l.length;n++)for(u=l[n],y=0;y<u.displayRecords.length;y++){var w=(D=u.displayRecords[y]).geometryType,b=(c=this.tileBufferData.geometries[w].vertexBuffer,this.tileBufferData.geometries[w].indexBuffer),R=v.geometries[w].vertexBuffer,C=v.geometries[w].indexBuffer,L=p.verticesFor(w),O=p.indicesFor(w);s.copyMeshData(L,O,R,C,D,c,b),D.vertexFrom=L,D.indexFrom=O,p.needMore(w,D.vertexCount,D.indexCount),this.tileDisplayData.displayList.addToList(D)}if(0!==a)for(u=o[r],y=0;y<a;y++){w=(D=u.displayRecords[y]).geometryType,c=this.tileBufferData.geometries[w].vertexBuffer,b=this.tileBufferData.geometries[w].indexBuffer,R=v.geometries[w].vertexBuffer,C=v.geometries[w].indexBuffer,L=p.verticesFor(w),O=p.indicesFor(w);s.copyMeshData(L,O,R,C,D,c,b),D.vertexFrom=L,D.indexFrom=O,p.needMore(w,D.vertexCount,D.indexCount),this.tileDisplayData.displayList.addToList(D)}for(n=r;n<o.length;n++){for(u=o[n],y=n===r?a:0;y<u.displayRecords.length;y++){w=(D=u.displayRecords[y]).geometryType;var j=t.addOrUpdate.tileBufferData.geometries[w];c=j.vertexBuffer,b=j.indexBuffer,R=v.geometries[w].vertexBuffer,C=v.geometries[w].indexBuffer,L=p.verticesFor(w),O=p.indicesFor(w);s.copyMeshData(L,O,R,C,D,c,b),D.vertexFrom=L,D.indexFrom=O,p.needMore(w,D.vertexCount,D.indexCount),this.tileDisplayData.displayList.addToList(D)}if(this.tileDisplayData.hasRegistry)this.tileDisplayData.displayObjectRegistry.set(u.id,u);this.tileDisplayData.displayObjects.push(u)}this.tileBufferData=v},e.prototype.getStrides=function(){for(var e=[],t=0;t<this.tileBufferData.geometries.length;++t){var r=this.tileBufferData.geometries[t];for(var i in e[t]={},r.vertexBuffer)e[t][i]=r.vertexBuffer[i].stride}return e},e.prototype.clone=function(){var t=new e;return t.tileBufferData=this.tileBufferData.clone(),t.tileDisplayData=this.tileDisplayData.clone(),t},e.prototype._guessSize=function(){for(var e=this.tileDisplayData.displayObjects,t=Math.min(e.length,4),r=0,i=0;i<t;i++)r=Math.max(r,e[i].displayRecords.length);return 2*(12*e.length+e.length*r*40)},e.prototype.serialize=function(){var e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),r=this.tileDisplayData.serialize(new u.default(Int32Array,this._guessSize())).buffer();return t.push(r),{result:{displayData:r,bufferData:e},transferList:t}},e.decode=function(t){var r=l.MeshData.deserializeDisplayObjects(t),i={};for(var a in t.vertexBuffersMap)i[a]=n.VertexBuffers.decode(t.vertexBuffersMap[a]);return e.fromMeshData({displayObjects:r,vertexBuffersMap:i})},e.fromMeshData=function(t){var r=new e,s=new a.default,f=new i;for(var o in s.displayObjects=t.displayObjects,t.vertexBuffersMap){var l=t.vertexBuffersMap[o];f.geometries[o].indexBuffer=l.indexBuffer,f.geometries[o].vertexBuffer=l.namedBuffers}return r.tileDisplayData=s,r.tileBufferData=f,r},e.bind=function(t,r){var i=new e;return i.tileDisplayData=t,i.tileBufferData=r,i},e.create=function(t,r){var s=new e;s.tileDisplayData=new a.default,s.tileDisplayData.displayObjects=t;for(var f=[0,0,0,0,0],l=[0,0,0,0,0],n=[[],[],[],[],[]],u=0,d=t;u<d.length;u++)for(var p=0,D=d[u].displayRecords;p<D.length;p++){var v=D[p];n[v.geometryType].push(v),f[v.geometryType]+=v.meshData.vertexCount,l[v.geometryType]+=v.meshData.indexData.length}for(var h=new i,c=function(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}(r),g=0;g<5;g++){var B=new Uint32Array(l[g]),x=y(c[g],f[g]);o.writeAllMeshDataToBuffers(n[g],x,B),h.geometries[g]={indexBuffer:B,vertexBuffer:x}}return s.tileBufferData=h,s},e._align=function(e,t){var r=e%t;return 0===r?e:e+(t-r)},e._computeVertexAlignment=function(e){for(var t=!1,r=!1,i=0,a=e;i<a.length;i++){var s=a[i];s%4==2?t=!0:s%4!=0&&(r=!0)}return r?4:t?2:1},e}();t.TileData=D}));