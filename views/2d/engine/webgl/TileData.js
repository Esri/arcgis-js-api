/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","./MemoryRequirements","./TileBufferData","./TileDisplayData","./Utils","./WGLDisplayRecord","./cpuMapped/DisplayRecordReader","./mesh/VertexBuffer","./mesh/VertexVector","./util/Writer"],(function(e,t,r,i,s,a,n,o,f,l,u){"use strict";const c=new r,d=new r,D=1.5,p=5;function m(e,t){const r={};for(const i in e){const s={data:a.allocateTypedArrayBuffer(t,e[i]),stride:e[i]};r[i]=s}return r}function y(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}let h=function(){function e(){this.tileDisplayData=null,this.tileBufferData=null}var r=e.prototype;return r.reshuffle=function(){c.reset();const t=s.groupRecordsByGeometryType(this.tileDisplayData.displayObjects);for(const e of t)for(const t of e)t&&c.needMore(t.geometryType,t.meshData?t.meshData.vertexCount:t.vertexCount,t.meshData?t.meshData.indexData.length:t.indexCount);const r=t.length,n=new i;for(let i=0;i<r;++i){n.geometries[i].indexBuffer=new Uint32Array(Math.round(D*c.indicesFor(i)));const t=[];for(const e in this.tileBufferData.geometries[i].vertexBuffer)t.push(this.tileBufferData.geometries[i].vertexBuffer[e].stride);const r=e._computeVertexAlignment(t),s=Math.round(D*c.verticesFor(i)),o=e._align(s,r);for(const e in this.tileBufferData.geometries[i].vertexBuffer){const t=this.tileBufferData.geometries[i].vertexBuffer[e].stride;n.geometries[i].vertexBuffer[e]={stride:t,data:a.allocateTypedArrayBuffer(o,t)}}}d.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<r;++e){const r=t[e];for(const t of r){if(t.meshData)t.writeMeshDataToBuffers(d.verticesFor(e),n.geometries[e].vertexBuffer,d.indicesFor(e),n.geometries[e].indexBuffer),t.meshData=null;else{const r=this.tileBufferData.geometries[e].vertexBuffer,i=this.tileBufferData.geometries[e].indexBuffer,s=n.geometries[e].vertexBuffer,o=n.geometries[e].indexBuffer,f=d.verticesFor(e),l=d.indicesFor(e);a.copyMeshData(f,l,s,o,t,r,i),t.vertexFrom=f,t.indexFrom=l}d.needMore(e,t.vertexCount,t.indexCount)}}for(const e of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(e.displayRecords);this.tileBufferData=n},r.getStrides=function(){const e=[];for(let t=0;t<this.tileBufferData.geometries.length;++t){const r=this.tileBufferData.geometries[t];e[t]={};for(const i in r.vertexBuffer)e[t][i]=r.vertexBuffer[i].stride}return e},r.clone=function(){const t=new e;return t.tileBufferData=this.tileBufferData.clone(),t.tileDisplayData=this.tileDisplayData.clone(),t},r._guessSize=function(){const{displayObjects:e}=this.tileDisplayData,t=Math.min(e.length,4),r=12,i=40;let s=0;for(let a=0;a<t;a++)s=Math.max(s,e[a].displayRecords.length);return 2*(e.length*r+e.length*s*i)},r.serialize=function(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),r=this.tileDisplayData.serialize(new u(Int32Array,this._guessSize())).buffer();return t.push(r),{result:{displayData:r,bufferData:e},transferList:t}},e.fromVertexData=function(r,i){const s={},u=new Map;for(const e of i)u.set(e.id,e);return a.forEachGeometryType((e=>{const i=r.data[e];if(t.isSome(i)){const t=o.DisplayRecordReader.from(i.records).getCursor();for(;t.next();){const r=t.id,i=t.materialKey,s=t.indexFrom,a=t.indexCount,o=t.vertexFrom,f=t.vertexCount,l=u.get(r),c=new n(r,e,i);c.indexFrom=s,c.indexCount=a,c.vertexFrom=o,c.vertexCount=f,l.displayRecords.push(c)}s[e]=f.VertexBuffers.fromVertexData(i,e)}else s[e]=new l.VertexVectors(e,0,{fill:"default"}).intoBuffers()})),e.fromMeshData({displayObjects:i,vertexBuffersMap:s})},e.fromMeshData=function(t){const r=new e,a=new s.default,n=new i;a.displayObjects=t.displayObjects;for(const e in t.vertexBuffersMap){const r=t.vertexBuffersMap[e];n.geometries[e].indexBuffer=r.indexBuffer,n.geometries[e].vertexBuffer=r.namedBuffers}return r.tileDisplayData=a,r.tileBufferData=n,r},e.bind=function(t,r){const i=new e;return i.tileDisplayData=t,i.tileBufferData=r,i},e.create=function(t,r){const a=new e;a.tileDisplayData=new s.default,a.tileDisplayData.displayObjects=t;const o=[0,0,0,0,0],f=[0,0,0,0,0],l=[[],[],[],[],[]];for(const e of t)for(const t of e.displayRecords)l[t.geometryType].push(t),o[t.geometryType]+=t.meshData.vertexCount,f[t.geometryType]+=t.meshData.indexData.length;const u=new i,c=y(r);for(let e=0;e<p;e++){const t=new Uint32Array(f[e]),r=m(c[e],o[e]);n.writeAllMeshDataToBuffers(l[e],r,t),u.geometries[e]={indexBuffer:t,vertexBuffer:r}}return a.tileBufferData=u,a},e._align=function(e,t){const r=e%t;return 0===r?e:e+(t-r)},e._computeVertexAlignment=function(e){let t=!1,r=!1;for(const i of e)i%4==2?t=!0:i%4!=0&&(r=!0);return r?4:t?2:1},e}();e.TileData=h,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
