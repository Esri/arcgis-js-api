/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../../core/maybe","./Utils","./cpuMapped/DisplayRecordReader","./MemoryRequirements","./TileBufferData","./WGLDisplayRecord","./WGLDisplayObject","./TileDisplayData","./mesh/VertexBuffer","./util/Writer","./mesh/VertexVector"],(function(e,t,r,i,s,a,n,o,f,l,u,c){"use strict";const d=new s,D=new s,p=1.5,y=5;function h(e,t){const i={};for(const s in e){const a={data:r.allocateTypedArrayBuffer(t,e[s]),stride:e[s]};i[s]=a}return i}function m(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}let x=function(){function e(){this.tileDisplayData=null,this.tileBufferData=null}var s=e.prototype;return s.reshuffle=function(){d.reset();const t=f.groupRecordsByGeometryType(this.tileDisplayData.displayObjects);for(const e of t)for(const t of e)t&&d.needMore(t.geometryType,t.meshData?t.meshData.vertexCount:t.vertexCount,t.meshData?t.meshData.indexData.length:t.indexCount);const i=t.length,s=new a;for(let a=0;a<i;++a){s.geometries[a].indexBuffer=new Uint32Array(Math.round(p*d.indicesFor(a)));const t=[];for(const e in this.tileBufferData.geometries[a].vertexBuffer)t.push(this.tileBufferData.geometries[a].vertexBuffer[e].stride);const i=e._computeVertexAlignment(t),n=Math.round(p*d.verticesFor(a)),o=e._align(n,i);for(const e in this.tileBufferData.geometries[a].vertexBuffer){const t=this.tileBufferData.geometries[a].vertexBuffer[e].stride;s.geometries[a].vertexBuffer[e]={stride:t,data:r.allocateTypedArrayBuffer(o,t)}}}D.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<i;++e){const i=t[e];for(const t of i){if(t.meshData)t.writeMeshDataToBuffers(D.verticesFor(e),s.geometries[e].vertexBuffer,D.indicesFor(e),s.geometries[e].indexBuffer),t.meshData=null;else{const i=this.tileBufferData.geometries[e].vertexBuffer,a=this.tileBufferData.geometries[e].indexBuffer,n=s.geometries[e].vertexBuffer,o=s.geometries[e].indexBuffer,f=D.verticesFor(e),l=D.indicesFor(e);r.copyMeshData(f,l,n,o,t,i,a),t.vertexFrom=f,t.indexFrom=l}D.needMore(e,t.vertexCount,t.indexCount)}}for(const e of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(e.displayRecords);this.tileBufferData=s},s.getStrides=function(){const e=[];for(let t=0;t<this.tileBufferData.geometries.length;++t){const r=this.tileBufferData.geometries[t];e[t]={};for(const i in r.vertexBuffer)e[t][i]=r.vertexBuffer[i].stride}return e},s.clone=function(){const t=new e;return t.tileBufferData=this.tileBufferData.clone(),t.tileDisplayData=this.tileDisplayData.clone(),t},s._guessSize=function(){const{displayObjects:e}=this.tileDisplayData,t=Math.min(e.length,4),r=12,i=40;let s=0;for(let a=0;a<t;a++)s=Math.max(s,e[a].displayRecords.length);return 2*(e.length*r+e.length*s*i)},s.serialize=function(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),r=this.tileDisplayData.serialize(new u(Int32Array,this._guessSize())).buffer();return t.push(r),{result:{displayData:r,bufferData:e},transferList:t}},e.fromVertexData=function(s){const a=[],f={},u=new Map;return r.forEachGeometryType((e=>{const r=s.data[e];if(t.isSome(r)){const t=i.DisplayRecordReader.from(r.records).getCursor();for(;t.next();){const r=t.id,i=t.materialKey,s=t.insertAfter,f=t.indexFrom,l=t.indexCount,c=t.vertexFrom,d=t.vertexCount;if(!u.has(r)){const e=new o(r);e.insertAfter=s,u.set(r,e),a.push(e)}const D=u.get(r),p=new n(r,e,i);p.indexFrom=f,p.indexCount=l,p.vertexFrom=c,p.vertexCount=d,D.displayRecords.push(p)}f[e]=l.VertexBuffers.fromVertexData(r,e)}else f[e]=new c.VertexVectors(e,0).intoBuffers()})),a.sort(((e,t)=>e.id-t.id)),e.fromMeshData({displayObjects:a,vertexBuffersMap:f})},e.fromMeshData=function(t){const r=new e,i=new f.default,s=new a;i.displayObjects=t.displayObjects;for(const e in t.vertexBuffersMap){const r=t.vertexBuffersMap[e];s.geometries[e].indexBuffer=r.indexBuffer,s.geometries[e].vertexBuffer=r.namedBuffers}return r.tileDisplayData=i,r.tileBufferData=s,r},e.bind=function(t,r){const i=new e;return i.tileDisplayData=t,i.tileBufferData=r,i},e.create=function(t,r){const i=new e;i.tileDisplayData=new f.default,i.tileDisplayData.displayObjects=t;const s=[0,0,0,0,0],o=[0,0,0,0,0],l=[[],[],[],[],[]];for(const e of t)for(const t of e.displayRecords)l[t.geometryType].push(t),s[t.geometryType]+=t.meshData.vertexCount,o[t.geometryType]+=t.meshData.indexData.length;const u=new a,c=m(r);for(let e=0;e<y;e++){const t=new Uint32Array(o[e]),r=h(c[e],s[e]);n.writeAllMeshDataToBuffers(l[e],r,t),u.geometries[e]={indexBuffer:t,vertexBuffer:r}}return i.tileBufferData=u,i},e._align=function(e,t){const r=e%t;return 0===r?e:e+(t-r)},e._computeVertexAlignment=function(e){let t=!1,r=!1;for(const i of e)i%4==2?t=!0:i%4!=0&&(r=!0);return r?4:t?2:1},e}();e.TileData=x,Object.defineProperty(e,"__esModule",{value:!0})}));
