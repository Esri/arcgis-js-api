/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","./mesh/templates/util"],(function(t,e){"use strict";let r,i=function(){this.closed=void 0,this.isFirstVertex=void 0,this.isLastVertex=void 0,this.isCap=void 0,this.currentVertex={x:void 0,y:void 0},this.inbound={x:void 0,y:void 0},this.outbound={x:void 0,y:void 0},this.prevNormal={x:void 0,y:void 0},this.nextNormal={x:void 0,y:void 0},this.bisector={x:void 0,y:void 0},this.leftInner={x:void 0,y:void 0},this.rightInner={x:void 0,y:void 0},this.leftOuter={x:void 0,y:void 0},this.rightOuter={x:void 0,y:void 0}};function n(t,e,i){s.trackDistance=null!=e.trackDistance&&e.trackDistance,s.wrapDistance=null!=e.wrapDistance?e.wrapDistance:65535,s.thin=null!=e.thin&&e.thin,s.initialDistance=null!=e.initialDistance?e.initialDistance:0,s.enableOuterBisectorSplit=null!=e.enableOuterBisectorSplit&&e.enableOuterBisectorSplit,s.outerBisectorAutoSplitThreshold=null!=e.outerBisectorAutoSplitThreshold?e.outerBisectorAutoSplitThreshold:0,s.enableInnerBisectorSplit=null!=e.enableOuterBisectorSplit&&e.enableOuterBisectorSplit,s.innerBisectorAutoSplitThreshold=null!=e.innerBisectorAutoSplitThreshold?e.innerBisectorAutoSplitThreshold:0,r=t,u=i,l=0,c=0,y=0,a=!1,d=null,h=null,b.currentVertex.x=null,b.currentVertex.y=null,b.distance=s.initialDistance;const n=r[0],x=r[r.length-1];b.canSplit=!1,b.closed=n.x===x.x&&n.y===x.y,r.length<2||2===r.length&&b.closed||(s.thin?s.trackDistance?p():f():s.enableOuterBisectorSplit||s.outerBisectorAutoSplitThreshold>0||s.enableInnerBisectorSplit||s.innerBisectorAutoSplitThreshold>0?(b.canSplit=!0,g()):V())}function x(){r=null,u=null}function o(){if(b.cosine<s.innerBisectorAutoSplitThreshold){b.splitInner=!0,b.gapInner=!0;const t=Math.max(s.innerBisectorAutoSplitThreshold,b.cosine),e=Math.sqrt(1-t*t)/t;b.leftInner.x=b.nextNormal.x+b.sign*e*b.outbound.x,b.leftInner.y=b.nextNormal.y+b.sign*e*b.outbound.y,b.rightInner.x=b.prevNormal.x-b.sign*e*b.inbound.x,b.rightInner.y=b.prevNormal.y-b.sign*e*b.inbound.y}else s.enableInnerBisectorSplit&&(b.splitInner=!0,b.gapInner=!1,b.leftInner.x=b.rightInner.x=b.bisector.x/b.cosine,b.leftInner.y=b.rightInner.y=b.bisector.y/b.cosine);if(b.cosine<s.outerBisectorAutoSplitThreshold){b.splitOuter=!0,b.gapOuter=!0;const t=Math.max(s.outerBisectorAutoSplitThreshold,b.cosine),e=Math.sqrt(1-t*t)/t;b.leftOuter.x=b.prevNormal.x-b.sign*e*b.inbound.x,b.leftOuter.y=b.prevNormal.y-b.sign*e*b.inbound.y,b.rightOuter.x=b.nextNormal.x+b.sign*e*b.outbound.x,b.rightOuter.y=b.nextNormal.y+b.sign*e*b.outbound.y}else s.enableOuterBisectorSplit&&(b.splitOuter=!0,b.gapOuter=!1,b.leftOuter.x=b.rightOuter.x=b.bisector.x/b.cosine,b.leftOuter.y=b.rightOuter.y=b.bisector.y/b.cosine)}const s={};let u,l,c,y,a,d,h;const b=new i;function V(){for(E(),v(),N(1),b.closure0=b.leftEntry0,b.closure1=b.leftEntry1,b.closure2=b.leftEntry2;c-y>s.wrapDistance||l<r.length-1||l<r.length&&(!b.closed||s.trackDistance);)E(),v(),N(2),u.bridge(b),b.leftExit0=b.rightExit0,b.leftExit1=b.rightExit1,b.leftExit2=b.rightExit2;b.closed&&!s.trackDistance&&(b.rightEntry0=b.closure0,b.rightEntry1=b.closure1,b.rightEntry2=b.closure2,u.bridge(b),b.leftExit0=b.rightExit0,b.leftExit1=b.rightExit1,b.leftExit2=b.rightExit2)}function g(){for(E(),v(),b.splitInner=b.gapInner=b.splitOuter=b.gapOuter=!1,N(1),b.closure0=b.leftEntry0,b.closure1=b.leftEntry1,b.closure2=b.leftEntry2;c-y>s.wrapDistance||l<r.length-1||l<r.length&&(!b.closed||s.trackDistance);)E(),v(),b.splitInner=b.gapInner=b.splitOuter=b.gapOuter=!1,N(2),u.bridge(b),b.leftExit0=b.rightExit0,b.leftExit1=b.rightExit1,b.leftExit2=b.rightExit2;b.closed&&!s.trackDistance&&(b.rightEntry0=b.closure0,b.rightEntry1=b.closure1,b.rightEntry2=b.closure2,u.bridge(b),b.leftExit0=b.rightExit0,b.leftExit1=b.rightExit1,b.leftExit2=b.rightExit2)}function p(){for(E(),m(),w(1);c-y>s.wrapDistance||l<r.length;)E(),m(),w(2),u.bridge(b),b.leftExit0=b.rightExit0,b.leftExit2=b.rightExit2}function f(){for(;l<r.length;){if(l>0&&(b.inbound.x=b.outbound.x,b.inbound.y=b.outbound.y),l<r.length-1){b.outbound.x=r[l+1].x-r[l].x,b.outbound.y=r[l+1].y-r[l].y;const t=Math.sqrt(b.outbound.x*b.outbound.x+b.outbound.y*b.outbound.y);b.distance+=t,b.outbound.x/=t,b.outbound.y/=t}else b.outbound.x=b.inbound.x,b.outbound.y=b.inbound.y;0===l&&(b.inbound.x=b.outbound.x,b.inbound.y=b.outbound.y),b.currentVertex.x=r[l].x,b.currentVertex.y=r[l].y,b.prevNormal.x=-b.inbound.y,b.prevNormal.y=b.inbound.x,b.nextNormal.x=-b.outbound.y,b.nextNormal.y=b.outbound.x,0===l?(u.vertex(b),b.leftEntry0=b.entry0,b.leftEntry2=b.entry2,b.leftExit0=b.exit0,b.leftExit2=b.exit2):(u.vertex(b),b.rightEntry0=b.entry0,b.rightEntry2=b.entry2,b.rightExit0=b.exit0,b.rightExit2=b.exit2,u.bridge(b),b.leftExit0=b.rightExit0,b.leftExit2=b.rightExit2),++l}}function E(){if(a)return b.distance=0,b.isCap=b.isFirstVertex=b.isLastVertex=!1,void(a=!1);if(0===c)if(b.isFirstVertex=0===l,h=r[l],0===l){if(c=0,b.closed){b.inbound.x=h.x-r[r.length-2].x,b.inbound.y=h.y-r[r.length-2].y;const t=Math.sqrt(b.inbound.x*b.inbound.x+b.inbound.y*b.inbound.y);b.inbound.x/=t,b.inbound.y/=t}}else b.inbound.x=h.x-d.x,b.inbound.y=h.y-d.y,c=Math.sqrt(b.inbound.x*b.inbound.x+b.inbound.y*b.inbound.y),b.inbound.x/=c,b.inbound.y/=c;if(b.distance+c-y<=s.wrapDistance){if(l<r.length-1){b.outbound.x=r[l+1].x-h.x,b.outbound.y=r[l+1].y-h.y;const t=Math.sqrt(b.outbound.x*b.outbound.x+b.outbound.y*b.outbound.y);b.outbound.x/=t,b.outbound.y/=t}else if(b.closed){b.outbound.x=r[1].x-h.x,b.outbound.y=r[1].y-h.y;const t=Math.sqrt(b.outbound.x*b.outbound.x+b.outbound.y*b.outbound.y);b.outbound.x/=t,b.outbound.y/=t}else b.outbound.x=b.inbound.x,b.outbound.y=b.inbound.y;return 0!==l||b.closed||(b.inbound.x=b.outbound.x,b.inbound.y=b.outbound.y),++l,b.isLastVertex=l===r.length,b.isCap=!b.closed&&(b.isFirstVertex||b.isLastVertex),b.distance+=c-y,c=0,y=0,a=b.distance+c-y===s.wrapDistance,b.currentVertex.x=h.x,b.currentVertex.y=h.y,d=h,void(h=null)}b.outbound.x=b.inbound.x,b.outbound.y=b.inbound.y,y+=s.wrapDistance-b.distance,b.distance=s.wrapDistance,a=!0;const t=y/c;b.currentVertex.x=(1-t)*d.x+t*h.x,b.currentVertex.y=(1-t)*d.y+t*h.y}function m(){b.prevNormal.x=-b.inbound.y,b.prevNormal.y=b.inbound.x,b.nextNormal.x=-b.outbound.y,b.nextNormal.y=b.outbound.x}function v(){m(),b.bisector.x=b.prevNormal.x+b.nextNormal.x,b.bisector.y=b.prevNormal.y+b.nextNormal.y;const t=Math.sqrt(b.bisector.x*b.bisector.x+b.bisector.y*b.bisector.y);if(t<.001)return b.bisector.x=void 0,b.bisector.y=void 0,b.cosine=0,void(b.sign=void 0);b.bisector.x/=t,b.bisector.y/=t,b.cosine=b.bisector.x*b.nextNormal.x+b.bisector.y*b.nextNormal.y,b.sign=b.prevNormal.x*b.nextNormal.y-b.prevNormal.y*b.nextNormal.x>=0?1:-1}function N(t){u.vertex(b),1===t?(b.leftEntry0=b.entry0,b.leftEntry1=b.entry1,b.leftEntry2=b.entry2,b.leftExit0=b.exit0,b.leftExit1=b.exit1,b.leftExit2=b.exit2):2===t&&(b.rightEntry0=b.entry0,b.rightEntry1=b.entry1,b.rightEntry2=b.entry2,b.rightExit0=b.exit0,b.rightExit1=b.exit1,b.rightExit2=b.exit2)}function w(t){u.vertex(b),1===t?(b.leftEntry0=b.entry0,b.leftEntry2=b.entry2,b.leftExit0=b.exit0,b.leftExit2=b.exit2):2===t&&(b.rightEntry0=b.entry0,b.rightEntry2=b.entry2,b.rightExit0=b.exit0,b.rightExit2=b.exit2)}let T=function(){function t(t,r){this.writeVertex=t,this.writeTriangle=r,this.capType=0,this.joinType=2,this.miterLimitCosine=e.getLimitCosine(2),this.roundLimitCosine=Math.cos(23*Math.PI/180),this.almostParallelCosine=.97,this.radsPerSlice=.8,this.textured=!1,this.joinOnUTurn=!1}var r=t.prototype;return r.vertex=function(t){const e=2===this.joinType?this.miterLimitCosine:this.roundLimitCosine,r=t.isCap&&0!==this.capType;let i=!1;t.cosine>this.almostParallelCosine?(t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):t.cosine<1-this.almostParallelCosine?(i=!t.isCap&&this.joinOnUTurn,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.canSplit?(o(),t.sign>0?(t.splitInner?(t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,t.leftInner.x,t.leftInner.y,0,-1,t.distance),t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.rightInner.x,t.rightInner.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.cosine<e?(i=!t.isCap,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.splitOuter?(i=i||t.gapOuter,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,-t.leftOuter.x,-t.leftOuter.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,-t.rightOuter.x,-t.rightOuter.y,0,1,t.distance)):t.entry2=t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):(t.splitInner?(t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,-t.leftInner.x,-t.leftInner.y,0,1,t.distance),t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,-t.rightInner.x,-t.rightInner.y,0,1,t.distance)):t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance),t.cosine<e?(i=!t.isCap,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance)):t.splitOuter?(i=i||t.gapOuter,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.leftOuter.x,t.leftOuter.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,t.rightOuter.x,t.rightOuter.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance))):t.sign>0?(t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.cosine<e?(i=!t.isCap,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.entry2=t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):(t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance),t.cosine<e?(i=!t.isCap,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance));const n=t.canSplit&&(t.splitInner||t.splitOuter);let x;if(x=t.entry1=t.exit1=n||i||r?this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,0,0,0,0,t.distance):null,i&&1!==this.joinType)this.writeTriangle(x,t.sign>0?t.exit2:t.entry0,t.sign>0?t.entry2:t.exit0);else if(r&&1===this.capType||i&&1===this.joinType){let e,r,i,n,o,s;if(t.isCap){const x=Math.PI;o=Math.ceil(x/this.radsPerSlice),s=x/o,t.isFirstVertex?(e=t.prevNormal.x,r=t.prevNormal.y,i=t.entry0,n=t.entry2):t.isLastVertex&&(e=-t.nextNormal.x,r=-t.nextNormal.y,i=t.exit2,n=t.exit0)}else{const x=2*Math.acos(t.cosine);o=Math.ceil(x/this.radsPerSlice),s=x/o,e=t.sign>0?-t.prevNormal.x:t.nextNormal.x,r=t.sign>0?-t.prevNormal.y:t.nextNormal.y,i=t.sign>0?t.entry2:t.exit0,n=t.sign>0?t.exit2:t.entry0}const u=Math.cos(s),l=Math.sin(s),c=l*e+u*r;let y,a;e=u*e-l*r,r=c;for(let d=0;d<o;++d){if(y=a,d<o-1)if(t.isCap){const i=t.isFirstVertex?-1:1;a=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,e,r,i,0,t.distance)}else a=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,e,r,0,t.sign,t.distance);this.writeTriangle(0===d?i:y,x,d===o-1?n:a);const s=l*e+u*r;e=u*e-l*r,r=s}}else if(r&&2===this.capType){const e=t.isFirstVertex?1:-1;let r,i;this.textured?(r=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x-e*t.inbound.x,t.prevNormal.y-e*t.inbound.y,-e,-1,t.distance),i=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x-e*t.inbound.x,-t.prevNormal.y-e*t.inbound.y,-e,1,t.distance)):(r=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x-e*t.inbound.x,t.prevNormal.y-e*t.inbound.y,0,-1,t.distance),i=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x-e*t.inbound.x,-t.prevNormal.y-e*t.inbound.y,0,1,t.distance)),e>0?(this.writeTriangle(x,t.entry2,i),this.writeTriangle(x,i,r),this.writeTriangle(x,r,t.entry0)):(this.writeTriangle(x,i,t.exit2),this.writeTriangle(x,r,i),this.writeTriangle(x,t.exit0,r))}},r.bridge=function(t){this.writeTriangle(t.leftExit0,t.rightEntry0,null!=t.leftExit1?t.leftExit1:t.leftExit2),this.writeTriangle(t.rightEntry0,null!=t.rightEntry1?t.rightEntry1:t.rightEntry2,null!=t.leftExit1?t.leftExit1:t.leftExit2),null!=t.leftExit1&&null!=t.rightEntry1?(this.writeTriangle(t.leftExit1,t.rightEntry1,t.leftExit2),this.writeTriangle(t.rightEntry1,t.rightEntry2,t.leftExit2)):null!=t.leftExit1?this.writeTriangle(t.leftExit1,t.rightEntry2,t.leftExit2):null!=t.rightEntry1&&this.writeTriangle(t.rightEntry1,t.rightEntry2,t.leftExit2)},t}(),O=function(){function t(t,e){this.writeVertex=t,this.writeTriangle=e}var e=t.prototype;return e.vertex=function(t){t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)},e.bridge=function(t){this.writeTriangle(t.leftExit0,t.rightEntry0,t.leftExit2),this.writeTriangle(t.rightEntry0,t.rightEntry2,t.leftExit2)},t}();t.StandardTessellationCallbacks=T,t.TessellationState=i,t.ThinTessellationCallbacks=O,t.cleanup=x,t.splitVertex=o,t.tessellate=n,Object.defineProperty(t,"__esModule",{value:!0})}));
