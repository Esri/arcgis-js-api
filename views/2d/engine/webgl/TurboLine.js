/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{CapType as t,JoinType as e}from"../../../../symbols/cim/enums.js";import{THIN_LINE_HALF_WIDTH_THRESHOLD as i}from"./definitions.js";function x(t,e){return t.x===e.x&&t.y===e.y}function r(t){if(!t)return;const e=t.length;if(e<=1)return;let i=0;for(let r=1;r<e;r++)x(t[r],t[i])||++i===r||(t[i]=t[r]);t.length=i+1}function n(t,e){return t.x=e.y,t.y=-e.x,t}function s(t,e){return t.x=-e.y,t.y=e.x,t}function y(t,e){return t.x=e.x,t.y=e.y,t}function o(t,e){return t.x=-e.x,t.y=-e.y,t}function h(t){return Math.sqrt(t.x*t.x+t.y*t.y)}function l(t,e){return t.x*e.y-t.y*e.x}function a(t,e){return t.x*e.x+t.y*e.y}function c(t,e,i,x){return t.x=e.x*i+e.y*x,t.y=e.x*x-e.y*i,t}class d{constructor(t,e,i){this.writeVertex=t,this.writeTriangle=e,this.canUseThinTessellation=i,this.prevNormal={x:void 0,y:void 0},this.nextNormal={x:void 0,y:void 0},this.textureNormalLeft={x:0,y:1},this.textureNormalRight={x:0,y:-1},this.textureNormal={x:void 0,y:void 0},this.joinNormal={x:void 0,y:void 0},this.inner={x:void 0,y:void 0},this.outer={x:void 0,y:void 0},this.roundStart={x:void 0,y:void 0},this.roundEnd={x:void 0,y:void 0},this.startBreak={x:void 0,y:void 0},this.endBreak={x:void 0,y:void 0},this.innerPrev={x:void 0,y:void 0},this.innerNext={x:void 0,y:void 0},this.bevelStart={x:void 0,y:void 0},this.bevelEnd={x:void 0,y:void 0},this.bevelMiddle={x:void 0,y:void 0}}tessellate(t,e){r(t),this.canUseThinTessellation&&e.halfWidth<i&&!e.offset?this._tessellateThin(t,e):this._tessellate(t,e)}_tessellateThin(t,e){if(t.length<2)return;const i=e.wrapDistance||65535;let x=e.initialDistance||0,r=!1,n=t[0].x,s=t[0].y;const y=t.length;for(let o=1;o<y;++o){r&&(r=!1,x=0);let e=t[o].x,y=t[o].y,h=e-n,l=y-s,a=Math.sqrt(h*h+l*l);if(h/=a,l/=a,x+a>i){r=!0;const t=(i-x)/a;a=i-x,e=(1-t)*n+t*e,y=(1-t)*s+t*y,--o}const c=this.writeVertex(n,s,0,0,h,l,l,-h,0,-1,x),d=this.writeVertex(n,s,0,0,h,l,-l,h,0,1,x);x+=a;const u=this.writeVertex(e,y,0,0,h,l,l,-h,0,-1,x),v=this.writeVertex(e,y,0,0,h,l,-l,h,0,1,x);this.writeTriangle(c,d,u),this.writeTriangle(d,u,v),n=e,s=y}}_tessellate(i,r){const d=i[0],u=i[i.length-1],v=x(d,u),f=v?3:2;if(i.length<f)return;const w=r.pixelCoordRatio,T=null!=r.capType?r.capType:t.BUTT,g=null!=r.joinType?r.joinType:e.MITER,m=null!=r.miterLimit?Math.min(r.miterLimit,4):2,V=null!=r.roundLimit?Math.min(r.roundLimit,1.05):1.05,N=null!=r.halfWidth?r.halfWidth:2,E=!!r.textured;let b,R,U=null,k=null;const p=this.prevNormal,M=this.nextNormal;let B=-1,L=-1;const D=this.joinNormal;let S,j;const A=this.textureNormalLeft,O=this.textureNormalRight,_=this.textureNormal;let I=-1,P=-1;const W=r.wrapDistance||65535;let q=r.initialDistance||0;const Q=this.writeVertex,X=this.writeTriangle,C=(t,e,i,x,r,n)=>{const s=Q(b,R,S,j,i,x,t,e,r,n,q);return I>=0&&P>=0&&s>=0&&X(I,P,s),I=P,P=s,s};v&&(U=i[i.length-2],M.x=u.x-U.x,M.y=u.y-U.y,L=h(M),M.x/=L,M.y/=L);let z=!1;for(let x=0;x<i.length;++x){if(z&&(z=!1,q=0),U&&(p.x=-M.x,p.y=-M.y,B=L,q+B>W&&(z=!0)),z){const t=(W-q)/B;B=W-q,U={x:(1-t)*U.x+t*i[x].x,y:(1-t)*U.y+t*i[x].y},--x}else U=i[x];b=U.x,R=U.y;const r=x<=0&&!z,d=x===i.length-1;if(r||(q+=B),k=d?v?i[1]:null:i[x+1],k?(M.x=k.x-b,M.y=k.y-R,L=h(M),M.x/=L,M.y/=L):(M.x=void 0,M.y=void 0),!v){if(r){s(D,M),S=D.x,j=D.y,T===t.SQUARE&&(C(-M.y-M.x,M.x-M.y,M.x,M.y,0,-1),C(M.y-M.x,-M.x-M.y,M.x,M.y,0,1)),T===t.ROUND&&(C(-M.y-M.x,M.x-M.y,M.x,M.y,-1,-1),C(M.y-M.x,-M.x-M.y,M.x,M.y,-1,1)),T!==t.ROUND&&T!==t.BUTT||(C(-M.y,M.x,M.x,M.y,0,-1),C(M.y,-M.x,M.x,M.y,0,1));continue}if(d){n(D,p),S=D.x,j=D.y,T!==t.ROUND&&T!==t.BUTT||(C(p.y,-p.x,-p.x,-p.y,0,-1),C(-p.y,p.x,-p.x,-p.y,0,1)),T===t.SQUARE&&(C(p.y-p.x,-p.x-p.y,-p.x,-p.y,0,-1),C(-p.y-p.x,p.x-p.y,-p.x,-p.y,0,1)),T===t.ROUND&&(C(p.y-p.x,-p.x-p.y,-p.x,-p.y,1,-1),C(-p.y-p.x,p.x-p.y,-p.x,-p.y,1,1));continue}}let u,f,Q=-l(p,M);if(Math.abs(Q)<.01)a(p,M)>0?(D.x=p.x,D.y=p.y,Q=1,u=Number.MAX_VALUE,f=!0):(s(D,M),Q=1,u=1,f=!1);else{D.x=(p.x+M.x)/Q,D.y=(p.y+M.y)/Q,u=h(D);const t=(u-1)*N*w;f=u>4||t>B&&t>L}S=D.x,j=D.y;let X=g;switch(g){case e.BEVEL:u<1.05&&(X=e.MITER);break;case e.ROUND:u<V&&(X=e.MITER);break;case e.MITER:u>m&&(X=e.BEVEL)}switch(X){case e.MITER:if(C(D.x,D.y,-p.x,-p.y,0,-1),C(-D.x,-D.y,-p.x,-p.y,0,1),d)break;if(E){const t=z?0:q;I=this.writeVertex(b,R,S,j,M.x,M.y,D.x,D.y,0,-1,t),P=this.writeVertex(b,R,S,j,M.x,M.y,-D.x,-D.y,0,1,t)}break;case e.BEVEL:{const t=Q<0;let e,i,x,r;if(t){const t=I;I=P,P=t,e=A,i=O}else e=O,i=A;if(f)x=t?s(this.innerPrev,p):n(this.innerPrev,p),r=t?n(this.innerNext,M):s(this.innerNext,M);else{const e=t?o(this.inner,D):y(this.inner,D);x=e,r=e}const h=t?n(this.bevelStart,p):s(this.bevelStart,p);C(x.x,x.y,-p.x,-p.y,e.x,e.y);const l=C(h.x,h.y,-p.x,-p.y,i.x,i.y);if(d)break;const a=t?s(this.bevelEnd,M):n(this.bevelEnd,M);if(f){const t=this.writeVertex(b,R,S,j,-p.x,-p.y,0,0,0,0,q);I=this.writeVertex(b,R,S,j,M.x,M.y,r.x,r.y,e.x,e.y,q),P=this.writeVertex(b,R,S,j,M.x,M.y,a.x,a.y,i.x,i.y,q),this.writeTriangle(l,t,P)}else{if(E){const t=this.bevelMiddle;t.x=(h.x+a.x)/2,t.y=(h.y+a.y)/2,c(_,t,-p.x,-p.y),C(t.x,t.y,-p.x,-p.y,_.x,_.y),c(_,t,M.x,M.y),I=this.writeVertex(b,R,S,j,M.x,M.y,t.x,t.y,_.x,_.y,q),P=this.writeVertex(b,R,S,j,M.x,M.y,r.x,r.y,e.x,e.y,q)}else{const t=I;I=P,P=t}C(a.x,a.y,M.x,M.y,i.x,i.y)}if(t){const t=I;I=P,P=t}break}case e.ROUND:{const t=Q<0;let e,i;if(t){const t=I;I=P,P=t,e=A,i=O}else e=O,i=A;const x=t?o(this.inner,D):y(this.inner,D);let r,h;f?(r=t?s(this.innerPrev,p):n(this.innerPrev,p),h=t?n(this.innerNext,M):s(this.innerNext,M)):(r=x,h=x);const l=t?n(this.roundStart,p):s(this.roundStart,p),v=t?s(this.roundEnd,M):n(this.roundEnd,M),w=C(r.x,r.y,-p.x,-p.y,e.x,e.y),T=C(l.x,l.y,-p.x,-p.y,i.x,i.y);if(d)break;const g=this.writeVertex(b,R,S,j,-p.x,-p.y,0,0,0,0,q);f||this.writeTriangle(I,P,g);const m=o(this.outer,x),V=this.writeVertex(b,R,S,j,M.x,M.y,v.x,v.y,i.x,i.y,q);let N,U;const k=u>2;if(k){let e;u!==Number.MAX_VALUE?(m.x/=u,m.y/=u,e=a(p,m),e=(u*(e*e-1)+1)/e):e=-1,N=t?n(this.startBreak,p):s(this.startBreak,p),N.x+=p.x*e,N.y+=p.y*e,U=t?s(this.endBreak,M):n(this.endBreak,M),U.x+=M.x*e,U.y+=M.y*e}c(_,m,-p.x,-p.y);const B=this.writeVertex(b,R,S,j,-p.x,-p.y,m.x,m.y,_.x,_.y,q);c(_,m,M.x,M.y);const L=E?this.writeVertex(b,R,S,j,M.x,M.y,m.x,m.y,_.x,_.y,q):B,W=g,X=E?this.writeVertex(b,R,S,j,M.x,M.y,0,0,0,0,q):g;let z=-1,F=-1;if(k&&(c(_,N,-p.x,-p.y),z=this.writeVertex(b,R,S,j,-p.x,-p.y,N.x,N.y,_.x,_.y,q),c(_,U,M.x,M.y),F=this.writeVertex(b,R,S,j,M.x,M.y,U.x,U.y,_.x,_.y,q)),E?k?(this.writeTriangle(W,T,z),this.writeTriangle(W,z,B),this.writeTriangle(X,L,F),this.writeTriangle(X,F,V)):(this.writeTriangle(W,T,B),this.writeTriangle(X,L,V)):k?(this.writeTriangle(g,T,z),this.writeTriangle(g,z,F),this.writeTriangle(g,F,V)):(this.writeTriangle(g,T,B),this.writeTriangle(g,L,V)),f?(I=this.writeVertex(b,R,S,j,M.x,M.y,h.x,h.y,e.x,e.y,q),P=V):(I=E?this.writeVertex(b,R,S,j,M.x,M.y,h.x,h.y,e.x,e.y,q):w,this.writeTriangle(I,X,V),P=V),t){const t=I;I=P,P=t}break}}}}}export{d as LineTessellation};
