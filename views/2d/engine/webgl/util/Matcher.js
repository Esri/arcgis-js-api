/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../../../core/Error.js";import t from"../../../../../core/Logger.js";import s from"../../../../../core/LRUCache.js";import{createRendererExpression as r}from"../../../../../support/arcadeOnDemand.js";import i from"../../../arcade/callExpressionWithFeature.js";import{expandSymbol as a}from"../../../layers/support/cimSymbolUtils.js";const n=t.getLogger("esri/views/2d/engine/webgl/util/Matcher");async function l(e,t,s,r){switch(e.type){case"simple":case"heatmap":return o.fromBasicRenderer(e,t,s,r);case"map":return m.fromUVRenderer(e,t,s,r);case"interval":return c.fromCBRenderer(e,t,s,r);case"dictionary":return p.fromDictionaryRenderer(e,t,s,r);case"pie-chart":return u.fromPieChartRenderer(e,t,s,r);case"subtype":return u.fromSubtypes(e,t,s,r)}}class o{constructor(){this.type="feature",this._defaultResult=null}static async fromBasicRenderer(e,t,s,r){const i=new o;if(e.symbol){const n=await a(e.symbol,s,r),l=t.createTemplateGroup(n,null);i.setDefault(l)}return i}static async fromPieChartRenderer(e,t,s,r){const i=new o;if(e.markerSymbol){const n=await a(e.markerSymbol,s,r);let l;e.fillSymbol&&(l=await a(e.fillSymbol,s,r));const o=t.createTemplateGroup(n,l);i.setDefault(o)}return i}size(){return 1}getDefault(){return this._defaultResult}setDefault(e){this._defaultResult=e}match(e,t,s,r,i){return this.getDefault()}async analyze(e,t,s,r,i,a){return null}}class u extends o{constructor(e,t){super(),this._subMatchers=e,this._subtypeField=t}static async fromSubtypes(e,t,s,r){const i=new Map,a=[];for(const n in e.renderers){const o=parseInt(n,10),u=l(e.renderers[n],t,s,r).then((e=>i.set(o,e)));a.push(u)}return await Promise.all(a),new u(i,e.subtypeField)}match(e,t,s,r,i){const a=t.readAttribute(this._subtypeField),n=this._subMatchers.get(a);return n?n.match(e,t,s,r,i):null}}class c extends o{constructor(e,t,s,r){super(),this.type="interval",this._intervals=[],this._isMaxInclusive=t,this._fieldIndex=r,this._field=e,this._normalizationInfo=s}static async fromCBRenderer(e,t,s,r){const{isMaxInclusive:i,normalizationField:n,normalizationTotal:l,normalizationType:o}=e,u=e.field,m=new c(u,i,{normalizationField:n,normalizationTotal:l,normalizationType:o},e.fieldIndex),d=await a(e.backgroundFillSymbol,s,r);await Promise.all(e.intervals.map((async e=>{const i=await a(e.symbol,s,r),n=await t.createTemplateGroup(i,d),l={min:e.min,max:e.max};m.add(l,n)})));const h=await a(e.defaultSymbol,s,r);if(h){const e=await t.createTemplateGroup(h,d);m.setDefault(e)}return m}add(e,t){this._intervals.push({interval:e,result:t}),this._intervals.sort(((e,t)=>e.interval.min-t.interval.min))}size(){return super.size()+this._intervals.length}match(e,t,s,r,i){if(null==this._fieldIndex&&!this._field)return this.getDefault();const a=null!=this._fieldIndex?t.getComputedNumericAtIndex(this._fieldIndex):this._getValueFromField(t);if(!a&&(null==a||isNaN(a)))return this.getDefault();for(let n=0;n<this._intervals.length;n++){const{interval:e,result:t}=this._intervals[n],s=a>=e.min,r=this._isMaxInclusive?a<=e.max:a<e.max;if(s&&r)return t}return this.getDefault()}_needsNormalization(){const e=this._normalizationInfo;return e&&(e.normalizationField||e.normalizationTotal||e.normalizationType)}_getValueFromField(e){const t=e.readAttribute(this._field);if(!this._needsNormalization()||null==t)return t;const{normalizationField:s,normalizationTotal:r,normalizationType:i}=this._normalizationInfo,a=!!s&&e.readAttribute(s);if(i)switch(i){case"esriNormalizeByField":return a?t/a:void 0;case"esriNormalizeByLog":return Math.log(t)*Math.LOG10E;case"esriNormalizeByPercentOfTotal":return t/r*100;default:return void n.error(`Found unknown normalization type: ${i}`)}else n.error("Normalization is required, but no type was set!")}}class m extends o{constructor(e,t,s){super(),this.type="map",this._nullResult=null,this._resultsMap=new Map,this._fieldsIndex=s,this._fields=e,this._seperator=t||""}static async fromUVRenderer(e,t,s,r){const i=e.fieldDelimiter,n=[e.field];e.field2&&n.push(e.field2),e.field3&&n.push(e.field3);const l=await a(e.backgroundFillSymbol,s,r),o=new m(n,i,e.fieldIndex);await Promise.all(e.map.map((async e=>{const i=await a(e.symbol,s,r),n=await t.createTemplateGroup(i,l);"<Null>"===e.value?o.setNullResult(n):o.add(e.value,n)})));const u=await a(e.defaultSymbol,s,r);if(u){const e=await t.createTemplateGroup(u,l);o.setDefault(e)}return o}setNullResult(e){this._nullResult=e}add(e,t){this._resultsMap.set(e.toString(),t)}size(){return super.size()+this._resultsMap.size}match(e,t,s,r,i){if(null==this._fieldsIndex&&!this._fields)return this.getDefault();const a=null!=this._fieldsIndex?t.getComputedStringAtIndex(this._fieldsIndex):this._getValueFromFields(t);if(null!==this._nullResult&&(null==a||""===a||"<Null>"===a))return this._nullResult;if(!a&&null==a)return this.getDefault();const n=a.toString();return this._resultsMap.has(n)?this._resultsMap.get(n):this.getDefault()}_getValueFromFields(e){const t=[];for(const s of this._fields){const r=e.readAttribute(s);null==r||""===r?t.push("<Null>"):t.push(r)}return t.join(this._seperator)}}async function d(e,t){const s=e||1;if("number"==typeof s)return(e,t,r)=>s;const a=await r(s,t.spatialReference,t.fields);return(e,s,r)=>i(a,e,{$view:r},t.geometryType,s)||1}let h;async function f(){return h||(h=import("../../../layers/features/createSymbolSchema.js")),h}class p extends o{constructor(e,t,r,i,a,n){super(),this.type="dictionary",this._groupIdCache=new s(100),this._loader=e,this._fieldMap=e.fieldMap,this._symbolFields=e.getSymbolFields(),this._templates=t,this._info=r,this._scaleFn=i,this._schemaUtilsModule=a,this._symbolOptions=n}static async fromDictionaryRenderer(e,t,s,r){const[{DictionaryLoader:i},a]=await Promise.all([import("../../../../../renderers/support/DictionaryLoader.js"),f()]),n=new i(e.url,e.config,e.fieldMap);await n.fetchResources({spatialReference:s.spatialReference,fields:s.fields});const l=await d(e.scaleExpression,s);return new p(n,t,s,l,a,e.symbolOptions)}async _analyzeFeature(t,s,r,i,l){const o=t.readLegacyFeature(),u=this._scaleFn(o,r,i),c=this._attributeHash(o)+"-"+u,m=this._groupIdCache.get(c);if(m)return m;const d={...i,spatialReference:this._info.spatialReference,abortOptions:l,fields:this._info.fields},h=await this._loader.getSymbolAsync(o,d),f=this._schemaUtilsModule.createSymbolSchema(h,this._symbolOptions),p=a(f,this._info,s,l).then((t=>{if("expanded-cim"!==t.type)return n.error(new e("mapview-bad-type",`Found unexpected type ${t.type} in dictionary response`)),null;t.hash+="-"+u;for(const e of t.layers)e.scaleFactor=u,e.templateHash+="-"+u;return this._templates.createTemplateGroup(t,null)}));return this._groupIdCache.put(c,p,1),p}async analyze(e,t,s,r,i,a){const n=t.getCursor(),l=[];for(;n.next();)l.push(this._analyzeFeature(n,s,r,i,a));return Promise.all(l)}match(e,t,s,r,i){return null}_attributeHash(e){let t="";for(const s of this._symbolFields){const r=this._fieldMap[s];r&&(t+=e.attributes[r]+"-")}return t}}export{p as DictionaryMatcher,o as FeatureMatcher,c as IntervalMatcher,m as MapMatcher,u as SubtypeMatcher,l as createMatcher};
