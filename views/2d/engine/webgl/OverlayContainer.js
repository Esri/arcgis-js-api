/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isNone as t}from"../../../../core/maybe.js";import{createScreenPoint as e}from"../../../../core/screenUtils.js";import{b as s,m as r,c as o,d as a,r as i}from"../../../../chunks/mat3.js";import{c as n}from"../../../../chunks/mat3f32.js";import{f as c}from"../../../../chunks/vec2f32.js";import{f as p}from"../../../../chunks/vec3f32.js";import{normalizeMapX as d}from"../../../../geometry/support/normalizeUtils.js";import{getInfo as l}from"../../../../geometry/support/spatialReferenceUtils.js";import{getWorldWidth as m}from"../../viewpointUtils.js";import{brushes as h}from"../brushes.js";import{WGLDrawPhase as f}from"./enums.js";import u from"./WGLContainer.js";class M extends u{constructor(){super(...arguments),this._localOrigin=e(0,0),this._viewStateId=-1,this._dvsMat3=n(),this.requiresDedicatedFBO=!1}get dvsMat3(){return this._dvsMat3}beforeRender(t){this._updateMatrices(t),this._updateOverlays(t,this.children);for(const e of this.children)e.beforeRender(t)}prepareRenderPasses(t){const e=t.registerRenderPass({name:"overlay",brushes:[h.overlay],target:()=>this.children,drawPhase:f.MAP});return[...super.prepareRenderPasses(t),e]}_updateMatrices(t){const{state:e}=t,{id:n,size:l,pixelRatio:m,resolution:h,rotation:f,viewpoint:u,displayMat3:M}=e;if(this._viewStateId===n)return;const v=Math.PI/180*f,_=m*l[0],w=m*l[1],{x:y,y:j}=u.targetGeometry,g=d(y,e.spatialReference);this._localOrigin.x=g,this._localOrigin.y=j;const b=h*_,R=h*w,O=s(this._dvsMat3);r(O,O,M),o(O,O,c(_/2,w/2)),a(O,O,p(_/b,-w/R,1)),i(O,O,-v),this._viewStateId=n}_updateOverlays(e,s){const{state:r}=e,{rotation:o,spatialReference:a,worldScreenWidth:i,size:n,viewpoint:c}=r,p=this._localOrigin;let d=0;if(a.isWrappable){const e=n[0],h=n[1],f=180/Math.PI*o,u=Math.abs(Math.cos(f)),M=Math.abs(Math.sin(f)),v=Math.round(e*u+h*M),[_,w]=l(a).valid,y=m(a),{x:j,y:g}=c.targetGeometry,b=[j,g],R=[0,0];r.toScreen(R,b);const O=[0,0];let P;P=v>i?.5*i:.5*v;const x=Math.floor((j+.5*y)/y),C=_+x*y,D=w+x*y,I=[R[0]+P,0];r.toMap(O,I),O[0]>D&&(d=y),I[0]=R[0]-P,r.toMap(O,I),O[0]<C&&(d=-y);for(const r of s){const e=r.elementView.bounds;if(t(e))continue;const[s,,o]=e;s<_&&o>_?r.updateDrawCoords(p,y):o>w&&s<w?r.updateDrawCoords(p,-y):r.updateDrawCoords(p,d)}}else for(const t of s)t.updateDrawCoords(p,d)}}export{M as default};
