/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["../../../../core/has","./Utils","./FreeList"],(function(e,t,r){"use strict";const i=["FILL","LINE","MARKER","TEXT","LABEL"];return function(){function e(e,i,n,o){this._strides=e,this._displayList=i,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=n;for(const i in e){this._freeListsAndStorage[i]={vtxFreeList:o?new r.FreeList(o):null,idxFreeList:o?new r.FreeList(o):null,vertexBuffers:{},indexBuffer:o?new Uint32Array(o):null};for(const r in e[i])this._freeListsAndStorage[i].vertexBuffers[r]={data:o?t.allocateTypedArrayBuffer(o,e[i][r]):null,stride:e[i][r]}}}e.fromTileData=function(n,o){const s=function(e){const t=e.getStrides(),r={};for(let e=0;e<t.length;e++)r[i[e]]=t[e];return r}(n),a=[0,0,0,0,0],d=[0,0,0,0,0],u=n.tileDisplayData.displayObjects;for(const e of u)for(const t of e.displayRecords)a[t.geometryType]=Math.max(a[t.geometryType],t.vertexFrom+t.vertexCount),d[t.geometryType]=Math.max(d[t.geometryType],t.indexFrom+t.indexCount);const f=new e(s,n.tileDisplayData.displayList,o,null);for(let e=0;e<n.tileBufferData.geometries.length;++e){const o=a[e],s=d[e],u=n.tileBufferData.geometries[e],x=i[e],c=f._storageFor(x),l=n.tileBufferData.geometries[e].indexBuffer;let v;c.indexBuffer=l,c.idxFreeList=new r.FreeList(l.length),c.idxFreeList.allocate(s);for(const r in u.vertexBuffer){const i=n.tileBufferData.geometries[e].vertexBuffer[r];c.vertexBuffers[r].data=i.data,c.vertexBuffers[r].stride=i.stride;const o=t.strideToPackingFactor(i.stride),s=i.data.length*o/i.stride;v||(v=s)}c.vtxFreeList=new r.FreeList(v),c.vtxFreeList.allocate(o)}return f};var n=e.prototype;return n.delete=function(e){const t=i[e.geometryType];this._freeVertices(t,e.vertexFrom,e.vertexCount),this._freeIndices(t,e.indexFrom,e.indexCount),this._displayList.removeFromList(e),e.vertexFrom=void 0,e.indexFrom=void 0},n.setMeshData=function(e,r,n,o,s){const a=i[e.geometryType];let d,u;e.meshData=null,void 0===e.vertexFrom?(u=r.vertexCount,d=this._allocateVertices(a,u)):r.vertexCount>e.vertexCount?(this._freeVertices(a,e.vertexFrom,e.vertexCount),u=r.vertexCount,d=this._allocateVertices(a,u)):r.vertexCount===e.vertexCount?(d=e.vertexFrom,u=e.vertexCount):(this._freeVertices(a,e.vertexFrom+r.vertexCount,e.vertexCount-r.vertexCount),d=e.vertexFrom,u=r.vertexCount);let f,x,c,l=!0;if(void 0===e.indexFrom?(f=s,c=r.indexCount,x=this._allocateIndices(a,c)):r.indexCount>e.indexCount?(f=this._displayList.removeFromList(e),this._freeIndices(a,e.indexFrom,e.indexCount),c=r.indexCount,x=this._allocateIndices(a,c)):r.indexCount===e.indexCount?(l=!1,x=e.indexFrom,c=e.indexCount):(f=this._displayList.removeFromList(e),this._freeIndices(a,e.indexFrom+r.indexCount,e.indexCount-r.indexCount),x=e.indexFrom,c=r.indexCount),-1!==d&&-1!==x){const i=this._storageFor(a);if(t.copyMeshData(d,x,i.vertexBuffers,i.indexBuffer,r,n,o),e.vertexFrom=d,e.indexFrom=x,e.vertexCount=r.vertexCount,e.indexCount=r.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in n)this._dirtyMap.markDirtyVertices(e.geometryType,t,e.vertexFrom,e.vertexCount)}return l&&this._displayList.addToList(e,f),!0}return-1!==d&&this._freeVertices(a,d,u),-1!==x&&this._freeIndices(a,x,c),e.setMeshDataFromBuffers(r,n,o),e.vertexFrom=void 0,e.vertexCount=0,e.indexFrom=void 0,e.indexCount=0,!1},n.tryAddMeshData=function(e,r){const n=r.vertexBuffer,o=r.indexBuffer,s=i[e.geometryType],a=this._allocateVertices(s,e.vertexCount);if(-1===a)return this._freeVertices(s,a,e.vertexCount),!1;const d=this._allocateIndices(s,e.indexCount);if(-1===d)return this._freeVertices(s,a,e.vertexCount),this._freeIndices(s,d,e.indexCount),!1;const u=this._storageFor(s);if(t.copyMeshData(a,d,u.vertexBuffers,u.indexBuffer,e,n,o),e.vertexFrom=a,e.indexFrom=d,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const t in n)this._dirtyMap.markDirtyVertices(e.geometryType,t,a,e.vertexCount)}return this._displayList.addToList(e),!0},n._allocateVertices=function(e,t){const r=this._storageFor(e),i=r.vtxFreeList.allocate(t);if(-1===i)return-1;return r.vtxFreeList.fragmentation>.5?-1:i},n._freeVertices=function(e,t,r){this._storageFor(e).vtxFreeList.free(t,r)},n._freeIndices=function(e,t,r){this._storageFor(e).idxFreeList.free(t,r)},n._allocateIndices=function(e,t){const r=this._storageFor(e),i=r.idxFreeList.allocate(t);if(-1===i)return-1;return r.idxFreeList.fragmentation>.5?-1:i},n._storageFor=function(e){return this._freeListsAndStorage[e]},n._stridesFor=function(e,t){return this._strides[e][t]},e}()}));
