/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import{property as t}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as s}from"../../../core/accessorSupport/decorators/subclass.js";import{e as r}from"../../../chunks/earcut.js";import{create as o}from"../../../geometry/support/aaBoundingRect.js";import{closeRings as i}from"../../../geometry/support/coordsUtils.js";import{normalizeCentralMeridianForDisplay as n}from"../../../geometry/support/normalizeUtilsSync.js";import{equals as a}from"../../../geometry/support/spatialReferenceUtils.js";import{checkProjectionSupport as c,project as l}from"../../../layers/graphics/data/projectionSupport.js";import"../tiling/PagedTileQueue.js";import p from"../tiling/TileInfoView.js";import"../tiling/TileKey.js";import"../tiling/TileQueue.js";import"../tiling/TileStrategy.js";import{THIN_LINE_HALF_WIDTH_THRESHOLD as f}from"../engine/webgl/definitions.js";import{LineTessellation as h}from"../engine/webgl/TurboLine.js";import{LayerView2DMixin as d}from"./LayerView2D.js";import u from"./support/DisplayGL.js";import{analyzeRings as m}from"./support/util.js";import y from"../../layers/LayerView.js";import x from"../../layers/RefreshableLayerView.js";const g=new Set,v=[],T=[];class w{constructor(e,t,s,r,i,n,a,c=[0,0],l=o()){this.id=e,this.level=t,this.row=s,this.col=r,this.world=i,this.resolution=n,this.scale=a,this.coords=c,this.bounds=l}}let j=class extends(x(d(y))){constructor(e){super(e),this._tileMap=new Map,this.container=new u(this),this.layer=null,this.tiles=[],this._renderTarget={framebuffer:null,viewport:[0,0,0,0]}}get _tileInfoView(){const e=this.layer&&this.layer.tileInfo;return e?new p(e):null}get context(){return this.view._stage.context.gl}attach(){}detach(){}requestRender(){this.container.requestRender()}tilesChanged(e,t){}supportsSpatialReference(e){const t=this.layer?.tileInfo;return!t||a(t.spatialReference,e)}async doRefresh(){}isUpdating(){return!1}update(e){const t=this._tileInfoView,s=this.tiles;if(t){const r=t.getTileCoverage(e.state,0),{spans:o,lodInfo:i}=r,{level:n}=i;if(o.length)for(const{row:e,colFrom:t,colTo:a}of o)for(let r=t;r<=a;r++){const t=i.normalizeCol(r),o=i.getWorldForColumn(r),a=`${n}/${e}/${t}/${o}`;if(!this._tileMap.has(a)){const r=new w(a,n,e,t,o,i.resolution,i.scale);i.getTileCoords(r.coords,r,!1),i.getTileBounds(r.bounds,r,!0),this._tileMap.set(a,r),s.push(r),v.push(r)}g.add(a)}}for(let r=s.length-1;r>=0;r--){const e=s[r];g.has(e.id)||(s.splice(r,1),T.push(e),this._tileMap.delete(e.id))}(v.length||T.length)&&(this.tilesChanged(v,T),v.length=T.length=0),g.clear(),this.requestRender()}moveStart(){}viewChange(){this.requestUpdate()}moveEnd(){}bindRenderTarget(){this.context.bindFramebuffer(this.context.FRAMEBUFFER,this._renderTarget.framebuffer),this.context.viewport(this._renderTarget.viewport[0],this._renderTarget.viewport[1],this._renderTarget.viewport[2],this._renderTarget.viewport[3])}getRenderTarget(){return this._renderTarget}async tessellateExtent(e){const t={vertices:[],indices:[]},s=await this._projectAndNormalizeGeometry(e),r=t.vertices.length;return t.vertices.push({x:s.xmin,y:s.ymin,xOffset:0,yOffset:0,uTexcoord:0,vTexcoord:0,distance:0}),t.vertices.push({x:s.xmax,y:s.ymin,xOffset:0,yOffset:0,uTexcoord:1,vTexcoord:0,distance:0}),t.vertices.push({x:s.xmin,y:s.ymax,xOffset:0,yOffset:0,uTexcoord:0,vTexcoord:1,distance:0}),t.vertices.push({x:s.xmax,y:s.ymax,xOffset:0,yOffset:0,uTexcoord:1,vTexcoord:1,distance:0}),t.indices.push(r+0,r+1,r+2,r+1,r+3,r+2),t}async tessellatePoint(e,t){const s=await this._projectAndNormalizeGeometry(e);return this._tessellatePoints([s],t)}async tessellateMultipoint(e,t){const s=await this._projectAndNormalizeGeometry(e),r=s.points.map((e=>({x:e[0],y:e[1],spatialReference:s.spatialReference})));return this._tessellatePoints(r,t)}async _tessellatePoints(e,t){const s={vertices:[],indices:[]};for(const r of e){const e=s.vertices.length;s.vertices.push({x:r.x,y:r.y,xOffset:t.x,yOffset:t.y+t.height,uTexcoord:0,vTexcoord:0,distance:0}),s.vertices.push({x:r.x,y:r.y,xOffset:t.x+t.width,yOffset:t.y+t.height,uTexcoord:1,vTexcoord:0,distance:0}),s.vertices.push({x:r.x,y:r.y,xOffset:t.x,yOffset:t.y,uTexcoord:0,vTexcoord:1,distance:0}),s.vertices.push({x:r.x,y:r.y,xOffset:t.x+t.width,yOffset:t.y,uTexcoord:1,vTexcoord:1,distance:0}),s.indices.push(e+0,e+1,e+2,e+1,e+3,e+2)}return s}async tessellatePolyline(e,t){const s={vertices:[],indices:[]},r=(await this._projectAndNormalizeGeometry(e)).paths;if(!r||!r.length)return s;let o;const i=new h(((e,r,i,n,a,c,l,p,f,h,d)=>{const u=s.vertices.length;return s.vertices.push({x:e,y:-r,xOffset:l*t/2,yOffset:p*t/2,uTexcoord:d/o,vTexcoord:(h+1)/2,distance:d}),u}),((e,t,r)=>{s.indices.push(e,t,r)}),!0);for(const n of r){o=0;for(let t=1;t<n.length;++t){const e=n[t][0]-n[t-1][0],s=n[t][1]-n[t-1][1];o+=Math.sqrt(e*e+s*s)}const e=n.map((e=>({x:e[0],y:-e[1]})));i.tessellate(e,_)}return s}async tessellatePolygon(e){const t={vertices:[],indices:[]},s=await this._projectAndNormalizeGeometry(e),r=s.rings;if(!r||!r.length)return t;i(s);for(const i of s.rings)for(const e of i)e[1]=-e[1];let o=1/0,n=1/0,a=-1/0,c=-1/0;return m(s.rings,(()=>{}),((e,t,s)=>{for(let r=e;r<t;r+=2)o=Math.min(o,s[r]),n=Math.min(n,s[r+1]),a=Math.max(a,s[r]),c=Math.max(c,s[r+1])})),m(s.rings,(()=>{}),((e,s,r,i)=>{this._invokeEarcut(t,e,s,r,i,[o,n,a,c])})),t}_invokeEarcut(e,t,s,o,i,n){const a=o.slice(t,s),c=r(a,i,2),l=e.vertices.length;for(let r=0;r<a.length;r+=2){const t=a[r],s=a[r+1];e.vertices.push({x:t,y:-s,xOffset:0,yOffset:0,uTexcoord:(t-n[0])/(n[2]-n[0]),vTexcoord:1-(s-n[1])/(n[3]-n[1]),distance:0})}for(let r=0;r<c.length;++r)e.indices.push(l+c[r])}async _projectAndNormalizeGeometry(e){await c(e.spatialReference,this.view.spatialReference);const t=n(e);return l(t,e.spatialReference,this.view.spatialReference)}};e([t()],j.prototype,"_tileInfoView",null),e([t()],j.prototype,"layer",void 0),e([t()],j.prototype,"context",null),j=e([s("esri.views.2d.layers.BaseLayerViewGL2D")],j);const _={pixelCoordRatio:1,wrapDistance:1e11,halfWidth:f+1,initialDistance:0,textured:!0,offset:0},O=j;export{O as default};
