/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["../../../../chunks/_rollupPluginBabelHelpers","../../../../core/maybe","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/centroid","../../../../geometry/support/jsonUtils","../../../../geometry/support/quantizationUtils","../../../../layers/graphics/featureConversionUtils","../../../../layers/graphics/OptimizedGeometry","./graphicsUtils"],(function(e,t,i,n,o,s,r,l,u){"use strict";const h=new l,a=new l,c="esriGeometryPolyline";function y(e){e.coords.length=0,e.lengths.length=0}let p=function(){function l(){this.bounds=i.create(),this.graphic=null,this.size=[0,0,0,0]}l.acquire=function(e=null,t,i,n,o,s){let r;return 0===l._pool.length?r=new l:(r=l._pool.pop(),this._set.delete(r)),r.acquire(e,t,i,n,o,s),r},l.release=function(e){e&&!this._set.has(e)&&(e.release(),this._pool.push(e),this._set.add(e))},l.getCentroidQuantized=function(e,i){if(o.isPolygon(e.geometry)){const o=e.symbol;if(t.isNone(o))return null;if(u.isMarkerSymbol(o.type)||u.isTextSymbol(o.type)){const t=n.polygonCentroid(e.geometry);return s.quantizePoint(i,{},{x:t[0],y:t[1]},!1,!1)}}return null};var p=l.prototype;return p.acquire=function(e=null,t,i,n,o,s){e&&this.set(e,t,i,n,o,s)},p.release=function(){this.graphic=null,this.symbolResource=null,this.geometry=null},p.set=function(e,t,i,n,o,s){this.graphic=e,this.geometry=i,this.symbolResource=t,this.resolution=n,this.updateBounds(n,o,s)},p.updateBounds=function(e,t,i){u.getBounds(this.bounds,this.size,this.symbolResource,this.geometry,e,t,i)},p.getGeometryQuantized=function(e,t){const n=this.geometry;if(o.isPolygon(n)){const t=n.rings;if(1===t.length&&2===t[0].length)return s.quantizeGeometry(e,{paths:[[t[0][0],t[0][1]]]})}else{if(o.isPolyline(n))return y(h),y(a),r.convertFromPolyline(h,n),r.generalizeOptimizedGeometry(a,h,n.hasZ,n.hasM,c,e.scale[0]),r.quantizeOptimizedGeometry(h,a,n.hasZ,n.hasM,c,e),r.convertToPolyline(h,n.hasZ,n.hasM);if(o.isMultipoint(n)){const o=.5*this.resolution*this.size[0],r=n.points.filter((e=>i.containsPointWithMargin(t,e,o)));return 0===r.length?{points:r}:s.quantizeGeometry(e,{points:r})}}return s.quantizeGeometry(e,this.geometry)},e._createClass(l,[{key:"symbol",get:function(){return this.symbolResource.symbol}}]),l}();return p._pool=[],p._set=new Set,p}));
