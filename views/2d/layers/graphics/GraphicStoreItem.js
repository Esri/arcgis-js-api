/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{isNone as t}from"../../../../core/maybe.js";import{create as e,containsPointWithMargin as s}from"../../../../geometry/support/aaBoundingRect.js";import{polygonCentroid as r}from"../../../../geometry/support/centroid.js";import{isPolygon as i,isPolyline as o,isMultipoint as n}from"../../../../geometry/support/jsonUtils.js";import{quantizePoint as l,quantizeGeometry as a}from"../../../../geometry/support/quantizationUtils.js";import{getInfo as h}from"../../../../geometry/support/spatialReferenceUtils.js";import{convertFromPolyline as u,generalizeOptimizedGeometry as m,quantizeOptimizedGeometry as p,convertToPolyline as c}from"../../../../layers/graphics/featureConversionUtils.js";import g from"../../../../layers/graphics/OptimizedGeometry.js";const y=new g,f=new g,d="esriGeometryPolyline";function b(t){t.coords.length=0,t.lengths.length=0}class z{constructor(){this.bounds=e(),this.graphic=null}static acquire(t=null,e,s,r,i){let o;return 0===z._pool.length?o=new z:(o=z._pool.pop(),this._set.delete(o)),o.acquire(t,e,s,r,i),o}static release(t){t&&!this._set.has(t)&&(t.release(),this._pool.push(t),this._set.add(t))}static getCentroidQuantized(e,s){if(i(e.geometry)){const i=e.symbol;if(t(i))return null;if(i?.layers.length>0&&i.layers.some((t=>"text"===t.type||"marker"===t.type))){const t=r(e.geometry);return null!==t?l(s,{},{x:t[0],y:t[1]},!1,!1):null}}return null}acquire(t=null,e,s,r,i){t&&this.set(t,e,s,r,i)}release(){this.graphic=null,this.symbolResource=null,this.geometry=null}get symbol(){return this.symbolResource.symbol}set(t,e,s,r,i){this.graphic=t,this.geometry=s,this.symbolResource=e,this.bounds=r,i&&(this.size=i)}getGeometryQuantized(t,e,r,l){const g=this.geometry;if(i(g)){const e=g.rings;if(1===e.length&&2===e[0].length)return a(t,{paths:[[e[0][0],e[0][1]]]})}else{if(o(g))return b(y),b(f),u(y,g),m(f,y,g.hasZ,g.hasM,d,t.scale[0]),p(y,f,g.hasZ,g.hasM,d,t),c(y,g.hasZ,g.hasM);if(n(g)){const i=.5*l*Math.max(Math.abs(this.size[0])+this.size[2]-this.size[0],Math.abs(this.size[1])+this.size[3]-this.size[1]),o=h(r);let n=g.points;if(o){const[t,r]=o.valid,l=r-t;n=n.filter((o=>{if(o[0]+i>r||o[0]-i<t){const t=[...o];return o[0]+i>r?t[0]-=l:t[0]+=l,s(e,o,i)||s(e,t,i)}return s(e,o,i)}))}return 0===n.length?{points:n}:a(t,{points:n})}}return a(t,this.geometry)}}z._pool=[],z._set=new Set;export{z as default};
