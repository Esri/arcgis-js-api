/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../geometry","../../../core/arrayUtils","../../../core/lang","../../../core/maybe","../../../core/unitUtils","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/Circle","../../../geometry/geometryEngine","../../../geometry/support/coordsUtils","../../../geometry/support/spatialReferenceUtils","./surfaceCoordinateSystems","../../../geometry/Point","../../../geometry/Multipoint","../../../geometry/Polyline","../../../geometry/Polygon"],(function(e,t,a,n,o,r,i,c,l,s,u,y,f,m,p,x,h){"use strict";function M(e,t){const a=new m({x:e[0],y:e[1],spatialReference:t});return e.length>2&&(a.z=e[2]),a}function S(e,t){return new p({points:e,spatialReference:t})}function P(e,t,a){const n=new x({paths:e,spatialReference:t});return a&&u.unnormalizeGeometryOnDatelineCrossing(n),n}function g(e,t,o,r=!0){const i=n.clone(e);i.forEach((e=>{const t=e[0],n=e[e.length-1];a.equals(t,n)&&1!==e.length||e.push(e[0])}));let c=new h({rings:i,spatialReference:t});return c.rings.forEach((e=>{u.isClockwise(e,!1,!1)||e.reverse()})),o&&u.unnormalizeGeometryOnDatelineCrossing(c),r&&c.isSelfIntersecting&&y.isValid(t)&&(c=s.simplify(c)),c}function k(e,t,a){const n=t.mapToLocalMultiple(e),r=[],i={x:n[0].x,y:n[0].y},c={x:n[1].x,y:n[1].y},l=Math.round(c.x-i.x),s=Math.round(c.y-i.y),u=Math.max(Math.abs(l),Math.abs(s));if(a){const e={x:i.x+u,y:i.y+u},t={x:i.x-u,y:i.y-u};r.push(f.makeSurfacePoint(e.x,t.y),f.makeSurfacePoint(t.x,t.y),f.makeSurfacePoint(t.x,e.y),f.makeSurfacePoint(e.x,e.y))}else{const e={x:l>0?i.x+u:i.x-u,y:s>0?i.y+u:i.y-u};r.push(f.makeSurfacePoint(i.x,i.y),f.makeSurfacePoint(e.x,i.y),f.makeSurfacePoint(e.x,e.y),f.makeSurfacePoint(i.x,e.y))}return R(g([o.filterNones(r.map((e=>t.localToMap(e))))],t.spatialReference,t.doUnnormalization,!0),r,t)}function d(e,t,a){let n=t.mapToLocalMultiple(e);if(1===n.length){const e=48,t=n[0];n=[f.makeSurfacePoint(t.x-e,t.y+e),f.makeSurfacePoint(t.x+e,t.y-e),f.makeSurfacePoint(t.x+e,t.y-e),f.makeSurfacePoint(t.x-e,t.y+e)]}const r=[],i={x:n[0].x,y:n[0].y},c={x:n[1].x,y:n[1].y};if(a){const e=Math.round(c.x-i.x),t=Math.round(c.y-i.y);r.push(f.makeSurfacePoint(i.x-e,i.y-t),f.makeSurfacePoint(c.x,i.y-t),f.makeSurfacePoint(c.x,c.y),f.makeSurfacePoint(i.x-e,c.y))}else r.push(f.makeSurfacePoint(i.x,i.y),f.makeSurfacePoint(c.x,i.y),f.makeSurfacePoint(c.x,c.y),f.makeSurfacePoint(i.x,c.y));return R(g([o.filterNones(r.map((e=>t.localToMap(e))))],t.spatialReference,t.doUnnormalization,!0),r,t)}function R(e,t,a){const n=T(t[3],t[2],a),r=T(t[1],t[2],a),i=T(t[0],t[1],a),c=T(t[0],t[3],a);return{geometry:e,midpoints:o.isSome(n)&&o.isSome(r)&&o.isSome(i)&&o.isSome(c)?{top:n,right:r,bottom:i,left:c}:null}}function T(e,t,a){U[0]=e.x,U[1]=e.y,U[2]=0,z[0]=t.x,z[1]=t.y,z[2]=0,i.lerp(U,U,z,.5),b.x=U[0],b.y=z[1],b.z=z[2];const n=a.localToMap(b);return o.isSome(n)?M(n,a.spatialReference):null}const b=f.makeSurfacePoint(0,0,0),U=c.create(),z=c.create();function C(e,t,a,n){const i=t.mapToLocalMultiple(e);let c=null,m=null;if(a)c=i[0],m=i[1];else{const e=i[0],t=i[1],a=Math.round(t.x-e.x),n=Math.round(t.y-e.y),o=Math.max(Math.abs(a),Math.abs(n));c=f.makeSurfacePoint(a>0?e.x+o/2:e.x-o/2,n>0?e.y+o/2:e.y-o/2),m=f.makeSurfacePoint(Math.abs(a)>Math.abs(n)?c.x-o/2:c.x,Math.abs(a)>Math.abs(n)?c.y:c.y-o/2)}const p=t.localToMap(c),x=t.localToMap(m);if(o.isNone(p)||o.isNone(x))return null;t.doUnnormalization&&u.unnormalizeVerticesOnDatelineCrossing([[p,x]],t.spatialReference);const h=M(p,t.spatialReference),S=M(x,t.spatialReference),P=r.getMetersPerUnitForSR(t.spatialReference);let k=0;if(y.isValid(t.spatialReference))k=P*s.distance(h,S,null);else{const e=c.x-m.x,t=c.y-m.y;k=P*Math.sqrt(e*e+t*t)*(n||1)}const d=new l({center:h,radius:k,radiusUnit:"meters",spatialReference:t.spatialReference});return{geometry:g(d.rings,d.spatialReference,!1),center:h,edge:S}}function w(e,t,a){const n=t.mapToLocalMultiple(e),r=n[0],i=n[1],c=Math.round(i.x-r.x),l=Math.round(i.y-r.y),s=f.makeSurfacePoint(a?r.x:r.x+c/2,a?r.y:r.y+l/2),u=a?c:c/2,y=a?l:l/2,m=60,p=[],x=2*Math.PI/m;function h(e){const t=Math.cos(e),a=Math.sin(e);return f.makeSurfacePoint(u*t+s.x,y*a+s.y)}for(let o=0;o<m;o++)p.push(h(o*x));p.push(p[0]);const{spatialReference:S,doUnnormalization:P}=t,k=g([o.filterNones(p.map((e=>t.localToMap(e))))],S,P,!1),d=t.localToMap(h(Math.PI/2)),R=t.localToMap(h(0)),T=t.localToMap(h(-Math.PI/2)),b=t.localToMap(h(Math.PI));return{geometry:k,midpoints:o.isSome(d)&&o.isSome(R)&&o.isSome(T)&&o.isSome(b)?{top:M(d,S),right:M(R,S),bottom:M(T,S),left:M(b,S)}:null}}e.createCircle=C,e.createEllipse=w,e.createMultipoint=S,e.createPoint=M,e.createPolygon=g,e.createPolyline=P,e.createRectangle=d,e.createSquare=k,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
