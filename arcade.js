/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"./Graphic.js";import t from"./arcade/Dictionary.js";import r from"./arcade/Feature.js";import a from"./arcade/ImmutableArray.js";import{parseScript as n}from"./arcade/parser.js";import c from"./core/Error.js";import o from"./layers/FeatureLayer.js";import s from"./rest/support/FeatureSet.js";import{loadArcade as i}from"./support/arcadeOnDemand.js";function u(e,t,r,n={}){const c=t.elementType,o="value",s="array"===c.type?[{name:o,type:c.type,elementType:c.elementType}]:"dictionary"===c.type?[{name:o,type:c.type,properties:c.properties}]:[{name:o,type:c.type}];return new a(e.map((e=>{const t={};return y(t,s,{[o]:e},r,n),t[o]})))}function p(e,t,r={}){const a=e instanceof s?new o({source:e.features,geometryType:e.geometryType,fields:e.fields,spatialReference:e.spatialReference}):e;return t.constructFeatureSet(a,r.spatialReference,null,!0,r.lruCache,r.interceptor)}function l(e,t,r={}){const{spatialReference:a,interceptor:n,lruCache:c}=r;return"string"==typeof e?t.createFeatureSetCollectionFromService(e,a,c,n):t.createFeatureSetCollectionFromMap(e,a,c,n)}function f(e,r,a,n={}){const c={};return y(c,r.properties,e,a,n),new t(c)}function y(e,t,a,n,c={}){const o={};for(const r of Object.keys(a))o[r.toLowerCase()]=a[r];for(const s of t){const t=s.name.toLowerCase();if(c.variablesPreProcessed)e[t]=o[t];else switch(s.type){case"array":{const r=o[t];e[t]=u(r,s,n,c);break}case"feature":{const a=o[t];e[t]=null==a?null:r.createFromGraphic(a);break}case"featureSet":{const r=o[t];e[t]=n?p(r,n,c):null;break}case"featureSetCollection":{const r=o[t];e[t]=n?l(r,n,c):null;break}case"dictionary":{const r=o[t];e[t]=f(r,s,n,c);break}case"geometry":case"boolean":case"date":case"text":case"number":e[t]=o[t]}}}function m(e,t){for(const r of e)t.push(r),"dictionary"===r.type&&m(r.properties,t);return t}function d(e,t,r,a,n){const{spatialReference:c,interceptor:o,lruCache:s,services:i,console:u}=r,p={vars:{},spatialReference:c,interceptor:o,lrucache:s,useAsync:n,services:i,console:u};return t?(y(p.vars,e.variables,t,a,r),p):p}function b(t,r){switch(r.getArcadeType(t)){case"number":case"text":case"boolean":case"point":case"polygon":case"polyline":case"multipoint":case"extent":return t;case"date":return new Date(t.getTime());case"feature":{const r=(t.type,t),a="geometry"in r?r.geometry():null,n="readAttributes"in r?r.readAttributes():r.attributes;return new e({geometry:a,attributes:n})}case"dictionary":{const e=t,a=e.attributes,n={};for(const t of Object.keys(a))n[t]=b(e.field(t),r);return n}case"array":return("toArray"in t?t.toArray():t).map((e=>b(e,r)))}return t}async function w(e,t,r={}){const{arcade:a,arcadeUtils:o}=await i(),{loadScriptDependencies:s,referencesMember:u,scriptIsAsync:p}=a,l=m(t.variables,[]),f=l.filter((e=>"featureSet"===e.type||"featureSetCollection"===e.type)).map((e=>e.name.toLowerCase())),y=n(e,f);if(!y)throw new c("arcade:invalid-script","Unable to create SyntaxTree");const w=o.extractFieldNames(y),h=l.map((e=>e.name.toLowerCase())).filter((e=>u(y,e))),C=p(y,f);await s(y,C,f);const v={vars:{},spatialReference:null,useAsync:C};for(const n of h)v.vars[n]="any";const{lruCache:S}=r,j=a.compileScript(y,v),x=a.featureSetUtils();return{execute:(e,r={})=>{if(C)throw new c("arcade:invalid-execution-mode","Cannot execute the script in synchronous mode");const a=j(d(t,e,{lruCache:S,...r},x,C));return r.rawOutput?a:b(a,o)},executeAsync:async(e,r={})=>{const a=await j(d(t,e,{lruCache:S,...r},x,C));return r.rawOutput?a:b(a,o)},isAsync:C,variablesUsed:h,fieldsUsed:w,syntaxTree:y}}export{w as createArcadeExecutor};
