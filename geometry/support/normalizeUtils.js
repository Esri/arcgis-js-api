/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../config","../../core/maybe","../../core/Logger","../../core/Error","./spatialReferenceUtils","./webMercatorUtils","../Polygon","../Polyline","./normalizeUtilsCommon","../../tasks/geometry/cut","../../tasks/geometry/simplify"],(function(e,t,n,o,s,r,i,l,f,c,a,u){"use strict";const p=o.getLogger("esri.geometry.support.normalizeUtils");function h(e){return"polygon"===e.type}function g(e){return"polygon"===e[0].type}function m(e){return"polyline"===e[0].type}function y(e){const t=[];let n=0,o=0;for(let s=0;s<e.length;s++){const r=e[s];let i=null;for(let e=0;e<r.length;e++)i=r[e],t.push(i),0===e?(n=i[0],o=n):(n=Math.min(n,i[0]),o=Math.max(o,i[0]));i&&t.push([(n+o)/2,0])}return t}function x(e,t){if(!(e instanceof f||e instanceof l)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw p.error(e),new s(e)}const n=c.getGeometryParts(e),o=[];for(const s of n){const e=[];o.push(e),e.push([s[0][0],s[0][1]]);for(let n=0;n<s.length-1;n++){const o=s[n][0],r=s[n][1],i=s[n+1][0],l=s[n+1][1],f=Math.sqrt((i-o)*(i-o)+(l-r)*(l-r)),c=(l-r)/f,a=(i-o)/f,u=f/t;if(u>1){for(let l=1;l<=u-1;l++){const n=l*t,s=a*n+o,i=c*n+r;e.push([s,i])}const n=(f+Math.floor(u-1)*t)/2,s=a*n+o,i=c*n+r;e.push([s,i])}e.push([i,l])}}return h(e)?new l({rings:o,spatialReference:e.spatialReference}):new f({paths:o,spatialReference:e.spatialReference})}function d(e,t,n){if(t){const t=x(e,1e6);e=i.webMercatorToGeographic(t,!0)}return n&&(e=c.updatePolyGeometry(e,n)),e}function M(e,t,n){if(Array.isArray(e)){const o=e[0];if(o>t){const n=c.offsetMagnitude(o,t);e[0]=o+n*(-2*t)}else if(o<n){const t=c.offsetMagnitude(o,n);e[0]=o+t*(-2*n)}}else{const o=e.x;if(o>t){const n=c.offsetMagnitude(o,t);e=e.clone().offset(n*(-2*t),0)}else if(o<n){const t=c.offsetMagnitude(o,n);e=e.clone().offset(t*(-2*n),0)}}return e}function P(e,t){let n=-1;for(let o=0;o<t.cutIndexes.length;o++){const s=t.cutIndexes[o],r=t.geometries[o],i=c.getGeometryParts(r);for(let e=0;e<i.length;e++){const t=i[e];t.some((n=>{if(n[0]<180)return!0;{let n=0;for(let e=0;e<t.length;e++){const o=t[e][0];n=o>n?o:n}n=Number(n.toFixed(9));const o=-360*c.offsetMagnitude(n,180);for(let s=0;s<t.length;s++){const t=r.getPoint(e,s);r.setPoint(e,s,t.clone().offset(o,0))}return!0}}))}if(s===n){if(g(e))for(const t of c.getGeometryParts(r))e[s]=e[s].addRing(t);else if(m(e))for(const t of c.getGeometryParts(r))e[s]=e[s].addPath(t)}else n=s,e[s]=r}return e}async function w(e,o,s){if(!Array.isArray(e))return w([e],o);const p=o?o.url:t.geometryServiceUrl;let h,g,m,y,x,b,R,G,z=0;const L=[],v=[];for(const t of e)if(n.isNone(t))v.push(t);else if(h||(h=t.spatialReference,g=r.getInfo(h),m=h.isWebMercator,b=m?102100:4326,y=c.cutParams[b].maxX,x=c.cutParams[b].minX,R=c.cutParams[b].plus180Line,G=c.cutParams[b].minus180Line),g)if("mesh"===t.type)v.push(t);else if("point"===t.type)v.push(M(t.clone(),y,x));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((e=>M(e,y,x))),v.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,g);v.push(e.rings?new l(e):e)}else if(t.extent){const e=t.extent,n=c.offsetMagnitude(e.xmin,x)*(2*y);let o=0===n?t.clone():c.updatePolyGeometry(t.clone(),n);e.offset(n,0),e.intersects(R)&&e.xmax!==y?(z=e.xmax>z?e.xmax:z,o=d(o,m),L.push(o),v.push("cut")):e.intersects(G)&&e.xmin!==x?(z=e.xmax*(2*y)>z?e.xmax*(2*y):z,o=d(o,m,360),L.push(o),v.push("cut")):v.push(o)}else v.push(t.clone());else v.push(t);let I=c.offsetMagnitude(z,y),U=-90;const k=I,A=new f;for(;I>0;){const e=360*I-180;A.addPath([[e,U],[e,-1*U]]),U*=-1,I--}if(L.length>0&&k>0){const t=P(L,await a.cut(p,L,A,s)),o=[],r=[];for(let s=0;s<v.length;s++){const l=v[s];if("cut"!==l)r.push(l);else{const l=t.shift(),f=e[s];n.isSome(f)&&"polygon"===f.type&&f.rings&&f.rings.length>1&&l.rings.length>=f.rings.length?(o.push(l),r.push("simplify")):r.push(m?i.geographicToWebMercator(l):l)}}if(!o.length)return r;const l=await u.simplify(p,o,s),f=[];for(let e=0;e<r.length;e++){const t=r[e];"simplify"!==t?f.push(t):f.push(m?i.geographicToWebMercator(l.shift()):l.shift())}return f}const T=[];for(let t=0;t<v.length;t++){const e=v[t];if("cut"!==e)T.push(e);else{const e=L.shift();T.push(!0===m?i.geographicToWebMercator(e):e)}}return Promise.resolve(T)}function b(e){if(!e)return null;const t=e.extent;if(!t)return null;const n=e.spatialReference&&r.getInfo(e.spatialReference);if(!n)return t;const[o,s]=n.valid,i=2*s,{width:l}=t;let f,{xmin:c,xmax:a}=t;if([c,a]=[a,c],"extent"===e.type||0===l||l<=s||l>i||c<o||a>s)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;f=y(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;f=y(e.paths);break;case"multipoint":f=e.points}const u=t.clone();for(let r=0;r<f.length;r++){let e=f[r][0];e<0?(e+=s,a=Math.max(e,a)):(e-=s,c=Math.min(e,c))}return u.xmin=c,u.xmax=a,u.width<l?(u.xmin-=s,u.xmax-=s,u):t}function R(e,t){const n=r.getInfo(t);if(n){const[t,o]=n.valid,s=o-t;if(e<t)for(;e<t;)e+=s;if(e>o)for(;e>o;)e-=s}return e}e.getDenormalizedExtent=b,e.normalizeCentralMeridian=w,e.normalizeMapX=R,e.straightLineDensify=x,Object.defineProperty(e,"__esModule",{value:!0})}));
