/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../config","../../core/maybe","../../core/Logger","../../core/Error","../../core/promiseUtils","./spatialReferenceUtils","../SpatialReference","./webMercatorUtils","../Polygon","../Polyline","../../tasks/geometry/cut","../../tasks/geometry/simplify"],(function(e,t,n,s,o,r,i,c,l,f,a,p,u){"use strict";const h=s.getLogger("esri.geometry.support.normalizeUtils"),g={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new a({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:c.WebMercator}),minus180Line:new a({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:c.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new a({paths:[[[180,-180],[180,180]]],spatialReference:c.WGS84}),minus180Line:new a({paths:[[[-180,-180],[-180,180]]],spatialReference:c.WGS84})}};function m(e){return"polygon"===e.type}function y(e){return"polyline"===e[0].type}function x(e){return m(e)?e.rings:e.paths}function d(e,t){return Math.ceil((e-t)/(2*t))}function M(e,t){const n=x(e);for(const e of n)for(const n of e)n[0]+=t;return e}function w(e){const t=[];let n=0,s=0;for(let o=0;o<e.length;o++){const r=e[o];let i=null;for(let e=0;e<r.length;e++)i=r[e],t.push(i),0===e?(n=i[0],s=n):(n=Math.min(n,i[0]),s=Math.max(s,i[0]));i&&t.push([(n+s)/2,0])}return t}function R(e,t){if(!(e instanceof a||e instanceof f)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw h.error(e),new o(e)}const n=x(e),s=[];for(const e of n){const n=[];s.push(n),n.push([e[0][0],e[0][1]]);for(let s=0;s<e.length-1;s++){const o=e[s][0],r=e[s][1],i=e[s+1][0],c=e[s+1][1],l=Math.sqrt((i-o)*(i-o)+(c-r)*(c-r)),f=(c-r)/l,a=(i-o)/l,p=l/t;if(p>1){for(let e=1;e<=p-1;e++){const s=e*t,i=a*s+o,c=f*s+r;n.push([i,c])}const e=(l+Math.floor(p-1)*t)/2,s=a*e+o,i=f*e+r;n.push([s,i])}n.push([i,c])}}return m(e)?new f({rings:s,spatialReference:e.spatialReference}):new a({paths:s,spatialReference:e.spatialReference})}function b(e,t,n){if(t){const t=R(e,1e6);e=l.webMercatorToGeographic(t,!0)}return n&&(e=M(e,n)),e}function L(e,t,n){if(Array.isArray(e)){const s=e[0];if(s>t){const n=d(s,t);e[0]=s+n*(-2*t)}else if(s<n){const t=d(s,n);e[0]=s+t*(-2*n)}}else{const s=e.x;if(s>t){const n=d(s,t);e=e.clone().offset(n*(-2*t),0)}else if(s<n){const t=d(s,n);e=e.clone().offset(t*(-2*n),0)}}return e}e.getDenormalizedExtent=function(e){if(!e)return null;const t=e.extent;if(!t)return null;const n=e.spatialReference&&i.getInfo(e.spatialReference);if(!n)return t;const[s,o]=n.valid,r=2*o,{width:c}=t;let l,{xmin:f,xmax:a}=t;if([f,a]=[a,f],"extent"===e.type||0===c||c<=o||c>r||f<s||a>o)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;l=w(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;l=w(e.paths);break;case"multipoint":l=e.points}const p=t.clone();for(let e=0;e<l.length;e++){let t=l[e][0];t<0?(t+=o,a=Math.max(t,a)):(t-=o,f=Math.min(t,f))}return p.xmin=f,p.xmax=a,p.width<c?(p.xmin-=o,p.xmax-=o,p):t},e.normalizeCentralMeridian=async function e(s,o,c){if(!Array.isArray(s))return e([s],o);const h=o?o.url:t.geometryServiceUrl;let m,w,R,W,P,X,v,z,I=0;const S=[],U=[];for(const e of s)if(n.isNone(e))U.push(e);else if(m||(m=e.spatialReference,w=i.getInfo(m),R=m.isWebMercator,X=R?102100:4326,W=g[X].maxX,P=g[X].minX,v=g[X].plus180Line,z=g[X].minus180Line),w)if("mesh"===e.type)U.push(e);else if("point"===e.type)U.push(L(e.clone(),W,P));else if("multipoint"===e.type){const t=e.clone();t.points=t.points.map((e=>L(e,W,P))),U.push(t)}else if("extent"===e.type){const t=e.clone()._normalize(!1,!1,w);U.push(t.rings?new f(t):t)}else if(e.extent){const t=e.extent,n=d(t.xmin,P)*(2*W);let s=0===n?e.clone():M(e.clone(),n);t.offset(n,0),t.intersects(v)&&t.xmax!==W?(I=t.xmax>I?t.xmax:I,s=b(s,R),S.push(s),U.push("cut")):t.intersects(z)&&t.xmin!==P?(I=t.xmax*(2*W)>I?t.xmax*(2*W):I,s=b(s,R,360),S.push(s),U.push("cut")):U.push(s)}else U.push(e.clone());else U.push(e);let k=d(I,W),A=-90;const T=k,D=new a;for(;k>0;){const e=360*k-180;D.addPath([[e,A],[e,-1*A]]),A*=-1,k--}if(S.length>0&&T>0){const e=function(e,t){let n=-1;for(let s=0;s<t.cutIndexes.length;s++){const o=t.cutIndexes[s],r=t.geometries[s],i=x(r);for(let e=0;e<i.length;e++){const t=i[e];t.some((n=>{if(n[0]<180)return!0;{let n=0;for(let e=0;e<t.length;e++){const s=t[e][0];n=s>n?s:n}n=Number(n.toFixed(9));const s=-360*d(n,180);for(let n=0;n<t.length;n++){const t=r.getPoint(e,n);r.setPoint(e,n,t.clone().offset(s,0))}return!0}}))}if(o===n){if("polygon"===e[0].type)for(const t of x(r))e[o]=e[o].addRing(t);else if(y(e))for(const t of x(r))e[o]=e[o].addPath(t)}else n=o,e[o]=r}return e}(S,await p.cut(h,S,D,c)),t=[],o=[];for(let r=0;r<U.length;r++){const i=U[r];if("cut"!==i)o.push(i);else{const i=e.shift(),c=s[r];n.isSome(c)&&"polygon"===c.type&&c.rings&&c.rings.length>1&&i.rings.length>=c.rings.length?(t.push(i),o.push("simplify")):o.push(R?l.geographicToWebMercator(i):i)}}if(!t.length)return o;const r=await u.simplify(h,t,c),i=[];for(let e=0;e<o.length;e++){const t=o[e];"simplify"!==t?i.push(t):i.push(R?l.geographicToWebMercator(r.shift()):r.shift())}return i}const G=[];for(let e=0;e<U.length;e++){const t=U[e];if("cut"!==t)G.push(t);else{const e=S.shift();G.push(!0===R?l.geographicToWebMercator(e):e)}}return r.resolve(G)},e.normalizeMapX=function(e,t){const n=i.getInfo(t);if(n){const[t,s]=n.valid,o=s-t;if(e<t)for(;e<t;)e+=o;if(e>s)for(;e>s;)e-=o}return e},e.straightLineDensify=R,Object.defineProperty(e,"__esModule",{value:!0})}));
