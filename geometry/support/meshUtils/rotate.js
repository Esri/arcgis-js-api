/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../core/Logger","../../../core/maybe","../../../chunks/mat3","../../../chunks/mat3f64","../../../chunks/mat4","../../../chunks/mat4f64","../../../chunks/vec3","../../../chunks/vec3f64","../../projection","../../projectionEllipsoid","../axisAngleDegrees","./geographicUtils","./projection"],(function(e,t,r,o,n,i,a,s,c,l,g,p,u,f){"use strict";const m=t.getLogger("esri.geometry.support.meshUtils.rotate");function h(e,t,o){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const n=e.spatialReference;if(r.isSome(e.transform)){var i;null!=(null==o?void 0:o.geographic)&&o.geographic!==e.transform.geographic&&m.warn(`Specifying the 'geographic' parameter (${o.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const r=null!=(i=null==o?void 0:o.origin)?i:e.transform.getOriginPoint(n);d(e.transform,t,r)}else{var a;const r=null!=(a=null==o?void 0:o.origin)?a:e.origin;u.isGeographicMesh(e.spatialReference,o)?v(e,t,r):P(e,t,r)}}function d(e,t,r){const o=s.set(b,r.x,r.y,r.z),n=s.subtract(b,o,e.origin);e.applyLocalInverse(n,A),e.rotation=p.compose(e.rotation,t,p.create()),e.applyLocalInverse(n,n),s.subtract(n,n,A),e.translation=s.add(c.create(),e.translation,n)}function v(e,t,n){const i=e.spatialReference,a=g.getSphericalPCPF(i),c=y;l.projectPointToVector(n,c,a)||l.projectPointToVector(e.origin,c,a);const u=e.vertexAttributes.position,m=e.vertexAttributes.normal,h=e.vertexAttributes.tangent,d=new Float64Array(u.length),v=r.isSome(m)?new Float32Array(m.length):null,P=r.isSome(h)?new Float32Array(h.length):null;l.computeTranslationToOriginAndRotation(a,c,F,a),o.fromMat4(S,F);const b=j;s.transformMat3(p.axis(j),p.axis(t),S),b[3]=t[3],f.projectToPCPF(u,i,d),r.isSome(m)&&f.projectNormalToPCPF(m,u,d,i,v),r.isSome(h)&&f.projectTangentToPCPF(h,u,d,i,P),x(d,b,3,c),f.projectFromPCPF(d,u,i),r.isSome(m)&&(x(v,b,3),f.projectNormalFromPCPF(v,u,d,i,m)),r.isSome(h)&&(x(P,b,4),f.projectTangentFromPCPF(P,u,d,i,h)),e.vertexAttributesChanged()}function P(e,t,r){const o=y;if(!l.projectPointToVector(r,o,e.spatialReference)){const t=e.origin;o[0]=t.x,o[1]=t.y,o[2]=t.z,m.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}x(e.vertexAttributes.position,t,3,o),x(e.vertexAttributes.normal,t,3),x(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}function x(e,t,o,n=c.ZEROS){if(!r.isNone(e)){i.fromRotation(F,p.angleRad(t),p.axis(t));for(let t=0;t<e.length;t+=o){for(let r=0;r<3;r++)b[r]=e[t+r]-n[r];s.transformMat4(b,b,F);for(let r=0;r<3;r++)e[t+r]=b[r]+n[r]}}}const b=c.create(),A=c.create(),j=p.create(),F=a.create(),S=n.create(),y=c.create();e.rotate=h,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
