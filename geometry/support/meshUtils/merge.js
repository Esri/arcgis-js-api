/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["exports","../../../core/Logger","../../../core/maybe","../../../chunks/vec3","../../../chunks/vec3f64","../MeshComponent","../MeshTransform","../MeshVertexAttributes","./georeference"],(function(e,t,r,o,n,i,s,a,l){"use strict";const f=t.getLogger("esri.geometry.support.triangleMeshMerge");function c(e,t){if(0===e.length)return f.error("merge()","Must specify one more more geometries to merge"),null;const o=e[0].spatialReference;for(const r of e){if(!r.spatialReference.equals(o))return f.error("merge()","Geometries must all be in the same spatial reference"),null;if(!r.loaded)return f.error("merge()","Geometries must all be loaded before merging"),null}const n=u(e);if(r.isNone(n))return null;const i=d(e),s=[],a={position:0,uv:0,normal:0,tangent:0,color:0},l=new Map,c=new Map;for(const r of e){const e=m(r,n);if(t&&t.reuseMaterials&&r.components)for(const t of r.components)t.material&&l.set(t.material,t.material);h(r,a,l,c,s),b("position",e,i,a,0),b("normal",e,i,a,0),b("tangent",e,i,a,0),b("uv",r.vertexAttributes,i,a,0),b("color",r.vertexAttributes,i,a,255)}return{vertexAttributes:i,components:s,transform:n.transform,spatialReference:o}}function u(e){let t=null,i=!0;const a=n.create();let l=0,c=!1;for(const n of e)if(!r.isSome(t)||!r.isNone(n.transform)&&n.transform.equals(t)||(i=!1),r.isSome(n.transform)){if(r.isSome(t)&&t.geographic!==n.transform.geographic)return f.error("merge()","Inconsistent geographic mode for provided geometries transform. Some are geographic while others are not, unable to merge geometries."),null;r.isNone(t)&&(t=n.transform),n.transform.geographic&&(c=!0),l++,o.add(a,a,n.transform.origin)}if(r.isNone(t))return{transform:null,rebake:!1};if(i)return{transform:t.clone(),rebake:!1};const u=o.scale(a,a,1/l);return{transform:new s({origin:u,geographic:c}),rebake:!0}}function m(e,t){if(!t.rebake)return e.vertexAttributes;const o=l.georeferenceApplyTransform(e.vertexAttributes,e.transform,e.spatialReference);return r.isSome(t.transform)?l.ungeoreference(o,t.transform.getOriginPoint(e.spatialReference),{geographic:t.transform.geographic}):o}function g(e,t){return t.normal>0&&!e.vertexAttributes.normal}function p(e,t,r){g(e,t)&&"source"===r.shading&&(r.shading="flat")}function h(e,t,r,o,n){if(e.components)for(const i of e.components){const s=i.cloneWithDeduplication(r,o);for(let e=0;e<s.faces.length;e++)s.faces[e]+=t.position/3;p(e,t,s),n.push(s)}else if(e.vertexAttributes&&e.vertexAttributes.position){const r=e.vertexAttributes.position.length/3,o=new Uint32Array(r);for(let e=0;e<r;e++)o[e]=e+t.position;const s=new i({faces:o});p(e,t,s),n.push(s)}}function b(e,t,o,n,i){if(!t)return;const s=t.position;if(!s)return;const a=t[e],l=o[e];if(r.isNone(a)){let t=n[e];const o=x[e];if(r.isSome(l)){for(let e=0;e<s.length;e+=3)for(let r=0;r<o;r++)l[t++]=i;n[e]=t}}else r.isSome(l)&&r.isSome(a)&&(v(a,0,l,n[e],a.length),n[e]+=a.length)}function v(e,t,r,o,n){for(let i=0;i<n;i++)r[o++]=e[t++];return r}function A(e){let t=!1,r=!1,o=!1,n=!1;for(const i of e){const e=i.vertexAttributes;if(e&&e.position&&(e.uv&&(t=!0),e.normal&&(r=!0),e.tangent&&(n=!0),e.color&&(o=!0),r&&t&&o&&n))break}return{normal:r,uv:t,color:o,tangent:n}}function d(e){let t=0,r=0,o=0,n=0,i=0;const s=A(e);for(const a of e){const e=a.vertexAttributes;e&&e.position&&(t+=e.position.length,s.uv&&(r+=e.position.length/x.position*x.uv),s.normal&&(o+=e.position.length/x.position*x.normal),s.color&&(n+=e.position.length/x.position*x.color),s.tangent&&(i+=e.position.length/x.position*x.tangent))}return new a.default({position:new Float64Array(t),uv:r?new Float32Array(r):null,normal:o?new Float32Array(o):null,tangent:i?new Float32Array(i):null,color:n?new Uint8Array(n):null})}const x={position:3,normal:3,tangent:4,uv:2,color:4};e.merge=c,Object.defineProperty(e,"__esModule",{value:!0})}));
