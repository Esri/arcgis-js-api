/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../../core/Logger","../MeshComponent"],(function(t,e,n){"use strict";const o=e.getLogger("esri.geometry.support.triangleMeshMerge");function r(t,e){if(0===t.length)return o.error("merge()","Must specify one more more geometries to merge"),null;const n=t[0].spatialReference;if(t.some((t=>!t.spatialReference.equals(n))))return o.error("merge()","Geometries must all be in the same spatial reference"),null;const r=f(t),i=[],s={position:0,uv:0,normal:0,tangent:0,color:0},c=new Map,u=new Map;for(const o of t){const t=o.vertexAttributes;if(e&&e.reuseMaterials&&o.components)for(const e of o.components)e.material&&c.set(e.material,e.material);l(o,s,c,u,i),a("position",t,r,s,0),a("normal",t,r,s,0),a("tangent",t,r,s,0),a("uv",t,r,s,0),a("color",t,r,s,255)}return{vertexAttributes:r,components:i,spatialReference:n}}function i(t,e){return e.normal>0&&!t.vertexAttributes.normal}function s(t,e,n){i(t,e)&&"source"===n.shading&&(n.shading="flat")}function l(t,e,o,r,i){if(t.components)for(const n of t.components){const l=n.cloneWithDeduplication(o,r);for(let t=0;t<l.faces.length;t++)l.faces[t]+=e.position/3;s(t,e,l),i.push(l)}else if(t.vertexAttributes&&t.vertexAttributes.position){const o=t.vertexAttributes.position.length/3,r=new Uint32Array(o);for(let t=0;t<o;t++)r[t]=t+e.position;const l=new n({faces:r});s(t,e,l),i.push(l)}}function a(t,e,n,o,r){if(!e)return;const i=e.position;if(!i)return;const s=e[t];if(s)c(s,0,n[t],o[t],s.length),o[t]+=s.length;else{const e=n[t];let s=o[t];const l=p[t];if(e){for(let t=0;t<i.length;t+=3)for(let n=0;n<l;n++)e[s++]=r;o[t]=s}}}function c(t,e,n,o,r){for(let i=0;i<r;i++)n[o++]=t[e++];return n}function u(t){let e=!1,n=!1,o=!1,r=!1;for(const i of t){const t=i.vertexAttributes;if(t&&t.position&&(t.uv&&(e=!0),t.normal&&(n=!0),t.tangent&&(r=!0),t.color&&(o=!0),n&&e&&o&&r))break}return{normal:n,uv:e,color:o,tangent:r}}function f(t){let e=0,n=0,o=0,r=0,i=0;const s=u(t);for(const l of t){const t=l.vertexAttributes;t&&t.position&&(e+=t.position.length,s.uv&&(n+=t.position.length/p.position*p.uv),s.normal&&(o+=t.position.length/p.position*p.normal),s.color&&(r+=t.position.length/p.position*p.color),s.tangent&&(i+=t.position.length/p.position*p.tangent))}return{position:new Float64Array(e),uv:n?new Float32Array(n):null,normal:o?new Float32Array(o):null,tangent:i?new Float32Array(i):null,color:r?new Uint8Array(r):null}}const p={position:3,normal:3,tangent:4,uv:2,color:4};t.merge=r,Object.defineProperty(t,"__esModule",{value:!0})}));
