/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{isNone as t,isSome as r}from"../../../core/maybe.js";import{a as o,g as n}from"../../../chunks/vec3.js";import{c as s}from"../../../chunks/vec3f64.js";import i from"../MeshComponent.js";import a from"../MeshTransform.js";import{MeshVertexAttributes as l}from"../MeshVertexAttributes.js";import{georeferenceApplyTransform as f,ungeoreference as c}from"./georeference.js";const m=e.getLogger("esri.geometry.support.triangleMeshMerge");function u(e,r){if(0===e.length)return m.error("merge()","Must specify one more geometries to merge"),null;const o=e[0].spatialReference;for(const t of e){if(!t.spatialReference.equals(o))return m.error("merge()","Geometries must all be in the same spatial reference"),null;if(!t.loaded)return m.error("merge()","Geometries must all be loaded before merging"),null}const n=g(e);if(t(n))return null;const s=d(e),i=[],a={position:0,uv:0,normal:0,tangent:0,color:0},l=new Map,f=new Map;for(const t of e){const e=p(t,n);if(r&&r.reuseMaterials&&t.components)for(const r of t.components)r.material&&l.set(r.material,r.material);v(t,a,l,f,i),A("position",e,s,a,0),A("normal",e,s,a,0),A("tangent",e,s,a,0),A("uv",t.vertexAttributes,s,a,0),A("color",t.vertexAttributes,s,a,255)}return{vertexAttributes:s,components:i,transform:n.transform,spatialReference:o}}function g(e){let i=null,l=!0;const f=s();let c=0,u=!1;for(const n of e)if(!r(i)||!t(n.transform)&&n.transform.equals(i)||(l=!1),r(n.transform)){if(r(i)&&i.geographic!==n.transform.geographic)return m.error("merge()","Inconsistent geographic mode for provided geometries transform. Some are geographic while others are not, unable to merge geometries."),null;t(i)&&(i=n.transform),n.transform.geographic&&(u=!0),c++,o(f,f,n.transform.origin)}if(t(i))return{transform:null,rebake:!1};if(l)return{transform:i.clone(),rebake:!1};const g=n(f,f,1/c);return{transform:new a({origin:g,geographic:u}),rebake:!0}}function p(e,t){if(!t.rebake)return e.vertexAttributes;const o=f(e.vertexAttributes,e.transform,e.spatialReference);return r(t.transform)?c(o,t.transform.getOriginPoint(e.spatialReference),{geographic:t.transform.geographic}):o}function h(e,t){return t.normal>0&&!e.vertexAttributes.normal}function b(e,t,r){h(e,t)&&"source"===r.shading&&(r.shading="flat")}function v(e,t,r,o,n){if(e.components)for(const s of e.components){const i=s.cloneWithDeduplication(r,o),a=t.position/3;if(i.faces)for(let e=0;e<i.faces.length;e++)i.faces[e]+=a;else{i.faces=new Uint32Array(e.vertexAttributes.position.length/3);for(let e=0;e<i.faces.length;e++)i.faces[e]=e+a}b(e,t,i),n.push(i)}else if(e.vertexAttributes&&e.vertexAttributes.position){const r=e.vertexAttributes.position.length/3,o=new Uint32Array(r),s=t.position/3;for(let e=0;e<r;e++)o[e]=e+s;const a=new i({faces:o});b(e,t,a),n.push(a)}}function A(e,o,n,s,i){if(!o)return;const a=o.position;if(!a)return;const l=o[e],f=n[e];if(t(l)){let t=s[e];const o=y[e];if(r(f)){for(let e=0;e<a.length;e+=3)for(let r=0;r<o;r++)f[t++]=i;s[e]=t}}else r(f)&&r(l)&&(x(l,0,f,s[e],l.length),s[e]+=l.length)}function x(e,t,r,o,n){for(let s=0;s<n;s++)r[o++]=e[t++];return r}function w(e){let t=!1,r=!1,o=!1,n=!1;for(const s of e){const e=s.vertexAttributes;if(e&&e.position&&(e.uv&&(t=!0),e.normal&&(r=!0),e.tangent&&(n=!0),e.color&&(o=!0),r&&t&&o&&n))break}return{normal:r,uv:t,color:o,tangent:n}}function d(e){let t=0,r=0,o=0,n=0,s=0;const i=w(e);for(const a of e){const e=a.vertexAttributes;e&&e.position&&(t+=e.position.length,i.uv&&(r+=e.position.length/y.position*y.uv),i.normal&&(o+=e.position.length/y.position*y.normal),i.color&&(n+=e.position.length/y.position*y.color),i.tangent&&(s+=e.position.length/y.position*y.tangent))}return new l({position:new Float64Array(t),uv:r?new Float32Array(r):null,normal:o?new Float32Array(o):null,tangent:s?new Float32Array(s):null,color:n?new Uint8Array(n):null})}const y={position:3,normal:3,tangent:4,uv:2,color:4};export{u as merge};
