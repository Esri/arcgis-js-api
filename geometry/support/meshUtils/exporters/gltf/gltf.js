/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/Logger","../../../../../core/MapUtils","../../../../../core/maybe","../../../../../chunks/quat","../../../../../chunks/quatf64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../MeshMaterialMetallicRoughness","../../../MeshTransform","../../georeference","./buffer","./geometry","./types","./imageutils","../../../../../views/3d/glTF/internal/resourceUtils","../../../../../views/webgl/enums"],(function(e,t,s,r,i,a,o,n,u,c,l,f,h,p,d,m,g){"use strict";const T=t.getLogger("gltf");let x=function(){function e(e,t,s){this.params={},this._materialMap=new Array,this._imageMap=new Map,this._textureMap=new Map,this.gltf={asset:{version:"2.0",copyright:e.copyright,generator:e.generator},extras:{options:t,binChunkBuffer:null,promises:[]}},s&&(this.params=s),this._addScenes(e)}var t=e.prototype;return t._addScenes=function(e){this.gltf.scene=e.defaultScene;const t=this.gltf.extras,s=t.options.bufferOutputType===p.BufferOutputType.GLB||t.options.imageOutputType===p.ImageOutputType.GLB;s&&(t.binChunkBuffer=new f.Buffer(this.gltf)),e.forEachScene((e=>{this._addScene(e)})),s&&t.binChunkBuffer.finalize()},t._addScene=function(e){this.gltf.scenes||(this.gltf.scenes=[]);const t={};e.name&&(t.name=e.name),e.forEachNode((e=>{t.nodes||(t.nodes=[]);const s=this._addNode(e);t.nodes.push(s)})),this.gltf.scenes.push(t)},t._addNode=function(e){this.gltf.nodes||(this.gltf.nodes=[]);const t={};e.name&&(t.name=e.name);const s=e.translation;o.exactEquals(s,n.ZEROS)||(t.translation=n.clone(s));const r=e.rotation;i.exactEquals(r,a.IDENTITY)||(t.rotation=a.clone(r));const u=e.scale;o.exactEquals(u,n.ONES)||(t.scale=n.clone(u)),e.mesh&&e.mesh.vertexAttributes.position?t.mesh=this._addMesh(e.mesh):e.forEachNode((e=>{t.children||(t.children=[]);const s=this._addNode(e);t.children.push(s)}));const c=this.gltf.nodes.length;return this.gltf.nodes.push(t),c},t._addMesh=function(e){this.gltf.meshes||(this.gltf.meshes=[]);const t={primitives:[]},s=this.gltf.extras,i=s.options.bufferOutputType===p.BufferOutputType.GLB;let a;a=i?s.binChunkBuffer:new f.Buffer(this.gltf),this.params.origin||(this.params.origin=h.computeOrigin(e));const o=this.params.ignoreLocalTransform?r.applySome(e.transform,(e=>new c({origin:[e.origin[0],e.origin[1],e.origin[2]],geographic:!1}))):e.transform,n=l.ungeoreferenceByTransform(e.vertexAttributes,o,this.params.origin,{geographic:this.params.geographic,unit:"meters"});h.smoothNormals(e,n),this._flipYZAxis(n);const u=a.addBufferView(g.DataType.FLOAT,p.AttributeType.VEC3,p.TargetBuffer.ARRAY_BUFFER);let d,m,T,x;n.normal&&(d=a.addBufferView(g.DataType.FLOAT,p.AttributeType.VEC3,p.TargetBuffer.ARRAY_BUFFER)),e.vertexAttributes.uv&&(m=a.addBufferView(g.DataType.FLOAT,p.AttributeType.VEC2,p.TargetBuffer.ARRAY_BUFFER)),n.tangent&&(T=a.addBufferView(g.DataType.FLOAT,p.AttributeType.VEC4,p.TargetBuffer.ARRAY_BUFFER)),e.vertexAttributes.color&&(x=a.addBufferView(g.DataType.UNSIGNED_BYTE,p.AttributeType.VEC4,p.TargetBuffer.ARRAY_BUFFER)),u.startAccessor("POSITION"),d&&d.startAccessor("NORMAL"),m&&m.startAccessor("TEXCOORD_0"),T&&T.startAccessor("TANGENT"),x&&x.startAccessor("COLOR_0");const A=n.position.length/3,{position:_,normal:M,tangent:b}=n,{color:R,uv:E}=e.vertexAttributes;for(let c=0;c<A;++c)u.push(_[3*c+0]),u.push(_[3*c+1]),u.push(_[3*c+2]),d&&r.isSome(M)&&(d.push(M[3*c+0]),d.push(M[3*c+1]),d.push(M[3*c+2])),m&&r.isSome(E)&&(m.push(E[2*c+0]),m.push(E[2*c+1])),T&&r.isSome(b)&&(T.push(b[4*c+0]),T.push(b[4*c+1]),T.push(b[4*c+2]),T.push(b[4*c+3])),x&&r.isSome(R)&&(x.push(R[4*c+0]),x.push(R[4*c+1]),x.push(R[4*c+2]),x.push(R[4*c+3]));const O=u.endAccessor(),y=this._addAccessor(u.index,O);let B,S,w,N,C;if(d){const e=d.endAccessor();B=this._addAccessor(d.index,e)}if(m){const e=m.endAccessor();S=this._addAccessor(m.index,e)}if(T){const e=T.endAccessor();w=this._addAccessor(T.index,e)}if(x){const e=x.endAccessor();N=this._addAccessor(x.index,e)}e.components&&e.components.length>0&&e.components[0].faces?(C=a.addBufferView(g.DataType.UNSIGNED_INT,p.AttributeType.SCALAR,p.TargetBuffer.ELEMENT_ARRAY_BUFFER),this._addMeshVertexIndexed(C,e.components,t,y,B,S,w,N)):this._addMeshVertexNonIndexed(e.components,t,y,B,S,w,N),u.finalize(),d&&d.finalize(),m&&m.finalize(),T&&T.finalize(),C&&C.finalize(),x&&x.finalize(),i||a.finalize();const I=this.gltf.meshes.length;return this.gltf.meshes.push(t),I},t._flipYZAxis=function({position:e,normal:t,tangent:s}){this._flipYZBuffer(e,3),this._flipYZBuffer(t,3),this._flipYZBuffer(s,4)},t._flipYZBuffer=function(e,t){if(!r.isNone(e))for(let s=1,r=2;s<e.length;s+=t,r+=t){const t=e[s],i=e[r];e[s]=i,e[r]=-t}},t._addMaterial=function(e){if(null===e)return;const t=this._materialMap.indexOf(e);if(-1!==t)return t;this.gltf.materials||(this.gltf.materials=[]);const s={};switch(e.alphaMode){case"mask":s.alphaMode=p.AlphaMode.MASK;break;case"auto":case"blend":s.alphaMode=p.AlphaMode.BLEND}.5!==e.alphaCutoff&&(s.alphaCutoff=e.alphaCutoff),e.doubleSided&&(s.doubleSided=e.doubleSided),s.pbrMetallicRoughness={};const i=e=>e**2.1,a=e=>{const t=e.toRgba();return t[0]=i(t[0]/255),t[1]=i(t[1]/255),t[2]=i(t[2]/255),t};if(r.isSome(e.color)&&(s.pbrMetallicRoughness.baseColorFactor=a(e.color)),r.isSome(e.colorTexture)&&(s.pbrMetallicRoughness.baseColorTexture={index:this._addTexture(e.colorTexture)}),r.isSome(e.normalTexture)&&(s.normalTexture={index:this._addTexture(e.normalTexture)}),e instanceof u){if(r.isSome(e.emissiveTexture)&&(s.emissiveTexture={index:this._addTexture(e.emissiveTexture)}),r.isSome(e.emissiveColor)){const t=a(e.emissiveColor);s.emissiveFactor=[t[0],t[1],t[2]]}r.isSome(e.occlusionTexture)&&(s.occlusionTexture={index:this._addTexture(e.occlusionTexture)}),r.isSome(e.metallicRoughnessTexture)&&(s.pbrMetallicRoughness.metallicRoughnessTexture={index:this._addTexture(e.metallicRoughnessTexture)}),s.pbrMetallicRoughness.metallicFactor=e.metallic,s.pbrMetallicRoughness.roughnessFactor=e.roughness}else s.pbrMetallicRoughness.metallicFactor=1,s.pbrMetallicRoughness.roughnessFactor=1,T.warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");const o=this.gltf.materials.length;return this.gltf.materials.push(s),this._materialMap.push(e),o},t._addTexture=function(e){const t=this.gltf.textures??[];return this.gltf.textures=t,s.getOrCreateMapValue(this._textureMap,e,(()=>{const s={sampler:this._addSampler(e),source:this._addImage(e)},r=t.length;return t.push(s),r}))},t._addImage=function(e){const t=this._imageMap.get(e);if(null!=t)return t;this.gltf.images||(this.gltf.images=[]);const s={};if(e.url)s.uri=e.url;else{const t=e.data;s.extras=t;for(let e=0;e<this.gltf.images.length;++e)if(t===this.gltf.images[e].extras)return e;const i=this.gltf.extras;switch(i.options.imageOutputType){case p.ImageOutputType.GLB:{const e=i.binChunkBuffer.addBufferView(g.DataType.UNSIGNED_BYTE,p.AttributeType.SCALAR);if(m.isEncodedMeshTexture(t))r.isSome(t.data)&&e.writeOutToBuffer(t.data,0);else{const r=d.imageToArrayBuffer(t).then((({data:e,type:t})=>(s.mimeType=t,e)));e.writeAsync(r).then((()=>{e.finalize()}))}s.bufferView=e.index;break}case p.ImageOutputType.DataURI:if(m.isEncodedMeshTexture(t)){T.warnOnce("Image export for basis compressed textures not available.");break}s.uri=d.imageToDataURI(t);break;default:if(m.isEncodedMeshTexture(t)){T.warnOnce("Image export for basis compressed textures not available.");break}i.promises.push(d.imageToArrayBuffer(t).then((({data:e,type:t})=>{s.uri=e,s.mimeType=t})))}}const i=this.gltf.images.length;return this.gltf.images.push(s),this._imageMap.set(e,i),i},t._addSampler=function(e){this.gltf.samplers||(this.gltf.samplers=[]);let t=g.TextureWrapMode.REPEAT,s=g.TextureWrapMode.REPEAT;if("string"==typeof e.wrap)switch(e.wrap){case"clamp":t=g.TextureWrapMode.CLAMP_TO_EDGE,s=g.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":t=g.TextureWrapMode.MIRRORED_REPEAT,s=g.TextureWrapMode.MIRRORED_REPEAT}else{switch(e.wrap.vertical){case"clamp":s=g.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":s=g.TextureWrapMode.MIRRORED_REPEAT}switch(e.wrap.horizontal){case"clamp":t=g.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":t=g.TextureWrapMode.MIRRORED_REPEAT}}const r={wrapS:t,wrapT:s};for(let a=0;a<this.gltf.samplers.length;++a)if(JSON.stringify(r)===JSON.stringify(this.gltf.samplers[a]))return a;const i=this.gltf.samplers.length;return this.gltf.samplers.push(r),i},t._addAccessor=function(e,t){this.gltf.accessors||(this.gltf.accessors=[]);const s={bufferView:e,byteOffset:t.byteOffset,componentType:t.componentType,count:t.count,type:t.type,min:t.min,max:t.max,name:t.name};t.normalized&&(s.normalized=!0);const r=this.gltf.accessors.length;return this.gltf.accessors.push(s),r},t._addMeshVertexIndexed=function(e,t,s,r,i,a,o,n){for(const u of t){e.startAccessor("INDICES");for(let s=0;s<u.faces.length;++s)e.push(u.faces[s]);const t=e.endAccessor(),c={attributes:{POSITION:r},indices:this._addAccessor(e.index,t),material:this._addMaterial(u.material)};i&&"flat"!==u.shading&&(c.attributes.NORMAL=i),a&&(c.attributes.TEXCOORD_0=a),o&&"flat"!==u.shading&&(c.attributes.TANGENT=o),n&&(c.attributes.COLOR_0=n),s.primitives.push(c)}},t._addMeshVertexNonIndexed=function(e,t,s,r,i,a,o){const n={attributes:{POSITION:s}};r&&(n.attributes.NORMAL=r),i&&(n.attributes.TEXCOORD_0=i),a&&(n.attributes.TANGENT=a),o&&(n.attributes.COLOR_0=o),e&&(n.material=this._addMaterial(e[0].material)),t.primitives.push(n)},e}();e.GLTF=x,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
