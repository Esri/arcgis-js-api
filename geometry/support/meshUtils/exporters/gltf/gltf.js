/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/MapUtils","../../../../../core/maybe","../../../../../chunks/quat","../../../../../chunks/quatf64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../MeshMaterialMetallicRoughness","../../georeference","./buffer","./geometry","./types","./imageutils","../../../../../views/webgl/enums"],(function(e,t,s,i,a,r,n,o,u,l,c,h,f,p){"use strict";let d=function(){function e(e,t,s){this.params={},this.materialMap=new Array,this.imageMap=new Map,this.textureMap=new Map,this.gltf={asset:{version:"2.0",copyright:e.copyright,generator:e.generator},extras:{options:t,binChunkBuffer:null,promises:[]}},s&&(this.params=s),this._addScenes(e)}var d=e.prototype;return d._addScenes=function(e){this.gltf.scene=e.defaultScene;const t=this.gltf.extras.options.bufferOutputType===h.BufferOutputType.GLB||this.gltf.extras.options.imageOutputType===h.ImageOutputType.GLB;t&&(this.gltf.extras.binChunkBuffer=new l.Buffer(this.gltf)),e.forEachScene((e=>{this._addScene(e)})),t&&this.gltf.extras.binChunkBuffer.finalize()},d._addScene=function(e){this.gltf.scenes||(this.gltf.scenes=[]);const t={};e.name&&(t.name=e.name),e.forEachNode((e=>{t.nodes||(t.nodes=[]);const s=this._addNode(e);t.nodes.push(s)})),this.gltf.scenes.push(t)},d._addNode=function(e){this.gltf.nodes||(this.gltf.nodes=[]);const t={};e.name&&(t.name=e.name);const s=e.translation;r.exactEquals(s,n.ZEROS)||(t.translation=n.clone(s));const o=e.rotation;i.exactEquals(o,a.IDENTITY)||(t.rotation=a.clone(o));const u=e.scale;r.exactEquals(u,n.ONES)||(t.scale=n.clone(u)),e.mesh&&e.mesh.vertexAttributes.position?t.mesh=this._addMesh(e.mesh):e.forEachNode((e=>{t.children||(t.children=[]);const s=this._addNode(e);t.children.push(s)}));const l=this.gltf.nodes.length;return this.gltf.nodes.push(t),l},d._addMesh=function(e){this.gltf.meshes||(this.gltf.meshes=[]);const t={primitives:[]},i=this.gltf.extras.options.bufferOutputType===h.BufferOutputType.GLB;let a;a=i?this.gltf.extras.binChunkBuffer:new l.Buffer(this.gltf),this.params.origin||(this.params.origin=c.computeOrigin(e));const r=u.ungeoreferenceByTransform(e.vertexAttributes,e.transform,this.params.origin,{geographic:this.params.geographic,unit:"meters"});c.smoothNormals(e,r),this._flipYZAxis(r);const n=a.addBufferView(p.DataType.FLOAT,h.AttributeType.VEC3,h.TargetBuffer.ARRAY_BUFFER);let o,f,d,g;r.normal&&(o=a.addBufferView(p.DataType.FLOAT,h.AttributeType.VEC3,h.TargetBuffer.ARRAY_BUFFER)),e.vertexAttributes.uv&&(f=a.addBufferView(p.DataType.FLOAT,h.AttributeType.VEC2,h.TargetBuffer.ARRAY_BUFFER)),r.tangent&&(d=a.addBufferView(p.DataType.FLOAT,h.AttributeType.VEC4,h.TargetBuffer.ARRAY_BUFFER)),e.vertexAttributes.color&&(g=a.addBufferView(p.DataType.UNSIGNED_BYTE,h.AttributeType.VEC4,h.TargetBuffer.ARRAY_BUFFER)),n.startAccessor("POSITION"),o&&o.startAccessor("NORMAL"),f&&f.startAccessor("TEXCOORD_0"),d&&d.startAccessor("TANGENT"),g&&g.startAccessor("COLOR_0");const m=r.position.length/3,{position:T,normal:x,tangent:A}=r,{color:_,uv:R}=e.vertexAttributes;for(let u=0;u<m;++u)n.push(T[3*u+0]),n.push(T[3*u+1]),n.push(T[3*u+2]),o&&s.isSome(x)&&(o.push(x[3*u+0]),o.push(x[3*u+1]),o.push(x[3*u+2])),f&&s.isSome(R)&&(f.push(R[2*u+0]),f.push(R[2*u+1])),d&&s.isSome(A)&&(d.push(A[4*u+0]),d.push(A[4*u+1]),d.push(A[4*u+2]),d.push(A[4*u+3])),g&&s.isSome(_)&&(g.push(_[4*u+0]),g.push(_[4*u+1]),g.push(_[4*u+2]),g.push(_[4*u+3]));const M=n.endAccessor(),E=this._addAccessor(n.index,M);let b,O,y,B,S;if(o){const e=o.endAccessor();b=this._addAccessor(o.index,e)}if(f){const e=f.endAccessor();O=this._addAccessor(f.index,e)}if(d){const e=d.endAccessor();y=this._addAccessor(d.index,e)}if(g){const e=g.endAccessor();B=this._addAccessor(g.index,e)}e.components&&e.components.length>0&&e.components[0].faces?(S=a.addBufferView(p.DataType.UNSIGNED_INT,h.AttributeType.SCALAR,h.TargetBuffer.ELEMENT_ARRAY_BUFFER),this._addMeshVertexIndexed(S,e.components,t,E,b,O,y,B)):this._addMeshVertexNonIndexed(e.components,t,E,b,O,y,B),n.finalize(),o&&o.finalize(),f&&f.finalize(),d&&d.finalize(),S&&S.finalize(),g&&g.finalize(),i||a.finalize();const N=this.gltf.meshes.length;return this.gltf.meshes.push(t),N},d._flipYZAxis=function({position:e,normal:t,tangent:s}){this._flipYZBuffer(e,3),this._flipYZBuffer(t,3),this._flipYZBuffer(s,4)},d._flipYZBuffer=function(e,t){if(!s.isNone(e))for(let s=1,i=2;s<e.length;s+=t,i+=t){const t=e[s],a=e[i];e[s]=a,e[i]=-t}},d._addMaterial=function(e){if(null===e)return;const t=this.materialMap.indexOf(e);if(-1!==t)return t;this.gltf.materials||(this.gltf.materials=[]);const i={};switch(e.alphaMode){case"mask":i.alphaMode=h.AlphaMode.MASK;break;case"auto":case"blend":i.alphaMode=h.AlphaMode.BLEND}.5!==e.alphaCutoff&&(i.alphaCutoff=e.alphaCutoff),e.doubleSided&&(i.doubleSided=e.doubleSided),i.pbrMetallicRoughness={};const a=e=>e**2.1,r=e=>{const t=e.toRgba();return t[0]=a(t[0]/255),t[1]=a(t[1]/255),t[2]=a(t[2]/255),t};if(s.isSome(e.color)&&(i.pbrMetallicRoughness.baseColorFactor=r(e.color)),s.isSome(e.colorTexture)&&(i.pbrMetallicRoughness.baseColorTexture={index:this._addTexture(e.colorTexture)}),s.isSome(e.normalTexture)&&(i.normalTexture={index:this._addTexture(e.normalTexture)}),e instanceof o){if(s.isSome(e.emissiveTexture)&&(i.emissiveTexture={index:this._addTexture(e.emissiveTexture)}),s.isSome(e.emissiveColor)){const t=r(e.emissiveColor);i.emissiveFactor=[t[0],t[1],t[2]]}s.isSome(e.occlusionTexture)&&(i.occlusionTexture={index:this._addTexture(e.occlusionTexture)}),s.isSome(e.metallicRoughnessTexture)&&(i.pbrMetallicRoughness.metallicRoughnessTexture={index:this._addTexture(e.metallicRoughnessTexture)}),i.pbrMetallicRoughness.metallicFactor=e.metallic,i.pbrMetallicRoughness.roughnessFactor=e.roughness}else i.pbrMetallicRoughness.metallicFactor=1,i.pbrMetallicRoughness.roughnessFactor=1;const n=this.gltf.materials.length;return this.gltf.materials.push(i),this.materialMap.push(e),n},d._addTexture=function(e){return this.gltf.textures||(this.gltf.textures=[]),t.getOrCreateMapValue(this.textureMap,e,(()=>{const t={sampler:this._addSampler(e),source:this._addImage(e)},s=this.gltf.textures.length;return this.gltf.textures.push(t),s}))},d._addImage=function(e){const t=this.imageMap.get(e);if(null!=t)return t;this.gltf.images||(this.gltf.images=[]);const s={};if(e.url)s.uri=e.url;else{s.extras=e.data;for(let t=0;t<this.gltf.images.length;++t)if(e.data===this.gltf.images[t].extras)return t;switch(this.gltf.extras.options.imageOutputType){case h.ImageOutputType.GLB:{const t=this.gltf.extras.binChunkBuffer.addBufferView(p.DataType.UNSIGNED_BYTE,h.AttributeType.SCALAR),i=f.imageToArrayBuffer(e.data).then((({data:e,type:t})=>(s.mimeType=t,e)));t.writeAsync(i).then((()=>{t.finalize()})),s.bufferView=t.index;break}case h.ImageOutputType.DataURI:s.uri=f.imageToDataURI(e.data);break;default:this.gltf.extras.promises.push(f.imageToArrayBuffer(e.data).then((({data:e,type:t})=>{s.uri=e,s.mimeType=t})))}}const i=this.gltf.images.length;return this.gltf.images.push(s),this.imageMap.set(e,i),i},d._addSampler=function(e){this.gltf.samplers||(this.gltf.samplers=[]);let t=p.TextureWrapMode.REPEAT,s=p.TextureWrapMode.REPEAT;if("string"==typeof e.wrap)switch(e.wrap){case"clamp":t=p.TextureWrapMode.CLAMP_TO_EDGE,s=p.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":t=p.TextureWrapMode.MIRRORED_REPEAT,s=p.TextureWrapMode.MIRRORED_REPEAT}else{switch(e.wrap.vertical){case"clamp":s=p.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":s=p.TextureWrapMode.MIRRORED_REPEAT}switch(e.wrap.horizontal){case"clamp":t=p.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":t=p.TextureWrapMode.MIRRORED_REPEAT}}const i={wrapS:t,wrapT:s};for(let r=0;r<this.gltf.samplers.length;++r)if(JSON.stringify(i)===JSON.stringify(this.gltf.samplers[r]))return r;const a=this.gltf.samplers.length;return this.gltf.samplers.push(i),a},d._addAccessor=function(e,t){this.gltf.accessors||(this.gltf.accessors=[]);const s={bufferView:e,byteOffset:t.byteOffset,componentType:t.componentType,count:t.count,type:t.type,min:t.min,max:t.max,name:t.name};t.normalized&&(s.normalized=!0);const i=this.gltf.accessors.length;return this.gltf.accessors.push(s),i},d._addMeshVertexIndexed=function(e,t,s,i,a,r,n,o){for(const u of t){e.startAccessor("INDICES");for(let s=0;s<u.faces.length;++s)e.push(u.faces[s]);const t=e.endAccessor(),l={attributes:{POSITION:i},indices:this._addAccessor(e.index,t),material:this._addMaterial(u.material)};a&&"flat"!==u.shading&&(l.attributes.NORMAL=a),r&&(l.attributes.TEXCOORD_0=r),n&&"flat"!==u.shading&&(l.attributes.TANGENT=n),o&&(l.attributes.COLOR_0=o),s.primitives.push(l)}},d._addMeshVertexNonIndexed=function(e,t,s,i,a,r,n){const o={attributes:{POSITION:s}};i&&(o.attributes.NORMAL=i),a&&(o.attributes.TEXCOORD_0=a),r&&(o.attributes.TANGENT=r),n&&(o.attributes.COLOR_0=n),e&&(o.material=this._addMaterial(e[0].material)),t.primitives.push(o)},e}();e.GLTF=d,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
