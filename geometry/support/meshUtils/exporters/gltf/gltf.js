/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/Logger","../../../../../core/MapUtils","../../../../../core/maybe","../../../../../chunks/quat","../../../../../chunks/quatf64","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../MeshMaterialMetallicRoughness","../../georeference","./buffer","./geometry","./types","./imageutils","../../../../../views/webgl/enums"],(function(e,t,s,i,r,a,n,o,u,c,l,h,f,p,d){"use strict";const m=t.getLogger("gltf");let g=function(){function e(e,t,s){this.params={},this._materialMap=new Array,this._imageMap=new Map,this._textureMap=new Map,this.gltf={asset:{version:"2.0",copyright:e.copyright,generator:e.generator},extras:{options:t,binChunkBuffer:null,promises:[]}},s&&(this.params=s),this._addScenes(e)}var t=e.prototype;return t._addScenes=function(e){this.gltf.scene=e.defaultScene;const t=this.gltf.extras,s=t.options.bufferOutputType===f.BufferOutputType.GLB||t.options.imageOutputType===f.ImageOutputType.GLB;s&&(t.binChunkBuffer=new l.Buffer(this.gltf)),e.forEachScene((e=>{this._addScene(e)})),s&&t.binChunkBuffer.finalize()},t._addScene=function(e){this.gltf.scenes||(this.gltf.scenes=[]);const t={};e.name&&(t.name=e.name),e.forEachNode((e=>{t.nodes||(t.nodes=[]);const s=this._addNode(e);t.nodes.push(s)})),this.gltf.scenes.push(t)},t._addNode=function(e){this.gltf.nodes||(this.gltf.nodes=[]);const t={};e.name&&(t.name=e.name);const s=e.translation;n.exactEquals(s,o.ZEROS)||(t.translation=o.clone(s));const i=e.rotation;r.exactEquals(i,a.IDENTITY)||(t.rotation=a.clone(i));const u=e.scale;n.exactEquals(u,o.ONES)||(t.scale=o.clone(u)),e.mesh&&e.mesh.vertexAttributes.position?t.mesh=this._addMesh(e.mesh):e.forEachNode((e=>{t.children||(t.children=[]);const s=this._addNode(e);t.children.push(s)}));const c=this.gltf.nodes.length;return this.gltf.nodes.push(t),c},t._addMesh=function(e){this.gltf.meshes||(this.gltf.meshes=[]);const t={primitives:[]},s=this.gltf.extras,r=s.options.bufferOutputType===f.BufferOutputType.GLB;let a;a=r?s.binChunkBuffer:new l.Buffer(this.gltf),this.params.origin||(this.params.origin=h.computeOrigin(e));const n=c.ungeoreferenceByTransform(e.vertexAttributes,e.transform,this.params.origin,{geographic:this.params.geographic,unit:"meters"});h.smoothNormals(e,n),this._flipYZAxis(n);const o=a.addBufferView(d.DataType.FLOAT,f.AttributeType.VEC3,f.TargetBuffer.ARRAY_BUFFER);let u,p,m,g;n.normal&&(u=a.addBufferView(d.DataType.FLOAT,f.AttributeType.VEC3,f.TargetBuffer.ARRAY_BUFFER)),e.vertexAttributes.uv&&(p=a.addBufferView(d.DataType.FLOAT,f.AttributeType.VEC2,f.TargetBuffer.ARRAY_BUFFER)),n.tangent&&(m=a.addBufferView(d.DataType.FLOAT,f.AttributeType.VEC4,f.TargetBuffer.ARRAY_BUFFER)),e.vertexAttributes.color&&(g=a.addBufferView(d.DataType.UNSIGNED_BYTE,f.AttributeType.VEC4,f.TargetBuffer.ARRAY_BUFFER)),o.startAccessor("POSITION"),u&&u.startAccessor("NORMAL"),p&&p.startAccessor("TEXCOORD_0"),m&&m.startAccessor("TANGENT"),g&&g.startAccessor("COLOR_0");const T=n.position.length/3,{position:_,normal:x,tangent:A}=n,{color:M,uv:R}=e.vertexAttributes;for(let c=0;c<T;++c)o.push(_[3*c+0]),o.push(_[3*c+1]),o.push(_[3*c+2]),u&&i.isSome(x)&&(u.push(x[3*c+0]),u.push(x[3*c+1]),u.push(x[3*c+2])),p&&i.isSome(R)&&(p.push(R[2*c+0]),p.push(R[2*c+1])),m&&i.isSome(A)&&(m.push(A[4*c+0]),m.push(A[4*c+1]),m.push(A[4*c+2]),m.push(A[4*c+3])),g&&i.isSome(M)&&(g.push(M[4*c+0]),g.push(M[4*c+1]),g.push(M[4*c+2]),g.push(M[4*c+3]));const b=o.endAccessor(),E=this._addAccessor(o.index,b);let O,y,B,S,N;if(u){const e=u.endAccessor();O=this._addAccessor(u.index,e)}if(p){const e=p.endAccessor();y=this._addAccessor(p.index,e)}if(m){const e=m.endAccessor();B=this._addAccessor(m.index,e)}if(g){const e=g.endAccessor();S=this._addAccessor(g.index,e)}e.components&&e.components.length>0&&e.components[0].faces?(N=a.addBufferView(d.DataType.UNSIGNED_INT,f.AttributeType.SCALAR,f.TargetBuffer.ELEMENT_ARRAY_BUFFER),this._addMeshVertexIndexed(N,e.components,t,E,O,y,B,S)):this._addMeshVertexNonIndexed(e.components,t,E,O,y,B,S),o.finalize(),u&&u.finalize(),p&&p.finalize(),m&&m.finalize(),N&&N.finalize(),g&&g.finalize(),r||a.finalize();const w=this.gltf.meshes.length;return this.gltf.meshes.push(t),w},t._flipYZAxis=function({position:e,normal:t,tangent:s}){this._flipYZBuffer(e,3),this._flipYZBuffer(t,3),this._flipYZBuffer(s,4)},t._flipYZBuffer=function(e,t){if(!i.isNone(e))for(let s=1,i=2;s<e.length;s+=t,i+=t){const t=e[s],r=e[i];e[s]=r,e[i]=-t}},t._addMaterial=function(e){if(null===e)return;const t=this._materialMap.indexOf(e);if(-1!==t)return t;this.gltf.materials||(this.gltf.materials=[]);const s={};switch(e.alphaMode){case"mask":s.alphaMode=f.AlphaMode.MASK;break;case"auto":case"blend":s.alphaMode=f.AlphaMode.BLEND}.5!==e.alphaCutoff&&(s.alphaCutoff=e.alphaCutoff),e.doubleSided&&(s.doubleSided=e.doubleSided),s.pbrMetallicRoughness={};const r=e=>e**2.1,a=e=>{const t=e.toRgba();return t[0]=r(t[0]/255),t[1]=r(t[1]/255),t[2]=r(t[2]/255),t};if(i.isSome(e.color)&&(s.pbrMetallicRoughness.baseColorFactor=a(e.color)),i.isSome(e.colorTexture)&&(s.pbrMetallicRoughness.baseColorTexture={index:this._addTexture(e.colorTexture)}),i.isSome(e.normalTexture)&&(s.normalTexture={index:this._addTexture(e.normalTexture)}),e instanceof u){if(i.isSome(e.emissiveTexture)&&(s.emissiveTexture={index:this._addTexture(e.emissiveTexture)}),i.isSome(e.emissiveColor)){const t=a(e.emissiveColor);s.emissiveFactor=[t[0],t[1],t[2]]}i.isSome(e.occlusionTexture)&&(s.occlusionTexture={index:this._addTexture(e.occlusionTexture)}),i.isSome(e.metallicRoughnessTexture)&&(s.pbrMetallicRoughness.metallicRoughnessTexture={index:this._addTexture(e.metallicRoughnessTexture)}),s.pbrMetallicRoughness.metallicFactor=e.metallic,s.pbrMetallicRoughness.roughnessFactor=e.roughness}else s.pbrMetallicRoughness.metallicFactor=1,s.pbrMetallicRoughness.roughnessFactor=1,m.warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");const n=this.gltf.materials.length;return this.gltf.materials.push(s),this._materialMap.push(e),n},t._addTexture=function(e){const t=this.gltf.textures??[];return this.gltf.textures=t,s.getOrCreateMapValue(this._textureMap,e,(()=>{const s={sampler:this._addSampler(e),source:this._addImage(e)},i=t.length;return t.push(s),i}))},t._addImage=function(e){const t=this._imageMap.get(e);if(null!=t)return t;this.gltf.images||(this.gltf.images=[]);const s={};if(e.url)s.uri=e.url;else{const t=e.data;s.extras=t;for(let e=0;e<this.gltf.images.length;++e)if(t===this.gltf.images[e].extras)return e;const i=this.gltf.extras;switch(i.options.imageOutputType){case f.ImageOutputType.GLB:{const e=i.binChunkBuffer.addBufferView(d.DataType.UNSIGNED_BYTE,f.AttributeType.SCALAR),r=p.imageToArrayBuffer(t).then((({data:e,type:t})=>(s.mimeType=t,e)));e.writeAsync(r).then((()=>{e.finalize()})),s.bufferView=e.index;break}case f.ImageOutputType.DataURI:s.uri=p.imageToDataURI(t);break;default:i.promises.push(p.imageToArrayBuffer(t).then((({data:e,type:t})=>{s.uri=e,s.mimeType=t})))}}const i=this.gltf.images.length;return this.gltf.images.push(s),this._imageMap.set(e,i),i},t._addSampler=function(e){this.gltf.samplers||(this.gltf.samplers=[]);let t=d.TextureWrapMode.REPEAT,s=d.TextureWrapMode.REPEAT;if("string"==typeof e.wrap)switch(e.wrap){case"clamp":t=d.TextureWrapMode.CLAMP_TO_EDGE,s=d.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":t=d.TextureWrapMode.MIRRORED_REPEAT,s=d.TextureWrapMode.MIRRORED_REPEAT}else{switch(e.wrap.vertical){case"clamp":s=d.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":s=d.TextureWrapMode.MIRRORED_REPEAT}switch(e.wrap.horizontal){case"clamp":t=d.TextureWrapMode.CLAMP_TO_EDGE;break;case"mirror":t=d.TextureWrapMode.MIRRORED_REPEAT}}const i={wrapS:t,wrapT:s};for(let a=0;a<this.gltf.samplers.length;++a)if(JSON.stringify(i)===JSON.stringify(this.gltf.samplers[a]))return a;const r=this.gltf.samplers.length;return this.gltf.samplers.push(i),r},t._addAccessor=function(e,t){this.gltf.accessors||(this.gltf.accessors=[]);const s={bufferView:e,byteOffset:t.byteOffset,componentType:t.componentType,count:t.count,type:t.type,min:t.min,max:t.max,name:t.name};t.normalized&&(s.normalized=!0);const i=this.gltf.accessors.length;return this.gltf.accessors.push(s),i},t._addMeshVertexIndexed=function(e,t,s,i,r,a,n,o){for(const u of t){e.startAccessor("INDICES");for(let s=0;s<u.faces.length;++s)e.push(u.faces[s]);const t=e.endAccessor(),c={attributes:{POSITION:i},indices:this._addAccessor(e.index,t),material:this._addMaterial(u.material)};r&&"flat"!==u.shading&&(c.attributes.NORMAL=r),a&&(c.attributes.TEXCOORD_0=a),n&&"flat"!==u.shading&&(c.attributes.TANGENT=n),o&&(c.attributes.COLOR_0=o),s.primitives.push(c)}},t._addMeshVertexNonIndexed=function(e,t,s,i,r,a,n){const o={attributes:{POSITION:s}};i&&(o.attributes.NORMAL=i),r&&(o.attributes.TEXCOORD_0=r),a&&(o.attributes.TANGENT=a),n&&(o.attributes.COLOR_0=n),e&&(o.material=this._addMaterial(e[0].material)),t.primitives.push(o)},e}();e.GLTF=g,Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
