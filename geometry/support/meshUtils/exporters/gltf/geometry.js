/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["exports","../../../../../geometry","../../../../../core/mathUtils","../../../../../core/maybe","../../../../../chunks/vec3","../../../../../chunks/vec3f64","../../../../Point"],(function(t,e,r,s,i,n,o){"use strict";function a(t){if(t.components){for(const e of t.components)"smooth"===e.shading&&e.faces&&u(t,e);t.vertexAttributesChanged()}}function u(t,e){s.isNone(t.vertexAttributes.normal)&&(t.vertexAttributes.normal=new Float32Array(t.vertexAttributes.position.length));const n=e.faces.length/3;for(let s=0;s<n;++s){const n=e.faces[3*s+0],o=e.faces[3*s+1],a=e.faces[3*s+2],u=i.set(m,t.vertexAttributes.position[3*n+0],t.vertexAttributes.position[3*n+1],t.vertexAttributes.position[3*n+2]),x=i.set(b,t.vertexAttributes.position[3*o+0],t.vertexAttributes.position[3*o+1],t.vertexAttributes.position[3*o+2]),v=i.set(l,t.vertexAttributes.position[3*a+0],t.vertexAttributes.position[3*a+1],t.vertexAttributes.position[3*a+2]),A=i.subtract(x,x,u),c=i.subtract(v,v,u),f=i.cross(A,A,c);r.isNaN(t.vertexAttributes.normal[3*n+0])&&(t.vertexAttributes.normal[3*n+0]=0),r.isNaN(t.vertexAttributes.normal[3*n+1])&&(t.vertexAttributes.normal[3*n+1]=0),r.isNaN(t.vertexAttributes.normal[3*n+2])&&(t.vertexAttributes.normal[3*n+2]=0),r.isNaN(t.vertexAttributes.normal[3*o+0])&&(t.vertexAttributes.normal[3*o+0]=0),r.isNaN(t.vertexAttributes.normal[3*o+1])&&(t.vertexAttributes.normal[3*o+1]=0),r.isNaN(t.vertexAttributes.normal[3*o+2])&&(t.vertexAttributes.normal[3*o+2]=0),r.isNaN(t.vertexAttributes.normal[3*a+0])&&(t.vertexAttributes.normal[3*a+0]=0),r.isNaN(t.vertexAttributes.normal[3*a+1])&&(t.vertexAttributes.normal[3*a+1]=0),r.isNaN(t.vertexAttributes.normal[3*a+2])&&(t.vertexAttributes.normal[3*a+2]=0),t.vertexAttributes.normal[3*n+0]+=f[0],t.vertexAttributes.normal[3*n+1]+=f[1],t.vertexAttributes.normal[3*n+2]+=f[2],t.vertexAttributes.normal[3*o+0]+=f[0],t.vertexAttributes.normal[3*o+1]+=f[1],t.vertexAttributes.normal[3*o+2]+=f[2],t.vertexAttributes.normal[3*a+0]+=f[0],t.vertexAttributes.normal[3*a+1]+=f[1],t.vertexAttributes.normal[3*a+2]+=f[2]}for(let r=0;r<t.vertexAttributes.normal.length;r+=3)i.set(v,t.vertexAttributes.normal[r],t.vertexAttributes.normal[r+1],t.vertexAttributes.normal[r+2]),i.normalize(v,v),t.vertexAttributes.normal[r+0]=v[0],t.vertexAttributes.normal[r+1]=v[1],t.vertexAttributes.normal[r+2]=v[2]}function x(t){if(s.isSome(t.transform))return t.transform.getOriginPoint(t.spatialReference);const e=t.extent.xmax-t.extent.width/2,r=t.extent.ymax-t.extent.height/2,i=t.extent.zmin;return new o({x:e,y:r,z:i,spatialReference:t.extent.spatialReference})}const m=n.create(),b=n.create(),l=n.create(),v=n.create();t.computeOrigin=x,t.smoothNormalsMesh=a,Object.defineProperty(t,"__esModule",{value:!0})}));
