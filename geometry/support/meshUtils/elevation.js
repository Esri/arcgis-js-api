/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import"../../../geometry.js";import e from"../../../Ground.js";import t from"../../../core/Logger.js";import{unwrapOr as o}from"../../../core/maybe.js";import{eachAlways as r}from"../../../core/promiseUtils.js";import{getMetersPerUnitForSR as n}from"../../../core/unitUtils.js";import i from"../../Mesh.js";import{project as a}from"../../projection.js";import s from"../MeshComponent.js";import{MeshVertexAttributes as l}from"../MeshVertexAttributes.js";import m from"../../Point.js";const c=t.getLogger("esri.geometry.support.meshUtils.elevation");async function p(t,o,r){let n;if(d(t)||t instanceof e){const e=await f(t);return n=await e.createElevationSampler(o,{demResolution:r?.demResolution??"finest-contiguous"}),u(n,o,{material:r?.material})}return"string"==typeof r?.demResolution?(c.error("create()","demResolution must be a number when used directly with a sampler"),null):u(t,o,{material:r?.material,demResolution:r?.demResolution})}function u(e,t,r){const m=n(t.spatialReference),c=(r.demResolution??e.demResolution.min)/m,p=Math.round(t.width/c),u=Math.round(t.height/c),f=p+1,d=u+1,h=new Float64Array(f*d*3),R=new Float32Array(f*d*2);let w=0,g=0;const j=new Uint32Array(p*u*2*3);let v=0,A=0;const b=!e.spatialReference.equals(t.spatialReference);y.spatialReference=t.spatialReference;const{xmin:x,ymin:M,height:U,width:F}=t;for(let n=0;n<d;n++){const t=M+U*(n/u);for(let r=0;r<f;r++){const i=x+F*(r/p);if(h[w++]=i,h[w++]=t,b){y.x=i,y.y=t;const r=a(y,e.spatialReference);h[w++]=o(e.elevationAt(r.x,r.y),0)}else h[w++]=o(e.elevationAt(i,t),0);const s=r/p,l=n/u;R[g++]=s,R[g++]=l,n!==u&&r!==p&&(j[A++]=v+1,j[A++]=v+f+1,j[A++]=v+f,j[A++]=v,j[A++]=v+1,j[A++]=v+f),v++}}return new i({vertexAttributes:new l({position:h,uv:R}),components:[new s({faces:j,shading:"smooth",material:r?.material??null})],spatialReference:t.spatialReference})}async function f(e){return d(e)?e.load():(await e.load(),await r(e.layers.map((e=>e.load()))),e)}function d(e){return"type"in e&&("elevation"===e.type||"base-elevation"===e.type)}const y=new m;export{p as create};
