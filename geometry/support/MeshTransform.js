/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../core/JSONSupport","../../core/maybe","../../core/accessorSupport/decorators/property","../../core/has","../../core/accessorSupport/ensureType","../../core/Logger","../../core/accessorSupport/decorators/subclass","../../chunks/mat4","../../chunks/mat4f64","../../chunks/vec3","../../chunks/vec3f64","../Point","../projection","../projectionEllipsoid","./axisAngleDegrees","./buffer/BufferView","../../chunks/vec32","../../chunks/vec33"],(function(e,r,t,o,n,a,i,c,s,l,p,u,h,f,g,y,d,m,_,v){"use strict";var x;let M=x=function(r){function t(e){var t;return(t=r.call(this,e)||this).origin=h.create(),t.translation=h.create(),t.rotation=d.create(),t.scale=h.fromValues(1,1,1),t.geographic=!0,t}e._inheritsLoose(t,r);var n=t.prototype;return n.applyLocal=function(e,r){return u.transformMat4(r,e,this.localMatrix)},n.applyLocalInverse=function(e,r){return u.transformMat4(r,e,this.localMatrixInverse)},n.project=function(e,r){const t=new Float64Array(e.length),o=m.BufferViewVec3f64.fromTypedArray(t),n=m.BufferViewVec3f64.fromTypedArray(e);if(this.geographic){const e=y.getSphericalPCPFForEllipsoid(y.getReferenceEllipsoid(r)),a=p.create();return g.computeLinearTransformation(r,this.origin,a,e),l.multiply(a,a,this.localMatrix),_.transformMat4(o,n,a),g.projectBuffer(t,e,0,t,r,0,t.length/3),t}const{localMatrix:a,origin:i}=this;l.equals(a,p.IDENTITY)?v.copy(o,n):_.transformMat4(o,n,a);for(let c=0;c<t.length;c+=3)t[c+0]+=i[0],t[c+1]+=i[1],t[c+2]+=i[2];return t},n.getOriginPoint=function(e){const[r,t,o]=this.origin;return new f({x:r,y:t,z:o,spatialReference:e})},n.equals=function(e){return o.isSome(e)&&this.geographic===e.geographic&&u.exactEquals(this.origin,e.origin)&&l.exactEquals(this.localMatrix,e.localMatrix)},n.clone=function(){const e={origin:h.clone(this.origin),translation:h.clone(this.translation),rotation:d.create(this.rotation),scale:h.clone(this.scale),geographic:this.geographic};return new x(e)},e._createClass(t,[{key:"localMatrix",get:function(){const e=p.create();return l.scale(e,e,this.scale),l.rotate(e,e,d.angleRad(this.rotation),d.axis(this.rotation)),l.translate(e,e,this.translation),e}},{key:"localMatrixInverse",get:function(){return l.invert(p.create(),this.localMatrix)}}]),t}(t.JSONSupport);return r.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],M.prototype,"origin",void 0),r.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],M.prototype,"translation",void 0),r.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],M.prototype,"rotation",void 0),r.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],M.prototype,"scale",void 0),r.__decorate([n.property({type:Boolean,nonNullable:!0,json:{write:!0}})],M.prototype,"geographic",void 0),r.__decorate([n.property()],M.prototype,"localMatrix",null),r.__decorate([n.property()],M.prototype,"localMatrixInverse",null),M=x=r.__decorate([s.subclass("esri.geometry.support.MeshTransform")],M),M}));
