/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../core/JSONSupport","../../core/maybe","../../core/accessorSupport/decorators/property","../../core/arrayUtils","../../core/accessorSupport/ensureType","../../core/accessorSupport/decorators/subclass","../../chunks/mat4","../../chunks/mat4f64","../../chunks/quat","../../chunks/quatf64","../../chunks/vec3","../../chunks/vec3f64","../Point","../projection","../projectionEllipsoid","./axisAngleDegrees","./buffer/BufferView","../../chunks/vec32","../../chunks/vec33"],(function(t,e,r,o,n,a,i,c,s,l,p,u,h,f,g,y,d,m,_,v,x){"use strict";var M;let b=M=function(e){function r(t){var r;return(r=e.call(this,t)||this).origin=f.create(),r.translation=f.create(),r.rotation=m.create(),r.scale=f.fromValues(1,1,1),r.geographic=!0,r}t._inheritsLoose(r,e);var n=r.prototype;return n.applyLocal=function(t,e){return h.transformMat4(e,t,this.localMatrix)},n.applyLocalInverse=function(t,e){return h.transformMat4(e,t,this.localMatrixInverse)},n.project=function(t,e){const r=new Float64Array(t.length),o=_.BufferViewVec3f64.fromTypedArray(r),n=_.BufferViewVec3f64.fromTypedArray(t);if(this.geographic){const t=d.getSphericalPCPF(e),a=l.create();return y.computeTranslationToOriginAndRotation(e,this.origin,a,t),s.multiply(a,a,this.localMatrix),v.transformMat4(o,n,a),y.projectBuffer(r,t,0,r,e,0,r.length/3),r}const{localMatrix:a,origin:i}=this;s.equals(a,l.IDENTITY)?x.copy(o,n):v.transformMat4(o,n,a);for(let c=0;c<r.length;c+=3)r[c+0]+=i[0],r[c+1]+=i[1],r[c+2]+=i[2];return r},n.getOriginPoint=function(t){const[e,r,o]=this.origin;return new g({x:e,y:r,z:o,spatialReference:t})},n.equals=function(t){return o.isSome(t)&&this.geographic===t.geographic&&h.exactEquals(this.origin,t.origin)&&s.exactEquals(this.localMatrix,t.localMatrix)},n.clone=function(){const t={origin:f.clone(this.origin),translation:f.clone(this.translation),rotation:m.create(this.rotation),scale:f.clone(this.scale),geographic:this.geographic};return new M(t)},t._createClass(r,[{key:"localMatrix",get:function(){const t=l.create();return p.setAxisAngle(k,m.axis(this.rotation),m.angleRad(this.rotation)),s.fromRotationTranslationScale(t,k,this.translation,this.scale),t}},{key:"localMatrixInverse",get:function(){return s.invert(l.create(),this.localMatrix)}}]),r}(r.JSONSupport);e.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],b.prototype,"origin",void 0),e.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],b.prototype,"translation",void 0),e.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],b.prototype,"rotation",void 0),e.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],b.prototype,"scale",void 0),e.__decorate([n.property({type:Boolean,nonNullable:!0,json:{write:!0}})],b.prototype,"geographic",void 0),e.__decorate([n.property()],b.prototype,"localMatrix",null),e.__decorate([n.property()],b.prototype,"localMatrixInverse",null),b=M=e.__decorate([c.subclass("esri.geometry.support.MeshTransform")],b);const k=u.create();return b}));
