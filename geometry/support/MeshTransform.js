/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../core/JSONSupport","../../core/maybe","../../core/accessorSupport/decorators/property","../../core/arrayUtils","../../core/has","../../core/accessorSupport/ensureType","../../core/accessorSupport/decorators/subclass","../../chunks/mat4","../../chunks/mat4f64","../../chunks/vec3","../../chunks/vec3f64","../Point","../projection","../projectionEllipsoid","./axisAngleDegrees","./buffer/BufferView","../../chunks/vec32","../../chunks/vec33"],(function(e,t,r,o,n,a,i,c,s,l,p,u,h,f,g,y,d,m,_,v){"use strict";var x;let M=x=function(t){function r(e){var r;return(r=t.call(this,e)||this).origin=h.create(),r.translation=h.create(),r.rotation=d.create(),r.scale=h.fromValues(1,1,1),r.geographic=!0,r}e._inheritsLoose(r,t);var n=r.prototype;return n.applyLocal=function(e,t){return u.transformMat4(t,e,this.localMatrix)},n.applyLocalInverse=function(e,t){return u.transformMat4(t,e,this.localMatrixInverse)},n.project=function(e,t){const r=new Float64Array(e.length),o=m.BufferViewVec3f64.fromTypedArray(r),n=m.BufferViewVec3f64.fromTypedArray(e);if(this.geographic){const e=y.getSphericalPCPF(t),a=p.create();return g.computeTranslationToOriginAndRotation(t,this.origin,a,e),l.multiply(a,a,this.localMatrix),_.transformMat4(o,n,a),g.projectBuffer(r,e,0,r,t,0,r.length/3),r}const{localMatrix:a,origin:i}=this;l.equals(a,p.IDENTITY)?v.copy(o,n):_.transformMat4(o,n,a);for(let c=0;c<r.length;c+=3)r[c+0]+=i[0],r[c+1]+=i[1],r[c+2]+=i[2];return r},n.getOriginPoint=function(e){const[t,r,o]=this.origin;return new f({x:t,y:r,z:o,spatialReference:e})},n.equals=function(e){return o.isSome(e)&&this.geographic===e.geographic&&u.exactEquals(this.origin,e.origin)&&l.exactEquals(this.localMatrix,e.localMatrix)},n.clone=function(){const e={origin:h.clone(this.origin),translation:h.clone(this.translation),rotation:d.create(this.rotation),scale:h.clone(this.scale),geographic:this.geographic};return new x(e)},e._createClass(r,[{key:"localMatrix",get:function(){const e=p.create();return l.fromScaling(e,this.scale),l.rotate(e,e,d.angleRad(this.rotation),d.axis(this.rotation)),l.translate(e,e,this.translation),e}},{key:"localMatrixInverse",get:function(){return l.invert(p.create(),this.localMatrix)}}]),r}(r.JSONSupport);t.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],M.prototype,"origin",void 0),t.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],M.prototype,"translation",void 0),t.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],M.prototype,"rotation",void 0),t.__decorate([n.property({type:[Number],nonNullable:!0,json:{write:!0}})],M.prototype,"scale",void 0),t.__decorate([n.property({type:Boolean,nonNullable:!0,json:{write:!0}})],M.prototype,"geographic",void 0),t.__decorate([n.property()],M.prototype,"localMatrix",null),t.__decorate([n.property()],M.prototype,"localMatrixInverse",null),M=x=t.__decorate([s.subclass("esri.geometry.support.MeshTransform")],M);return M}));
