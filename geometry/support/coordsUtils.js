/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
define(["exports","../../core/arrayUtils","./spatialReferenceUtils"],(function(n,t,e){"use strict";function r(n){if(!n)return null;if(Array.isArray(n))return n;const t=n.hasZ,e=n.hasM;if("point"===n.type)return e&&t?[n.x,n.y,n.z,n.m]:t?[n.x,n.y,n.z]:e?[n.x,n.y,n.m]:[n.x,n.y];if("polygon"===n.type)return n.rings.slice(0);if("polyline"===n.type)return n.paths.slice(0);if("multipoint"===n.type)return n.points.slice(0);if("extent"===n.type){const t=n.clone().normalize();if(!t)return null;let e=!1,r=!1;return t.forEach((n=>{n.hasZ&&(e=!0),n.hasM&&(r=!0)})),t.map((n=>{const t=[[n.xmin,n.ymin],[n.xmin,n.ymax],[n.xmax,n.ymax],[n.xmax,n.ymin],[n.xmin,n.ymin]];if(e&&n.hasZ){const e=.5*(n.zmax-n.zmin);for(let n=0;n<t.length;n++)t[n].push(e)}if(r&&n.hasM){const e=.5*(n.mmax-n.mmin);for(let n=0;n<t.length;n++)t[n].push(e)}return t}))}return null}function o(n,t){const e=t[0]-n[0],r=t[1]-n[1];if(n.length>2&&t.length>2){const o=n[2]-t[2];return Math.sqrt(e*e+r*r+o*o)}return Math.sqrt(e*e+r*r)}function i(n,t,e){const r=n[0]+e*(t[0]-n[0]),o=n[1]+e*(t[1]-n[1]);return n.length>2&&t.length>2?[r,o,n[2]+e*(t[2]-n[2])]:[r,o]}function s(n,t,e,r){const[o,i]=t,[s,l]=e[r],[c,u]=e[r+1],f=c-s,a=u-l,g=f*f+a*a,h=(o-s)*f+(i-l)*a,m=Math.min(1,Math.max(0,h/g));return n[0]=s+f*m,n[1]=l+a*m,n}function l(n,t,e){const r=e.rings;let o,i,s=!1,l=1/0;for(let u=0;u<r.length;u++){const e=r[u];for(let r=0,u=e.length-1;r<e.length;u=r++)o=e[r],i=e[u],o[1]>t!=i[1]>t&&n<(i[0]-o[0])*(t-o[1])/(i[1]-o[1])+o[0]&&(s=!s),l=Math.min(l,c(n,t,o,i))}return 0===l?0:(s?1:-1)*Math.sqrt(l)}function c(n,t,e,r){let o=e[0],i=e[1],s=r[0]-o,l=r[1]-i;if(0!==s||0!==l){const e=((n-o)*s+(t-i)*l)/(s*s+l*l);e>1?(o=r[0],i=r[1]):e>0&&(o+=s*e,i+=l*e)}return s=n-o,l=t-i,s*s+l*l}function u(n,t){return i(n,t,.5)}function f(n){const t=n.length;let e=0;for(let r=0;r<t-1;++r)e+=o(n[r],n[r+1]);return e}function a(n,t){if(t<=0)return n[0];const e=n.length;let r=0;for(let s=0;s<e-1;++s){const e=o(n[s],n[s+1]);if(t-r<e){const o=(t-r)/e;return i(n[s],n[s+1],o)}r+=e}return n[e-1]}function g(n,t,e){const r=n.length;let o=0,i=0,s=0;for(let l=0;l<r;l++){const c=n[l],u=n[(l+1)%r];let f=2;o+=c[0]*u[1]-u[0]*c[1],c.length>2&&u.length>2&&e&&(i+=c[0]*u[2]-u[0]*c[2],f=3),c.length>f&&u.length>f&&t&&(s+=c[0]*u[f]-u[0]*c[f])}return o<=0&&i<=0&&s<=0}function h(n){const e=n.length;return e>2&&t.equals(n[0],n[e-1])}function m(n){if("rings"in n&&(y(n),n.rings.length>0&&!g(n.rings[0],n.hasM??!1,n.hasZ??!1)))for(const t of n.rings)t.reverse()}function y(n){if("rings"in n)for(const t of n.rings)h(t)||t.push(t[0].slice())}function p(n){if("polygon"!==n.type&&"polyline"!==n.type)return n;return x("polygon"===n.type?n.rings:n.paths,n.spatialReference),n}function x(n,t){const r=e.getInfo(t);if(!r)return;const o=r.valid[0],i=r.valid[1],s=i-o;for(const e of n){let n=1/0,t=-1/0;for(const s of e){const e=d(s[0],o,i);n=Math.min(n,e),t=Math.max(t,e),s[0]=e}const r=t-n;s-r<r&&e.forEach((n=>{n[0]<0&&(n[0]+=s)}))}}function d(n,t,e){const r=e-t;return n<t?e-(t-n)%r:n>e?t+(n-t)%r:n}function M(n){if(!n||n.length<3)return 0;let t=0;const e=n.length-1;for(let r=0;r<e;r++)t+=(n[r][0]-n[r+1][0])*(n[r][1]+n[r+1][1]);return t+=(n[e][0]-n[0][0])*(n[e][1]+n[0][1]),-.5*t}n.closeRings=y,n.closeRingsAndFixWinding=m,n.distanceFromPointToPolygon=l,n.distanceToSegmentSquared=c,n.geometryToCoordinates=r,n.getLength=o,n.getMidpoint=u,n.getPathLength=f,n.getPointOnPath=a,n.getRingArea=M,n.isClockwise=g,n.isClosed=h,n.projectPointOnLine=s,n.unnormalizeGeometryOnDatelineCrossing=p,n.unnormalizeVerticesOnDatelineCrossing=x,n.unnormalizedCoordinate=d,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
