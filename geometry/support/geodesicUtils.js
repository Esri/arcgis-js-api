/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
define(["exports","../../core/Error","../SpatialReference","../Point","../Polygon","../Polyline","../../geometry","../../core/unitUtils","./geodesicConstants"],(function(e,t,n,s,i,a,o,r,c){"use strict";function l(e){if(!e)return null;if(e.isGeographic&&e.wkid){const t=c.spheroids[e.wkid];if(t)return t}if(e.wkt){const t=c.WKT_SPHEROID_REGEX.exec(e.wkt);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),i=parseFloat(n[2]);if(isNaN(s)||isNaN(i))return null;return{a:s,f:0===i?0:1/i}}return null}function h(e){const t=l(e||n.WGS84);if(function(e){return"b"in e&&"eSq"in e&&"radius"in e}(t))return t;const s=t.a*(1-t.f);return Object.assign(t,{b:s,eSq:1-(s/t.a)**2,radius:(2*t.a+s)/3,densificationRatio:1e4/((2*t.a+s)/3)})}function p(e,t,n){const{a:s,eSq:i}=h(n),a=Math.sqrt(i),o=Math.sin(t[1]*c.toRadians),r=s*t[0]*c.toRadians;let l;if(i>0){l=s*((1-i)*(o/(1-i*(o*o))-1/(2*a)*Math.log((1-a*o)/(1+a*o))))*.5}else l=s*o;return e[0]=r,e[1]=l,e}function f(e){return null!==l(e)}function u(e,n){if("polyline"!==e.type&&"polygon"!==e.type)throw new t("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:s}=e;if(!f(s))throw new t("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const{radius:o}=h(s),r=o/1e4;n<r&&(n=r);const c="polyline"===e.type?e.paths:e.rings,l=[],p=[0,0],u={distance:null};for(const e of c){const t=[];l.push(t),t.push([e[0][0],e[0][1]]);let i,a,o=e[0][0],r=e[0][1];for(let c=0;c<e.length-1;c++){if(i=e[c+1][0],a=e[c+1][1],o===i&&r===a)continue;const l=[o,r];g(u,[o,r],[i,a],s);const{azimuth:h,distance:f}=u,M=f/n;if(M>1){for(let e=1;e<=M-1;e++){d(p,l,h,e*n,s),t.push(p.slice(0))}d(p,l,h,(f+Math.floor(M-1)*n)/2,s),t.push(p.slice(0))}d(p,l,h,f,s),t.push(p.slice(0)),o=p[0],r=p[1]}}return"polyline"===e.type?new a({paths:l,spatialReference:s}):new i({rings:l,spatialReference:s})}function d(e,t,n,s,i){const a=t[0],o=t[1],r=a*c.toRadians,l=o*c.toRadians,p=n*c.toRadians,{a:f,b:u,f:d}=h(i),g=Math.sin(p),M=Math.cos(p),m=(1-d)*Math.tan(l),R=1/Math.sqrt(1+m*m),w=m*R,y=Math.atan2(m,M),v=R*g,b=v*v,q=1-b,S=q*(f*f-u*u)/(u*u),z=1+S/16384*(4096+S*(S*(320-175*S)-768)),x=S/1024*(256+S*(S*(74-47*S)-128));let N,P,G,k,D=s/(u*z),E=2*Math.PI;for(;Math.abs(D-E)>1e-12;)G=Math.cos(2*y+D),N=Math.sin(D),P=Math.cos(D),k=x*N*(G+x/4*(P*(2*G*G-1)-x/6*G*(4*N*N-3)*(4*G*G-3))),E=D,D=s/(u*z)+k;const U=w*N-R*P*M,_=Math.atan2(w*P+R*N*M,(1-d)*Math.sqrt(b+U*U)),A=d/16*q*(4+d*(4-3*q)),F=Math.atan2(N*g,R*P-w*N*M)-(1-A)*d*v*(D+A*N*(G+A*P*(2*G*G-1))),O=_/c.toRadians,j=(r+F)/c.toRadians;return e.splice(0,e.length),e.push(j,O),e}function g(e,t,n,s){const i=t[0]*c.toRadians,a=t[1]*c.toRadians,o=n[0]*c.toRadians,r=n[1]*c.toRadians,{a:l,b:p,f:f,radius:u}=h(s),d=o-i,g=Math.atan((1-f)*Math.tan(a)),M=Math.atan((1-f)*Math.tan(r)),m=Math.sin(g),R=Math.cos(g),w=Math.sin(M),y=Math.cos(M);let v,b,q,S,z,x,N,P,G,k,D=1e3,E=d;do{if(N=Math.sin(E),P=Math.cos(E),q=Math.sqrt(y*N*(y*N)+(R*w-m*y*P)*(R*w-m*y*P)),0===q)return{distance:0};z=m*w+R*y*P,x=Math.atan2(q,z),G=R*y*N/q,b=1-G*G,S=z-2*m*w/b,isNaN(S)&&(S=0),k=f/16*b*(4+f*(4-3*b)),v=E,E=d+(1-k)*f*G*(x+k*q*(S+k*z*(2*S*S-1)))}while(Math.abs(E-v)>1e-12&&--D>0);if(0===D){const e=u,t=Math.acos(Math.sin(a)*Math.sin(r)+Math.cos(a)*Math.cos(r)*Math.cos(o-i))*e,n=o-i,s=Math.sin(n)*Math.cos(r),l=Math.cos(a)*Math.sin(r)-Math.sin(a)*Math.cos(r)*Math.cos(n);return{azimuth:Math.atan2(s,l)/c.toRadians,distance:t}}const U=b*(l*l-p*p)/(p*p),_=U/1024*(256+U*(U*(74-47*U)-128)),A=p*(1+U/16384*(4096+U*(U*(320-175*U)-768)))*(x-_*q*(S+_/4*(z*(2*S*S-1)-_/6*S*(4*q*q-3)*(4*S*S-3)))),F=Math.atan2(y*Math.sin(E),R*w-m*y*Math.cos(E)),O=Math.atan2(R*Math.sin(E),R*w*Math.cos(E)-m*y);return e.azimuth=F/c.toRadians,e.distance=A,e.reverseAzimuth=O/c.toRadians,e}e.directGeodeticSolver=d,e.geodesicAreas=function(e,n="square-meters"){if(e.some((e=>!f(e.spatialReference))))throw new t("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const s=[];for(let t=0;t<e.length;t++){const n=e[t],i=n.spatialReference,{radius:a,densificationRatio:o}=h(i),r=a*o;s.push(u(n,r))}const i=[],a=[0,0],o=[0,0];for(let e=0;e<s.length;e++){const{rings:t,spatialReference:c}=s[e];let l=0;for(let e=0;e<t.length;e++){const n=t[e];p(a,n[0],c),p(o,n[n.length-1],c);let s=o[0]*a[1]-a[0]*o[1];for(let e=0;e<n.length-1;e++)p(a,n[e+1],c),p(o,n[e],c),s+=o[0]*a[1]-a[0]*o[1];l+=s}l=r.convertUnit(l,"square-meters",n),i.push(l/-2)}return i},e.geodesicDensify=u,e.geodesicDistance=function(e,n,s="meters"){if(!e||!n)throw new t("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!n.spatialReference)throw new t("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!e.spatialReference.equals(n.spatialReference))throw new t("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:i}=e;if(!f(i))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.equals(n))return{distance:0,azimuth:0,reverseAzimuth:0};const a={distance:null};return g(a,[e.x,e.y],[n.x,n.y],i),a.distance=r.convertUnit(a.distance,"meters",s),a},e.geodesicLengths=function(e,n="meters"){const s=e,i=e;if(!s&&!i)throw new t("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(s?s.some((e=>!f(e.spatialReference))):i.some((e=>!f(e.spatialReference))))throw new t("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const a=[];for(let t=0;t<e.length;t++){const s=e[t],{spatialReference:i}=s,o="polyline"===s.type?s.paths:s.rings;let c=0;for(let e=0;e<o.length;e++){const t=o[e];let n=0;for(let e=1;e<t.length;e++){const s=t[e-1][0],a=t[e][0],o=t[e-1][1],r=t[e][1];if(o!==r||s!==a){const e={distance:null};g(e,[s,o],[a,r],i),n+=e.distance}}c+=n}c=r.convertUnit(c,"meters",n),a.push(c)}return a},e.inverseGeodeticSolver=g,e.isSupported=f,e.pointFromDistance=function(e,n,i){if(!e||null==n||null==i)throw new t("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(i<0||i>360)throw new t("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!e.spatialReference)throw new t("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:a}=e;if(!f(a))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");const o=[0,0];return d(o,[e.x,e.y],i,n,a),new s({x:o[0],y:o[1],spatialReference:a})},Object.defineProperty(e,"__esModule",{value:!0})}));
