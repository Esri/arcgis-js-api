/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["exports","../../core/Error","../SpatialReference","../Point","../Polygon","../Polyline","../../geometry","../../core/unitUtils","./geodesicConstants"],(function(e,t,n,i,s,a,o,r,c){"use strict";function l(e){if(!e)return null;if(e.isGeographic&&e.wkid){const t=c.spheroids[e.wkid];if(t)return t}if(e.wkt){const t=c.WKT_SPHEROID_REGEX.exec(e.wkt);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const i=parseFloat(n[1]),s=parseFloat(n[2]);if(isNaN(i)||isNaN(s))return null;return{a:i,f:0===s?0:1/s}}return null}function h(e){return"b"in e&&"eSq"in e&&"radius"in e}function p(e){const t=l(e||n.WGS84);if(h(t))return t;const i=t.a*(1-t.f);return Object.assign(t,{b:i,eSq:1-(i/t.a)**2,radius:(2*t.a+i)/3,densificationRatio:1e4/((2*t.a+i)/3)})}function u(e,t,n){const{a:i,eSq:s}=p(n),a=Math.sqrt(s),o=Math.sin(t[1]*c.toRadians),r=i*t[0]*c.toRadians;let l;if(s>0){l=i*((1-s)*(o/(1-s*(o*o))-1/(2*a)*Math.log((1-a*o)/(1+a*o))))*.5}else l=i*o;return e[0]=r,e[1]=l,e}function f(e){return null!==l(e)}function d(e,n="square-meters"){if(e.some((e=>!f(e.spatialReference))))throw new t("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const i=[];for(let t=0;t<e.length;t++){const n=e[t],s=n.spatialReference,{radius:a,densificationRatio:o}=p(s),r=a*o;i.push(M(n,r))}const s=[],a=[0,0],o=[0,0];for(let t=0;t<i.length;t++){const{rings:e,spatialReference:c}=i[t];let l=0;for(let t=0;t<e.length;t++){const n=e[t];u(a,n[0],c),u(o,n[n.length-1],c);let i=o[0]*a[1]-a[0]*o[1];for(let e=0;e<n.length-1;e++)u(a,n[e+1],c),u(o,n[e],c),i+=o[0]*a[1]-a[0]*o[1];l+=i}l=r.convertUnit(l,"square-meters",n),s.push(l/-2)}return s}function g(e,n="meters"){const i=e,s=e;if(!i&&!s)throw new t("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(i?i.some((e=>!f(e.spatialReference))):s.some((e=>!f(e.spatialReference))))throw new t("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const a=[];for(let t=0;t<e.length;t++){const i=e[t],{spatialReference:s}=i,o="polyline"===i.type?i.paths:i.rings;let c=0;for(let e=0;e<o.length;e++){const t=o[e];let n=0;for(let e=1;e<t.length;e++){const i=t[e-1][0],a=t[e][0],o=t[e-1][1],r=t[e][1];if(o!==r||i!==a){const e={distance:null};R(e,[i,o],[a,r],s),n+=e.distance}}c+=n}c=r.convertUnit(c,"meters",n),a.push(c)}return a}function M(e,n){if("polyline"!==e.type&&"polygon"!==e.type)throw new t("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:i}=e;if(!f(i))throw new t("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const o="polyline"===e.type?e.paths:e.rings,r=[],c=[0,0],l={distance:null};for(const t of o){const e=[];r.push(e),e.push([t[0][0],t[0][1]]);let s,a,o=t[0][0],h=t[0][1];for(let r=0;r<t.length-1;r++){if(s=t[r+1][0],a=t[r+1][1],o===s&&h===a)continue;const p=[o,h];R(l,[o,h],[s,a],i);const{azimuth:u,distance:f}=l,d=f/n;if(d>1){for(let t=1;t<=d-1;t++){m(c,p,u,t*n,i),e.push(c.slice(0))}m(c,p,u,(f+Math.floor(d-1)*n)/2,i),e.push(c.slice(0))}m(c,p,u,f,i),e.push(c.slice(0)),o=c[0],h=c[1]}}return"polyline"===e.type?new a({paths:r,spatialReference:i}):new s({rings:r,spatialReference:i})}function m(e,t,n,i,s){const a=t[0],o=t[1],r=a*c.toRadians,l=o*c.toRadians,h=n*c.toRadians,{a:u,b:f,f:d}=p(s),g=Math.sin(h),M=Math.cos(h),m=(1-d)*Math.tan(l),R=1/Math.sqrt(1+m*m),w=m*R,y=Math.atan2(m,M),v=R*g,b=v*v,q=1-b,z=q*(u*u-f*f)/(f*f),S=1+z/16384*(4096+z*(z*(320-175*z)-768)),x=z/1024*(256+z*(z*(74-47*z)-128));let N,P,A,G,k=i/(f*S),D=2*Math.PI;for(;Math.abs(k-D)>1e-12;)A=Math.cos(2*y+k),N=Math.sin(k),P=Math.cos(k),G=x*N*(A+x/4*(P*(2*A*A-1)-x/6*A*(4*N*N-3)*(4*A*A-3))),D=k,k=i/(f*S)+G;const E=w*N-R*P*M,U=Math.atan2(w*P+R*N*M,(1-d)*Math.sqrt(b+E*E)),_=d/16*q*(4+d*(4-3*q)),F=Math.atan2(N*g,R*P-w*N*M)-(1-_)*d*v*(k+_*N*(A+_*P*(2*A*A-1))),O=U/c.toRadians,j=(r+F)/c.toRadians;return e[0]=j,e[1]=O,e}function R(e,t,n,i){const s=t[0]*c.toRadians,a=t[1]*c.toRadians,o=n[0]*c.toRadians,r=n[1]*c.toRadians,{a:l,b:h,f:u,radius:f}=p(i),d=o-s,g=Math.atan((1-u)*Math.tan(a)),M=Math.atan((1-u)*Math.tan(r)),m=Math.sin(g),R=Math.cos(g),w=Math.sin(M),y=Math.cos(M);let v,b,q,z,S,x,N,P,A,G,k=1e3,D=d;do{if(N=Math.sin(D),P=Math.cos(D),q=Math.sqrt(y*N*(y*N)+(R*w-m*y*P)*(R*w-m*y*P)),0===q)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;S=m*w+R*y*P,x=Math.atan2(q,S),A=R*y*N/q,b=1-A*A,z=S-2*m*w/b,isNaN(z)&&(z=0),G=u/16*b*(4+u*(4-3*b)),v=D,D=d+(1-G)*u*A*(x+G*q*(z+G*S*(2*z*z-1)))}while(Math.abs(D-v)>1e-12&&--k>0);if(0===k){const t=f,n=Math.acos(Math.sin(a)*Math.sin(r)+Math.cos(a)*Math.cos(r)*Math.cos(o-s))*t,i=o-s,l=Math.sin(i)*Math.cos(r),h=Math.cos(a)*Math.sin(r)-Math.sin(a)*Math.cos(r)*Math.cos(i),p=Math.atan2(l,h);return e.azimuth=p/c.toRadians,e.distance=n,e.reverseAzimuth=void 0,e}const E=b*(l*l-h*h)/(h*h),U=E/1024*(256+E*(E*(74-47*E)-128)),_=h*(1+E/16384*(4096+E*(E*(320-175*E)-768)))*(x-U*q*(z+U/4*(S*(2*z*z-1)-U/6*z*(4*q*q-3)*(4*z*z-3)))),F=Math.atan2(y*Math.sin(D),R*w-m*y*Math.cos(D)),O=Math.atan2(R*Math.sin(D),R*w*Math.cos(D)-m*y);return e.azimuth=F/c.toRadians,e.distance=_,e.reverseAzimuth=O/c.toRadians,e}function w(e,n,i="meters"){if(!e||!n)throw new t("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!n.spatialReference)throw new t("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!e.spatialReference.equals(n.spatialReference))throw new t("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:s}=e;if(!f(s))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.equals(n))return{distance:0,azimuth:0,reverseAzimuth:0};const a={distance:null};return R(a,[e.x,e.y],[n.x,n.y],s),a.distance=r.convertUnit(a.distance,"meters",i),a}function y(e,n,s){if(!e||null==n||null==s)throw new t("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(s<0||s>360)throw new t("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!e.spatialReference)throw new t("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:a}=e;if(!f(a))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");const o=[0,0];return m(o,[e.x,e.y],s,n,a),new i({x:o[0],y:o[1],spatialReference:a})}e.directGeodeticSolver=m,e.geodesicAreas=d,e.geodesicDensify=M,e.geodesicDistance=w,e.geodesicLengths=g,e.inverseGeodeticSolver=R,e.isSupported=f,e.pointFromDistance=y,Object.defineProperty(e,"__esModule",{value:!0})}));
