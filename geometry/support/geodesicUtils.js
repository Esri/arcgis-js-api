// COPYRIGHT © 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.17/esri/copyright.txt for details.

define(["require","exports","@dojo/framework/shim/object","../.","../../core/Error","../../core/unitUtils","./geodesicConstants"],(function(e,t,a,n,i,r,s){"use strict";function o(e){if(!e||!e.isGeographic)return null;if(e.wkid){var t=s.spheroids[e.wkid];if(t)return t}if(e.wkt){var a=s.WKT_SPHEROID_REGEX.exec(e.wkt);if(!a||2!==a.length)return null;var n=a[1].split(",");if(!n||3!==n.length)return null;var i=parseFloat(n[1]),r=parseFloat(n[2]);return isNaN(i)||isNaN(r)?null:{a:i,f:0===r?0:1/r}}return null}function c(e){var t=o(e||n.SpatialReference.WGS84);if(function(e){return"b"in e&&"eSq"in e&&"radius"in e}(t))return t;var i=t.a*(1-t.f);return a.assign(t,{b:i,eSq:1-Math.pow(i/t.a,2),radius:(2*t.a+i)/3})}function h(e,t,a){var n,i=c(a),r=i.a,o=i.eSq,h=Math.sqrt(o),l=Math.sin(t[1]*s.toRadians),p=r*t[0]*s.toRadians;o>0?n=r*((1-o)*(l/(1-o*(l*l))-1/(2*h)*Math.log((1-h*l)/(1+h*l))))*.5:n=r*l;return e[0]=p,e[1]=n,e}function l(e){return null!==o(e)}function p(e,t){if("polyline"!==e.type&&"polygon"!==e.type)throw new i("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");var a=e.spatialReference;if(!l(a))throw new i("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");var r=c(a).radius/1e4;t<r&&(t=r);for(var s=[],o=[0,0],h={distance:null},p=0,f="polyline"===e.type?e.paths:e.rings;p<f.length;p++){var g=f[p],v=[];s.push(v),v.push([g[0][0],g[0][1]]);for(var M=g[0][0],m=g[0][1],w=void 0,R=void 0,y=0;y<g.length-1;y++)if(w=g[y+1][0],R=g[y+1][1],M!==w||m!==R){var b=[M,m];d(h,[M,m],[w,R],a);var q=h.azimuth,S=h.distance,z=S/t;if(z>1){for(var D=1;D<=z-1;D++){u(o,b,q,D*t,a),v.push(o.slice(0))}u(o,b,q,(S+Math.floor(z-1)*t)/2,a),v.push(o.slice(0))}u(o,b,q,S,a),v.push(o.slice(0)),M=o[0],m=o[1]}}return"polyline"===e.type?new n.Polyline({paths:s,spatialReference:a}):new n.Polygon({rings:s,spatialReference:a})}function u(e,t,a,n,i){for(var r,o,h,l=t[0],p=t[1],u=l*s.toRadians,d=p*s.toRadians,f=a*s.toRadians,g=c(i),v=g.a,M=g.b,m=g.f,w=Math.sin(f),R=Math.cos(f),y=(1-m)*Math.tan(d),b=1/Math.sqrt(1+y*y),q=y*b,S=Math.atan2(y,R),z=b*w,D=z*z,G=1-D,x=G*(v*v-M*M)/(M*M),N=1+x/16384*(4096+x*(x*(320-175*x)-768)),P=x/1024*(256+x*(x*(74-47*x)-128)),k=n/(M*N),A=2*Math.PI;Math.abs(k-A)>1e-12;)h=Math.cos(2*S+k),A=k,k=n/(M*N)+P*(r=Math.sin(k))*(h+P/4*((o=Math.cos(k))*(2*h*h-1)-P/6*h*(4*r*r-3)*(4*h*h-3)));var E=q*r-b*o*R,F=Math.atan2(q*o+b*r*R,(1-m)*Math.sqrt(D+E*E)),U=m/16*G*(4+m*(4-3*G)),_=Math.atan2(r*w,b*o-q*r*R)-(1-U)*m*z*(k+U*r*(h+U*o*(2*h*h-1))),j=F/s.toRadians,I=(u+_)/s.toRadians;return e.splice(0,e.length),e.push(I,j),e}function d(e,t,a,n){var i,r,o,h,l,p,u,d,f,g,v=t[0]*s.toRadians,M=t[1]*s.toRadians,m=a[0]*s.toRadians,w=a[1]*s.toRadians,R=c(n),y=R.a,b=R.b,q=R.f,S=R.radius,z=m-v,D=Math.atan((1-q)*Math.tan(M)),G=Math.atan((1-q)*Math.tan(w)),x=Math.sin(D),N=Math.cos(D),P=Math.sin(G),k=Math.cos(G),A=1e3,E=z;do{if(u=Math.sin(E),d=Math.cos(E),0===(o=Math.sqrt(k*u*(k*u)+(N*P-x*k*d)*(N*P-x*k*d))))return{distance:0};l=x*P+N*k*d,p=Math.atan2(o,l),h=l-2*x*P/(r=1-(f=N*k*u/o)*f),isNaN(h)&&(h=0),i=E,E=z+(1-(g=q/16*r*(4+q*(4-3*r))))*q*f*(p+g*o*(h+g*l*(2*h*h-1)))}while(Math.abs(E-i)>1e-12&&--A>0);if(0===A){var F=S,U=Math.acos(Math.sin(M)*Math.sin(w)+Math.cos(M)*Math.cos(w)*Math.cos(m-v))*F,_=m-v,j=Math.sin(_)*Math.cos(w),I=Math.cos(M)*Math.sin(w)-Math.sin(M)*Math.cos(w)*Math.cos(_);return{azimuth:Math.atan2(j,I)/s.toRadians,distance:U}}var L=r*(y*y-b*b)/(b*b),O=L/1024*(256+L*(L*(74-47*L)-128)),W=b*(1+L/16384*(4096+L*(L*(320-175*L)-768)))*(p-O*o*(h+O/4*(l*(2*h*h-1)-O/6*h*(4*o*o-3)*(4*h*h-3)))),C=Math.atan2(k*Math.sin(E),N*P-x*k*Math.cos(E)),H=Math.atan2(N*Math.sin(E),N*P*Math.cos(E)-x*k);return e.azimuth=C/s.toRadians,e.distance=W,e.reverseAzimuth=H/s.toRadians,e}Object.defineProperty(t,"__esModule",{value:!0}),t.pointFromDistance=t.geodesicDistance=t.inverseGeodeticSolver=t.directGeodeticSolver=t.geodesicDensify=t.geodesicLengths=t.geodesicAreas=t.isSupported=void 0,t.isSupported=l,t.geodesicAreas=function(e,t){if(void 0===t&&(t="square-meters"),e.some((function(e){return!l(e.spatialReference)})))throw new i("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");for(var a=[],n=0;n<e.length;n++){var o=e[n],u=c(w=o.spatialReference).radius*s.densificationRatio;a.push(p(o,u))}for(var d=[],f=[0,0],g=[0,0],v=0;v<a.length;v++){for(var M=a[v],m=M.rings,w=M.spatialReference,R=0,y=0;y<m.length;y++){var b=m[y];h(f,b[0],w),h(g,b[b.length-1],w);for(var q=g[0]*f[1]-f[0]*g[1],S=0;S<b.length-1;S++)h(f,b[S+1],w),h(g,b[S],w),q+=g[0]*f[1]-f[0]*g[1];R+=q}R=r.convertUnit(R,"square-meters",t),d.push(R/-2)}return d},t.geodesicLengths=function(e,t){void 0===t&&(t="meters");var a=e,n=e;if(!a&&!n)throw new i("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(a?a.some((function(e){return!l(e.spatialReference)})):n.some((function(e){return!l(e.spatialReference)})))throw new i("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");for(var s=[],o=0;o<e.length;o++){for(var c=e[o],h=c.spatialReference,p="polyline"===c.type?c.paths:c.rings,u=0,f=0;f<p.length;f++){for(var g=p[f],v=0,M=1;M<g.length;M++){var m=g[M-1][0],w=g[M][0],R=g[M-1][1],y=g[M][1];if(R!==y||m!==w){var b={distance:null};d(b,[m,R],[w,y],h),v+=b.distance}}u+=v}u=r.convertUnit(u,"meters",t),s.push(u)}return s},t.geodesicDensify=p,t.directGeodeticSolver=u,t.inverseGeodeticSolver=d,t.geodesicDistance=function(e,t,a){if(void 0===a&&(a="meters"),!e||!t)throw new i("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!t.spatialReference)throw new i("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!e.spatialReference.equals(t.spatialReference))throw new i("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");var n=e.spatialReference;if(!l(n))throw new i("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.equals(t))return{distance:0,azimuth:0,reverseAzimuth:0};var s={distance:null};return d(s,[e.x,e.y],[t.x,t.y],n),s.distance=r.convertUnit(s.distance,"meters",a),s},t.pointFromDistance=function(e,t,a){if(!e||null==t||null==a)throw new i("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(a<0||a>360)throw new i("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!e.spatialReference)throw new i("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");var r=e.spatialReference;if(!l(r))throw new i("geodesic-distance:not-supported","input geometry spatial reference is not supported");var s=[0,0];return u(s,[e.x,e.y],a,t,r),new n.Point({x:s[0],y:s[1],spatialReference:r})}}));