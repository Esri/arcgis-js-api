/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import{convertUnit as r,lengthToDegrees as t}from"../core/unitUtils.js";import{property as s}from"../core/accessorSupport/decorators/property.js";import"../core/arrayUtils.js";import"../core/has.js";import"../core/accessorSupport/ensureType.js";import{subclass as i}from"../core/accessorSupport/decorators/subclass.js";import o from"./Point.js";import c from"./Polygon.js";import{getReferenceEllipsoid as n}from"./projectionEllipsoid.js";import{directGeodeticSolver as a}from"./support/geodesicUtils.js";import{webMercatorToGeographic as p,geographicToWebMercator as l}from"./support/webMercatorUtils.js";import u from"./support/WKIDUnitConversion.js";var d;let h=d=class extends c{constructor(...e){super(...e),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}normalizeCtorArgs(e,r){let t;if(e&&e.center)t=e;else{if(e&&e.rings)return super.normalizeCtorArgs(e,r);t={center:e}}return{...super.normalizeCtorArgs(),...t,...r}}initialize(){const e=this.center,s=this.numberOfPoints;if(this.hasZ=e&&e.hasZ,0!==this.rings.length||!e)return;const i=r(this.radius,this.radiusUnit,"meters"),o=e.spatialReference;let c,a="geographic";if(o.isWebMercator?a="webMercator":(null!=u[o.wkid]||o.wkt&&0===o.wkt.indexOf("PROJCS"))&&(a="projected"),this.geodesic){let r;switch(a){case"webMercator":r=p(e);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":r=e}c=this._createGeodesicCircle(r,i,s),"webMercator"===a&&(c=l(c))}else{let r;"webMercator"===a||"projected"===a?r=i/this._convert2Meters(1,e.spatialReference):"geographic"===a&&(r=t(i,"meters",n(e.spatialReference).radius)),c=this._createPlanarCircle(e,r,s)}this.spatialReference=c.spatialReference,this.addRing(c.rings[0])}clone(){const{center:e,numberOfPoints:r,radius:t,radiusUnit:s,geodesic:i}=this;return new d({center:e.clone(),numberOfPoints:r,radius:t,radiusUnit:s,geodesic:i})}_createGeodesicCircle(e,r,t){let s=0;const i=[];for(;s<360;){const o=[0,0],c=[e.x,e.y];a(o,c,s,r),this.hasZ&&o.push(e.z),i.push(o),s+=360/t}return i.push(i[0]),new c(i)}_createPlanarCircle(e,r,t){const s=[],i=2*Math.PI/t;for(let o=0;o<t;++o){const t=i*o,c=[e.x+Math.cos(-t)*r,e.y+Math.sin(-t)*r];this.hasZ&&c.push(e.z),s.push(c)}return s.push(s[0]),new c({spatialReference:e.spatialReference,rings:[s]})}_convert2Meters(e,r){let t;if(null!=u[r.wkid])t=u.values[u[r.wkid]];else{const e=r.wkt,s=e.lastIndexOf(",")+1,i=e.lastIndexOf("]]");t=parseFloat(e.substring(s,i))}return e*t}};e([s({type:o})],h.prototype,"center",void 0),e([s()],h.prototype,"geodesic",void 0),e([s()],h.prototype,"numberOfPoints",void 0),e([s()],h.prototype,"radius",void 0),e([s()],h.prototype,"radiusUnit",void 0),h=d=e([i("esri.geometry.Circle")],h);const m=h;export{m as default};
