/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
define(["../chunks/_rollupPluginBabelHelpers","../chunks/tslib.es6","../core/has","../core/lang","../core/Logger","../core/accessorSupport/ensureType","../core/accessorSupport/decorators/property","../core/accessorSupport/decorators/subclass","../core/accessorSupport/decorators/writer","../core/urlUtils","../core/uuid","../portal/support/resourceExtension","./SpatialReference","./Geometry","./support/webMercatorUtils","./Point","./support/contains","./support/intersects","./Extent","./support/zmUtils","./support/coordsUtils","./support/centroid","./support/extentUtils"],(function(t,e,n,r,i,s,o,a,c,l,u,p,h,f,g,y,m,d,R,_,x,w,v){"use strict";var P;function S(t){return!Array.isArray(t[0])}let Z=P=function(e){function n(...t){var n;return(n=e.call(this,...t)||this).rings=[],n.type="polygon",n}t._inheritsLoose(n,e),n.fromExtent=function(t){const e=t.clone().normalize(),n=t.spatialReference;let r=!1,i=!1;e.map((t=>{t.hasZ&&(r=!0),t.hasM&&(i=!0)}));const s={rings:e.map((function(t){const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(r&&t.hasZ){const n=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(n)}if(i&&t.hasM){const n=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(n)}return e})),spatialReference:n};return r&&(s.hasZ=!0),i&&(s.hasM=!0),new P(s)};var i=n.prototype;return i.normalizeCtorArgs=function(t,e){let n,r,i=null,s=null;return t&&!Array.isArray(t)?(i=t.rings?t.rings:null,e||(t.spatialReference?e=t.spatialReference:t.rings||(e=t)),n=t.hasZ,r=t.hasM):i=t,i=i||[],e=e||h.WGS84,i.length&&i[0]&&null!=i[0][0]&&"number"==typeof i[0][0]&&(i=[i]),s=i[0]&&i[0][0],s&&(void 0===n&&void 0===r?(n=s.length>2,r=!1):void 0===n?n=!r&&s.length>3:void 0===r&&(r=!n&&s.length>3)),{rings:i,spatialReference:e,hasZ:n,hasM:r}},i.writeRings=function(t,e){e.rings=r.clone(this.rings)},i.addRing=function(t){if(!t)return;const e=this.rings,n=e.length;if(S(t)){const r=[];for(let e=0,n=t.length;e<n;e++)r[e]=t[e].toArray();e[n]=r}else e[n]=t.concat();return this.notifyChange("rings"),this},i.clone=function(){const t=new P;return t.spatialReference=this.spatialReference,t.rings=r.clone(this.rings),t.hasZ=this.hasZ,t.hasM=this.hasM,t},i.contains=function(t){return!!t&&(g.canProject(t,this.spatialReference)&&(t=g.project(t,this.spatialReference)),m.polygonContainsPoint(this,t))},i.isClockwise=function(t){let e;return e=S(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t,x.isClockwise(e,this.hasM,this.hasZ)},i.getPoint=function(t,e){if(!this._validateInputs(t,e))return null;const n=this.rings[t][e],r=this.hasZ,i=this.hasM;return r&&!i?new y(n[0],n[1],n[2],void 0,this.spatialReference):i&&!r?new y(n[0],n[1],void 0,n[2],this.spatialReference):r&&i?new y(n[0],n[1],n[2],n[3],this.spatialReference):new y(n[0],n[1],this.spatialReference)},i.insertPoint=function(t,e,n){return this._validateInputs(t,e,!0)?(_.updateSupportFromPoint(this,n),Array.isArray(n)||(n=n.toArray()),this.rings[t].splice(e,0,n),this.notifyChange("rings"),this):this},i.removePoint=function(t,e){if(!this._validateInputs(t,e))return null;const n=new y(this.rings[t].splice(e,1)[0],this.spatialReference);return this.notifyChange("rings"),n},i.removeRing=function(t){if(!this._validateInputs(t,null))return null;const e=this.rings.splice(t,1)[0],n=this.spatialReference,r=e.map((t=>new y(t,n)));return this.notifyChange("rings"),r},i.setPoint=function(t,e,n){return this._validateInputs(t,e)?(_.updateSupportFromPoint(this,n),Array.isArray(n)||(n=n.toArray()),this.rings[t][e]=n,this.notifyChange("rings"),this):this},i._validateInputs=function(t,e,n=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=e){const r=this.rings[t];if(n&&(e<0||e>r.length))return!1;if(!n&&(e<0||e>=r.length))return!1}return!0},i.toJSON=function(t){return this.write(null,t)},t._createClass(n,[{key:"cache",get:function(){return this.commitProperty("rings"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}},{key:"centroid",get:function(){const t=w.polygonCentroid(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const e=new y;return e.x=t[0],e.y=t[1],e.spatialReference=this.spatialReference,this.hasZ&&(e.z=t[2]),e}},{key:"extent",get:function(){const{spatialReference:t}=this,e=v.getPolygonExtent(this);if(!e)return null;const n=new R(e);return n.spatialReference=t,n}},{key:"isSelfIntersecting",get:function(){return d.isSelfIntersecting(this.rings)}}]),n}(f);return e.__decorate([o.property({readOnly:!0})],Z.prototype,"cache",null),e.__decorate([o.property({readOnly:!0})],Z.prototype,"centroid",null),e.__decorate([o.property({readOnly:!0})],Z.prototype,"extent",null),e.__decorate([o.property({readOnly:!0})],Z.prototype,"isSelfIntersecting",null),e.__decorate([o.property({type:[[[Number]]],json:{write:{isRequired:!0}}})],Z.prototype,"rings",void 0),e.__decorate([c.writer("rings")],Z.prototype,"writeRings",null),Z=P=e.__decorate([a.subclass("esri.geometry.Polygon")],Z),Z.prototype.toJSON.isDefaultToJSON=!0,Z}));
