/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../core/colorUtils","../../core/JSONSupport","../../core/Logger","../../core/maybe","../../core/accessorSupport/decorators/property","../../core/accessorSupport/ensureType","../../core/arrayUtils","../../core/accessorSupport/decorators/subclass","../../layers/support/RasterInfo","../../layers/support/rasterFunctions/pixelUtils","../../layers/support/rasterFunctions/stretchUtils","../../layers/support/rasterFunctions/surfaceUtils","./colorRampUtils"],(function(e,t,r,s,o,a,n,i,l,u,c,p,d,h,f){"use strict";function m(e,t){const{attributeTable:r,bandCount:s}=e;if(a.isNone(r)||s>1)return!1;if(t){if(null==r.fields.find((e=>e.name.toLowerCase()===t.toLowerCase())))return!1}return!0}function y(e){const{bandCount:t,dataType:r,pixelType:s}=e;return"elevation"===r||"generic"===r&&1===t&&("s16"===s||"f32"===s||"f64"===s)}function g(e){const{bandCount:t,colormap:r}=e;return a.isSome(r)&&r.length>0&&1===t}let S=function(t){function s(e){return t.call(this,e)||this}e._inheritsLoose(s,t);var n=s.prototype;return n.bind=function(){const{rendererJSON:e}=this;if(!e)return{success:!1};let t;switch(this.lookup={rendererJSON:{}},e.type){case"uniqueValue":t=this._updateUVRenderer(e);break;case"rasterColormap":t=this._updateColormapRenderer(e);break;case"rasterStretch":t=this._updateStretchRenderer(e);break;case"classBreaks":t=this._updateClassBreaksRenderer(e);break;case"rasterShadedRelief":t=this._updateShadedReliefRenderer(e);break;case"vectorField":t=this._updateVectorFieldRenderer();break;case"flowRenderer":t=this._updateFlowRenderer()}return t},n.symbolize=function(e){let t=e&&e.pixelBlock;if(!b(t))return t;if(e.simpleStretchParams&&"rasterStretch"===this.rendererJSON.type)return this.simpleStretch(t,e.simpleStretchParams);try{let r;switch(t.pixels.length>3&&(t=p.extractBands(t,[0,1,2])),this.rendererJSON.type){case"uniqueValue":case"rasterColormap":r=this._symbolizeColormap(t);break;case"classBreaks":r=this._symbolizeClassBreaks(t);break;case"rasterStretch":r=this._symbolizeStretch(t,e.bandIds);break;case"rasterShadedRelief":{const s=e.extent,o=s.spatialReference.isGeographic,a={x:(s.xmax-s.xmin)/t.width,y:(s.ymax-s.ymin)/t.height};r=this._symbolizeShadedRelief(t,{isGCS:o,resolution:a});break}}return r}catch(r){return o.getLogger(this.declaredClass).error("symbolize",r.message),t}},n.simpleStretch=function(e,t){if(!b(e))return e;try{return e.pixels.length>3&&(e=p.extractBands(e,[0,1,2])),d.stretch(e,{...t,isRenderer:!0})}catch(r){return o.getLogger(this.declaredClass).error("symbolize",r.message),e}},n.generateWebGLParameters=function(e){if(["uniqueValue","rasterColormap","classBreaks"].includes(this.rendererJSON.type)){const{indexedColormap:e,offset:t}=this.lookup.colormapLut||{};return{colormap:e,colormapOffset:t,type:"lut"}}const{pixelBlock:t,isGCS:r,resolution:s,bandIds:o}=e,{rendererJSON:a}=this;return"rasterStretch"===a.type?this._generateStretchWebGLParams(t,a,o):"rasterShadedRelief"===a.type?this._generateShadedReliefWebGLParams(a,r,s??void 0):"vectorField"===a.type?this._generateVectorFieldWebGLParams(a):null},n._isLUTChanged=function(e){if(!this.lookup||!this.lookup.rendererJSON)return!0;if("colorRamp"in this.rendererJSON){const t=this.rendererJSON.colorRamp;return e?JSON.stringify(t)!==JSON.stringify(this.lookup.rendererJSON.colorRamp):(this.rendererJSON,this.lookup.rendererJSON,JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON))}return JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON)},n._symbolizeColormap=function(e){if(this._isLUTChanged()){if(!this.bind().success)return e}return p.colorize(e,this.lookup.colormapLut)},n._symbolizeClassBreaks=function(e){const{canUseIndexedLUT:t}=this._analyzeClassBreaks(this.rendererJSON);if(this._isLUTChanged()){if(!this.bind().success)return e}return t?p.colorize(e,this.lookup.colormapLut):p.remapColor(e,this.lookup.remapLut??[])},n._symbolizeStretch=function(e,t){const{rasterInfo:r}=this,{pixelType:s,bandCount:o}=r,n=this.rendererJSON,i=["u8","u16","s8","s16"].includes(s);let l,u;const{dra:c}=n,{gamma:h}=this.lookup;if("histogramEqualization"===n.stretchType){const s=c?null:this.lookup?.histogramLut,o=d.getStretchCutoff(n,{rasterInfo:r,pixelBlock:e,bandIds:t,returnHistogramLut:!s}),a=d.stretch(e,{...o,gamma:h,isRenderer:!0});u=p.lookupPixels(a,{lut:c?o.histogramLut:s,offset:0})}else if(i){if(c){const o=d.getStretchCutoff(n,{rasterInfo:r,pixelBlock:e,bandIds:t});l=d.createStretchLUT({pixelType:s,...o,gamma:h,rounding:"floor"})}else if(this._isLUTChanged()){if(!this.bind().success)return e;l=this.lookup?this.lookup.stretchLut:null}else l=this.lookup?this.lookup.stretchLut:null;if(!l)return e;o>1&&t?.length===a.unwrap(e)?.pixels.length&&l?.lut.length===o&&(l={lut:t.map((e=>l.lut[e])),offset:l.offset}),u=p.lookupPixels(e,l)}else{const s=d.getStretchCutoff(n,{rasterInfo:r,pixelBlock:e,bandIds:t});u=d.stretch(e,{...s,gamma:h,isRenderer:!0})}if(n.colorRamp){if(this._isLUTChanged(!0)){if(!this.bind().success)return e}u=p.colorize(u,this.lookup?.colormapLut)}return u},n._symbolizeShadedRelief=function(e,t){const r=this.rendererJSON,s={...r,...t},o=h.hillshade(e,s);if(!r.colorRamp)return o;let n;if(this._isLUTChanged(!0)){if(!this.bind().success)return o;n=this.lookup?this.lookup.hsvMap:null}else n=this.lookup?this.lookup.hsvMap:null;if(!n)return o;const i=a.unwrap(this.rasterInfo.statistics)?.[0]??{min:0,max:8e3};return h.tintHillshade(o,e,n,i),o},n._isVectorFieldData=function(){const{bandCount:e,dataType:t}=this.rasterInfo;return 2===e&&("vector-magdir"===t||"vector-uv"===t)},n._updateVectorFieldRenderer=function(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".`}},n._updateFlowRenderer=function(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".`}},n._updateUVRenderer=function(e){const{bandCount:t,attributeTable:r,pixelType:s}=this.rasterInfo,o=e.field1;if(!o)return{success:!1,error:"Unsupported renderer; missing UniqueValueRenderer.field."};const n=e.defaultSymbol,i=1===t&&["u8","s8"].includes(s);if(!m(this.rasterInfo,o)&&!i)return{success:!1,error:"Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table."};const l=[];if(a.isSome(r)){const t=r.fields.find((e=>"value"===e.name.toLowerCase()));if(!t)return{success:!1,error:"Unsupported data; the data's raster attribute table does not have a value field."};r.features.forEach((r=>{const s=e.uniqueValueInfos?.find((e=>String(e.value)===String(r.attributes[o]))),a=s?.symbol?.color;a?l.push([r.attributes[t.name]].concat(a)):n&&l.push([r.attributes[t.name]].concat(n.color))}))}else{if("value"!==o.toLowerCase())return{success:!1,error:'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.'};e.uniqueValueInfos?.forEach((e=>{const t=e?.symbol?.color;t?l.push([parseInt(""+e.value,10)].concat(t)):n&&l.push([parseInt(""+e.value,10)].concat(n?.color))}))}if(0===l.length)return{success:!1,error:"Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table."};const u=p.createColormapLUT({colormap:l});return this.lookup={rendererJSON:e,colormapLut:u},this.canRenderInWebGL=!0,{success:!0}},n._updateColormapRenderer=function(e){if(!g(this.rasterInfo))return{success:!1,error:"Unsupported data; the data source does not have a colormap."};const t=e.colormapInfos.map((e=>[e.value].concat(e.color))).sort(((e,t)=>e[0]-t[0]));if(!t||0===t.length)return{success:!1,error:"Unsupported renderer; ColormapRenderer must have meaningful colormapInfos."};const r=p.createColormapLUT({colormap:t});return this.lookup={rendererJSON:e,colormapLut:r},this.canRenderInWebGL=!0,{success:!0}},n._updateShadedReliefRenderer=function(e){if(!y(this.rasterInfo))return{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.`};if(e.colorRamp){const t=f.convertColorRampToColormap(e.colorRamp,{interpolateAlpha:!0}),s=p.createColormapLUT({colormap:t}),o=[],a=s.indexedColormap;for(let e=0;e<a.length;e+=4){const t=r.toHSV({r:a[e],g:a[e+1],b:a[e+2]});o.push([t.h/60,t.s/100,255*t.v/100])}this.lookup={rendererJSON:e,colormapLut:s,hsvMap:o}}else this.lookup=null;return this.canRenderInWebGL=!0,{success:!0}},n._analyzeClassBreaks=function(e){const{attributeTable:t,pixelType:r}=this.rasterInfo,s=a.isSome(t)?t.fields.find((e=>"value"===e.name.toLowerCase())):null,o=a.isSome(t)?t.fields.find((t=>t.name.toLowerCase()===e.field.toLowerCase())):null,n=null!=s&&null!==o;return{canUseIndexedLUT:["u8","u16","s8","s16"].includes(r)||n,tableValueField:s,tableBreakField:o}},n._updateClassBreaksRenderer=function(e){const{attributeTable:t}=this.rasterInfo,{canUseIndexedLUT:r,tableValueField:s,tableBreakField:o}=this._analyzeClassBreaks(e),n=e.classBreakInfos;if(!n?.length)return{success:!1,error:"Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos."};const i=n.sort(((e,t)=>e.classMaxValue-t.classMaxValue)),l=i[i.length-1];let u=e.minValue;if(!r){const t=[];for(let e=0;e<i.length;e++)t.push({value:i[e].classMinValue??u,mappedColor:i[e].symbol.color}),u=i[e].classMaxValue;return t.push({value:l.classMaxValue,mappedColor:l.symbol.color}),this.lookup={rendererJSON:e,remapLut:t},this.canRenderInWebGL=!1,{success:!0}}const c=[];if(a.isSome(t)&&null!=s&&null!==o&&s!==o){const r=s.name,a=o.name,n=i[i.length-1],{classMaxValue:l}=n;u=e.minValue;for(const e of t.features){const t=e.attributes[r],s=e.attributes[a],o=s===l?n:s<u?null:i.find((({classMaxValue:e})=>e>s));o&&c.push([t].concat(o.symbol.color))}}else{u=Math.floor(e.minValue);for(let e=0;e<i.length;e++){const t=i[e];for(let e=u;e<t.classMaxValue;e++)c.push([e].concat(t.symbol.color));u=Math.ceil(t.classMaxValue)}l.classMaxValue===u&&c.push([l.classMaxValue].concat(l.symbol.color))}const d=p.createColormapLUT({colormap:c,fillUnspecified:!1});return this.lookup={rendererJSON:e,colormapLut:d},this.canRenderInWebGL=!0,{success:!0}},n._isHistogramRequired=function(e){return"percentClip"===e||"histogramEqualization"===e},n._isValidRasterStatistics=function(e){return a.isSome(e)&&e.length>0&&null!=e[0].min&&null!=e[0].max},n._updateStretchRenderer=function(e){let{stretchType:t,dra:r}=e;if(!("none"===t||e.statistics?.length||this._isValidRasterStatistics(this.rasterInfo.statistics)||r))return{success:!1,error:"Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used."};const s=a.unwrap(e.histograms||this.rasterInfo.histograms);!this._isHistogramRequired(e.stretchType)||s?.length||r||(t="minMax");const{computeGamma:o,useGamma:n,colorRamp:i}=e;let{gamma:l}=e;if(n&&o&&!l?.length){const t=e.statistics?.length?e.statistics:a.unwrap(this.rasterInfo.statistics);l=d.computeGammaValues(this.rasterInfo.pixelType,t)}const u=this.rasterInfo.pixelType,c=!r&&["u8","u16","s8","s16"].includes(u);if("histogramEqualization"===t){const t=s.map((e=>d.createHistogramEqualizationLUT(e)));this.lookup={rendererJSON:e,histogramLut:t}}else if(c){const t=d.getStretchCutoff(e,{rasterInfo:this.rasterInfo}),r=d.createStretchLUT({pixelType:u,...t,gamma:n?l:null,rounding:"floor"});this.lookup={rendererJSON:e,stretchLut:r}}if(i){const t=f.convertColorRampToColormap(i,{interpolateAlpha:!0});this.lookup||(this.lookup={rendererJSON:e}),this.lookup.colormapLut=p.createColormapLUT({colormap:t}),this.lookup.rendererJSON=e}return this.lookup.gamma=n&&l?.length?l:null,this.canRenderInWebGL=!0,{success:!0}},n._generateStretchWebGLParams=function(e,t,r){let s=null,o=null;const n=this.lookup&&this.lookup.colormapLut;t.colorRamp&&n&&(s=n.indexedColormap,o=n.offset),"histogramEqualization"===t.stretchType&&(t={...t,stretchType:"minMax"});const{gamma:i}=this.lookup,l=!!(t.useGamma&&i&&i.some((e=>1!==e))),{minCutOff:u,maxCutOff:c,outMin:p,outMax:h}=d.getStretchCutoff(t,{rasterInfo:this.rasterInfo,pixelBlock:e,bandIds:r});let f=0;a.isSome(e)&&(f=e.getPlaneCount(),2===f&&((e=e.clone()).statistics=[e.statistics[0]],e.pixels=[e.pixels[0]]));const{bandCount:m}=this.rasterInfo,y=Math.min(3,r?.length||f||m,m),g=new Float32Array(y),S=s||l?1:255;let b;for(b=0;b<u.length;b++)g[b]=c[b]===u[b]?0:(h-p)/(c[b]-u[b])/S;const k=new Float32Array(y);if(l&&i)for(b=0;b<y;b++)i[b]>1?i[b]>2?k[b]=6.5+(i[b]-2)**2.5:k[b]=6.5+100*(2-i[b])**4:k[b]=1;return{bandCount:y,outMin:p/S,outMax:h/S,minCutOff:u,maxCutOff:c,factor:g,useGamma:l,gamma:l?i:[1,1,1],gammaCorrection:l?k:[1,1,1],colormap:s,colormapOffset:o,stretchType:t.stretchType,type:"stretch"}},n._generateShadedReliefWebGLParams=function(e,t=!1,r={x:0,y:0}){let s=null,o=null;const n=this.lookup&&this.lookup.colormapLut;e.colorRamp&&n&&(s=n.indexedColormap,o=n.offset);const i={...e,isGCS:t,resolution:r},l=h.calculateHillshadeParams(i),u=a.unwrap(this.rasterInfo.statistics)?.[0];return{...l,minValue:u?.min??0,maxValue:u?.max??8e3,hillshadeType:"traditional"===e.hillshadeType?0:1,type:"hillshade",colormap:s,colormapOffset:o}},n._generateVectorFieldWebGLParams=function(e){const{style:t,inputUnit:r,outputUnit:s,visualVariables:o,symbolTileSize:n,flowRepresentation:i}=e;let l;const u=this.rasterInfo.statistics?.[0].min??0,c=this.rasterInfo.statistics?.[0].max??50,p=o?.find((e=>"sizeInfo"===e.type))??{type:"sizeInfo",field:"Magnitude",maxDataValue:c,maxSize:.8*n,minDataValue:u,minSize:.2*n},d=p.minDataValue??u,h=p.maxDataValue??c,f=a.isSome(p.maxSize)&&a.isSome(p.minSize)?[p.minSize/n,p.maxSize/n]:[.2,.8];if("wind_speed"===t){const e=(f[0]+f[1])/2;f[0]=f[1]=e}const m=a.isSome(d)&&a.isSome(h)?[d,h]:null;if("classified_arrow"===t)if(a.isSome(d)&&a.isSome(h)&&a.isSome(p)){l=[];const e=(p.maxDataValue-p.minDataValue)/5;for(let t=0;t<6;t++)l.push(p.minDataValue+e*t)}else l=[0,1e-6,3.5,7,10.5,14];const y="flow_to"===i===("ocean_current_kn"===t||"ocean_current_m"===t)?0:Math.PI,g=o?.find((e=>"rotationInfo"===e.type));return{breakValues:l,dataRange:m,inputUnit:r,outputUnit:s,symbolTileSize:n,symbolPercentRange:f,style:t||"single_arrow",rotation:y,rotationType:this.rasterInfo.storageInfo?.tileInfo&&"vector-uv"===this.rasterInfo.dataType?"geographic":g?.rotationType||e.rotationType,type:"vectorField"}},s}(s.JSONSupport);function b(e){return p.isValidPixelBlock(e)&&0!==e.validPixelCount}t.__decorate([n.property({json:{write:!0}})],S.prototype,"rendererJSON",void 0),t.__decorate([n.property({type:c,json:{write:!0}})],S.prototype,"rasterInfo",void 0),t.__decorate([n.property({json:{write:!0}})],S.prototype,"lookup",void 0),t.__decorate([n.property()],S.prototype,"canRenderInWebGL",void 0),S=t.__decorate([u.subclass("esri.renderers.support.RasterSymbolizer")],S);return S}));
