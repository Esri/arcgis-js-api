/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../core/colorUtils","../../core/JSONSupport","../../core/Logger","../../core/maybe","../../core/accessorSupport/decorators/property","../../core/arrayUtils","../../core/has","../../core/accessorSupport/ensureType","../../core/accessorSupport/decorators/subclass","../../layers/support/RasterInfo","../../layers/support/rasterFunctions/pixelUtils","../../layers/support/rasterFunctions/surfaceUtils","./colorRampUtils"],(function(e,t,r,s,o,a,n,i,l,u,c,p,d,h,m){"use strict";const f=o.getLogger("esri.renderers.support.RasterSymbolizer");function g(e,t){const{attributeTable:r,bandCount:s}=e;if(!a.isSome(r)||s>1)return!1;if(t){if(null==r.fields.find((e=>e.name.toLowerCase()===t.toLowerCase())))return!1}return!0}function S(e){return"elevation"===e.dataType}function y(e){const{bandCount:t,colormap:r}=e;return a.isSome(r)&&r.length&&1===t}const b={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767],u32:[0,4294967295],s32:[-2147483648,2147483647],f32:[-34e38,34e38],f64:[-Number.MAX_VALUE,Number.MAX_VALUE]};let v=function(t){function s(e){return t.call(this,e)||this}e._inheritsLoose(s,t);var o=s.prototype;return o.bind=function(){const{rendererJSON:e}=this;if(!e)return{success:!1};let t;switch(this.lookup={rendererJSON:{}},e.type){case"uniqueValue":t=this._updateUVRenderer(e);break;case"rasterColormap":t=this._updateColormapRenderer(e);break;case"rasterStretch":t=this._updateStretchRenderer(e);break;case"classBreaks":t=this._updateClassBreaksRenderer(e);break;case"rasterShadedRelief":t=this._updateShadedReliefRenderer(e);break;case"vectorField":t=this._updateVectorFieldRenderer();break;case"flowRenderer":t=this._updateFlowRenderer()}return t},o.symbolize=function(e){let t=e&&e.pixelBlock;if(!x(t))return t;if(e.simpleStretchParams&&"rasterStretch"===this.rendererJSON.type)return this.simpleStretch(t,e.simpleStretchParams);try{let r;switch(t.pixels.length>3&&(t=d.extractBands(t,[0,1,2])),this.rendererJSON.type){case"uniqueValue":case"rasterColormap":r=this._symbolizeColormap(t);break;case"classBreaks":r=this._symbolizeClassBreaks(t);break;case"rasterStretch":r=this._symbolizeStretch(t,e.bandIds);break;case"rasterShadedRelief":{const{extent:s}=e,o=s.spatialReference.isGeographic,a={x:(s.xmax-s.xmin)/t.width,y:(s.ymax-s.ymin)/t.height};r=this._symbolizeShadedRelief(t,{isGCS:o,resolution:a});break}}return r}catch(r){return f.error("symbolize",r.message),t}},o.simpleStretch=function(e,t){if(!x(e))return e;try{return e.pixels.length>3&&(e=d.extractBands(e,[0,1,2])),d.stretch(e,t)}catch(r){return f.error("symbolize",r.message),e}},o.generateWebGLParameters=function(e){if(["uniqueValue","rasterColormap","classBreaks"].indexOf(this.rendererJSON.type)>-1){var t;const{indexedColormap:e,offset:r}=(null==(t=this.lookup)?void 0:t.colormapLut)||{};return{colormap:e,colormapOffset:r,type:"lut"}}const{pixelBlock:r,isGCS:s,resolution:o,bandIds:a}=e,{rendererJSON:n}=this;return"rasterStretch"===n.type?this._generateStretchWebGLParams(r,n,a):"rasterShadedRelief"===n.type?this._generateShadedReliefWebGLParams(n,s,o):"vectorField"===n.type?this._generateVectorFieldWebGLParams(n):null},o._isLUTChanged=function(e){if(!this.lookup||!this.lookup.rendererJSON)return!0;if("colorRamp"in this.rendererJSON){const t=this.rendererJSON.colorRamp;return e?JSON.stringify(t)!==JSON.stringify(this.lookup.rendererJSON.colorRamp):(this.rendererJSON,this.lookup.rendererJSON,JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON))}return JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON)},o._symbolizeColormap=function(e){if(this._isLUTChanged()){if(!this.bind().success)return e}return d.colorize(e,this.lookup.colormapLut)},o._symbolizeClassBreaks=function(e){const t=this.rasterInfo.pixelType,r=["u8","u16","s8","s16"].indexOf(t)>-1;if(this._isLUTChanged()){if(!this.bind().success)return e}return r?d.colorize(e,this.lookup.colormapLut):d.remapColor(e,this.lookup.remapLut)},o._symbolizeStretch=function(e,t){const{pixelType:r,bandCount:s}=this.rasterInfo,o=this.rendererJSON,n=["u8","u16","s8","s16"].indexOf(r)>-1;let i,l;const{dra:u}=o,c=o.useGamma?o.gamma:null;if("histogramEqualization"===o.stretchType){const r=u?null:this.lookup.histogramLut,s=this._getStretchCutoff(o,e,t,!r),a=d.stretch(e,{...s,gamma:c});l=d.lookupPixels(a,{lut:u?s.histogramLut:r,offset:0})}else if(n){var p,h;if(u){const s=this._getStretchCutoff(o,e,t);i=d.createStretchLUT({pixelType:r,...s,gamma:c})}else if(this._isLUTChanged()){if(!this.bind().success)return e;i=this.lookup?this.lookup.stretchLut:null}else i=this.lookup?this.lookup.stretchLut:null;if(!i)return e;s>1&&(null==t?void 0:t.length)===(null==(p=a.unwrap(e))?void 0:p.pixels.length)&&(null==(h=i)?void 0:h.lut.length)===s&&(i={lut:t.map((e=>i.lut[e])),offset:i.offset}),l=d.lookupPixels(e,i)}else{const r=this._getStretchCutoff(o,e,t);l=d.stretch(e,{...r,gamma:c})}if(o.colorRamp){if(this._isLUTChanged(!0)){if(!this.bind().success)return e}l=d.colorize(l,this.lookup.colormapLut)}return l},o._symbolizeShadedRelief=function(e,t){var r,s;const o=this.rendererJSON,n={...o,...t},i=h.hillshade(e,n);if(!o.colorRamp)return i;let l;if(this._isLUTChanged(!0)){if(!this.bind().success)return i;l=this.lookup?this.lookup.hsvMap:null}else l=this.lookup?this.lookup.hsvMap:null;if(!l)return i;const u=null!=(r=null==(s=a.unwrap(this.rasterInfo.statistics))?void 0:s[0])?r:{min:0,max:8e3};return h.tintHillshade(i,e,l,u),i},o._isVectorFieldData=function(){const{bandCount:e,dataType:t}=this.rasterInfo;return 2===e&&("vector-magdir"===t||"vector-uv"===t)},o._updateVectorFieldRenderer=function(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".`}},o._updateFlowRenderer=function(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".`}},o._updateUVRenderer=function(e){const{bandCount:t,attributeTable:r,pixelType:s}=this.rasterInfo,o=e.field1;if(!o)return{success:!1,error:"Unsupported renderer; missing UniqueValueRenderer.field."};const a=e.defaultSymbol,n=1===t&&["u8","s8"].includes(s);if(!g(this.rasterInfo,o)&&!n)return{success:!1,error:"Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table."};const i=[];if(r){const t=r.fields.find((e=>"value"===e.name.toLowerCase()));if(!t)return{success:!1,error:"Unsupported data; the data's raster attribute table does not have a value field."};r.features.forEach((r=>{var s;const n=e.uniqueValueInfos.find((e=>String(e.value)===String(r.attributes[o]))),l=null==n||null==(s=n.symbol)?void 0:s.color;l?i.push([r.attributes[t.name]].concat(l)):a&&i.push([r.attributes[t.name]].concat(a.color))}))}else{if("value"!==o.toLowerCase())return{success:!1,error:'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.'};e.uniqueValueInfos.forEach((e=>{var t;const r=null==e||null==(t=e.symbol)?void 0:t.color;r?i.push([parseInt(""+e.value,10)].concat(r)):a&&i.push([parseInt(""+e.value,10)].concat(a.color))}))}if(0===i.length)return{success:!1,error:"Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table."};const l=d.createColormapLUT({colormap:i});return this.lookup={rendererJSON:e,colormapLut:l},this.canRenderInWebGL=!0,{success:!0}},o._updateColormapRenderer=function(e){if(!y(this.rasterInfo))return{success:!1,error:"Unsupported data; the data source does not have a colormap."};const t=e.colormapInfos.map((e=>[e.value].concat(e.color))).sort(((e,t)=>e[0]-t[0]));if(!t||0===t.length)return{success:!1,error:"Unsupported renderer; ColormapRenderer must have meaningful colormapInfos."};const r=d.createColormapLUT({colormap:t});return this.lookup={rendererJSON:e,colormapLut:r},this.canRenderInWebGL=!0,{success:!0}},o._updateShadedReliefRenderer=function(e){if(!S(this.rasterInfo))return{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation".`};if(e.colorRamp){const t=m.convertColorRampToColormap(e.colorRamp,256,!0),s=d.createColormapLUT({colormap:t}),o=[],a=s.indexedColormap;for(let e=0;e<a.length;e+=4){const t=r.toHSV({r:a[e],g:a[e+1],b:a[e+2]});o.push([t.h/60,t.s/100,255*t.v/100])}this.lookup={rendererJSON:e,colormapLut:s,hsvMap:o}}else this.lookup=null;return this.canRenderInWebGL=!0,{success:!0}},o._updateClassBreaksRenderer=function(e){const t=this.rasterInfo.pixelType,r=["u8","u16","s8","s16"].indexOf(t)>-1,s=e.classBreakInfos;if(null==s||!s.length)return{success:!1,error:"Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos."};const o=s.sort(((e,t)=>e.classMaxValue-t.classMaxValue)),a=o[o.length-1];let n=e.minValue;if(!r){const t=[];for(let e=0;e<o.length;e++){var i;t.push({value:null!=(i=o[e].classMinValue)?i:n,mappedColor:o[e].symbol.color}),n=o[e].classMaxValue}return t.push({value:a.classMaxValue,mappedColor:a.symbol.color}),this.lookup={rendererJSON:e,remapLut:t},this.canRenderInWebGL=!1,{success:!0}}const l=[];n=Math.floor(e.minValue);for(let c=0;c<o.length;c++){const e=o[c];for(let t=n;t<e.classMaxValue;t++)l.push([t].concat(e.symbol.color));n=Math.ceil(e.classMaxValue)}a.classMaxValue===n&&l.push([a.classMaxValue].concat(a.symbol.color));const u=d.createColormapLUT({colormap:l,fillUnspecified:!1});return this.lookup={rendererJSON:e,colormapLut:u},this.canRenderInWebGL=!0,{success:!0}},o._isHistogramRequired=function(e){return"percentClip"===e||"histogramEqualization"===e},o._isValidRasterStatistics=function(e){return a.isSome(e)&&e.length>0&&null!=e[0].min&&null!=e[0].max},o._updateStretchRenderer=function(e){var t;let{stretchType:r,dra:s}=e;if(!("none"===r||null!=(t=e.statistics)&&t.length||this._isValidRasterStatistics(this.rasterInfo.statistics)||s))return{success:!1,error:"Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used."};const o=a.unwrap(e.histograms||this.rasterInfo.histograms);!this._isHistogramRequired(e.stretchType)||null!=o&&o.length||s||(r="minMax");const{gamma:n,useGamma:i,colorRamp:l}=e,u=this.rasterInfo.pixelType,c=!s&&["u8","u16","s8","s16"].indexOf(u)>-1;if("histogramEqualization"===r){const t=o.map((e=>d.createHistogramEqualizationLUT(e)));this.lookup={rendererJSON:e,histogramLut:t}}else if(c){const t=this._getStretchCutoff(e),r=d.createStretchLUT({pixelType:u,...t,gamma:i?n:null});this.lookup={rendererJSON:e,stretchLut:r}}if(l){const t=m.convertColorRampToColormap(l,256,!0);this.lookup||(this.lookup={rendererJSON:e}),this.lookup.colormapLut=d.createColormapLUT({colormap:t}),this.lookup.rendererJSON=e}return this.canRenderInWebGL=!0,{success:!0}},o._getStretchCutoff=function(e,t=null,r,s){var o,n,i;let l,u,c=e.stretchType;var p;if(e.dra)if("minMax"===c&&a.isSome(t)&&t.statistics)l=t.statistics.map((e=>[e.minValue,e.maxValue,0,0]));else{const e=d.estimateStatisticsHistograms(t);l=a.isSome(e)?e.statistics:null,u=a.isSome(e)?e.histograms:null}else l=(null==(p=e.statistics)?void 0:p.length)>0?e.statistics:a.unwrap(this.rasterInfo.statistics),u=e.histograms||a.unwrap(this.rasterInfo.histograms);!this._isHistogramRequired(c)||null!=(o=u)&&o.length||(c="minMax");const h=(null==(n=l)?void 0:n.length)||(null==(i=u)?void 0:i.length)||this.rasterInfo.bandCount,m=[],f=[];let g,S,y,v,x,k,C,_,R,L,O,I;switch(l&&!Array.isArray(l[0])&&(l=l.map((e=>[e.min,e.max,e.avg,e.stddev]))),c){case"none":{const e=b[this.rasterInfo.pixelType]||b.f32;for(_=0;_<h;_++)m[_]=e[0],f[_]=e[1]}break;case"minMax":for(_=0;_<h;_++)m[_]=l[_][0],f[_]=l[_][1];break;case"standardDeviation":for(_=0;_<h;_++)m[_]=l[_][2]-e.numberOfStandardDeviations*l[_][3],f[_]=l[_][2]+e.numberOfStandardDeviations*l[_][3],m[_]<l[_][0]&&(m[_]=l[_][0]),f[_]>l[_][1]&&(f[_]=l[_][1]);break;case"histogramEqualization":for(_=0;_<h;_++)m[_]=u[_].min,f[_]=u[_].max;break;case"percentClip":for(_=0;_<u.length;_++){for(g=u[_],x=new Uint32Array(g.size),v=[...g.counts],v.length>=20&&(v[0]=v[1]=v[2]=v[v.length-1]=v[v.length-2]=0),y=0,S=(g.max-g.min)/g.size,C=-.5===g.min&&1===S?.5:0,R=0;R<g.size;R++)y+=v[R],x[R]=y;for(k=(e.minPercent||0)*y/100,R=0;R<g.size;R++)if(x[R]>k){m[_]=g.min+S*(R+C);break}for(k=(1-(e.maxPercent||0)/100)*y,R=g.size-2;R>=0;R--)if(x[R]<k){f[_]=g.min+S*(R+2-C);break}}break;default:for(_=0;_<h;_++)m[_]=l[_][0],f[_]=l[_][1]}"histogramEqualization"===c?(O=u[0].size||256,L=0,s&&(I=u.map((e=>d.createHistogramEqualizationLUT(e))))):(O=e.max||255,L=e.min||0);const V={minCutOff:m,maxCutOff:f,outMax:O,outMin:L,histogramLut:I};return this._getSelectedBandCutoffs(V,r)},o._getSelectedBandCutoffs=function(e,t){if(null==t||0===t.length)return e;const r=Math.max.apply(null,t),{minCutOff:s,maxCutOff:o,outMin:a,outMax:n,histogramLut:i}=e;return s.length===t.length||s.length<=r?e:{minCutOff:t.map((e=>s[e])),maxCutOff:t.map((e=>o[e])),histogramLut:i?t.map((e=>i[e])):null,outMin:a,outMax:n}},o._generateStretchWebGLParams=function(e,t,r){let s=null,o=null;const n=this.lookup&&this.lookup.colormapLut;t.colorRamp&&n&&(s=n.indexedColormap,o=n.offset),"histogramEqualization"===t.stretchType&&(t={...t,stretchType:"minMax"});const{gamma:i}=t,l=!!(t.useGamma&&i&&i.some((e=>1!==e))),{minCutOff:u,maxCutOff:c,outMin:p,outMax:d}=this._getStretchCutoff(t,e,r);let h=0;a.isSome(e)&&(h=e.getPlaneCount(),2===h&&((e=e.clone()).statistics=[e.statistics[0]],e.pixels=[e.pixels[0]]));const m=Math.min(3,(null==r?void 0:r.length)||h||this.rasterInfo.bandCount),f=new Float32Array(m),g=s||l?1:255;let S;for(S=0;S<m;S++)f[S]=(d-p)/(c[S]-u[S])/g;const y=new Float32Array(m);if(l)for(S=0;S<m;S++)i[S]>1?i[S]>2?y[S]=6.5+(i[S]-2)**2.5:y[S]=6.5+100*(2-i[S])**4:y[S]=1;return{bandCount:m,outMin:p/g,outMax:d/g,minCutOff:u,maxCutOff:c,factor:f,useGamma:l,gamma:l?i:[1,1,1],gammaCorrection:l?y:[1,1,1],colormap:s,colormapOffset:o,stretchType:t.stretchType,type:"stretch"}},o._generateShadedReliefWebGLParams=function(e,t,r){var s,o,n;let i=null,l=null;const u=this.lookup&&this.lookup.colormapLut;e.colorRamp&&u&&(i=u.indexedColormap,l=u.offset);const c={...e,isGCS:t,resolution:r},p=h.calculateHillshadeParams(c),d=null==(s=a.unwrap(this.rasterInfo.statistics))?void 0:s[0];return{...p,minValue:null!=(o=null==d?void 0:d.min)?o:0,maxValue:null!=(n=null==d?void 0:d.max)?n:8e3,hillshadeType:"traditional"===e.hillshadeType?0:1,type:"hillshade",colormap:i,colormapOffset:l}},o._generateVectorFieldWebGLParams=function(e){var t,r,s,o,n,i,l,u;const{style:c,inputUnit:p,outputUnit:d,visualVariables:h,symbolTileSize:m,flowRepresentation:f}=e;let g;const S=null!=(t=null==(r=this.rasterInfo.statistics)?void 0:r[0].min)?t:0,y=null!=(s=null==(o=this.rasterInfo.statistics)?void 0:o[0].max)?s:50,b=null!=(n=null==h?void 0:h.find((e=>"sizeInfo"===e.type)))?n:{type:"sizeInfo",field:"Magnitude",maxDataValue:y,maxSize:.8*m,minDataValue:S,minSize:.2*m},v=null!=(i=b.minDataValue)?i:S,x=null!=(l=b.maxDataValue)?l:y,k=a.isSome(b.maxSize)&&a.isSome(b.minSize)?[b.minSize/m,b.maxSize/m]:[.2,.8];if("wind_speed"===c){const e=(k[0]+k[1])/2;k[0]=k[1]=e}const C=a.isSome(v)&&a.isSome(x)?[v,x]:null;if("classified_arrow"===c)if(a.isSome(v)&&a.isSome(x)&&a.isSome(b)){g=[];const e=(b.maxDataValue-b.minDataValue)/5;for(let t=0;t<6;t++)g.push(b.minDataValue+e*t)}else g=[0,1e-6,3.5,7,10.5,14];const _="flow_to"===f===("ocean_current_kn"===c||"ocean_current_m"===c)?0:Math.PI,R=null==h?void 0:h.find((e=>"rotationInfo"===e.type));return{breakValues:g,dataRange:C,inputUnit:p,outputUnit:d,symbolTileSize:m,symbolPercentRange:k,style:c||"single_arrow",rotation:_,rotationType:(null==(u=this.rasterInfo.storageInfo)?void 0:u.tileInfo)&&"vector-uv"===this.rasterInfo.dataType?"geographic":(null==R?void 0:R.rotationType)||e.rotationType,type:"vectorField"}},s}(s.JSONSupport);function x(e){return d.isValidPixelBlock(e)&&0!==e.validPixelCount}t.__decorate([n.property({json:{write:!0}})],v.prototype,"rendererJSON",void 0),t.__decorate([n.property({type:p,json:{write:!0}})],v.prototype,"rasterInfo",void 0),t.__decorate([n.property({json:{write:!0}})],v.prototype,"lookup",void 0),t.__decorate([n.property()],v.prototype,"canRenderInWebGL",void 0),v=t.__decorate([c.subclass("esri.renderers.support.RasterSymbolizer")],v);return v}));
