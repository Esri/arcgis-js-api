/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{clamp as t}from"../../core/mathUtils.js";import{px2pt as r,pt2px as n}from"../../core/screenUtils.js";import{l as o}from"../../chunks/vec4.js";import{c as e}from"../../chunks/vec4f64.js";const a=2.4;function i(t){return r(t*a)}function f(t){return n(t)/a}function c(r,n,e,a){let{color:i,ratio:f}=n,{color:c,ratio:s}=e;if(s===f){const t=1e-6;1===s?f-=t:s+=t}const u=t((a-f)/(s-f),0,1);o(r,i.toArray(),c.toArray(),u)}function s(t){const r=512,n=new Uint8ClampedArray(4*r);if(t=t.filter((({ratio:t})=>t>=0&&t<=1)).sort(((t,r)=>t.ratio-r.ratio)).map((({color:t,ratio:r})=>({color:t,ratio:Math.max(r,.001)}))),t.length<1)return n;let o=t[0],a=t[0],i=1;const f=e();for(let e=0;e<r;e++){const s=(e+.5)/r;for(;s>a.ratio&&i<t.length;)o=a,a=t[i++];c(f,o,a,s),n.set(f,4*e)}return n}function u(t,r,o,e){const{radius:a,fieldOffset:i,field:f}=r,c=n(a),s=new Float64Array(o*e);let u,l=Number.NEGATIVE_INFINITY;const m=d(f,i);for(const{geometry:n,attributes:h}of t){const t=Math.max(0,n.x-c),r=Math.max(0,n.y-c),a=Math.min(e,n.y+c),i=Math.min(o,n.x+c),f=+m(h);for(let e=r;e<a;e++)for(let r=t;r<i;r++){const t=e*o+r,a=y(n.x-r,n.y-e,c);u=s[t]+=a*f,u>l&&(l=u)}}return{matrix:s.buffer,max:l}}function l(t,r,o,e){const{radius:a,fieldOffset:i,field:f}=r,c=Math.round(n(a)),s=new Float64Array(o*e);let u,l=Number.NEGATIVE_INFINITY;const m=x(f,i),h=new Set;for(const n of t){const t=n.getCursor();for(;t.next();){const r=t.getObjectId();if(h.has(r))continue;h.add(r);const n=t.readLegacyPointGeometry(),a=128;if(n.x<-a||n.x>=o+a||n.y<-a||n.y>e+a)continue;const i=+m(t),f=Math.max(0,Math.round(n.x)-c),d=Math.max(0,Math.round(n.y)-c),x=Math.min(e,Math.round(n.y)+c),M=Math.min(o,Math.round(n.x)+c);for(let t=d;t<x;t++)for(let r=f;r<M;r++){const e=t*o+r,a=y(n.x-r,n.y-t,c);u=s[e]+=a*i,u>l&&(l=u)}}}return{matrix:s.buffer,max:l}}function m(t,r,n,o,e,a){t.canvas.width=t.canvas.height=r,t.clearRect(0,0,r,r);const i=t.getImageData(0,0,r,r);n&&o&&i.data.set(new Uint8ClampedArray(h(r,n,o,e,a))),t.putImageData(i,0,0)}function h(r,n,o,e,a){const i=new Uint32Array(r*r),f="buffer"in n?n:new Float64Array(n),c="buffer"in o?new Uint32Array(o.buffer):new Uint32Array(new Uint8Array(o).buffer),s=c.length/(a-e);for(let u=0;u<f.length;u++){const r=f[u],n=Math.floor((r-e)*s);i[u]=c[t(n,0,c.length-1)]}return i.buffer}function y(t,r,n){const o=Math.sqrt(t**2+r**2)/n;return o>1?0:3/(Math.PI*n**2)*(1-o**2)**2}function d(t,r){return"function"==typeof t?t:t?"string"==typeof r?r=>-1*+r[t]:n=>+n[t]+r:()=>1}function x(t,r){return null!=t?"string"==typeof r?r=>-1*+r.readAttribute(t):n=>+n.readAttribute(t)+r:t=>1}export{a as MAGIC_KERNEL_DENSITY_RADIUS_INFLATION_FACTOR,u as calculateHeatmapIntensityInfo,l as calculateHeatmapIntensityInfoReaders,h as createHeatmapImageData,d as createValueFunction,x as createValueFunctionCursor,m as drawHeatmap,y as evaluateDensityKernel,i as gaussianBlurRadiusPxToKernelDensityRadiusPt,s as generateGradient,f as kernelDensityRadiusPtToGaussianBlurRadiusPx};
