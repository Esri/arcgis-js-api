/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{eachAlways as r}from"../../../core/promiseUtils.js";import t from"../../../layers/FeatureLayer.js";import{applyTextFormattingHTML as a,htmlEntities as i}from"./featureUtils.js";const s=["$datastore","$map","$layer","$aggregatedfeatures"],n="esri.widgets.Feature.support.arcadeFeatureUtils",o=e.getLogger(n);function c(e){return"string"==typeof e?a(i(e)):Array.isArray(e)?p(e):"esri.arcade.Dictionary"===e?.declaredClass?l(e):e}function p(e){return`<ul class="esri-widget__list">${e.map((e=>`<li>${"string"==typeof e?a(i(e)):e}</li>`)).join("")}</ul>`}function l(e){return`<table class="esri-widget__table">${e.keys().map((r=>{const t=e.field(r);return`<tr><th>${r}</th><td>${"string"==typeof t?a(i(t)):t}</td></tr>`})).join("")}</table>`}function u({aggregatedFeatures:e,arcadeUtils:r,featureSetVars:a,context:i,viewInfo:s,map:n,graphic:o,interceptor:c}){a.forEach((a=>{const p=a.toLowerCase(),l={map:n,spatialReference:s.sr,interceptor:c};if("$map"===p&&(i.vars[p]=r.convertMapToFeatureSetCollection(l)),"$layer"===p&&(i.vars[p]=r.convertFeatureLayerToFeatureSet({layer:o.sourceLayer,spatialReference:s.sr,interceptor:c})),"$datastore"===p&&(i.vars[p]=r.convertServiceUrlToWorkspace({url:o.sourceLayer.url,spatialReference:s.sr,interceptor:c})),"$aggregatedfeatures"===p){const a=o.layer,{fields:n,objectIdField:l,geometryType:u,spatialReference:f,displayField:g}=a,y=new t({fields:n,objectIdField:l,geometryType:u,spatialReference:f,displayField:g,..."feature"===a.type?{templates:a.templates,typeIdField:a.typeIdField,types:a.types}:null,source:e});i.vars[p]=r.convertFeatureLayerToFeatureSet({layer:y,spatialReference:s.sr,interceptor:c})}}))}function f(){return import("../../../support/arcadeUtils.js")}async function g({graphic:e,view:r}){const{isAggregate:t,layer:a}=e;if(!t||!a||"2d"!==r?.type)return[];const i=await r.whenLayerView(a);if(!i.createQuery||!i.queryFeatures)return[];const s=i.createQuery();s.aggregateIds=[e.getObjectId()];const{features:n}=await i.queryFeatures(s);return n}async function y({expressionInfo:e,arcadeUtils:r,interceptor:t,spatialReference:a,map:i,graphic:n,view:c}){if(!e||!e.expression)return null;const p=r.createSyntaxTree(e.expression),l=s.filter((e=>r.hasVariable(p,e))),[f]=await Promise.all([g({graphic:n,view:c}),r.loadScriptDependencies(p,!0,l)]),y=r.getViewInfo({spatialReference:a}),d=r.createExecContext(n,y);d.interceptor=t,d.useAsync=!0,u({aggregatedFeatures:f,arcadeUtils:r,featureSetVars:l,context:d,viewInfo:y,map:i,graphic:n,interceptor:t});const m=r.createFunction(p,d);return r.executeAsyncFunction(m,d).catch((r=>o.error("arcade-execution-error",{error:r,graphic:n,expressionInfo:e})))}async function d({expressionInfos:e,spatialReference:t,graphic:a,interceptor:i,map:s,view:n}){if(!e||!e.length)return{};const o=await f(),p={};for(const r of e)p[`expression/${r.name}`]=y({expressionInfo:r,arcadeUtils:o,interceptor:i,spatialReference:t,map:s,graphic:a,view:n});const l=await r(p),u={};for(const r in l)u[r]=c(l[r].value);return u}export{y as createCompiledExpression,d as createCompiledExpressions,f as loadArcadeUtils};
