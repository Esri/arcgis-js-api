/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import e from"../../core/Accessor.js";import i from"../../core/Error.js";import s from"../../core/Logger.js";import{isSome as r,isNone as o}from"../../core/maybe.js";import{property as n}from"../../core/accessorSupport/decorators/property.js";import"../../core/arrayUtils.js";import"../../core/has.js";import"../../core/accessorSupport/ensureType.js";import{subclass as a}from"../../core/accessorSupport/decorators/subclass.js";const l="esri.widgets.Slider.SliderViewModel",u=s.getLogger(l);let p=class extends e{constructor(t){super(t),this.precision=4,this.thumbsConstrained=!0}set effectiveMax(t){this.setEffectiveMax(t)}set effectiveMin(t){this.setEffectiveMin(t)}set labelFormatFunction(t){this._set("labelFormatFunction",t)}set inputFormatFunction(t){this._set("inputFormatFunction",t)}set inputParseFunction(t){this._set("inputParseFunction",t)}get labels(){const{max:t,min:e,values:i}=this,s=i&&i.length?i.map(((t,e)=>this.getLabelForValue(t,"value",e))):[];return{max:this.getLabelForValue(t,"max"),min:this.getLabelForValue(e,"min"),values:s}}set max(t){this.setMax(t)}set min(t){this.setMin(t)}get state(){const{max:t,min:e}=this;return r(t)&&r(e)&&t>e?"ready":"disabled"}set values(t){const{max:e,min:i}=this,s=this.values;s&&t&&s.length===t.length&&s.every(((e,i)=>e===t[i]))||(this._set("values",null),t&&t.length&&(r(i)&&t.some((t=>t<i))&&(this.min=Math.min(...t)),r(e)&&t.some((t=>t>e))&&(this.max=Math.max(...t))),this._set("values",t))}toPrecision(t){return parseFloat(t.toFixed(this.precision))}defaultLabelFormatFunction(t){const{max:e,min:i,precision:s}=this,r=e-i>10?2:s;return parseFloat(t.toFixed(r)).toString()}defaultInputFormatFunction(t){return t.toString()}defaultInputParseFunction(t){return parseFloat(t)}getBounds(){const{effectiveMax:t,effectiveMin:e,max:i,min:s}=this;return{min:r(e)?Math.max(s,e):s,max:r(t)?Math.min(i,t):i}}getBoundsForValueAtIndex(t){const{thumbsConstrained:e,values:i}=this,{min:s,max:o}=this.getBounds();if(e){const e=t-1,n=t+1;return{min:r(i[e])?i[e]:s,max:r(i[n])?i[n]:o}}return{min:s,max:o}}getLabelForValue(t,e,i){return o(t)?null:this.labelFormatFunction?this.labelFormatFunction(t,e,i):this.defaultLabelFormatFunction(t)}setMax(t){const{max:e,values:i}=this;if(isNaN(t))return void this._logError("slider:invalid-value","Supplied value for property 'max' is NaN.");if(null===t)return void this._set("max",null);const s=this.toPrecision(t);if(e!==s&&(this._set("max",s),i&&i.length))for(let r=0;r<i.length;r++)s<i[r]&&this.setValue(r,s)}setMin(t){const{min:e,values:i}=this;if(isNaN(t))return void this._logError("slider:invalid-value","Supplied value for property 'min' is NaN.");if(null===t)return void this._set("min",null);const s=this.toPrecision(t);if(e!==s&&(this._set("min",s),i&&i.length))for(let r=0;r<i.length;r++)s>i[r]&&this.setValue(r,s)}setEffectiveMax(t){if(isNaN(t))return void this._logError("slider:invalid-value","Supplied value for property 'effectiveMax' is NaN.");if(null===t)return void this._set("effectiveMax",null);const e=this.toPrecision(t);this.effectiveMax!==e&&this._set("effectiveMax",this._applyBoundsToValue(e))}setEffectiveMin(t){if(isNaN(t))return void this._logError("slider:invalid-value","Supplied value for property 'effectiveMin' is NaN.");if(null===t)return void this._set("effectiveMin",null);const e=this.toPrecision(t);this.effectiveMin!==e&&this._set("effectiveMin",this._applyBoundsToValue(e))}setValue(t,e){if(isNaN(e))return void this._logError("slider:invalid-value","Supplied value for member of property 'values' is NaN.");const{values:i}=this,s=i[t],r=this.toPrecision(e);if(s===r)return;const o=[...i];o[t]=r,this._set("values",o),this.notifyChange("labels")}_applyBoundsToValue(t){const{max:e,min:i}=this;return r(i)&&t<i?i:r(e)&&t>e?e:t}_logError(t,e,s){u.error(new i(t,e,s))}};t([n()],p.prototype,"effectiveMax",null),t([n()],p.prototype,"effectiveMin",null),t([n()],p.prototype,"labelFormatFunction",null),t([n()],p.prototype,"inputFormatFunction",null),t([n()],p.prototype,"inputParseFunction",null),t([n({readOnly:!0})],p.prototype,"labels",null),t([n()],p.prototype,"max",null),t([n()],p.prototype,"min",null),t([n()],p.prototype,"precision",void 0),t([n({readOnly:!0})],p.prototype,"state",null),t([n()],p.prototype,"thumbsConstrained",void 0),t([n()],p.prototype,"values",null),p=t([a(l)],p);const c=p;export{c as default};
