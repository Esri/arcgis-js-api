/**
 * The Print widget connects your application with a [printing service](https://enterprise.arcgis.com/en/portal/latest/administer/windows/configure-the-portal-to-print-maps.htm) to allow the map to be printed.
 * It takes advantage of server-side, high-quality, full cartographic print functionality using the ExportWebMap service of ArcGIS,
 * which can be configured with custom layout templates. One is provided that shows the map only, while another provides a layout with legend, etc.
 * The Print widget works with the {@link module:esri/rest/print} which generates a printer-ready version of the map.
 *
 * The Print widget has two required properties:
 * [view](#view) (reference to the MapView) and [printServiceUrl](#printServiceUrl) (URL of the REST endpoint of the Export Web Map Task).
 *
 * By default, the Print widget prints a localized date for all {@link module:esri/rest/support/PrintTemplate#layout layouts}
 * except `map-only`. This can be customized using the `customTextElements` property of
 * {@link module:esri/rest/support/PrintTemplate#layoutOptions PrintTemplate.layoutOptions}.
 *
 * For more information about printing with the `MAP_ONLY` layout, please see
 * {@link module:esri/rest/support/PrintTemplate#exportOptions exportOptions}.
 *
 * ::: esri-md class="panel trailer-1"
 * **Known Limitations**
 *
 * No support
 *
 * * There is no current support for printing {@link module:esri/views/SceneView SceneViews}. Instead, see {@link module:esri/views/SceneView#takeScreenshot SceneView.takeScreenshot()}.
 * * There is no current support for printing {@link module:esri/layers/Layer#blendMode layer blending}. Instead, see {@link module:esri/views/MapView#takeScreenshot MapView.takeScreenshot()}.
 * * There is no current support for printing {@link module:esri/views/layers/FeatureLayerView#highlight highlighted features}. Instead, see {@link module:esri/views/MapView#takeScreenshot MapView.takeScreenshot()}.
 * * There is no current support for printing {@link module:esri/layers/ImageryLayer ImageryLayers} when a {@link module:esri/layers/ImageryLayer#pixelFilter pixelFilter}
 * is defined.
 * * There is no current support for printing renderers generated from {@link module:esri/smartMapping/renderers/univariateColorSize#createContinuousRenderer univariateColorSize.createContinuousRenderer()}
 * with an above-and-below theme.
 * * There is no current support for printing legend items for layers that are sent as a client-side image in the printout.
 * * There is no current support for printing features when using a renderer with `above-and-below` theme.
 *
 * Versioned support
 *
 * * {@link module:esri/symbols/CIMSymbol} cannot be printed with any Printing Service published with ArcMap.
 * * {@link module:esri/layers/support/LabelClass Labels} currently cannot be printed as part of a FeatureLayer with ArcGIS Server 10.5.1 or any Printing Service published with ArcMap.
 * * {@link module:esri/layers/ImageryLayer} cannot be printed with ArcGIS Server 10.5.1 or earlier, or any Printing Service published with ArcMap.
 * * {@link module:esri/layers/VectorTileLayer} printing requires ArcGIS Server 10.5.1 or later.
 * * Printing layers rendered with the {@link module:esri/renderers/DotDensityRenderer} will create a client-side image of the layer in the printout with ArcGIS Server 10.8.0 or earlier.
 * * For printing secure VectorTileLayers with ArcGIS Server 10.5.1 or 10.6.0,
 * or for printing VectorTileLayers with ArcGIS Server 10.5.1 or any Printing Service published with [ArcMap](https://desktop.arcgis.com/en/arcmap/),
 * the {@link module:esri/rest/print} will create a client-side image for the VectorTileLayer to use in the printout.
 * This has some limitations related to large size printing quality and a dependency on browser window height/width ratio.
 * * Printing the background color of a {@link module:esri/views/MapView#background MapView} or {@link module:esri/webmap/background/ColorBackground WebMap} requires ArcGIS Server 10.9 or later.
 *
 * Behavior notes
 *
 * * Printing layers using {@link module:esri/layers/FeatureLayer#featureReduction clustering} will create a client-side image of the layer in the printout.
 * * The print server does not directly print [SVG](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/symbol) symbols. Rather, they are converted to {@link module:esri/symbols/PictureMarkerSymbol PictureMarkerSymbols} for display.
 * * If the application and the print service are on the same origin, the name of the downloadable file can be customized with the {@link module:esri/widgets/Print/TemplateOptions#fileName fileName}
 * or {@link module:esri/widgets/Print/TemplateOptions#title title} properties. If not, the name of the downloadable file will be generated by the ArcGIS Enterprise that hosts the print service.
 * * Make certain that any resources to be printed are accessible by the print server. For example, if printing a map containing {@link module:esri/symbols/PictureMarkerSymbol PictureMarkerSymbols},
 * the URL to these symbols must be accessible to the print server for it to work properly.
 * :::
 *
 * @module esri/widgets/Print
 * @since 4.2
 *
 * @see [Print.tsx (widget view) [deprecated since 4.21]]({{ JSAPI_ARCGIS_JS_API_URL }}/widgets/Print.tsx)
 * @see [Print.scss]({{ JSAPI_ARCGIS_JS_API_URL }}/themes/base/widgets/_Print.scss)
 * @see [Sample - Print widget](../sample-code/widgets-print/index.html)
 * @see module:esri/widgets/Print/PrintViewModel
 * @see [Printing in web applications](https://enterprise.arcgis.com/en/server/latest/publish-services/windows/printing-in-web-applications.htm)
 * @see [Configure the portal to print maps](https://enterprise.arcgis.com/en/portal/latest/administer/windows/configure-the-portal-to-print-maps.htm)
 * @see [Export Web Map Task (Geoprocessing service) [REST doc]](https://developers.arcgis.com/rest/services-reference/export-web-map-task.htm)
 *
 * @example
 * const print = new Print({
 *   view: view,
 *   // specify your own print service
 *   printServiceUrl:
 *      "https://utility.arcgisonline.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task"
 * });
 *
 * // Adds widget below other elements in the top left corner of the view
 * view.ui.add(print, {
 *   position: "top-left"
 * });
 */

// esri.core
import Collection from "esri/core/Collection";
import EsriError from "esri/core/Error";
import { eventKey, on } from "esri/core/events";
import Logger from "esri/core/Logger";
import * as urlUtils from "esri/core/urlUtils";
import * as watchUtils from "esri/core/watchUtils";

// esri.core.accessorSupport
import { aliasOf, property, subclass } from "esri/core/accessorSupport/decorators";

// esri.portal
import Portal from "esri/portal/Portal";

// esri.rest.support
import PrintTemplate from "esri/rest/support/PrintTemplate";

// esri.t9n
import CommonMessages from "esri/t9n/common";

// esri.views
import IMapView from "esri/views/IMapView";

// esri.widgets
import Widget from "esri/widgets/Widget";

// esri.widgets.Print
import CustomTemplate from "esri/widgets/Print/CustomTemplate";
import FileLink from "esri/widgets/Print/FileLink";
import PrintViewModel from "esri/widgets/Print/PrintViewModel";
import TemplateOptions from "esri/widgets/Print/TemplateOptions";

// esri.widgets.Print.t9n
import type PrintMessages from "esri/widgets/Print/t9n/Print";

// esri.widgets.support
import { Heading, HeadingLevel } from "esri/widgets/support/Heading";
import { VNode } from "esri/widgets/support/interfaces";
import Popover from "esri/widgets/support/Popover";
import {
  isActivationKey,
  keepMenuItemWithinView,
  messageBundle,
  tsx,
  WidgetProperties
} from "esri/widgets/support/widget";

interface TemplateInfo {
  choiceList: string[];
  defaultValue: string;
}

interface TemplatesInfo {
  format: TemplateInfo;
  layout: TemplateInfo;
}

const FileLinkCollection = Collection.ofType<FileLink>(FileLink);

const mapOnlyLayout = "MAP_ONLY";

const enum TabId {
  layout = "layoutTab",
  mapOnly = "mapOnlyTab"
}

const CSS = {
  // base
  base: "esri-print",
  // print-widget
  headerTitle: "esri-print__header-title",
  inputText: "esri-print__input-text",
  layoutTabList: "esri-print__layout-tab-list",
  layoutTab: "esri-print__layout-tab",
  layoutSection: "esri-print__layout-section",
  mapOnlySection: "esri-print__map-only-section",
  scaleInput: "esri-print__scale-input",
  templateList: "esri-print__template-list",
  templateListScroller: "esri-print__template-list-scroller",
  templateListFooter: "esri-print__template-list-footer",
  // startup
  loader: "esri-print__loader",
  // buttons
  advancedOptionsButton: "esri-print__advanced-options-button",
  advancedOptionsButtonContainer: "esri-print__advanced-options-button-container",
  advancedOptionsButtonTitle: "esri-print__advanced-options-button-title",
  advancedOptionsButtonIconOpened: "esri-print__advanced-options-button-icon--opened",
  advancedOptionsButtonIconClosed: "esri-print__advanced-options-button-icon--closed",
  advancedOptionsButtonIconClosed_RTL: "esri-print__advanced-options-button-icon--closed-rtl",
  refreshButton: "esri-print__refresh-button",
  swapButton: "esri-print__swap-button",
  linkButton: "esri-print__link-button",
  printButton: "esri-print__export-button",
  templateButton: "esri-print__template-button",
  // containers
  formSectionContainer: "esri-print__form-section-container",
  advancedOptionsSection: "esri-print__advanced-options-section",
  advancedOptionsContainer: "esri-print__advanced-options-container",
  authorInfoContainer: "esri-print__author-info-container",
  copyrightInfoContainer: "esri-print__copyright-info-container",
  exportedFilesContainer: "esri-print__export-panel-container",
  exportedFilesTitle: "esri-print__export-title",
  exportedFile: "esri-print__exported-file",
  exportedFileLink: "esri-widget__anchor esri-print__exported-file-link",
  exportedFileLinkTitle: "esri-print__exported-file-link-title",
  heightContainer: "esri-print__height-container",
  legendInfoContainer: "esri-print__legend-info-container",
  printWidgetContainer: "esri-print__container",
  panelContainer: "esri-print__panel-container",
  scaleInfoContainer: "esri-print__scale-info-container",
  scaleInputContainer: "esri-print__scale-input-container",
  sizeContainer: "esri-print__size-container",
  widthContainer: "esri-print__width-container",
  // common
  widget: "esri-widget",
  panel: "esri-widget--panel",
  widgetButton: "esri-widget--button",
  button: "esri-button",
  buttonSecondary: "esri-button--secondary",
  buttonTertiary: "esri-button--tertiary",
  select: "esri-select",
  input: "esri-input",
  disabled: "esri-disabled",
  anchorDisabled: "esri-widget__anchor--disabled",
  buttonDisabled: "esri-button--disabled",
  panelError: "esri-print__panel--error",
  exportedFileError: "esri-print__exported-file--error",
  hide: "esri-hidden",
  rotate: "esri-rotating",
  anchor: "esri-widget__anchor",
  menu: "esri-menu",
  menuList: "esri-menu__list",
  menuItem: "esri-menu__list-item",
  menuItemFocus: "esri-menu__list-item--focus",
  menuHeader: "esri-menu__header",
  // icons
  iconCheckMark: "esri-icon-check-mark",
  iconDownload: "esri-icon-download",
  iconLaunchLink: "esri-icon-launch-link-external",
  iconError: "esri-icon-error",
  iconPrinter: "esri-icon-printer",
  iconRightTriangleArrow: "esri-icon-right-triangle-arrow",
  iconLeftTriangleArrow: "esri-icon-left-triangle-arrow",
  iconDownArrow: "esri-icon-down-arrow",
  iconRefresh: "esri-icon-refresh",
  iconSpinner: "esri-icon-loading-indicator",
  iconSwap: "esri-icon-swap",
  iconLinked: "esri-icon-link-horizontal",
  iconUnlinked: "esri-icon-unlocked-link-horizontal",
  widgetIcon: "esri-icon-printer"
};

const declaredClass = "esri.widgets.Print";
const logger = Logger.getLogger(declaredClass);
const invalidLayoutWarningMessage =
  "User sets an invalid layout, resetting it to the default valid one...";
const invalidFormatWarningMessage =
  "User sets an invalid format, resetting it to the default valid one...";

function dimensionsFromDPI(dpi: number): Pick<PrintTemplate["exportOptions"], "width" | "height"> {
  const dpiUnitToWidth = 8.3333;
  const dpiUnitToHeight = 11.4583;

  return {
    width: Math.round(dpi * dpiUnitToWidth),
    height: Math.round(dpi * dpiUnitToHeight)
  };
}

function isValidInputNumber(value: number): boolean {
  return !isNaN(value) && value > 0;
}

function isMapOnlyLayout(layout: string): boolean {
  return layout?.toUpperCase() === mapOnlyLayout;
}

interface PrintEvent {
  link: FileLink;
}

interface PrintEvents {
  submit: PrintEvent;
  complete: PrintEvent;
}

interface OptionalConstructProperties extends WidgetProperties<PrintViewModel> {
  allowedFormats: any;
  allowedLayouts: any;
  includeDefaultTemplates: boolean;
  portal: Portal;
  printServiceUrl: string;
  templateOptions: Partial<TemplateOptions>;
  view: IMapView;
}

type ConstructProperties = Partial<OptionalConstructProperties>;

@subclass("esri.widgets.Print")
class Print extends Widget<ConstructProperties, PrintEvents> implements ConstructProperties {
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------

  /**
   * @extends module:esri/widgets/Widget
   * @constructor
   * @alias module:esri/widgets/Print
   * @param {Object} [properties] - See the [properties](#properties-summary) for a list of all the properties
   *                                that may be passed into the constructor.
   *
   * @example
   * // typical usage
   * let print = new Print({
   *   view: view,
   *   printServiceUrl: "https://www.example.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task"
   * });
   */
  constructor(properties?: ConstructProperties, parentNode?: string | Element) {
    super(properties, parentNode);

    this._focusOnTabChange = this._focusOnTabChange.bind(this);
  }

  protected override initialize(): void {
    this.own([
      watchUtils.init(this, "viewModel.templatesInfo", (templatesInfo: TemplatesInfo) => {
        const { format, layout } = this.templateOptions;

        if (templatesInfo) {
          const isValidLayout =
            layout === templatesInfo.layout.defaultValue ||
            isMapOnlyLayout(layout) ||
            (templatesInfo.layout.choiceList &&
              templatesInfo.layout.choiceList.indexOf(layout) > -1);
          const isValidFormat =
            format === templatesInfo.format.defaultValue ||
            (templatesInfo.format.choiceList &&
              templatesInfo.format.choiceList.indexOf(format) > -1);

          if (!isValidLayout) {
            if (layout) {
              logger.warn(invalidLayoutWarningMessage);
            }

            this.templateOptions.layout = templatesInfo.layout.defaultValue;
          }

          if (!isValidFormat) {
            if (format) {
              logger.warn(invalidFormatWarningMessage);
            }

            this.templateOptions.format = templatesInfo.format.defaultValue;
          }

          if (isMapOnlyLayout(layout)) {
            this._layoutTabSelected = false;
          }
        }
      }),

      watchUtils.init(this, "templateOptions.format", (newValue: string) => {
        const {
          viewModel: { templatesInfo }
        } = this;

        if (templatesInfo && newValue) {
          let isValidFormat = false;
          templatesInfo.format.choiceList &&
            templatesInfo.format.choiceList.forEach((option) => {
              if (option.toUpperCase() === newValue.toUpperCase()) {
                this.templateOptions.format = option;
                isValidFormat = true;
              }
            });

          if (!isValidFormat) {
            this.templateOptions.format = templatesInfo.format.defaultValue;
            logger.warn(invalidFormatWarningMessage);
          }

          this.scheduleRender();
        }
      }),

      watchUtils.init(this, "templateOptions.layout", (newValue: string) => {
        const {
          viewModel: { templatesInfo }
        } = this;

        if (templatesInfo && newValue) {
          this._layoutTabSelected = !isMapOnlyLayout(newValue);
          let isValidLayout = false || !this._layoutTabSelected;

          if (!isValidLayout) {
            templatesInfo.layout.choiceList &&
              templatesInfo.layout.choiceList.forEach((option) => {
                if (option.toUpperCase() === newValue.toUpperCase()) {
                  this.templateOptions.layout = option;
                  isValidLayout = true;
                }
              });
          }

          if (!isValidLayout) {
            this.templateOptions.layout = templatesInfo.layout.defaultValue;
            logger.warn(invalidLayoutWarningMessage);
          }

          this.scheduleRender();
        }
      }),

      watchUtils.init(this, "templateOptions.dpi", (newValue: number) => {
        if (newValue <= 0) {
          this.templateOptions.dpi = 1;
          return;
        }

        this.scheduleRender();
      }),

      watchUtils.init(this, "viewModel.view.scale", (newValue: number) => {
        const { scale, scaleEnabled } = this.templateOptions;
        if (!scaleEnabled || !scale) {
          this.templateOptions.scale = newValue;
        }
      })
    ]);

    const { height, width } = this.templateOptions;

    this.templateOptions.width = width || 800;
    this.templateOptions.height = height || 1100;

    const maxWaitTime = 500;

    const timeoutId = setTimeout(() => {
      this._awaitingServerResponse = true;
      this.scheduleRender();
    }, maxWaitTime);

    this.viewModel.load().then(() => clearTimeout(timeoutId));
  }

  //--------------------------------------------------------------------------
  //
  //  Variables
  //
  //--------------------------------------------------------------------------

  private _activeTabFocusRequested = false;

  private _advancedOptionsVisibleForLayout = false;

  private _advancedOptionsVisibleForMapOnly = false;

  private _awaitingServerResponse = false;

  private _exportedFileNameMap: HashMap<number> = {};

  private _focusedTemplateIndex = 0;

  private _layoutTabSelected = true;

  private _pendingExportScroll = false;

  private _rootNode: HTMLElement = null;

  private _selectTemplateNode: HTMLButtonElement = null;

  private _templateListPopover: Popover = new Popover({
    owner: this,
    placement: "top",
    offset: [0, -100],
    anchorElement: () => this._selectTemplateNode,
    renderContentFunction: this.renderTemplateList
  });

  //--------------------------------------------------------------------------
  //
  //  Properties
  //
  //--------------------------------------------------------------------------

  //----------------------------------
  //  allowedFormats
  //----------------------------------

  /**
   * Specify the print output file format(s) that the user can select based on the options available from the print service.
   * This property can take a string value or an array of string values.
   *
   * When this value is "all" (default value), all the print service formats are available to be used.
   * When an array of string values is used, only those values that match the options available from the print service will be used.
   * If none of the input string values match those available from the print service, `allowedFormats` will fallback to default behavior.
   *
   * @name allowedFormats
   * @type {string | string[]}
   * @instance
   * @since 4.15
   * @default "all"
   * @see {@link module:esri/widgets/Print/TemplateOptions#format TemplateOptions.format}
   *
   * @example
   *
   * const print = new Print({
   *   view: view,
   *   printServiceUrl:
   *          "https://utility.arcgisonline.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task",
   *   allowedFormats: ["jpg", "png8", "png32"]
   * });
   *
   */
  @aliasOf("viewModel.allowedFormats")
  allowedFormats: any = null;

  //----------------------------------
  //  allowedLayouts
  //----------------------------------

  /**
   * Specify the print output layout(s) that the user can select based on the options available from the print service.
   * This property can take a string value or an array of string values.
   *
   * When this value is "all" (default value), all the print service layouts are available to be used.
   * When an array of string values is used, only those values that match the options available from the print service will be used.
   * If none of the input string values match those available from the print service, `allowedLayouts` will fallback to default behavior.
   *
   * @name allowedLayouts
   * @type {string | string[]}
   * @instance
   * @since 4.15
   * @default "all"
   * @see {@link module:esri/widgets/Print/TemplateOptions#format TemplateOptions.layout}
   *
   * @example
   *
   * const print = new Print({
   *   view: view,
   *   printServiceUrl:
   *          "https://utility.arcgisonline.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task",
   *   allowedLayouts: ["a3-landscape", "a3-portrait"]
   * });
   */
  @aliasOf("viewModel.allowedLayouts")
  allowedLayouts: any = null;

  //----------------------------------
  //  error
  //----------------------------------

  /**
   * The Error object returned if an error occurred while fetching information from service.
   * @type {EsriError}
   * @ignore
   */
  @aliasOf("viewModel.error")
  error: EsriError;

  //----------------------------------
  //  exportedLinks
  //----------------------------------

  /**
   * The collection of links exported from the Print widget.
   *
   * @since 4.17
   * @name exportedLinks
   * @instance
   * @readonly
   * @type {module:esri/core/Collection<module:esri/widgets/Print~FileLink>}
   *
   * @example
   * require([
   *   "esri/widgets/Print",
   *   "esri/config"
   * ], function(Print, esriConfig) {
   *
   *   // ...
   *
   *   view.when(function () {
   *     print = new Print({
   *       view: view,
   *       // specify your own print service
   *       printServiceUrl:
   *         "https://utility.arcgisonline.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task"
   *     });
   *
   *     // Add widget to the top right corner of the view
   *     view.ui.add(print, "top-right");
   *
   *     // use a requestInterceptor to monitor the print widget
   *     // for print completion
   *     esriConfig.request.interceptors.push({
   *       // set the `urls` property to the URL of the print service so that this
   *       // interceptor only applies to requests made to the print service URL
   *       urls: print.printServiceUrl,
   *       // use the AfterInterceptorCallback to interogate the exportedLinks property
   *       after: function(response) {
   *         console.log("exportedLinks: ", print.exportedLinks.items[0]);
   *       }
   *     });
   *   });
   */
  @property({ type: FileLinkCollection })
  exportedLinks: Collection<FileLink> = new FileLinkCollection();

  //----------------------------------
  //  extraParameters
  //----------------------------------

  /**
   * This option allows passing extra parameters (in addition to [templateOptions](#templateOptions)) to the print (export webmap) requests.
   *
   * @name extraParameters
   * @type {Object}
   * @since 4.20
   */
  @aliasOf("viewModel.extraParameters")
  extraParameters: any = null;

  //----------------------------------
  //  headingLevel
  //----------------------------------

  /**
   * Indicates the heading level to use for the "Exported files" text where users can
   * access the exported map printout. By default, this text is rendered
   * as a level 3 heading (e.g. `<h3>Exported files</h3>`). Depending on the widget's placement
   * in your app, you may need to adjust this heading for proper semantics. This is
   * important for meeting accessibility standards.
   *
   * @name headingLevel
   * @instance
   * @since 4.20
   * @type {number}
   * @default 3
   * @see [Heading Elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements)
   *
   * @example
   * // "Exported files" will render as an <h4>
   * print.headingLevel = 4;
   */
  @property()
  headingLevel: HeadingLevel = 3;

  //----------------------------------
  //  iconClass
  //----------------------------------

  /**
   * The widget's default CSS icon class.
   *
   * @since 4.7
   * @name iconClass
   * @instance
   * @type {string}
   */
  @property()
  override iconClass = CSS.widgetIcon;

  //----------------------------------
  //  includeDefaultTemplates
  //----------------------------------

  /**
   * Indicates whether or not to include {@link module:esri/widgets/Print/PrintViewModel#defaultTemplates defaultTemplates}.
   *
   * @name includeDefaultTemplates
   * @instance
   * @type {boolean}
   * @default true
   * @since 4.18
   *
   * @example
   * const printWidget = new Print({
   *    view: view,
   *    includeDefaultTemplates: false,
   *    portal: {url: "https://.example.arcgis.com/sharing/"},
   *    container: "printDiv"
   * });
   */
  @aliasOf("viewModel.includeDefaultTemplates")
  includeDefaultTemplates: boolean = null;

  //----------------------------------
  //  label
  //----------------------------------

  /**
   * The widget's default label.
   *
   * @since 4.7
   * @name label
   * @instance
   * @type {string}
   */
  @property({
    aliasOf: { source: "messages.widgetLabel", overridable: true }
  })
  override label: string = undefined;

  //----------------------------------
  //  messages
  //----------------------------------

  /**
   * @name messages
   * @instance
   * @type {Object}
   *
   * @ignore
   * @todo intl doc
   */
  @property()
  @messageBundle("esri/widgets/Print/t9n/Print")
  messages: PrintMessages;

  //----------------------------------
  //  messagesCommon
  //----------------------------------

  /**
   * @name messagesCommon
   * @instance
   * @type {Object}
   *
   * @ignore
   * @todo intl doc
   */
  @property()
  @messageBundle("esri/t9n/common")
  messagesCommon: CommonMessages;

  //----------------------------------
  //  portal
  //----------------------------------

  /**
   * It is possible to search a specified portal instance's [locator services](https://enterprise.arcgis.com/en/portal/latest/administer/windows/configure-portal-to-geocode-addresses.htm).
   * Use this property to set this [ArcGIS Portal](https://enterprise.arcgis.com/en/portal/) instance to search.
   * This is especially helpful when working with a {@link module:esri/widgets/Print/CustomTemplate custom print template}.
   *
   * If this property is set, it is not necessary to set the [printServiceUrl](#printServiceUrl) property.
   *
   * @name portal
   * @instance
   * @type {module:esri/portal/Portal}
   * @since 4.18
   * @see module:esri/widgets/Print/CustomTemplate
   *
   * @example
   * const printWidget = new Print({
   *    view: view,
   *    portal: {url: "https://example.arcgis.com/sharing/"},
   *    container: "printDiv"
   * });
   */
  @aliasOf("viewModel.portal")
  portal: Portal = null;

  //----------------------------------
  //  printServiceUrl
  //----------------------------------

  /**
   * The URL of the REST endpoint of the Export Web Map Task.
   * If the [portal](#portal) property is set, it is not necessary to set this property.
   *
   * @name printServiceUrl
   * @instance
   * @type {string}
   */

  @aliasOf("viewModel.printServiceUrl")
  printServiceUrl: string = null;

  //----------------------------------
  //  templateOptions
  //----------------------------------

  /**
   * Defines the layout template options used by the {@link module:esri/widgets/Print|Print} widget to generate the print page.
   *
   * @name templateOptions
   * @since 4.6
   * @instance
   *
   * @example
   * templateOptions: {
   *   title: "My Print",
   *   author: "Sam",
   *   copyright: "My Company",
   *   legendEnabled: false
   * }
   *
   * @type {module:esri/widgets/Print/TemplateOptions}
   * @autocast
   */
  @property({
    type: TemplateOptions
  })
  templateOptions: TemplateOptions = new TemplateOptions();

  //----------------------------------
  //  view
  //----------------------------------

  /**
   * A reference to the {@link module:esri/views/MapView}. Set this to link
   * the widget to a specific view.
   *
   * @todo REMOVE UNTIL SCENEVIEW SUPPORTS PRINTING or {@link module:esri/views/SceneView}
   *
   * @name view
   * @instance
   *
   * @type {module:esri/views/MapView}
   */
  @aliasOf("viewModel.view")
  view: IMapView = null;

  //----------------------------------
  //  viewModel
  //----------------------------------

  /**
   * The view model for this widget. This is a class that contains all the logic
   * (properties and methods) that controls this widget's behavior. See the
   * {@link module:esri/widgets/Print/PrintViewModel} class to access
   * all properties and methods on the widget.
   *
   * @name viewModel
   * @instance
   * @type {module:esri/widgets/Print/PrintViewModel}
   * @autocast
   */
  @property({
    type: PrintViewModel
  })
  override viewModel = new PrintViewModel();

  //--------------------------------------------------------------------------
  //
  //  Type definitions
  //
  //--------------------------------------------------------------------------

  /**
   * Represents an exported map request from the result of the Print widget.
   * Successful exports will have a URL that links to the printout. Failed ones will have information on what went wrong.
   *
   * @typedef module:esri/widgets/Print~FileLink
   *
   * @property {number} count - The location of the FileLink element in the array.
   * @property {String} error - The {@link module:esri/core/Error error} from the Print widget, if any.
   * @property {String} extension - The {@link module:esri/widgets/Print/TemplateOptions#format file} type of the print-out.
   * @property {String} name - The {@link module:esri/widgets/Print/TemplateOptions#fileName fileName}
   * or {@link module:esri/widgets/Print/TemplateOptions#title title} of the print-out.
   * @property {String} state - The state of the print-out. Either `"ready"` or `"pending"` or `"error"`.
   * @property {String} url - The [printServiceUrl](#printServiceUrl) of the print-out.
   *
   * @example
   * require([
   *   "esri/widgets/Print",
   *   "esri/config"
   * ], function(Print, esriConfig) {
   *
   *   // ...
   *
   *   view.when(function () {
   *     print = new Print({
   *       view: view,
   *       // specify your own print service
   *       printServiceUrl:
   *         "https://utility.arcgisonline.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task"
   *     });
   *
   *     // Add widget to the top right corner of the view
   *     view.ui.add(print, "top-right");
   *
   *     // use a requestInterceptor to monitor the print widget
   *     // for print completion
   *     esriConfig.request.interceptors.push({
   *       // set the `urls` property to the URL of the print service so that this
   *       // interceptor only applies to requests made to the print service URL
   *       urls: print.printServiceUrl,
   *       // use the AfterInterceptorCallback to interogate the exportedLinks property
   *       after: function(response) {
   *         console.log("exportedLinks: ", print.exportedLinks.items[0]);
   *       }
   *     });
   *   });
   */

  //--------------------------------------------------------------------------
  //
  //  Events
  //
  //--------------------------------------------------------------------------

  /**
   * Fires when a print request has been completed and returns its results.
   * This event will fire whether an export succeeds or fails.
   *
   * @since 4.17
   * @event module:esri/widgets/Print#complete
   * @property {Object} results - An object representing the results of the print.
   * @property {module:esri/core/Collection<module:esri/widgets/Print~FileLink>} results.link - Represents an
   * exported map request from the result of the Print widget.
   *
   * @example
   * const printWidget = new Print();
   *
   * printWidget.on("complete", function(results){
   *   // The results are stored in the results object
   *   console.log("Results of the print: ", results.link);
   * });
   */

  /**
   * Fires when an export request begins, and returns a reference to the exported [link](#FileLink).
   *
   * @since 4.17
   * @event module:esri/widgets/Print#submit
   * @property {Object} results - An object representing the results of submitting the print.
   * @property {module:esri/core/Collection<module:esri/widgets/Print~FileLink>} results.link - Represents an
   * exported map request from the result of the Print widget.
   *
   * @example
   * const printWidget = new Print();
   *
   * printWidget.on("submit", function(results){
   *   // The results are stored in the event object
   *   console.log("Results of submitting the print: ", results.link);
   * });
   */

  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------

  override render(): VNode {
    const {
      attributionEnabled,
      author,
      copyright,
      dpi,
      format,
      height,
      layout,
      legendEnabled,
      scaleEnabled,
      scale,
      width
    } = this.templateOptions;

    const exportDisabled = this.get<PrintViewModel["state"]>("viewModel.state") !== "ready";
    const titleOrFileNameSection = this.renderTitleOrFileNameSection();
    const { includeDefaultTemplates, messages, viewModel } = this;

    const fileFormatMenuItems =
      this.get<string[]>("viewModel.templatesInfo.format.choiceList") || [];
    const fileFormatOptions =
      fileFormatMenuItems.length > 0 ? (
        fileFormatMenuItems.map((fileFormatMenuItem) => {
          const selected = fileFormatMenuItem === format;

          return (
            <option key={fileFormatMenuItem} selected={selected} value={fileFormatMenuItem}>
              {fileFormatMenuItem.toUpperCase()}
            </option>
          );
        })
      ) : (
        <option key="format-default-option">{messages.formatDefaultOption}</option>
      );

    const fileFormatSection = (
      <div class={CSS.formSectionContainer}>
        <label>
          {messages.fileFormatTitle}
          <select
            class={CSS.select}
            onchange={this._updateFromOption}
            data-target-property="format"
            bind={this}
          >
            {fileFormatOptions}
          </select>
        </label>
      </div>
    );

    const layoutMenuItems = this.get<string[]>("viewModel.templatesInfo.layout.choiceList") || [];
    const layoutOptions =
      layoutMenuItems.length > 0 ? (
        layoutMenuItems.map((layoutMenuItem) => {
          const selected = layoutMenuItem === layout;
          const label = messages[layoutMenuItem] || layoutMenuItem;

          return (
            <option key={layoutMenuItem} selected={selected} value={layoutMenuItem}>
              {label}
            </option>
          );
        })
      ) : (
        <option key="layout-default-option">{messages.layoutDefaultOption}</option>
      );

    const pageSetupSection = (
      <div class={CSS.formSectionContainer}>
        <label>
          {messages.layoutTitle}
          <select
            class={CSS.select}
            onchange={this._updateFromOption}
            data-target-property="layout"
            bind={this}
          >
            {layoutOptions}
          </select>
        </label>
      </div>
    );

    const dpiSection = (
      <div class={CSS.formSectionContainer}>
        <label>
          {messages.dpi}
          <input
            type="number"
            class={this.classes(CSS.inputText, CSS.input)}
            data-input-name="dpi"
            onchange={this._handleDPIChange}
            value={`${dpi}`}
            min="1"
            tabIndex={0}
            bind={this}
          />
        </label>
      </div>
    );

    const scaleSection = (
      <div class={this.classes(CSS.scaleInfoContainer, CSS.formSectionContainer)}>
        <label>
          <input
            data-option-name="scaleEnabled"
            checked={scaleEnabled}
            type="checkbox"
            tabIndex={0}
            onchange={this._toggleInputValue}
            bind={this}
          />
          {messages.scale}
        </label>
        <div class={CSS.scaleInputContainer}>
          <input
            aria-label={messages.scaleLabel}
            aria-valuenow={`${scale}`}
            role="spinbutton"
            type="number"
            class={this.classes(CSS.inputText, CSS.input, CSS.scaleInput)}
            tabIndex={0}
            data-input-name="scale"
            onchange={this._updateInputValue}
            disabled={!scaleEnabled}
            value={`${scale}`}
            bind={this}
          />
          <button
            type="button"
            aria-label={messages.reset}
            class={this.classes(CSS.widgetButton, CSS.refreshButton, CSS.iconRefresh)}
            tabIndex={0}
            onclick={this._resetToCurrentScale}
            bind={this}
          />
        </div>
      </div>
    );

    const advancedSectionForLayout = this._advancedOptionsVisibleForLayout ? (
      <div
        aria-labelledby={`${this.id}__advancedOptionsForLayout`}
        class={CSS.advancedOptionsContainer}
      >
        {scaleSection}
        <div class={this.classes(CSS.authorInfoContainer, CSS.formSectionContainer)}>
          <label>
            {messages.author}
            <input
              type="text"
              value={author}
              class={this.classes(CSS.inputText, CSS.input)}
              tabIndex={0}
              data-input-name="author"
              onchange={this._updateInputValue}
              bind={this}
            />
          </label>
        </div>
        <div class={this.classes(CSS.copyrightInfoContainer, CSS.formSectionContainer)}>
          <label>
            {messages.copyright}
            <input
              type="text"
              class={this.classes(CSS.inputText, CSS.input)}
              tabIndex={0}
              value={copyright}
              data-input-name="copyright"
              onchange={this._updateInputValue}
              bind={this}
            />
          </label>
        </div>
        {dpiSection}
        <div class={this.classes(CSS.legendInfoContainer, CSS.formSectionContainer)}>
          <label>
            <input
              type="checkbox"
              data-option-name="legendEnabled"
              tabIndex={0}
              checked={legendEnabled}
              onchange={this._toggleInputValue}
              bind={this}
            />
            {messages.legend}
          </label>
        </div>
      </div>
    ) : null;

    const advancedSectionForMapOnly = this._advancedOptionsVisibleForMapOnly ? (
      <div
        aria-labelledby={`${this.id}__advancedOptionsForMapOnly`}
        class={CSS.advancedOptionsContainer}
      >
        {scaleSection}
        {dpiSection}
        <div class={CSS.formSectionContainer}>
          <label>
            <input
              data-option-name="attributionEnabled"
              type="checkbox"
              onchange={this._toggleInputValue}
              tabIndex={0}
              checked={attributionEnabled}
              bind={this}
            />
            {messages.attribution}
          </label>
        </div>
      </div>
    ) : null;

    const panel = this._layoutTabSelected ? (
      <section
        key="esri-print__layoutContent"
        id={`${this.id}__layoutContent`}
        aria-labelledby={`${this.id}__layoutTab`}
        class={CSS.layoutSection}
        role="tabpanel"
        aria-selected={this._layoutTabSelected.toString()}
      >
        <div class={CSS.panelContainer}>
          {titleOrFileNameSection}
          {pageSetupSection}
          {this._layoutTabSelected ? fileFormatSection : null}
        </div>

        <div class={this.classes(CSS.panelContainer, CSS.advancedOptionsSection)}>
          <button
            aria-label={messages.advancedOptions}
            aria-expanded={this._advancedOptionsVisibleForLayout ? "true" : "false"}
            class={CSS.advancedOptionsButton}
            onclick={this._showAdvancedOptions}
            bind={this}
            type="button"
          >
            <div class={CSS.advancedOptionsButtonContainer}>
              <span
                aria-hidden="true"
                class={this.classes(
                  CSS.iconRightTriangleArrow,
                  CSS.advancedOptionsButtonIconClosed
                )}
              />
              <span
                aria-hidden="true"
                class={this.classes(
                  CSS.iconLeftTriangleArrow,
                  CSS.advancedOptionsButtonIconClosed_RTL
                )}
              />
              <span
                aria-hidden="true"
                class={this.classes(CSS.iconDownArrow, CSS.advancedOptionsButtonIconOpened)}
              />
              <span class={CSS.advancedOptionsButtonTitle}>{messages.advancedOptions}</span>
            </div>
          </button>
          {advancedSectionForLayout}
        </div>
      </section>
    ) : (
      <section
        key="esri-print__mapOnlyContent"
        id={`${this.id}__mapOnlyContent`}
        aria-selected={(!this._layoutTabSelected).toString()}
        aria-labelledby={`${this.id}__mapOnlyTab`}
        class={CSS.mapOnlySection}
        role="tabpanel"
      >
        <div class={CSS.panelContainer}>
          {titleOrFileNameSection}
          {this._layoutTabSelected ? null : fileFormatSection}
          <div class={this.classes(CSS.sizeContainer, CSS.formSectionContainer)}>
            <div class={CSS.widthContainer}>
              <label>
                {messages.width}
                <input
                  type="number"
                  class={this.classes(CSS.inputText, CSS.input)}
                  data-input-name="width"
                  onchange={this._updateInputValue}
                  value={`${width}`}
                  tabIndex={0}
                  bind={this}
                />
              </label>
            </div>
            <div class={CSS.heightContainer}>
              <label>
                {messages.height}
                <input
                  type="number"
                  class={this.classes(CSS.inputText, CSS.input)}
                  data-input-name="height"
                  onchange={this._updateInputValue}
                  value={`${height}`}
                  tabIndex={0}
                  bind={this}
                />
              </label>
            </div>
            <button
              type="button"
              aria-label={messages.swap}
              class={this.classes(CSS.widgetButton, CSS.swapButton, CSS.iconSwap)}
              onclick={this._switchInput}
              tabIndex={0}
              bind={this}
            />
          </div>
          <div class={this.classes(CSS.panelContainer, CSS.advancedOptionsSection)}>
            <button
              aria-label={messages.advancedOptions}
              aria-expanded={this._advancedOptionsVisibleForMapOnly ? "true" : "false"}
              type="button"
              class={CSS.advancedOptionsButton}
              onclick={this._showAdvancedOptions}
              bind={this}
            >
              <div class={CSS.advancedOptionsButtonContainer}>
                <span
                  aria-hidden="true"
                  class={this.classes(
                    CSS.iconRightTriangleArrow,
                    CSS.advancedOptionsButtonIconClosed
                  )}
                />
                <span
                  aria-hidden="true"
                  class={this.classes(
                    CSS.iconLeftTriangleArrow,
                    CSS.advancedOptionsButtonIconClosed_RTL
                  )}
                />
                <span
                  aria-hidden="true"
                  class={this.classes(CSS.iconDownArrow, CSS.advancedOptionsButtonIconOpened)}
                />
                <span class={CSS.advancedOptionsButtonTitle}>{messages.advancedOptions}</span>
              </div>
            </button>
            {advancedSectionForMapOnly}
          </div>
        </div>
      </section>
    );

    const exportedLinksArray = this.exportedLinks.toArray();
    const exportedLinksItems = this._renderExportedLink(exportedLinksArray);
    const exportButtonClasses = {
      [CSS.buttonDisabled]: exportDisabled || (!layout && !format)
    };

    const isSceneView = this.get("view") != null && this.get("view.type") !== "2d";

    const errorPanel = (
      <div class={CSS.panelError}>
        {isSceneView ? messages.sceneViewError : messages.serviceError}
      </div>
    );

    const normalPanel = (
      <div>
        <ul
          class={CSS.layoutTabList}
          role="tablist"
          onclick={this._toggleLayoutPanel}
          onkeydown={this._handleLayoutPanelKeyDown}
          bind={this}
        >
          <li
            afterCreate={this._focusOnTabChange}
            afterUpdate={this._focusOnTabChange}
            id={`${this.id}__layoutTab`}
            data-tab-id={TabId.layout}
            class={CSS.layoutTab}
            role="tab"
            tabIndex={0}
            aria-selected={`${this._layoutTabSelected}`}
          >
            {messages.layoutTab}
          </li>
          <li
            afterCreate={this._focusOnTabChange}
            afterUpdate={this._focusOnTabChange}
            id={`${this.id}__mapOnlyTab`}
            data-tab-id={TabId.mapOnly}
            class={CSS.layoutTab}
            role="tab"
            tabIndex={0}
            aria-selected={`${!this._layoutTabSelected}`}
          >
            {messages.mapOnlyTab}
          </li>
        </ul>

        {panel}

        <button
          aria-label={messages.exportDescription}
          type="button"
          class={this.classes(CSS.printButton, CSS.button, exportButtonClasses)}
          disabled={exportDisabled}
          tabIndex={0}
          onclick={this._handlePrintMap}
          bind={this}
        >
          {messages.export}
        </button>
        {includeDefaultTemplates && viewModel.defaultTemplates.length > 0
          ? this.renderTemplateSectionTrigger()
          : null}
        <div
          class={CSS.exportedFilesContainer}
          afterUpdate={this._scrollExportIntoView}
          bind={this}
        >
          <Heading class={CSS.exportedFilesTitle} level={this.headingLevel}>
            {messages.exportText}
          </Heading>
          {exportedLinksArray.length > 0 ? null : (
            <div>
              <div>{messages.exportHint}</div>
            </div>
          )}

          {exportedLinksItems}
        </div>
      </div>
    );

    const printWidgetPanel = (
      <div class={CSS.printWidgetContainer}>
        <header class={CSS.headerTitle}>{messages.export}</header>
        {this.error || isSceneView || !this.view ? errorPanel : normalPanel}
      </div>
    );

    const initializing = this.get("viewModel.state") === "initializing";
    const panelContent = initializing ? this._renderLoader() : printWidgetPanel;

    return (
      <div
        afterCreate={this._handleRootAfterCreate}
        bind={this}
        class={this.classes(CSS.base, CSS.widget, CSS.panel)}
      >
        {panelContent}
      </div>
    );
  }

  protected renderTemplateSectionTrigger(): VNode {
    const { messages, _templateListPopover } = this;
    const active = _templateListPopover.open;

    return (
      <button
        afterCreate={(node: HTMLButtonElement) => (this._selectTemplateNode = node)}
        aria-controls={active ? `${this.id}__template-selection` : ""}
        aria-label={messages.selectTemplateDescription}
        aria-pressed={active.toString()}
        class={this.classes(CSS.button, CSS.buttonTertiary, CSS.templateButton)}
        onclick={this.handleSelectTemplateClick}
        title={messages.selectTemplateDescription}
      >
        {messages.selectTemplate}
      </button>
    );
  }

  protected renderTemplateList(): VNode {
    const { messages, messagesCommon, viewModel } = this;
    const { defaultTemplates } = viewModel;
    const description = messages.selectTemplateDescription;
    const id = `${this.id}__template-selection`;

    return (
      <div class={this.classes(CSS.templateList, CSS.widget, CSS.panel)} id={id}>
        <Heading class={CSS.menuHeader} level={this.headingLevel}>
          {messages.selectTemplate}
        </Heading>
        <div class={CSS.templateListScroller}>
          <ul
            afterCreate={this.handleTemplateListCreation}
            aria-activedescendant={`${this.id}__template-item--${this._focusedTemplateIndex}`}
            aria-label={description}
            class={CSS.menuList}
            key="templates"
            onblur={this.handleTemplateChildBlur}
            onclick={this.handleTemplateListClick}
            onkeydown={this.handleTemplateListKeyDown}
            role="listbox"
            tabIndex={0}
            title={description}
          >
            {defaultTemplates.toArray().map((template, index) => {
              const { description } = template;
              const focused = index === this._focusedTemplateIndex;
              const templateLabel = template.label;

              return (
                <li
                  aria-label={description}
                  class={this.classes(CSS.menuItem, {
                    [CSS.menuItemFocus]: focused
                  })}
                  data-template={template}
                  id={`${this.id}__template-item--${index}`}
                  key={templateLabel}
                  title={description}
                >
                  {isMapOnlyLayout(templateLabel) ? messages.mapOnlyTab : templateLabel}
                </li>
              );
            })}
          </ul>
        </div>
        <div class={CSS.templateListFooter}>
          <button
            type="button"
            class={this.classes(CSS.button, CSS.buttonSecondary)}
            onblur={this.handleTemplateChildBlur}
            onclick={this.handleCloseTemplateSelection}
          >
            {messagesCommon.done}
          </button>
        </div>
      </div>
    );
  }

  protected handleTemplateListCreation = (node: HTMLElement) => node.focus();

  protected handleTemplateChildBlur = (event: FocusEvent) => {
    const templateListChildFocused = (event.relatedTarget as HTMLElement)?.closest(
      `.${CSS.templateList}`
    );

    if (!templateListChildFocused) {
      this.handleCloseTemplateSelection();
    }
  };

  protected handleCloseTemplateSelection = () => {
    this._focusedTemplateIndex = 0;
    this._templateListPopover.open = false;
    this._selectTemplateNode.focus();
  };

  protected handleSelectTemplateClick = () => {
    this._focusedTemplateIndex = 0;
    this._templateListPopover.open = true;
  };

  protected handleTemplateListClick = (event: MouseEvent): void => {
    const item = event.target as HTMLLIElement;
    this.applyTemplate(item["data-template"] as CustomTemplate);
  };

  protected handleTemplateListKeyDown = (event: KeyboardEvent) => {
    if (isActivationKey(event.key)) {
      this.applyTemplate(this.viewModel.defaultTemplates.getItemAt(this._focusedTemplateIndex));
      event.preventDefault();
      return;
    }

    if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      const { defaultTemplates } = this.viewModel;
      const direction = event.key === "ArrowDown" ? 1 : -1;
      const nextIndex = (this._focusedTemplateIndex + direction) % defaultTemplates.length;
      this._focusedTemplateIndex = nextIndex < 0 ? defaultTemplates.length - 1 : nextIndex;
      const list = event.currentTarget as HTMLUListElement;

      keepMenuItemWithinView(
        list.querySelectorAll<HTMLLIElement>(`.${CSS.menuItem}`)[this._focusedTemplateIndex],
        list.parentElement
      );

      event.preventDefault();
    }

    if (event.key === "Escape") {
      this.handleCloseTemplateSelection();
    }
  };

  protected applyTemplate(template: CustomTemplate): void {
    const { format, layout, layoutOptions } = template;
    const { templateOptions } = this;

    this._templateListPopover.open = false;
    this._toggleTab(layout === "map-only" ? TabId.mapOnly : TabId.layout, false);

    if (format) {
      templateOptions.format = format;
    }

    if (layout) {
      templateOptions.layout = layout;
    }

    this._focusedTemplateIndex = null;
    templateOptions.legendEnabled = layoutOptions?.legend ?? templateOptions.legendEnabled;
    this.handleCloseTemplateSelection();
  }

  protected renderTitleOrFileNameSection(): VNode {
    const { templateOptions, messages } = this;

    let label: string;
    let placeholder: string;
    let value: string;
    let propName: Extract<keyof TemplateOptions, "fileName" | "title">;

    if (this._layoutTabSelected) {
      label = messages.title;
      placeholder = messages.titlePlaceHolder;
      value = templateOptions.title;
      propName = "title";
    } else {
      label = messages.fileName;
      placeholder = messages.fileNamePlaceHolder;
      value = templateOptions.fileName;
      propName = "fileName";
    }

    return (
      <div class={CSS.formSectionContainer} key={propName}>
        <label>
          {label}
          <input
            type="text"
            tabIndex={0}
            placeholder={placeholder}
            class={this.classes(CSS.inputText, CSS.input)}
            value={value}
            data-input-name={propName}
            onchange={this._updateInputValue}
            bind={this}
          />
        </label>
      </div>
    );
  }

  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------

  private _handleRootAfterCreate(node: HTMLElement): void {
    this._rootNode = node;
    this.own(
      on(node, "scroll", () => {
        if (this._templateListPopover.open) {
          this.handleCloseTemplateSelection();
        }
      })
    );
  }

  private _focusOnTabChange(node: HTMLElement): void {
    if (!this._activeTabFocusRequested) {
      return;
    }

    const tabType = node.getAttribute("data-tab-id") as TabId;

    if (
      (tabType === "layoutTab" && this._layoutTabSelected) ||
      (tabType === "mapOnlyTab" && !this._layoutTabSelected)
    ) {
      node.focus();
      this._activeTabFocusRequested = false;
    }
  }

  private _renderLoader(): VNode {
    const classes = {
      [CSS.loader]: this._awaitingServerResponse
    };

    return <div class={this.classes(classes)} key="loader" />;
  }

  private _createFileLink(template: PrintTemplate, fileName: string): FileLink {
    const titleText = fileName || this.messages.untitled;
    const lowercaseFormat = template.format.toLowerCase();
    const extension = lowercaseFormat.indexOf("png") > -1 ? "png" : lowercaseFormat;
    const fileNameWithExtension = titleText + extension;
    const hasSameFileName = this._exportedFileNameMap[fileNameWithExtension] !== undefined;

    if (hasSameFileName) {
      this._exportedFileNameMap[fileNameWithExtension]++;
    } else {
      this._exportedFileNameMap[fileNameWithExtension] = 0;
    }

    return new FileLink({
      name: titleText,
      extension,
      count: this._exportedFileNameMap[fileNameWithExtension]
    });
  }

  private _toPrintTemplate(templateOptions: TemplateOptions): PrintTemplate {
    const {
      attributionEnabled,
      author,
      copyright,
      dpi,
      forceFeatureAttributes,
      format,
      height,
      layout,
      legendEnabled,
      title,
      scale,
      width
    } = templateOptions;
    const printTemplate = new PrintTemplate({
      attributionVisible: attributionEnabled,
      layoutOptions: {
        authorText: author || "",
        copyrightText: copyright || "",
        titleText: title || ""
      },
      forceFeatureAttributes,
      format,
      layout,
      outScale: scale
    });

    if (width) {
      printTemplate.exportOptions.width = width;
    }

    if (height) {
      printTemplate.exportOptions.height = height;
    }

    if (dpi) {
      printTemplate.exportOptions.dpi = dpi;
    }

    if (!legendEnabled) {
      printTemplate.layoutOptions.legendLayers = [];
    }

    return printTemplate;
  }

  private _resetToCurrentScale(): void {
    this.templateOptions.scale = this.viewModel.view.scale;
  }

  private _updateInputValue(e: Event): void {
    const input = e.target as HTMLInputElement;
    const targetProperty = input.getAttribute("data-input-name");

    let value: string | number;

    if (input.type === "number") {
      if (!isValidInputNumber(input.valueAsNumber)) {
        const prevValue = this.templateOptions[targetProperty];
        input.value = `${prevValue}`;
        return;
      }

      value = input.valueAsNumber;
    } else {
      value = input.value;
    }

    this.templateOptions[targetProperty] = value;
  }

  private _handleDPIChange(event: Event): void {
    this._updateInputValue(event);

    const dpi = (event.currentTarget as HTMLInputElement).valueAsNumber;
    const { height, width } = dimensionsFromDPI(dpi);
    const { templateOptions } = this;

    templateOptions["height"] = height;
    templateOptions["width"] = width;
  }

  private _handlePrintMap(): void {
    this._pendingExportScroll = true;
    const { templateOptions } = this;
    const template = this._toPrintTemplate(templateOptions);
    const fileName = this._layoutTabSelected
      ? template.layoutOptions.titleText
      : templateOptions.fileName;
    const link = this._createFileLink(template, fileName);

    this.exportedLinks.add(link);
    this.emit("submit", { link });

    this.viewModel
      .print(template)
      .then((result) => {
        link.set({
          url: result && result.url,
          state: "ready"
        });
      })
      .catch((error: EsriError) => {
        link.set({
          error,
          state: "error"
        });
      })
      .then(() => {
        this.emit("complete", { link });
        this.scheduleRender();
      });
  }

  private _updateFromOption(e: Event): void {
    const target = e.target as HTMLSelectElement;
    const selectedOption = target.selectedOptions
      ? target.selectedOptions.item(0).value
      : target.options[target.selectedIndex].value;
    const targetProperty = target.getAttribute("data-target-property");

    this.templateOptions[targetProperty] = selectedOption;
  }

  private _switchInput(): void {
    [this.templateOptions.width, this.templateOptions.height] = [
      this.templateOptions.height,
      this.templateOptions.width
    ];
  }

  private _showAdvancedOptions(): void {
    if (this._layoutTabSelected) {
      this._advancedOptionsVisibleForLayout = !this._advancedOptionsVisibleForLayout;
    } else {
      this._advancedOptionsVisibleForMapOnly = !this._advancedOptionsVisibleForMapOnly;
    }
  }

  private _scrollExportIntoView(): void {
    if (this._pendingExportScroll) {
      this._pendingExportScroll = false;
      const {
        _rootNode,
        _rootNode: { clientHeight, scrollHeight }
      } = this;

      const delta = scrollHeight - clientHeight;

      if (delta > 0) {
        // scroll to bottom (export link area) only if root node owns scroller
        _rootNode.scrollTop = delta;
      }
    }
  }

  private _toggleInputValue(e: Event): void {
    const target = e.target as HTMLInputElement;
    const propName = target.getAttribute("data-option-name");

    this.templateOptions[propName] = target.checked;

    if (propName === "scaleEnabled") {
      this.viewModel.scaleEnabled = this.templateOptions.scaleEnabled;
      if (!this.templateOptions[propName]) {
        this._resetToCurrentScale();
      }
    }
  }

  private _removeLink = (e: MouseEvent): void => {
    const target = e.currentTarget as HTMLElement;
    const item = target["data-item"] as FileLink;

    if (item && item.state === "error") {
      this.exportedLinks.remove(item);
    }
  };

  private _renderExportedLink(exportedLinksArray: FileLink[]): VNode {
    const messages = this.messages;

    return exportedLinksArray.map((exportedLink) => {
      const {
        error: linkError,
        url: linkUrl,
        formattedName: linkName,
        state: linkState
      } = exportedLink;

      const hasError = linkState === "error";
      const pending = linkState === "pending";
      const ready = linkState === "ready";

      const anchorClasses = {
        [CSS.anchorDisabled]: pending || hasError
      };

      let url = linkUrl || null;

      if (url) {
        url = urlUtils.addProxy(url);
      }

      const sameOrigin = urlUtils.hasSameOrigin(linkUrl, location.href);

      const iconClasses = {
        [CSS.iconSpinner]: pending,
        [CSS.rotate]: pending,
        [CSS.iconDownload]: sameOrigin && ready,
        [CSS.iconLaunchLink]: !sameOrigin && ready,
        [CSS.iconError]: hasError,
        [CSS.exportedFileError]: hasError
      };

      const linkTitleClasses = {
        [CSS.exportedFileError]: hasError
      };

      let itemDescriptiveStatus: string;

      if (pending) {
        itemDescriptiveStatus = messages.pending;
      } else if (ready) {
        itemDescriptiveStatus = messages.ready;
      } else {
        itemDescriptiveStatus = messages.errorMessage;
      }

      const tooltip = hasError
        ? linkError.name === "print-task:cim-symbol-unsupported"
          ? messages.exportWebMapCIMError
          : messages.exportWebMapError
        : "";

      return (
        <div
          aria-label={itemDescriptiveStatus}
          class={CSS.exportedFile}
          data-item={exportedLink}
          key={linkName}
          onclick={this._removeLink}
          title={tooltip}
        >
          <a
            aria-label={`${linkName}. ${messages.linkReady}`}
            download={linkName}
            href={url}
            rel="noreferrer"
            tabIndex={0}
            target="_blank"
            class={this.classes(CSS.exportedFileLink, anchorClasses)}
          >
            <span class={this.classes(iconClasses)} />
            <span class={this.classes(CSS.exportedFileLinkTitle, linkTitleClasses)}>
              {linkName}
            </span>
          </a>
        </div>
      );
    });
  }

  private _toggleLayoutPanel(e: Event): void {
    const target = e.target as HTMLLIElement;
    this._toggleTab(target.getAttribute("data-tab-id") as TabId);
  }

  private _toggleTab(targetTab: TabId, focusOnTab = true): void {
    this._layoutTabSelected = targetTab === TabId.layout;

    if (!this._layoutTabSelected) {
      this.templateOptions.layout = mapOnlyLayout;
    } else {
      const layoutChoices = this.get<string[]>("viewModel.templatesInfo.layout.choiceList");
      this.templateOptions.layout = layoutChoices && layoutChoices[0];
    }

    if (focusOnTab) {
      this._activeTabFocusRequested = true;
    }
  }

  private _handleLayoutPanelKeyDown(event: KeyboardEvent): void {
    const key = eventKey(event);
    const target = event.target as HTMLLIElement;
    const currentTab = target.getAttribute("data-tab-id") as TabId;

    if (isActivationKey(key)) {
      this._toggleTab(currentTab);
      event.preventDefault();
      event.stopPropagation();
      return;
    }

    if (key === "ArrowLeft" || key === "ArrowRight") {
      this._toggleTab(currentTab === TabId.layout ? TabId.mapOnly : TabId.layout);
      event.preventDefault();
      event.stopPropagation();
    }
  }
}

export default Print;
